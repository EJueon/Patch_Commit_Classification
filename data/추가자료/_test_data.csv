title,desc,number,label
"bpf, cgroup: Assign cgroup in cgroup_sk_alloc when called from interrupt","If cgroup_sk_alloc() is called from interrupt context, then just assign the root cgroup to skcd->cgroup. Prior to commit 8520e224f547 (""bpf, cgroups: Fix cgroup v2 fallback on v1/v2 mixed mode"") we would just return, and later on in sock_cgroup_ptr(), we were NULL-testing the cgroup in fast-path, and iff indeed NULL returning the root cgroup (v ?: &cgrp_dfl_root.cgrp). Rather than re-adding the NULL-test to the fast-path we can just assign it once from cgroup_sk_alloc() given v1/v2 handling has been simplified. The migration from NULL test with returning &cgrp_dfl_root.cgrp to assigning &cgrp_dfl_root.cgrp directly does /not/ change behavior for callers of sock_cgroup_ptr().  syzkaller was able to trigger a splat in the legacy netrom code base, where the RX handler in nr_rx_frame() calls nr_make_new() which calls sk_alloc() and therefore cgroup_sk_alloc() with in_interrupt() condition. Thus the NULL skcd->cgroup, where it trips over on cgroup_sk_free() side given it expects a non-NULL object. There are a few other candidates aside from netrom which have similar pattern where in their accept-like implementation, they just call to sk_alloc() and thus cgroup_sk_alloc() instead of sk_clone_lock() with the corresponding cgroup_sk_clone() which then inherits the cgroup from the parent socket. None of them are related to core protocols where BPF cgroup programs are running from. However, in future, they should follow to implement a similar inheritance mechanism.  Additionally, with a !CONFIG_CGROUP_NET_PRIO and !CONFIG_CGROUP_NET_CLASSID configuration, the same issue was exposed also prior to 8520e224f547 due to commit e876ecc67db8 (""cgroup: memcg: net: do not associate sock with unrelated cgroup"") which added the early in_interrupt() return back then.  ",78cc316e9583067884eb8bd154301dc1e9ee945c,1
io-wq: remove worker to owner tw dependency,"INFO: task iou-wrk-6609:6612 blocked for more than 143 seconds.       Not tainted 5.15.0-rc5-syzkaller #0 ""echo 0 > /proc/sys/kernel/hung_task_timeout_secs"" disables this message. ",1d5f5ea7cb7d15b9fb1cc82673ebb054f02cd7d2,1
ethtool: use ethnl_parse_header_dev_put(),"It seems I missed that most ethnl_parse_header_dev_get() callers declare an on-stack struct ethnl_req_info, and that they simply call dev_put(req_info.dev) when about to return.  Add ethnl_parse_header_dev_put() helper to properly untrack reference taken by ethnl_parse_header_dev_get().  ",34ac17ecbf575eb079094d44f1bd30c66897aa21,0
batman-adv: mcast: fix multicast tt/tvlv worker locking,"Syzbot has reported some issues with the locking assumptions made for the multicast tt/tvlv worker: It was able to trigger the WARN_ON() in batadv_mcast_mla_tt_retract() and batadv_mcast_mla_tt_add(). While hard/not reproduceable for us so far it seems that the delayed_work_pending() we use might not be quite safe from reordering.  Therefore this patch adds an explicit, new spinlock to protect the update of the mla_list and flags in bat_priv and then removes the WARN_ON(delayed_work_pending()).  ",a3c7cd0cdf1107f891aff847ad481e34df727055,0
bpf: Fix umd memory leak in copy_process(),"The syzbot reported a memleak as follows:  BUG: memory leak unreferenced object 0xffff888101b41d00 (size 120):   comm ""kworker/u4:0"", pid 8, jiffies 4294944270 (age 12.780s)   backtrace:     [<ffffffff8125dc56>] alloc_pid+0x66/0x560     [<ffffffff81226405>] copy_process+0x1465/0x25e0     [<ffffffff81227943>] kernel_clone+0xf3/0x670     [<ffffffff812281a1>] kernel_thread+0x61/0x80     [<ffffffff81253464>] call_usermodehelper_exec_work     [<ffffffff81253464>] call_usermodehelper_exec_work+0xc4/0x120     [<ffffffff812591c9>] process_one_work+0x2c9/0x600     [<ffffffff81259ab9>] worker_thread+0x59/0x5d0     [<ffffffff812611c8>] kthread+0x178/0x1b0     [<ffffffff8100227f>] ret_from_fork+0x1f/0x30  unreferenced object 0xffff888110ef5c00 (size 232):   comm ""kworker/u4:0"", pid 8414, jiffies 4294944270 (age 12.780s)   backtrace:     [<ffffffff8154a0cf>] kmem_cache_zalloc     [<ffffffff8154a0cf>] __alloc_file+0x1f/0xf0     [<ffffffff8154a809>] alloc_empty_file+0x69/0x120     [<ffffffff8154a8f3>] alloc_file+0x33/0x1b0     [<ffffffff8154ab22>] alloc_file_pseudo+0xb2/0x140     [<ffffffff81559218>] create_pipe_files+0x138/0x2e0     [<ffffffff8126c793>] umd_setup+0x33/0x220     [<ffffffff81253574>] call_usermodehelper_exec_async+0xb4/0x1b0     [<ffffffff8100227f>] ret_from_fork+0x1f/0x30  After the UMD process exits, the pipe_to_umh/pipe_from_umh and tgid need to be released.  ",f60a85cad677c4f9bb4cadd764f1d106c38c7cf8,1
futex: Prevent inconsistent state and exit race,The recent rework of the requeue PI code introduced a possibility for going back to user space in inconsistent state:  CPU 0				CPU 1  requeue_futex()   if (lock_pifutex_user()) {       dequeue_waiter();       wake_waiter(task); 				sched_in(task);      				return_from_futex_syscall();    ,4f07ec0d76f242d4ca0f0c0c6f7293c28254a554,1
ppp: ensure minimum packet size in ppp_write(),It seems pretty clear ppp layer assumed user space would always be kind to provide enough data in their write() to a ppp device.  This patch makes sure user provides at least 2 bytes.  It adds PPP_PROTO_LEN macro that could replace in net-next many occurrences of hard-coded 2 value.  I replaced only one occurrence to ease backports to stable kernels.  The bug manifests in the following report:  BUG: KMSAN: uninit-value in ppp_send_frame+0x28d/0x27c0 drivers/net/ppp/ppp_generic.c:1740  ppp_send_frame+0x28d/0x27c0 drivers/net/ppp/ppp_generic.c:1740  __ppp_xmit_process+0x23e/0x4b0 drivers/net/ppp/ppp_generic.c:1640  ppp_xmit_process+0x1fe/0x480 drivers/net/ppp/ppp_generic.c:1661  ppp_write+0x5cb/0x5e0 drivers/net/ppp/ppp_generic.c:513  do_iter_write+0xb0c/0x1500 fs/read_write.c:853  vfs_writev fs/read_write.c:924 [inline]  do_writev+0x645/0xe00 fs/read_write.c:967  __do_sys_writev fs/read_write.c:1040 [inline]  __se_sys_writev fs/read_write.c:1037 [inline]  __x64_sys_writev+0xe5/0x120 fs/read_write.c:1037  do_syscall_x64 arch/x86/entry/common.c:51 [inline]  do_syscall_64+0x54/0xd0 arch/x86/entry/common.c:82  entry_SYSCALL_64_after_hwframe+0x44/0xae  ,44073187990d5629804ce0627525f6ea5cfef171,1
net: silence data-races on sk_backlog.tail,"sk->sk_backlog.tail might be read without holding the socket spinlock, we need to add proper READ_ONCE()/WRITE_ONCE() to silence the warnings.  KCSAN reported :  BUG: KCSAN: data-race in tcp_add_backlog / tcp_recvmsg  write to 0xffff8881265109f8 of 8 bytes by interrupt on cpu 1:  __sk_add_backlog include/net/sock.h:907 [inline]  sk_add_backlog include/net/sock.h:938 [inline]  tcp_add_backlog+0x476/0xce0 net/ipv4/tcp_ipv4.c:1759  tcp_v4_rcv+0x1a70/0x1bd0 net/ipv4/tcp_ipv4.c:1947  ip_protocol_deliver_rcu+0x4d/0x420 net/ipv4/ip_input.c:204  ip_local_deliver_finish+0x110/0x140 net/ipv4/ip_input.c:231  NF_HOOK include/linux/netfilter.h:305 [inline]  NF_HOOK include/linux/netfilter.h:299 [inline]  ip_local_deliver+0x133/0x210 net/ipv4/ip_input.c:252  dst_input include/net/dst.h:442 [inline]  ip_rcv_finish+0x121/0x160 net/ipv4/ip_input.c:413  NF_HOOK include/linux/netfilter.h:305 [inline]  NF_HOOK include/linux/netfilter.h:299 [inline]  ip_rcv+0x18f/0x1a0 net/ipv4/ip_input.c:523  __netif_receive_skb_one_core+0xa7/0xe0 net/core/dev.c:4929  __netif_receive_skb+0x37/0xf0 net/core/dev.c:5043  netif_receive_skb_internal+0x59/0x190 net/core/dev.c:5133  napi_skb_finish net/core/dev.c:5596 [inline]  napi_gro_receive+0x28f/0x330 net/core/dev.c:5629  receive_buf+0x284/0x30b0 drivers/net/virtio_net.c:1061  virtnet_receive drivers/net/virtio_net.c:1323 [inline]  virtnet_poll+0x436/0x7d0 drivers/net/virtio_net.c:1428  napi_poll net/core/dev.c:6311 [inline]  net_rx_action+0x3ae/0xa90 net/core/dev.c:6379  __do_softirq+0x115/0x33f kernel/softirq.c:292  invoke_softirq kernel/softirq.c:373 [inline]  irq_exit+0xbb/0xe0 kernel/softirq.c:413  exiting_irq arch/x86/include/asm/apic.h:536 [inline]  do_IRQ+0xa6/0x180 arch/x86/kernel/irq.c:263  ret_from_intr+0x0/0x19  native_safe_halt+0xe/0x10 arch/x86/kernel/paravirt.c:71  arch_cpu_idle+0x1f/0x30 arch/x86/kernel/process.c:571  default_idle_call+0x1e/0x40 kernel/sched/idle.c:94  cpuidle_idle_call kernel/sched/idle.c:154 [inline]  do_idle+0x1af/0x280 kernel/sched/idle.c:263  cpu_startup_entry+0x1b/0x20 kernel/sched/idle.c:355  start_secondary+0x208/0x260 arch/x86/kernel/smpboot.c:264  secondary_startup_64+0xa4/0xb0 arch/x86/kernel/head_64.S:241  read to 0xffff8881265109f8 of 8 bytes by task 8057 on cpu 0:  tcp_recvmsg+0x46e/0x1b40 net/ipv4/tcp.c:2050  inet_recvmsg+0xbb/0x250 net/ipv4/af_inet.c:838  sock_recvmsg_nosec net/socket.c:871 [inline]  sock_recvmsg net/socket.c:889 [inline]  sock_recvmsg+0x92/0xb0 net/socket.c:885  sock_read_iter+0x15f/0x1e0 net/socket.c:967  call_read_iter include/linux/fs.h:1889 [inline]  new_sync_read+0x389/0x4f0 fs/read_write.c:414  __vfs_read+0xb1/0xc0 fs/read_write.c:427  vfs_read fs/read_write.c:461 [inline]  vfs_read+0x143/0x2c0 fs/read_write.c:446  ksys_read+0xd5/0x1b0 fs/read_write.c:587  __do_sys_read fs/read_write.c:597 [inline]  __se_sys_read fs/read_write.c:595 [inline]  __x64_sys_read+0x4c/0x60 fs/read_write.c:595  do_syscall_64+0xcc/0x370 arch/x86/entry/common.c:290  entry_SYSCALL_64_after_hwframe+0x44/0xa9  Reported by Kernel Concurrency Sanitizer on: CPU: 0 PID: 8057 Comm: syz-fuzzer Not tainted 5.4.0-rc6+ #0 Hardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 01/01/2011  ",9ed498c6280a2f2b51d02df96df53037272ede49,1
KVM/x86: remove WARN_ON() for when vm_munmap() fails,"On x86, special KVM memslots such as the TSS region have anonymous memory mappings created on behalf of userspace, and these mappings are removed when the VM is destroyed.  It is however possible for removing these mappings via vm_munmap() to fail.  This can most easily happen if the thread receives SIGKILL while it's waiting to acquire ->mmap_sem.   This triggers the 'WARN_ON(r < 0)' in __x86_set_memory_region().  syzkaller was able to hit this, using 'exit()' to send the SIGKILL.  Note that while the vm_munmap() failure results in the mapping not being removed immediately, it is not leaked forever but rather will be freed when the process exits.  It's not really possible to handle this failure properly, so almost every other caller of vm_munmap() doesn't check the return value.  It's a limitation of having the kernel manage these mappings rather than userspace.  So just remove the WARN_ON() so that users can't spam the kernel log with this warning.  ",103c763c72dd2df3e8c91f2d7ec88f98ed391111,1
net: annotate data-races on txq->xmit_lock_owner,"syzbot found that __dev_queue_xmit() is reading txq->xmit_lock_owner without annotations.  No serious issue there, let's document what is happening there.  BUG: KCSAN: data-race in __dev_queue_xmit / __dev_queue_xmit  write to 0xffff888139d09484 of 4 bytes by interrupt on cpu 0:  __netif_tx_unlock include/linux/netdevice.h:4437 [inline]  __dev_queue_xmit+0x948/0xf70 net/core/dev.c:4229  dev_queue_xmit_accel+0x19/0x20 net/core/dev.c:4265  macvlan_queue_xmit drivers/net/macvlan.c:543 [inline]  macvlan_start_xmit+0x2b3/0x3d0 drivers/net/macvlan.c:567  __netdev_start_xmit include/linux/netdevice.h:4987 [inline]  netdev_start_xmit include/linux/netdevice.h:5001 [inline]  xmit_one+0x105/0x2f0 net/core/dev.c:3590  dev_hard_start_xmit+0x72/0x120 net/core/dev.c:3606  sch_direct_xmit+0x1b2/0x7c0 net/sched/sch_generic.c:342  __dev_xmit_skb+0x83d/0x1370 net/core/dev.c:3817  __dev_queue_xmit+0x590/0xf70 net/core/dev.c:4194  dev_queue_xmit+0x13/0x20 net/core/dev.c:4259  neigh_hh_output include/net/neighbour.h:511 [inline]  neigh_output include/net/neighbour.h:525 [inline]  ip6_finish_output2+0x995/0xbb0 net/ipv6/ip6_output.c:126  __ip6_finish_output net/ipv6/ip6_output.c:191 [inline]  ip6_finish_output+0x444/0x4c0 net/ipv6/ip6_output.c:201  NF_HOOK_COND include/linux/netfilter.h:296 [inline]  ip6_output+0x10e/0x210 net/ipv6/ip6_output.c:224  dst_output include/net/dst.h:450 [inline]  NF_HOOK include/linux/netfilter.h:307 [inline]  ndisc_send_skb+0x486/0x610 net/ipv6/ndisc.c:508  ndisc_send_rs+0x3b0/0x3e0 net/ipv6/ndisc.c:702  addrconf_rs_timer+0x370/0x540 net/ipv6/addrconf.c:3898  call_timer_fn+0x2e/0x240 kernel/time/timer.c:1421  expire_timers+0x116/0x240 kernel/time/timer.c:1466  __run_timers+0x368/0x410 kernel/time/timer.c:1734  run_timer_softirq+0x2e/0x60 kernel/time/timer.c:1747  __do_softirq+0x158/0x2de kernel/softirq.c:558  __irq_exit_rcu kernel/softirq.c:636 [inline]  irq_exit_rcu+0x37/0x70 kernel/softirq.c:648  sysvec_apic_timer_interrupt+0x3e/0xb0 arch/x86/kernel/apic/apic.c:1097  asm_sysvec_apic_timer_interrupt+0x12/0x20  read to 0xffff888139d09484 of 4 bytes by interrupt on cpu 1:  __dev_queue_xmit+0x5e3/0xf70 net/core/dev.c:4213  dev_queue_xmit_accel+0x19/0x20 net/core/dev.c:4265  macvlan_queue_xmit drivers/net/macvlan.c:543 [inline]  macvlan_start_xmit+0x2b3/0x3d0 drivers/net/macvlan.c:567  __netdev_start_xmit include/linux/netdevice.h:4987 [inline]  netdev_start_xmit include/linux/netdevice.h:5001 [inline]  xmit_one+0x105/0x2f0 net/core/dev.c:3590  dev_hard_start_xmit+0x72/0x120 net/core/dev.c:3606  sch_direct_xmit+0x1b2/0x7c0 net/sched/sch_generic.c:342  __dev_xmit_skb+0x83d/0x1370 net/core/dev.c:3817  __dev_queue_xmit+0x590/0xf70 net/core/dev.c:4194  dev_queue_xmit+0x13/0x20 net/core/dev.c:4259  neigh_resolve_output+0x3db/0x410 net/core/neighbour.c:1523  neigh_output include/net/neighbour.h:527 [inline]  ip6_finish_output2+0x9be/0xbb0 net/ipv6/ip6_output.c:126  __ip6_finish_output net/ipv6/ip6_output.c:191 [inline]  ip6_finish_output+0x444/0x4c0 net/ipv6/ip6_output.c:201  NF_HOOK_COND include/linux/netfilter.h:296 [inline]  ip6_output+0x10e/0x210 net/ipv6/ip6_output.c:224  dst_output include/net/dst.h:450 [inline]  NF_HOOK include/linux/netfilter.h:307 [inline]  ndisc_send_skb+0x486/0x610 net/ipv6/ndisc.c:508  ndisc_send_rs+0x3b0/0x3e0 net/ipv6/ndisc.c:702  addrconf_rs_timer+0x370/0x540 net/ipv6/addrconf.c:3898  call_timer_fn+0x2e/0x240 kernel/time/timer.c:1421  expire_timers+0x116/0x240 kernel/time/timer.c:1466  __run_timers+0x368/0x410 kernel/time/timer.c:1734  run_timer_softirq+0x2e/0x60 kernel/time/timer.c:1747  __do_softirq+0x158/0x2de kernel/softirq.c:558  __irq_exit_rcu kernel/softirq.c:636 [inline]  irq_exit_rcu+0x37/0x70 kernel/softirq.c:648  sysvec_apic_timer_interrupt+0x8d/0xb0 arch/x86/kernel/apic/apic.c:1097  asm_sysvec_apic_timer_interrupt+0x12/0x20  kcsan_setup_watchpoint+0x94/0x420 kernel/kcsan/core.c:443  folio_test_anon include/linux/page-flags.h:581 [inline]  PageAnon include/linux/page-flags.h:586 [inline]  zap_pte_range+0x5ac/0x10e0 mm/memory.c:1347  zap_pmd_range mm/memory.c:1467 [inline]  zap_pud_range mm/memory.c:1496 [inline]  zap_p4d_range mm/memory.c:1517 [inline]  unmap_page_range+0x2dc/0x3d0 mm/memory.c:1538  unmap_single_vma+0x157/0x210 mm/memory.c:1583  unmap_vmas+0xd0/0x180 mm/memory.c:1615  exit_mmap+0x23d/0x470 mm/mmap.c:3170  __mmput+0x27/0x1b0 kernel/fork.c:1113  mmput+0x3d/0x50 kernel/fork.c:1134  exit_mm+0xdb/0x170 kernel/exit.c:507  do_exit+0x608/0x17a0 kernel/exit.c:819  do_group_exit+0xce/0x180 kernel/exit.c:929  get_signal+0xfc3/0x1550 kernel/signal.c:2852  arch_do_signal_or_restart+0x8c/0x2e0 arch/x86/kernel/signal.c:868  handle_signal_work kernel/entry/common.c:148 [inline]  exit_to_user_mode_loop kernel/entry/common.c:172 [inline]  exit_to_user_mode_prepare+0x113/0x190 kernel/entry/common.c:207  __syscall_exit_to_user_mode_work kernel/entry/common.c:289 [inline]  syscall_exit_to_user_mode+0x20/0x40 kernel/entry/common.c:300  do_syscall_64+0x50/0xd0 arch/x86/entry/common.c:86  entry_SYSCALL_64_after_hwframe+0x44/0xae  value changed: 0x00000000 -> 0xffffffff  Reported by Kernel Concurrency Sanitizer on: CPU: 1 PID: 28712 Comm: syz-executor.0 Tainted: G        W         5.16.0-rc1-syzkaller #0 Hardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 01/01/2011  ",7a10d8c810cfad3e79372d7d1c77899d86cd6662,1
ipv6: repair fib6 tree in failure case,"In fib6_add(), it is possible that fib6_add_1() picks an intermediate node and sets the node's fn->leaf to NULL in order to add this new route. However, if fib6_add_rt2node() fails to add the new route for some reason, fn->leaf will be left as NULL and could potentially cause crash when fn->leaf is accessed in fib6_locate(). This patch makes sure fib6_repair_tree() is called to properly repair fn->leaf in the above failure case.  Here is the syzkaller reported general protection fault in fib6_locate: kasan: CONFIG_KASAN_INLINE enabled kasan: GPF could be caused by NULL-ptr deref or user memory access general protection fault: 0000 [#1] SMP KASAN ",348a4002729ccab8b888b38cbc099efa2f2a2036,1
RDMA/nl: Do not permit empty devices names during RDMA_NLDEV_CMD_NEWLINK/SET,Empty device names cannot be added to sysfs and crash with:    kobject: (00000000f9de3792): attempted to be registered with empty name!   ,7aefa6237cfe4a6fcf06a8656eee988b36f8fefc,1
netrom: fix locking in nr_find_socket(),"nr_find_socket(), nr_find_peer() and nr_find_listener() lock the sock after finding it in the global list. However, the call path requires BH disabled for the sock lock consistently.  Actually the locking is unnecessary at this point, we can just hold the sock refcnt to make sure it is not gone after we unlock the global list, and lock it later only when needed.  ",7314f5480f3e37e570104dc5e0f28823ef849e72,0
rsi: fix use-after-free on failed probe and unbind,Make sure to stop both URBs before returning after failed probe as well as on disconnect to avoid use-after-free in the completion handler.  ,e93cd35101b61e4c79149be2cfc927c4b28dc60c,1
pppoe: check sockaddr length in pppoe_connect(),"We must validate sockaddr_len, otherwise userspace can pass fewer data than we expect and we end up accessing invalid data.  ",a49e2f5d5fb141884452ddb428f551b123d436b5,0
HID: Fix slab-out-of-bounds read in hid_field_extract,"The syzbot fuzzer found a slab-out-of-bounds bug in the HID report handler.  The bug was caused by a report descriptor which included a field with size 12 bits and count 4899, for a total size of 7349 bytes.  The usbhid driver uses at most a single-page 4-KB buffer for reports. In the test there wasn't any problem about overflowing the buffer, since only one byte was received from the device.  Rather, the bug occurred when the HID core tried to extract the data from the report fields, which caused it to try reading data beyond the end of the allocated buffer.  This patch fixes the problem by rejecting any report whose total length exceeds the HID_MAX_BUFFER_SIZE limit (minus one byte to allow for a possible report index).  In theory a device could have a report longer than that, but if there was such a thing we wouldn't handle it correctly anyway.  ",8ec321e96e056de84022c032ffea253431a83c3c,1
udf: Limit sparing table size,"Although UDF standard allows it, we don't support sparing table larger than a single block. Check it during mount so that we don't try to access memory beyond end of buffer.  ",44ac6b829c4e173fdf6df18e6dd86aecf9a3dc99,0
netfilter: ipset: use bitmap infrastructure completely,The bitmap allocation did not use full unsigned long sizes when calculating the required size and that was triggered by KASAN as slab-out-of-bounds read in several places. The patch fixes all of them.  ,32c72165dbd0e246e69d16a3ad348a4851afd415,1
tcp: fix tcp_init_transfer() to not reset icsk_ca_initialized,"This commit fixes a bug (found by syzkaller) that could cause spurious double-initializations for congestion control modules, which could cause memory leaks or other problems for congestion control modules (like CDG) that allocate memory in their init functions.  The buggy scenario constructed by syzkaller was something like:  (1) create a TCP socket (2) initiate a TFO connect via sendto() (3) while socket is in TCP_SYN_SENT, call setsockopt(TCP_CONGESTION),     which calls:        tcp_set_congestion_control() ->          tcp_reinit_congestion_control() ->            tcp_init_congestion_control() (4) receive ACK, connection is established, call tcp_init_transfer(),     set icsk_ca_initialized=0 (without first calling cc->release()),     call tcp_init_congestion_control() again.  Note that in this sequence tcp_init_congestion_control() is called twice without a cc->release() call in between. Thus, for CC modules that allocate memory in their init() function, e.g, CDG, a memory leak may occur. The syzkaller tool managed to find a reproducer that triggered such a leak in CDG.  The bug was introduced when that commit 8919a9b31eb4 (""tcp: Only init congestion control if not initialized already"") introduced icsk_ca_initialized and set icsk_ca_initialized to 0 in tcp_init_transfer(), missing the possibility for a sequence like the one above, where a process could call setsockopt(TCP_CONGESTION) in state TCP_SYN_SENT (i.e. after the connect() or TFO open sendmsg()), which would call tcp_init_congestion_control(). It did not intend to reset any initialization that the user had already explicitly made; it just missed the possibility of that particular sequence (which syzkaller managed to find).  ",be5d1b61a2ad28c7e57fe8bfa277373e8ecffcdc,1
ANDROID: binder: synchronize_rcu() when using POLLFREE.,To prevent races with ep_remove_waitqueue() removing the waitqueue at the same time.  ,5eeb2ca02a2f6084fc57ae5c244a38baab07033a,1
io_uring: io_allocate_scq_urings() should return a sane state,"We currently rely on the ring destroy on cleaning things up in case of failure, but io_allocate_scq_urings() can leave things half initialized if only parts of it fails.  Be nice and return with either everything setup in success, or return an error with things nicely cleaned up.  ",eb065d301e8c83643367bdb0898becc364046bda,0
ext4: fix potential use after free after remounting with noblock_validity,"Remount process will release system zone which was allocated before if ""noblock_validity"" is specified. If we mount an ext4 file system to two mountpoints with default mount options, and then remount one of them with ""noblock_validity"", it may trigger a use after free problem when someone accessing the other one.   # mount /dev/sda foo  # mount /dev/sda bar  User access mountpoint ""foo""   |   Remount mountpoint ""bar""                                | ext4_map_blocks()              |   ext4_remount() check_block_validity()         |   ext4_setup_system_zone() ext4_data_block_valid()        |   ext4_release_system_zone()                                |   free system_blks rb nodes access system_blks rb nodes    | trigger use after free         |  This problem can also be reproduced by one mountpint, At the same time, add_system_zone() can get called during remount as well so there can be racing ext4_data_block_valid() reading the rbtree at the same time.  This patch add RCU to protect system zone from releasing or building when doing a remount which inverse current ""noblock_validity"" mount option. It assign the rbtree after the whole tree was complete and do actual freeing after rcu grace period, avoid any intermediate state.  ",7727ae52975d4f4ef7ff69ed8e6e25f6a4168158,1
libceph: avoid KEEPALIVE_PENDING races in ceph_con_keepalive(),"con_fault() can transition the connection into STANDBY right after ceph_con_keepalive() clears STANDBY in clear_standby():      libceph user thread               ceph-msgr worker  ceph_con_keepalive()   mutex_lock(&con->mutex)   clear_standby(con)   mutex_unlock(&con->mutex)                                 mutex_lock(&con->mutex)                                 con_fault()                                   ...                                   if KEEPALIVE_PENDING isn't set                                     set state to STANDBY                                   ...                                 mutex_unlock(&con->mutex)   set KEEPALIVE_PENDING   set WRITE_PENDING  This triggers warnings in clear_standby() when either ceph_con_send() or ceph_con_keepalive() get to clearing STANDBY next time.  I don't see a reason to condition queue_con() call on the previous value of KEEPALIVE_PENDING, so move the setting of KEEPALIVE_PENDING into the critical section -- unlike WRITE_PENDING, KEEPALIVE_PENDING could have been a non-atomic flag.  ",4aac9228d16458cedcfd90c7fb37211cf3653ac3,1
"bpf, sockmap: fix potential use after free in bpf_tcp_close","bpf_tcp_close() we pop the psock linkage to a map via psock_map_pop(). A parallel update on the sock hash map can happen between psock_map_pop() and lookup_elem_raw() where we override the element under link->hash / link->key. In bpf_tcp_close()'s lookup_elem_raw() we subsequently only test whether an element is present, but we do not test whether the element is infact the element we were looking for.  We lock the sock in bpf_tcp_close() during that time, so do we hold the lock in sock_hash_update_elem(). However, the latter locks the sock which is newly updated, not the one we're purging from the hash table. This means that while one CPU is doing the lookup from bpf_tcp_close(), another CPU is doing the map update in parallel, dropped our sock from the hlist and released the psock.  Subsequently the first CPU will find the new sock and attempts to drop and release the old sock yet another time. Fix is that we need to check the elements for a match after lookup, similar as we do in the sock map. Note that the hash tab elems are freed via RCU, so access to their link->hash / link->key is fine since we're under RCU read side there.  ",e06fa9c16ce4b740996189fa5610eabcee734e6c,1
kvm: vmx: Nested VM-entry prereqs for event inj.,"This patch extends the checks done prior to a nested VM entry. Specifically, it extends the check_vmentry_prereqs function with checks for fields relevant to the VM-entry event injection information, as described in the Intel SDM, volume 3.  This patch is motivated by a syzkaller bug, where a bad VM-entry interruption information field is generated in the VMCS02, which causes the nested VM launch to fail. Then, KVM fails to resume L1.  While KVM should be improved to correctly resume L1 execution after a failed nested launch, this change is justified because the existing code to resume L1 is flaky/ad-hoc and the test coverage for resuming L1 is sparse.  ",0447378a4a793da008451fad50bc0f93e9675ae6,1
mm: validate pmd after splitting,"syzbot reported the following KASAN splat:    general protection fault, probably for non-canonical address 0xdffffc0000000003: 0000 [#1] PREEMPT SMP KASAN   KASAN: null-ptr-deref in range [0x0000000000000018-0x000000000000001f]   CPU: 1 PID: 6826 Comm: syz-executor142 Not tainted 5.9.0-rc4-syzkaller #0   Hardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 01/01/2011   ",ce2684254bd4818ca3995c0d021fb62c4cf10a19,1
USB: Gadget: dummy-hcd: Fix shift-out-of-bounds bug,"The dummy-hcd driver was written under the assumption that all the parameters in URBs sent to its root hub would be valid.  With URBs sent from userspace via usbfs, that assumption can be violated.  In particular, the driver doesn't fully check the port-feature values stored in the wValue entry of Clear-Port-Feature and Set-Port-Feature requests.  Values that are too large can cause the driver to perform an invalid left shift of more than 32 bits.  Ironically, two of those left shifts are unnecessary, because they implement Set-Port-Feature requests that hubs are not required to support, according to section 11.24.2.13 of the USB-2.0 spec.  This patch adds the appropriate checks for the port feature selector values and removes the unnecessary feature settings.  It also rejects requests to set the TEST feature or to set or clear the INDICATOR and C_OVERCURRENT features, as none of these are relevant to dummy-hcd's root-hub emulation.  CC: <stable@vger.kernel.org> ",c318840fb2a42ce25febc95c4c19357acf1ae5ca,1
net: fix data-race in neigh_event_send(),"KCSAN reported the following data-race [1]  The fix will also prevent the compiler from optimizing out the condition.  [1]  BUG: KCSAN: data-race in neigh_resolve_output / neigh_resolve_output  write to 0xffff8880a41dba78 of 8 bytes by interrupt on cpu 1:  neigh_event_send include/net/neighbour.h:443 [inline]  neigh_resolve_output+0x78/0x480 net/core/neighbour.c:1474  neigh_output include/net/neighbour.h:511 [inline]  ip_finish_output2+0x4af/0xe40 net/ipv4/ip_output.c:228  __ip_finish_output net/ipv4/ip_output.c:308 [inline]  __ip_finish_output+0x23a/0x490 net/ipv4/ip_output.c:290  ip_finish_output+0x41/0x160 net/ipv4/ip_output.c:318  NF_HOOK_COND include/linux/netfilter.h:294 [inline]  ip_output+0xdf/0x210 net/ipv4/ip_output.c:432  dst_output include/net/dst.h:436 [inline]  ip_local_out+0x74/0x90 net/ipv4/ip_output.c:125  __ip_queue_xmit+0x3a8/0xa40 net/ipv4/ip_output.c:532  ip_queue_xmit+0x45/0x60 include/net/ip.h:237  __tcp_transmit_skb+0xe81/0x1d60 net/ipv4/tcp_output.c:1169  tcp_transmit_skb net/ipv4/tcp_output.c:1185 [inline]  __tcp_retransmit_skb+0x4bd/0x15f0 net/ipv4/tcp_output.c:2976  tcp_retransmit_skb+0x36/0x1a0 net/ipv4/tcp_output.c:2999  tcp_retransmit_timer+0x719/0x16d0 net/ipv4/tcp_timer.c:515  tcp_write_timer_handler+0x42d/0x510 net/ipv4/tcp_timer.c:598  tcp_write_timer+0xd1/0xf0 net/ipv4/tcp_timer.c:618  read to 0xffff8880a41dba78 of 8 bytes by interrupt on cpu 0:  neigh_event_send include/net/neighbour.h:442 [inline]  neigh_resolve_output+0x57/0x480 net/core/neighbour.c:1474  neigh_output include/net/neighbour.h:511 [inline]  ip_finish_output2+0x4af/0xe40 net/ipv4/ip_output.c:228  __ip_finish_output net/ipv4/ip_output.c:308 [inline]  __ip_finish_output+0x23a/0x490 net/ipv4/ip_output.c:290  ip_finish_output+0x41/0x160 net/ipv4/ip_output.c:318  NF_HOOK_COND include/linux/netfilter.h:294 [inline]  ip_output+0xdf/0x210 net/ipv4/ip_output.c:432  dst_output include/net/dst.h:436 [inline]  ip_local_out+0x74/0x90 net/ipv4/ip_output.c:125  __ip_queue_xmit+0x3a8/0xa40 net/ipv4/ip_output.c:532  ip_queue_xmit+0x45/0x60 include/net/ip.h:237  __tcp_transmit_skb+0xe81/0x1d60 net/ipv4/tcp_output.c:1169  tcp_transmit_skb net/ipv4/tcp_output.c:1185 [inline]  __tcp_retransmit_skb+0x4bd/0x15f0 net/ipv4/tcp_output.c:2976  tcp_retransmit_skb+0x36/0x1a0 net/ipv4/tcp_output.c:2999  tcp_retransmit_timer+0x719/0x16d0 net/ipv4/tcp_timer.c:515  tcp_write_timer_handler+0x42d/0x510 net/ipv4/tcp_timer.c:598  Reported by Kernel Concurrency Sanitizer on: CPU: 0 PID: 0 Comm: swapper/0 Not tainted 5.4.0-rc3+ #0 Hardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 01/01/2011  ",1b53d64435d56902fc234ff2507142d971a09687,1
mm/gup: Let __get_user_pages_locked() return -EINTR for fatal signal,"__get_user_pages_locked() will return 0 instead of -EINTR after commit 4426e945df588 (""mm/gup: allow VM_FAULT_RETRY for multiple times"") which added extra code to allow gup detect fatal signal faster.  Restore the original -EINTR behavior.  ",ae46d2aa6a7fbe8ca0946f24b061b6ccdc6c3f25,0
f2fs: handle errors of f2fs_get_meta_page_nofail,"First problem is we hit BUG_ON() in f2fs_get_sum_page given EIO on f2fs_get_meta_page_nofail().  Quick fix was not to give any error with infinite loop, but syzbot caught a case where it goes to that loop from fuzzed image. In turned out we abused f2fs_get_meta_page_nofail() like in the below call stack.  - f2fs_fill_super  - f2fs_build_segment_manager   - build_sit_entries    - get_current_sit_page  INFO: task syz-executor178:6870 can't die for more than 143 seconds. ",86f33603f8c51537265ff7ac0320638fd2cbdb1b,1
HID: hiddev: avoid opening a disconnected device,syzbot found the following crash on:  HEAD commit:    e96407b4 usb-fuzzer: main usb gadget fuzzer driver git tree:       https://github.com/google/kasan.git usb-fuzzer console output: https://syzkaller.appspot.com/x/log.txt?x=147ac20c600000 kernel config:  https://syzkaller.appspot.com/x/.config?x=792eb47789f57810 dashboard link: https://syzkaller.appspot.com/bug?extid=62a1e04fd3ec2abf099e compiler:       gcc (GCC) 9.0.0 20181231 (experimental)  ,9c09b214f30e3c11f9b0b03f89442df03643794d,1
bpf: fix bpf_prog_array_copy_to_user() issues,"1. move copy_to_user out of rcu section to fix the following issue:  ./include/linux/rcupdate.h:302 Illegal context switch in RCU read-side critical section! stack backtrace:  __dump_stack lib/dump_stack.c:17 [inline]  dump_stack+0x194/0x257 lib/dump_stack.c:53  lockdep_rcu_suspicious+0x123/0x170 kernel/locking/lockdep.c:4592  rcu_preempt_sleep_check include/linux/rcupdate.h:301 [inline]  ___might_sleep+0x385/0x470 kernel/sched/core.c:6079  __might_sleep+0x95/0x190 kernel/sched/core.c:6067  __might_fault+0xab/0x1d0 mm/memory.c:4532  _copy_to_user+0x2c/0xc0 lib/usercopy.c:25  copy_to_user include/linux/uaccess.h:155 [inline]  bpf_prog_array_copy_to_user+0x217/0x4d0 kernel/bpf/core.c:1587  bpf_prog_array_copy_info+0x17b/0x1c0 kernel/bpf/core.c:1685  perf_event_query_prog_array+0x196/0x280 kernel/trace/bpf_trace.c:877  _perf_ioctl kernel/events/core.c:4737 [inline]  perf_ioctl+0x3e1/0x1480 kernel/events/core.c:4757  2. move *prog under rcu, since it's not ok to dereference it afterwards  3. in a rare case of prog array being swapped between bpf_prog_array_length()    and bpf_prog_array_copy_to_user() calls make sure to copy zeros to user space,    so the user doesn't walk over uninited prog_ids while kernel reported    uattr->query.prog_cnt > 0  ",0911287ce32b14fbc8aab0083151d9b54254091c,1
writeback: fix use-after-free in finish_writeback_work(),"finish_writeback_work() reads @done->waitq after decrementing @done->cnt.  However, once @done->cnt reaches zero, @done may be freed (from stack) at any moment and @done->waitq can contain something unrelated by the time finish_writeback_work() tries to read it.  This led to the following crash.    ""BUG: kernel NULL pointer dereference, ",8e00c4e9dd852f7a9bf12234fad65a2f2f93788f,1
mac80211: free sta in sta_info_insert_finish() on errors,"If sta_info_insert_finish() fails, we currently keep the station around and free it only in the caller, but there's only one such caller and it always frees it immediately.  As syzbot found, another consequence of this split is that we can put things that sleep only into __cleanup_single_sta() and not in sta_info_free(), but this is the only place that requires such of sta_info_free() now.  Change this to free the station in sta_info_insert_finish(), in which case we can still sleep. This will also let us unify the cleanup code later.  ",7bc40aedf24d31d8bea80e1161e996ef4299fb10,0
ipc/util.c: use ipc_rcu_putref() for failues in ipc_addid(),"ipc_addid() is impossible to use: - for certain failures, the caller must not use ipc_rcu_putref(),   because the reference counter is not yet initialized. - for other failures, the caller must use ipc_rcu_putref(),   because parallel operations could be ongoing already.  The patch cleans that up, by initializing the refcount early, and by modifying all callers.  The issues is related to the finding of syzbot+2827ef6b3385deb07eaf@syzkaller.appspotmail.com: syzbot found an issue with reading kern_ipc_perm.seq, here both read and write to already released memory could happen.  ",39cfffd774a2e8818250360a3e028b5eac9d5392,1
rose: Fix Null pointer dereference in rose_send_frame(),"rose_send_frame() dereferences `neigh->dev` when called from rose_transmit_clear_request(), and the first occurrence of the `neigh` is in rose_loopback_timer() as `rose_loopback_neigh`, and it is initialized in rose_add_loopback_neigh() as NULL. i.e when `rose_loopback_neigh` used in rose_loopback_timer() its `->dev` was still NULL and rose_loopback_timer() was calling rose_rx_call_request() without checking for NULL.  - net/rose/rose_link.c This bug seems to get triggered in this line:  rose_call = (ax25_address *)neigh->dev->dev_addr;  Fix it by adding NULL checking for `rose_loopback_neigh->dev` in rose_loopback_timer().  ",3b3fd068c56e3fbea30090859216a368398e39bf,1
xfrm: policy: fix bydst hlist corruption on hash rebuild,"syzbot reported following spat:  BUG: KASAN: use-after-free in __write_once_size include/linux/compiler.h:221 BUG: KASAN: use-after-free in hlist_del_rcu include/linux/rculist.h:455 BUG: KASAN: use-after-free in xfrm_hash_rebuild+0xa0d/0x1000 net/xfrm/xfrm_policy.c:1318 Write of size 8 at addr ffff888095e79c00 by task kworker/1:3/8066 Workqueue: events xfrm_hash_rebuild Call Trace:  __write_once_size include/linux/compiler.h:221 [inline]  hlist_del_rcu include/linux/rculist.h:455 [inline]  xfrm_hash_rebuild+0xa0d/0x1000 net/xfrm/xfrm_policy.c:1318  process_one_work+0x814/0x1130 kernel/workqueue.c:2269 Allocated by task 8064:  __kmalloc+0x23c/0x310 mm/slab.c:3669  kzalloc include/linux/slab.h:742 [inline]  xfrm_hash_alloc+0x38/0xe0 net/xfrm/xfrm_hash.c:21  xfrm_policy_init net/xfrm/xfrm_policy.c:4036 [inline]  xfrm_net_init+0x269/0xd60 net/xfrm/xfrm_policy.c:4120  ops_init+0x336/0x420 net/core/net_namespace.c:130  setup_net+0x212/0x690 net/core/net_namespace.c:316  The faulting address is the address of the old chain head, free'd by xfrm_hash_resize().  In xfrm_hash_rehash(), chain heads get re-initialized without any hlist_del_rcu:   for (i = hmask; i >= 0; i--)     INIT_HLIST_HEAD(odst + i);  Then, hlist_del_rcu() gets called on the about to-be-reinserted policy when iterating the per-net list of policies.  hlist_del_rcu() will then make chain->first be nonzero again:  static inline void __hlist_del(struct hlist_node *n) {    struct hlist_node *next = n->next;   // address of next element in list    struct hlist_node **pprev = n->pprev;// location of previous elem, this                                         // can point at chain->first         WRITE_ONCE(*pprev, next);       // chain->first points to next elem         if (next)                 next->pprev = pprev;  Then, when we walk chainlist to find insertion point, we may find a non-empty list even though we're supposedly reinserting the first policy to an empty chain.  To fix this first unlink all exact and inexact policies instead of zeroing the list heads.  Add the commands equivalent to the syzbot reproducer to xfrm_policy.sh, without fix KASAN catches the corruption as it happens, SLUB poisoning detects it a bit later.  ",fd709721352dd5239056eacaded00f2244e6ef58,1
USB: ldusb: fix read info leaks,"Fix broken read implementation, which could be used to trigger slab info leaks.  The driver failed to check if the custom ring buffer was still empty when waking up after having waited for more data. This would happen on every interrupt-in completion, even if no data had been added to the ring buffer (e.g. on disconnect events).  Due to missing sanity checks and uninitialised (kmalloced) ring-buffer entries, this meant that huge slab info leaks could easily be triggered.  Note that the empty-buffer check after wakeup is enough to fix the info leak on disconnect, but let's clear the buffer on allocation and add a sanity check to read() to prevent further leaks.  ",7a6f22d7479b7a0b68eadd308a997dd64dda7dae,1
dccp: check sk for closed state in dccp_sendmsg(),"dccp_disconnect() sets 'dp->dccps_hc_tx_ccid' tx handler to NULL, therefore if DCCP socket is disconnected and dccp_sendmsg() is called after it, it will cause a NULL pointer dereference in dccp_write_xmit().  This crash and the reproducer was reported by syzbot. Looks like it is reproduced if commit 69c64866ce07 (""dccp: CVE-2017-8824: use-after-free in DCCP code"") is applied.  ",67f93df79aeefc3add4e4b31a752600f834236e2,1
lockdep: Fix preemption WARN for spurious IRQ-enable,It is valid (albeit uncommon) to call local_irq_enable() without first having called local_irq_disable(). In this case we enter lockdep_hardirqs_on*() with IRQs enabled and trip a preemption warning for using __this_cpu_read().  Use this_cpu_read() instead to avoid the warning.  ,f8e48a3dca060e80f672d398d181db1298fbc86c,0
tcp: annotate sk->sk_rcvbuf lockless reads,"For the sake of tcp_poll(), there are few places where we fetch sk->sk_rcvbuf while this field can change from IRQ or other cpu.  We need to add READ_ONCE() annotations, and also make sure write sides use corresponding WRITE_ONCE() to avoid store-tearing.  Note that other transports probably need similar fixes.  ",ebb3b78db7bf842270a46fd4fe7cc45c78fa5ed6,0
ALSA: usb-audio: Fix copy&paste error in the validator,The recently introduced USB-audio descriptor validator had a stupid copy&paste error that may lead to an unexpected overlook of too short descriptors for processing and extension units.  It's likely the cause of the report triggered by syzkaller fuzzer.  Let's fix it.  ,ba8bf0967a154796be15c4983603aad0b05c3138,1
net/smc: check for valid ib_client_data,In smc_ib_remove_dev() check if the provided ib device was actually initialized for SMC before.  ,a2f2ef4a54c0d97aa6a8386f4ff23f36ebb488cf,0
USB: adutux: fix use-after-free on disconnect,"The driver was clearing its struct usb_device pointer, which it used as an inverted disconnected flag, before deregistering the character device and without serialising against racing release().  This could lead to a use-after-free if a racing release() callback observes the cleared pointer and frees the driver data before disconnect() is finished with it.  This could also lead to NULL-pointer dereferences in a racing open().  ",44efc269db7929f6275a1fa927ef082e533ecde0,1
ovl: fix warning in ovl_create_real(),"Syzbot triggered the following warning in ovl_workdir_create() -> ovl_create_real():  	if (!err && WARN_ON(!newdentry->d_inode)) {  The reason is that the cgroup2 filesystem returns from mkdir without instantiating the new dentry.  Weird filesystems such as this will be rejected by overlayfs at a later stage during setup, but to prevent such a warning, call ovl_mkdir_real() directly from ovl_workdir_create() and reject this case early.  ",1f5573cfe7a7056e80a92c7a037a3e69f3a13d1c,0
libnvdimm: KASAN: global-out-of-bounds Read in internal_create_group,"Because the last member of the ""nvdimm_firmware_attributes"" array was not assigned a null ptr, when traversal of ""grp->attrs"" array is out of bounds in ""create_files"" func.  func: 	create_files: 		->for (i = 0, attr = grp->attrs; *attr && !error; i++, attr++) 			->....  BUG: KASAN: global-out-of-bounds in create_files fs/sysfs/group.c:43 [inline] BUG: KASAN: global-out-of-bounds in internal_create_group+0x9d8/0xb20 fs/sysfs/group.c:149 Read of size 8 at addr ffffffff8a2e4cf0 by task kworker/u17:10/959  CPU: 2 PID: 959 Comm: kworker/u17:10 Not tainted 5.8.0-syzkaller #0 Hardware name: QEMU Standard PC (Q35 + ICH9, 2009), BIOS rel-1.12.0-59-gc9ba5276e321-prebuilt.qemu.org 04/01/2014 Workqueue: events_unbound async_run_entry_fn Call Trace:  __dump_stack lib/dump_stack.c:77 [inline]  dump_stack+0x18f/0x20d lib/dump_stack.c:118  print_address_description.constprop.0.cold+0x5/0x497 mm/kasan/report.c:383  __kasan_report mm/kasan/report.c:513 [inline]  kasan_report.cold+0x1f/0x37 mm/kasan/report.c:530  create_files fs/sysfs/group.c:43 [inline]  internal_create_group+0x9d8/0xb20 fs/sysfs/group.c:149  internal_create_groups.part.0+0x90/0x140 fs/sysfs/group.c:189  internal_create_groups fs/sysfs/group.c:185 [inline]  sysfs_create_groups+0x25/0x50 fs/sysfs/group.c:215  device_add_groups drivers/base/core.c:2024 [inline]  device_add_attrs drivers/base/core.c:2178 [inline]  device_add+0x7fd/0x1c40 drivers/base/core.c:2881  nd_async_device_register+0x12/0x80 drivers/nvdimm/bus.c:506  async_run_entry_fn+0x121/0x530 kernel/async.c:123  process_one_work+0x94c/0x1670 kernel/workqueue.c:2269  worker_thread+0x64c/0x1120 kernel/workqueue.c:2415  kthread+0x3b5/0x4a0 kernel/kthread.c:292  ret_from_fork+0x1f/0x30 arch/x86/entry/entry_64.S:294  The buggy address belongs to the variable:  nvdimm_firmware_attributes+0x10/0x40  ",62c789270c0b1ed5598c6b87c53b6908cd3c6eb5,1
ALSA: line6: Assure canceling delayed work at disconnection,"The current code performs the cancel of a delayed work at the late stage of disconnection procedure, which may lead to the access to the already cleared state.  This patch assures to call cancel_delayed_work_sync() at the beginning of the disconnection procedure for avoiding that race.  The delayed work object is now assigned in the common line6 object instead of its derivative, so that we can call cancel_delayed_work_sync().  Along with the change, the startup function is called via the new callback instead.  This will make it easier to port other LINE6 drivers to use the delayed work for startup in later patches.  ",0b074ab7fc0d575247b9cc9f93bb7e007ca38840,1
Input: iforce - add sanity checks,The endpoint type should also be checked before a device is accepted.  ,849f5ae3a513c550cad741c68dd3d7eb2bcc2a2c,1
ipv4/igmp: fix another memory leak in igmpv3_del_delrec(),"syzbot reported memory leaks [1] that I have back tracked to a missing cleanup from igmpv3_del_delrec() when (im->sfmode != MCAST_INCLUDE)  Add ip_sf_list_clear_all() and kfree_pmc() helpers to explicitely handle the cleanups before freeing.  [1]  BUG: memory leak unreferenced object 0xffff888123e32b00 (size 64):   comm ""softirq"", pid 0, jiffies 4294942968 (age 8.010s)   ",3580d04aa674383c42de7b635d28e52a1e5bc72c,1
tracing: Avoid memory leak in predicate_parse(),"In case of errors, predicate_parse() goes to the out_free label to free memory and to return an error code.  However, predicate_parse() does not free the predicates of the temporary prog_stack array, thence leaking them.   ",dfb4a6f2191a80c8b790117d0ff592fd712d3296,1
media: hdpvr: Add device num check and handling,"Add hdpvr device num check and error handling  We need to increment the device count atomically before we checkout a device to make sure that we do not reach the max count, otherwise we get out-of-bounds errors as reported by syzbot.  ",d4a6a9537bc32811486282206ecfb7c53754b74d,1
net: openvswitch: free vport unless register_netdevice() succeeds,syzbot found the following crash on:  HEAD commit:    1e78030e Merge tag 'mmc-v5.3-rc1' of git://git.kernel.org/.. git tree:       upstream console output: https://syzkaller.appspot.com/x/log.txt?x=148d3d1a600000 kernel config:  https://syzkaller.appspot.com/x/.config?x=30cef20daf3e9977 dashboard link: https://syzkaller.appspot.com/bug?extid=13210896153522fe1ee5 compiler:       gcc (GCC) 9.0.0 20181231 (experimental) syz repro:      https://syzkaller.appspot.com/x/repro.syz?x=136aa8c4600000 C reproducer:   https://syzkaller.appspot.com/x/repro.c?x=109ba792600000  ,9464cc37f3671ee69cb1c00662b5e1f113a96b23,1
media: pvrusb2: use a different format for warnings,"When the pvrusb2 driver detects that there's something wrong with the device, it prints a warning message. Right now those message are printed in two different formats:  1. ***",1753c7c4367aa1201e1e5d0a601897ab33444af1,0
tipc: orphan sock in tipc_release(),"Before we unlock the sock in tipc_release(), we have to detach sk->sk_socket from sk, otherwise a parallel tipc_sk_fill_sock_diag() could stil read it after we free this socket.  ",0a3b8b2b215f9e84b82ae97df71292ccfd92b1e7,0
fuse: wait for writepages in syncfs,"In case of fuse the MM subsystem doesn't guarantee that page writeback completes by the time ->sync_fs() is called.  This is because fuse completes page writeback immediately to prevent DoS of memory reclaim by the userspace file server.  This means that fuse itself must ensure that writes are synced before sending the SYNCFS request to the server.  Introduce sync buckets, that hold a counter for the number of outstanding write requests.  On syncfs replace the current bucket with a new one and wait until the old bucket's counter goes down to zero.  It is possible to have multiple syncfs calls in parallel, in which case there could be more than one waited-on buckets.  Descendant buckets must not complete until the parent completes.  Add a count to the child (new) bucket until the (parent) old bucket completes.  Use RCU protection to dereference the current bucket and to wake up an emptied bucket.  Use fc->lock to protect against parallel assignments to the current bucket.  This leaves just the counter to be a possible scalability issue.  The fc->num_waiting counter has a similar issue, so both should be addressed at the same time.  ",660585b56e63ca034ad506ea53c807c5cdca3196,1
ethtool: fix string set id check,Syzbot reported a shift of a u32 by more than 31 in strset_parse_request() which is undefined behavior. This is caused by range check of string set id using variable ret (which is always 0 at this point) instead of id (string set id from request).  ,efb796f5571f030743e1d9c662cdebdad724f8c5,0
ISDN: hfcsusb: checking idx of ep configuration,The syzbot test with random endpoint address which made the idx is overflow in the table of endpoint configuations.  this adds the checking for fixing the error report from syzbot  KASAN: stack-out-of-bounds Read in hfcsusb_probe [1] The patch tested by syzbot [2]  ,f384e62a82ba5d85408405fdd6aeff89354deaa9,1
netfilter: ebtables: also count base chain policies,"ebtables doesn't include the base chain policies in the rule count, so we need to add them manually when we call into the x_tables core to allocate space for the comapt offset table.  This lead syzbot to trigger: ",3b48300d5cc7c7bed63fddb006c4046549ed4aec,0
ext4: fix memory leak in ext4_mb_init_backend on error path.,Fix a memory leak discovered by syzbot when a file system is corrupted with an illegally large s_log_groups_per_flex.  ,a8867f4e3809050571c98de7a2d465aff5e4daf5,1
"Revert ""vhost: access vq metadata through kernel virtual address""","This reverts commit 7f466032dc (""vhost: access vq metadata through kernel virtual address"").  The commit caused a bunch of issues, and while commit 73f628ec9e (""vhost: disable metadata prefetch optimization"") disabled the optimization it's not nice to keep lots of dead code around.  ",3d2c7d37047557175fb41de044091050b5f0d73b,0
net: openvswitch: fixes potential deadlock in dp cleanup code,"The previous patch introduced a deadlock, this patch fixes it by making sure the work is canceled without holding the global ovs lock. This is done by moving the reorder processing one layer up to the netns level.  ",a65878d6f00bb2d791348ae90dcc2ede1dbe2b91,0
media: pvrusb2: fix warning in pvr2_i2c_core_done,"syzbot has reported the following warning in pvr2_i2c_done:  	sysfs group 'power' not found for kobject '1-0043'  When the device is disconnected (pvr_hdw_disconnect), the i2c adapter is not unregistered along with the USB and v4l2 teardown. As part of the USB device disconnect, the sysfs files of the subdevices are also deleted. So, by the time pvr_i2c_core_done is called by pvr_context_destroy, the sysfs files have been deleted.  To fix this, unregister the i2c adapter too in pvr_hdw_disconnect. Make the device deregistration code shared by calling pvr_hdw_disconnect from pvr2_hdw_destroy.  ",f8194e5e63fdcb349e8da9eef9e574d5b1d687cb,0
fuse: fix control dir setup and teardown,"syzbot is reporting NULL pointer dereference at fuse_ctl_remove_conn() [1]. Since fc->ctl_ndents is incremented by fuse_ctl_add_conn() when new_inode() failed, fuse_ctl_remove_conn() reaches an inode-less dentry and tries to clear d_inode(dentry)->i_private field.  Fix by only adding the dentry to the array after being fully set up.  When tearing down the control directory, do d_invalidate() on it to get rid of any mounts that might have been added.  [1] https://syzkaller.appspot.com/bug?id=f396d863067238959c91c0b7cfc10b163638cac6 ",6becdb601bae2a043d7fb9762c4d48699528ea6e,1
misc/uss720: fix memory leak in uss720_probe,"uss720_probe forgets to decrease the refcount of usbdev in uss720_probe. Fix this by decreasing the refcount of usbdev by usb_put_dev.  BUG: memory leak unreferenced object 0xffff888101113800 (size 2048):   comm ""kworker/0:1"", pid 7, jiffies 4294956777 (age 28.870s)   ",dcb4b8ad6a448532d8b681b5d1a7036210b622de,1
dh key: fix rounding up KDF output length,"Commit 383203eff718 (""dh key: get rid of stack allocated array"") changed kdf_ctr() to assume that the length of key material to derive is a multiple of the digest size.  The length was supposed to be rounded up accordingly.  However, the round_up() macro was used which only gives the correct result on power-of-2 arguments, whereas not all hash algorithms have power-of-2 digest sizes.  In some cases this resulted in a write past the end of the 'outbuf' buffer.  Fix it by switching to roundup(), which works for non-power-of-2 inputs.  ",3619dec5103dd999a777e3e4ea08c8f40a6ddc57,0
Fix memory leak in sctp_process_init,"syzbot found the following leak in sctp_process_init BUG: memory leak unreferenced object 0xffff88810ef68400 (size 1024):   comm ""syz-executor273"", pid 7046, jiffies 4294945598 (age 28.770s)   ",0a8dd9f67cd0da7dc284f48b032ce00db1a68791,1
netfilter: xt_RATEEST: reject non-null terminated string from userspace,syzbot reports: detected buffer overflow in strlen [..] Call Trace:  strlen include/linux/string.h:325 [inline]  strlcpy include/linux/string.h:348 [inline]  xt_rateest_tg_checkentry+0x2a5/0x6b0 net/netfilter/xt_RATEEST.c:143  strlcpy assumes src is a c-string. Check info->name before its used.  ,6cb56218ad9e580e519dcd23bfb3db08d8692e5a,1
i2c: i801: Don't generate an interrupt on bus reset,"Now that the i2c-i801 driver supports interrupts, setting the KILL bit in a attempt to recover from a timed out transaction triggers an interrupt. Unfortunately, the interrupt handler (i801_isr) is not prepared for this situation and will try to process the interrupt as if it was signaling the end of a successful transaction. In the case of a block transaction, this can result in an out-of-range memory access.  This condition was reproduced several times by syzbot: https://syzkaller.appspot.com/bug?extid=ed71512d469895b5b34e https://syzkaller.appspot.com/bug?extid=8c8dedc0ba9e03f6c79e https://syzkaller.appspot.com/bug?extid=c8ff0b6d6c73d81b610e https://syzkaller.appspot.com/bug?extid=33f6c360821c399d69eb https://syzkaller.appspot.com/bug?extid=be15dc0b1933f04b043a https://syzkaller.appspot.com/bug?extid=b4d3fd1dfd53e90afd79  So disable interrupts while trying to reset the bus. Interrupts will be enabled again for the following transaction.  ",e4d8716c3dcec47f1557024add24e1f3c09eb24b,1
smackfs: restrict bytes count in smk_set_cipso(),"Oops, I failed to update subject line.  From 07571157c91b98ce1a4aa70967531e64b78e8346 Mon Sep 17 00:00:00 2001 From: Tetsuo Handa <penguin-kernel@I-love.SAKURA.ne.jp> Date: Mon, 12 Apr 2021 22:25:06 +0900 Subject: [PATCH] smackfs: restrict bytes count in smk_set_cipso()  Commit 7ef4c19d245f3dc2 (""smackfs: restrict bytes count in smackfs write functions"") missed that count > SMK_CIPSOMAX check applies to only format == SMK_FIXED24_FMT case.  ",49ec114a6e62d8d320037ce71c1aaf9650b3cafd,0
netfilter: x_tables: Switch synchronization to RCU,"When running concurrent iptables rules replacement with data, the per CPU sequence count is checked after the assignment of the new information. The sequence count is used to synchronize with the packet path without the use of any explicit locking. If there are any packets in the packet path using the table information, the sequence count is incremented to an odd value and is incremented to an even after the packet process completion.  The new table value assignment is followed by a write memory barrier so every CPU should see the latest value. If the packet path has started with the old table information, the sequence counter will be odd and the iptables replacement will wait till the sequence count is even prior to freeing the old table info.  However, this assumes that the new table information assignment and the memory barrier is actually executed prior to the counter check in the replacement thread. If CPU decides to execute the assignment later as there is no user of the table information prior to the sequence check, the packet path in another CPU may use the old table information. The replacement thread would then free the table information under it leading to a use after free in the packet processing context-  Unable to handle kernel NULL pointer dereference at virtual address 000000000000008e pc : ip6t_do_table+0x5d0/0x89c lr : ip6t_do_table+0x5b8/0x89c ip6t_do_table+0x5d0/0x89c ip6table_filter_hook+0x24/0x30 nf_hook_slow+0x84/0x120 ip6_input+0x74/0xe0 ip6_rcv_finish+0x7c/0x128 ipv6_rcv+0xac/0xe4 __netif_receive_skb+0x84/0x17c process_backlog+0x15c/0x1b8 napi_poll+0x88/0x284 net_rx_action+0xbc/0x23c __do_softirq+0x20c/0x48c  This could be fixed by forcing instruction order after the new table information assignment or by switching to RCU for the synchronization.  ",cc00bcaa589914096edef7fb87ca5cee4a166b5c,1
llc: use refcount_inc_not_zero() for llc_sap_find(),"llc_sap_put() decreases the refcnt before deleting sap from the global list. Therefore, there is a chance llc_sap_find() could find a sap with zero refcnt in this global list.  Close this race condition by checking if refcnt is zero or not in llc_sap_find(), if it is zero then it is being removed so we can just treat it as gone.  ",0dcb82254d65f72333aa50ad626d1e9665ad093b,1
NFS: Fix leak of ctx->nfs_server.hostname,"If userspace passes an nfs_mount_data struct in the data argument of mount(2), then nfs23_parse_monolithic() or nfs4_parse_monolithic() will allocate memory for ctx->nfs_server.hostname.  This needs to be freed in nfs_parse_source(), which also allocates memory for ctx->nfs_server.hostname, otherwise a leak will occur.  ",75a9b9176157f3095d3099adf512b5a233addbc7,0
net/x25: reset state in x25_connect(),"In case x25_connect() fails and frees the socket neighbour, we also need to undo the change done to x25->state.  Before my last bug fix, we had use-after-free so this patch fixes a latent bug.  syzbot report :  kasan: CONFIG_KASAN_INLINE enabled kasan: GPF could be caused by NULL-ptr deref or user memory access general protection fault: 0000 [#1] PREEMPT SMP KASAN CPU: 1 PID: 16137 Comm: syz-executor.1 Not tainted 5.0.0+ #117 Hardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 01/01/2011 ",ee74d0bd4325efb41e38affe5955f920ed973f23,1
batman-adv: Avoid uninitialized chaddr when handling DHCP,The gateway client code can try to optimize the delivery of DHCP packets to avoid broadcasting them through the whole mesh. But also transmissions to the client can be optimized by looking up the destination via the chaddr of the DHCP packet.  But the chaddr is currently only done when chaddr is fully inside the non-paged area of the skbuff. Otherwise it will not be initialized and the unoptimized path should have been taken.  But the implementation didn't handle this correctly. It didn't retrieve the correct chaddr but still tried to perform the TT lookup with this uninitialized memory.  ,303216e76dcab6049c9d42390b1032f0649a8206,1
USB: usbfs: Filter flags passed in from user space,USBDEVFS_URB_ISO_ASAP must be accepted only for ISO endpoints. Improve sanity checking.  ,446f666da9f019ce2ffd03800995487e79a91462,1
io_uring: drop sqd lock before handling signals for SQPOLL,"Don't call into get_signal() with the sqd mutex held, it'll fail if we're freezing the task and we'll get complaints on locks still being held:  ",82734c5b1b24c020d701cf90ccb075e43a5ccb07,1
kthread: zero the kthread data structure,"kthread() could bail out early before we initialize blkcg_css (if the kthread is killed very early. Please see xchg() statement in kthread()), which confuses free_kthread_struct. Instead of moving the blkcg_css initialization early, we simply zero the whole 'self' data structure, which doesn't sound much overhead.  ",e10237cc76ef9a4066a84aa2cc710bfd708cc341,0
io_uring: fix file leak on error path of io ctx creation,"Put file as part of error handling when setting up io ctx to fix memory leaks like the following one.     BUG: memory leak    unreferenced object 0xffff888101ea2200 (size 256):      comm ""syz-executor355"", pid 8470, jiffies 4294953658 (age 32.400s)      ",f26c08b444df833b19c00838a530d93963ce9cd0,1
packet: fix reserve calculation,"Commit b84bbaf7a6c8 (""packet: in packet_snd start writing at link layer allocation"") ensures that packet_snd always starts writing the link layer header in reserved headroom allocated for this purpose.  This is needed because packets may be shorter than hard_header_len, in which case the space up to hard_header_len may be zeroed. But that necessary padding is not accounted for in skb->len.  The fix, however, is buggy. It calls skb_push, which grows skb->len when moving skb->data back. But in this case packet length should not change.  Instead, call skb_reserve, which moves both skb->data and skb->tail back, without changing length.  ",9aad13b087ab0a588cd68259de618f100053360e,0
rtnetlink: avoid RCU read lock when holding RTNL,"When we call af_ops->set_link_af() we hold a RCU read lock as we retrieve af_ops from the RCU protected list, but this is unnecessary because we already hold RTNL lock, which is the writer lock for protecting rtnl_af_ops, so it is safer than RCU read lock. Similar for af_ops->validate_link_af().  This was not a problem until we begin to take mutex lock down the path of ->set_link_af() in __ipv6_dev_mc_dec() recently. We can just drop the RCU read lock there and assert RTNL lock.  ",a100243d95a60d74ae9bb9df1f5f2192e9aed6a7,0
mptcp: be careful on MPTCP-level ack.,"We can enter the main mptcp_recvmsg() loop even when no subflows are connected. As note by Eric, that would result in a divide by zero oops on ack generation.  Address the issue by checking the subflow status before sending the ack.  Additionally protect mptcp_recvmsg() against invocation with weird socket states.  v1 -> v2:  - removed unneeded inline keyword - Jakub  Reported-and-suggested-by: Eric Dumazet <eric.dumazet@gmail.com> ",fd8976790a6c1fee98bd7bc73754ddc9f01273ab,1
"revert ""net: kcm: fix memory leak in kcm_sendmsg""","In commit c47cc304990a (""net: kcm: fix memory leak in kcm_sendmsg"") I misunderstood the root case of the memory leak and came up with completely broken fix.  So, simply revert this commit to avoid GPF reported by syzbot.  Im so sorry for this situation.  ",a47c397bb29fce1751dc755246a2c8deeca5e38f,1
xfrm: policy: Fix out-of-bound array accesses in __xfrm_policy_unlink,"UBSAN report this:  UBSAN: Undefined behaviour in net/xfrm/xfrm_policy.c:1289:24 index 6 is out of range for type 'unsigned int [6]' CPU: 1 PID: 0 Comm: swapper/1 Not tainted 4.4.162-514.55.6.9.x86_64+ #13 Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS 1.10.2-1ubuntu1 04/01/2014  0000000000000000 1466cf39b41b23c9 ffff8801f6b07a58 ffffffff81cb35f4  0000000041b58ab3 ffffffff83230f9c ffffffff81cb34e0 ffff8801f6b07a80  ffff8801f6b07a20 1466cf39b41b23c9 ffffffff851706e0 ffff8801f6b07ae8 Call Trace:  <IRQ>  [<ffffffff81cb35f4>] __dump_stack lib/dump_stack.c:15 [inline]  <IRQ>  [<ffffffff81cb35f4>] dump_stack+0x114/0x1a0 lib/dump_stack.c:51  [<ffffffff81d94225>] ubsan_epilogue+0x12/0x8f lib/ubsan.c:164  [<ffffffff81d954db>] __ubsan_handle_out_of_bounds+0x16e/0x1b2 lib/ubsan.c:382  [<ffffffff82a25acd>] __xfrm_policy_unlink+0x3dd/0x5b0 net/xfrm/xfrm_policy.c:1289  [<ffffffff82a2e572>] xfrm_policy_delete+0x52/0xb0 net/xfrm/xfrm_policy.c:1309  [<ffffffff82a3319b>] xfrm_policy_timer+0x30b/0x590 net/xfrm/xfrm_policy.c:243  [<ffffffff813d3927>] call_timer_fn+0x237/0x990 kernel/time/timer.c:1144  [<ffffffff813d8e7e>] __run_timers kernel/time/timer.c:1218 [inline]  [<ffffffff813d8e7e>] run_timer_softirq+0x6ce/0xb80 kernel/time/timer.c:1401  [<ffffffff8120d6f9>] __do_softirq+0x299/0xe10 kernel/softirq.c:273  [<ffffffff8120e676>] invoke_softirq kernel/softirq.c:350 [inline]  [<ffffffff8120e676>] irq_exit+0x216/0x2c0 kernel/softirq.c:391  [<ffffffff82c5edab>] exiting_irq arch/x86/include/asm/apic.h:652 [inline]  [<ffffffff82c5edab>] smp_apic_timer_interrupt+0x8b/0xc0 arch/x86/kernel/apic/apic.c:926  [<ffffffff82c5c985>] apic_timer_interrupt+0xa5/0xb0 arch/x86/entry/entry_64.S:735  <EOI>  [<ffffffff81188096>] ? native_safe_halt+0x6/0x10 arch/x86/include/asm/irqflags.h:52  [<ffffffff810834d7>] arch_safe_halt arch/x86/include/asm/paravirt.h:111 [inline]  [<ffffffff810834d7>] default_idle+0x27/0x430 arch/x86/kernel/process.c:446  [<ffffffff81085f05>] arch_cpu_idle+0x15/0x20 arch/x86/kernel/process.c:437  [<ffffffff8132abc3>] default_idle_call+0x53/0x90 kernel/sched/idle.c:92  [<ffffffff8132b32d>] cpuidle_idle_call kernel/sched/idle.c:156 [inline]  [<ffffffff8132b32d>] cpu_idle_loop kernel/sched/idle.c:251 [inline]  [<ffffffff8132b32d>] cpu_startup_entry+0x60d/0x9a0 kernel/sched/idle.c:299  [<ffffffff8113e119>] start_secondary+0x3c9/0x560 arch/x86/kernel/smpboot.c:245  The issue is triggered as this:  xfrm_add_policy     -->verify_newpolicy_info  //check the index provided by user with XFRM_POLICY_MAX 			      //In my case, the index is 0x6E6BB6, so it pass the check.     -->xfrm_policy_construct  //copy the user's policy and set xfrm_policy_timer     -->xfrm_policy_insert 	--> __xfrm_policy_link //use the orgin dir, in my case is 2 	--> xfrm_gen_index   //generate policy index, there is 0x6E6BB6  then xfrm_policy_timer be fired  xfrm_policy_timer    --> xfrm_policy_id2dir  //get dir from (policy index & 7), in my case is 6    --> xfrm_policy_delete       --> __xfrm_policy_unlink //access policy_count[dir], trigger out of range access  Add xfrm_policy_id2dir check in verify_newpolicy_info, make sure the computed dir is valid, to fix the issue.  ",b805d78d300bcf2c83d6df7da0c818b0fee41427,1
nl80211: fix beacon head validation,"If the beacon head attribute (NL80211_ATTR_BEACON_HEAD) is too short to even contain the frame control field, we access uninitialized data beyond the buffer. Fix this by checking the minimal required size first. We used to do this until S1G support was added, where the fixed data portion has a different size.  ",9a6847ba1747858ccac53c5aba3e25c54fbdf846,1
rxrpc: Fix possible NULL pointer access in ICMP handling,"If an ICMP packet comes in on the UDP socket backing an AF_RXRPC socket as the UDP socket is being shut down, rxrpc_error_report() may get called to deal with it after sk_user_data on the UDP socket has been cleared, leading to a NULL pointer access when this local endpoint record gets accessed.  Fix this by just returning immediately if sk_user_data was NULL.  The oops looks like the following:  #PF: supervisor read access in kernel mode #PF: error_code(0x0000) - not-present page ... ",f0308fb0708078d6c1d8a4d533941a7a191af634,1
staging: wlan-ng: fix out of bounds read in prism2sta_probe_usb(),"let's use usb_find_common_endpoints() to discover endpoints, it does all necessary checks for type and xfer direction  remove memset() in hfa384x_create(), because we now assign endpoints in prism2sta_probe_usb() and because create_wlan() uses kzalloc() to allocate hfa384x struct before calling hfa384x_create()  ",fea22e159d51c766ba70473f473a0ec914cc7e92,1
soreuseport: fix initialization race,Syzkaller stumbled upon a way to trigger ,1b5f962e71bfad6284574655c406597535c3ea7a,1
netfilter: x_tables: don't return garbage pointer on modprobe failure,"request_module may return a positive error result from modprobe, if we cast this to ERR_PTR this returns a garbage result (it passes IS_ERR checks).  Fix it by ignoring modprobe return values entirely, just retry the table lookup instead.  ",e3eeacbac4ad34fac93f82a7cf15402bba83d22e,0
net_sched: fix an OOB access in cls_tcindex,"As Eric noticed, tcindex_alloc_perfect_hash() uses cp->hash to compute the size of memory allocation, but cp->hash is set again after the allocation, this caused an out-of-bound access.  So we have to move all cp->hash initialization and computation before the memory allocation. Move cp->mask and cp->shift together as cp->hash may need them for computation too.  ",599be01ee567b61f4471ee8078870847d0a11e8e,1
blk-mq: fallback to previous nr_hw_queues when updating fails,"When we try to increate the nr_hw_queues, we may fail due to shortage of memory or other reason, then blk_mq_realloc_hw_ctxs stops and some entries in q->queue_hw_ctx are left with NULL. However, because queue map has been updated with new nr_hw_queues, some cpus have been mapped to hw queue which just encounters allocation failure, thus blk_mq_map_queue could return NULL. This will cause panic in following blk_mq_map_swqueue.  To fix it, when increase nr_hw_queues fails, fallback to previous nr_hw_queues and post warning. At the same time, driver's .map_queues usually use completion irq affinity to map hw and cpu, fallback nr_hw_queues will cause lack of some cpu's map to hw, so use default blk_mq_map_queues to do that.  ",e01ad46d53b59720c6ae69963ee1756506954c85,0
proc: Use new_inode not new_inode_pseudo,"Recently syzbot reported that unmounting proc when there is an ongoing inotify watch on the root directory of proc could result in a use after free when the watch is removed after the unmount of proc when the watcher exits.  Commit 69879c01a0c3 (""proc: Remove the now unnecessary internal mount of proc"") made it easier to unmount proc and allowed syzbot to see the problem, but looking at the code it has been around for a long time.  Looking at the code the fsnotify watch should have been removed by fsnotify_sb_delete in generic_shutdown_super.  Unfortunately the inode was allocated with new_inode_pseudo instead of new_inode so the inode was not on the sb->s_inodes list.  Which prevented fsnotify_unmount_inodes from finding the inode and removing the watch as well as made it so the ""VFS: Busy inodes after unmount"" warning could not find the inodes to warn about them.  Make all of the inodes in proc visible to generic_shutdown_super, and fsnotify_sb_delete by using new_inode instead of new_inode_pseudo. The only functional difference is that new_inode places the inodes on the sb->s_inodes list.  I wrote a small test program and I can verify that without changes it can trigger this issue, and by replacing new_inode_pseudo with new_inode the issues goes away.  ",ef1548adada51a2f32ed7faef50aa465e1b4c5da,1
net: igmp: fix data-race in igmp_ifc_timer_expire(),"Fix the data-race reported by syzbot [1] Issue here is that igmp_ifc_timer_expire() can update in_dev->mr_ifc_count while another change just occured from another context.  in_dev->mr_ifc_count is only 8bit wide, so the race had little consequences.  [1] BUG: KCSAN: data-race in igmp_ifc_event / igmp_ifc_timer_expire  write to 0xffff8881051e3062 of 1 bytes by task 12547 on cpu 0:  igmp_ifc_event+0x1d5/0x290 net/ipv4/igmp.c:821  igmp_group_added+0x462/0x490 net/ipv4/igmp.c:1356  ____ip_mc_inc_group+0x3ff/0x500 net/ipv4/igmp.c:1461  __ip_mc_join_group+0x24d/0x2c0 net/ipv4/igmp.c:2199  ip_mc_join_group_ssm+0x20/0x30 net/ipv4/igmp.c:2218  do_ip_setsockopt net/ipv4/ip_sockglue.c:1285 [inline]  ip_setsockopt+0x1827/0x2a80 net/ipv4/ip_sockglue.c:1423  tcp_setsockopt+0x8c/0xa0 net/ipv4/tcp.c:3657  sock_common_setsockopt+0x5d/0x70 net/core/sock.c:3362  __sys_setsockopt+0x18f/0x200 net/socket.c:2159  __do_sys_setsockopt net/socket.c:2170 [inline]  __se_sys_setsockopt net/socket.c:2167 [inline]  __x64_sys_setsockopt+0x62/0x70 net/socket.c:2167  do_syscall_x64 arch/x86/entry/common.c:50 [inline]  do_syscall_64+0x3d/0x90 arch/x86/entry/common.c:80  entry_SYSCALL_64_after_hwframe+0x44/0xae  read to 0xffff8881051e3062 of 1 bytes by interrupt on cpu 1:  igmp_ifc_timer_expire+0x706/0xa30 net/ipv4/igmp.c:808  call_timer_fn+0x2e/0x1d0 kernel/time/timer.c:1419  expire_timers+0x135/0x250 kernel/time/timer.c:1464  __run_timers+0x358/0x420 kernel/time/timer.c:1732  run_timer_softirq+0x19/0x30 kernel/time/timer.c:1745  __do_softirq+0x12c/0x26e kernel/softirq.c:558  invoke_softirq kernel/softirq.c:432 [inline]  __irq_exit_rcu+0x9a/0xb0 kernel/softirq.c:636  sysvec_apic_timer_interrupt+0x69/0x80 arch/x86/kernel/apic/apic.c:1100  asm_sysvec_apic_timer_interrupt+0x12/0x20 arch/x86/include/asm/idtentry.h:638  console_unlock+0x8e8/0xb30 kernel/printk/printk.c:2646  vprintk_emit+0x125/0x3d0 kernel/printk/printk.c:2174  vprintk_default+0x22/0x30 kernel/printk/printk.c:2185  vprintk+0x15a/0x170 kernel/printk/printk_safe.c:392  printk+0x62/0x87 kernel/printk/printk.c:2216  selinux_netlink_send+0x399/0x400 security/selinux/hooks.c:6041  security_netlink_send+0x42/0x90 security/security.c:2070  netlink_sendmsg+0x59e/0x7c0 net/netlink/af_netlink.c:1919  sock_sendmsg_nosec net/socket.c:703 [inline]  sock_sendmsg net/socket.c:723 [inline]  ____sys_sendmsg+0x360/0x4d0 net/socket.c:2392  ___sys_sendmsg net/socket.c:2446 [inline]  __sys_sendmsg+0x1ed/0x270 net/socket.c:2475  __do_sys_sendmsg net/socket.c:2484 [inline]  __se_sys_sendmsg net/socket.c:2482 [inline]  __x64_sys_sendmsg+0x42/0x50 net/socket.c:2482  do_syscall_x64 arch/x86/entry/common.c:50 [inline]  do_syscall_64+0x3d/0x90 arch/x86/entry/common.c:80  entry_SYSCALL_64_after_hwframe+0x44/0xae  value changed: 0x01 -> 0x02  Reported by Kernel Concurrency Sanitizer on: CPU: 1 PID: 12539 Comm: syz-executor.1 Not tainted 5.14.0-rc4-syzkaller #0 Hardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 01/01/2011  ",4a2b285e7e103d4d6c6ed3e5052a0ff74a5d7f15,1
media: v4l2-ctrls.c: fix shift-out-of-bounds in std_validate,"If a menu has more than 64 items, then don't check menu_skip_mask for items 65 and up.  ",048c96e28674f15c0403deba2104ffba64544a06,1
signal/ptrace: Don't leak unitialized kernel memory with PTRACE_PEEK_SIGINFO,"Recently syzbot in conjunction with KMSAN reported that ptrace_peek_siginfo can copy an uninitialized siginfo to userspace. Inspecting ptrace_peek_siginfo confirms this.  The problem is that off when initialized from args.off can be initialized to a negaive value.  At which point the ""if (off >= 0)"" test to see if off became negative fails because off started off negative.  Prevent the core problem by adding a variable found that is only true if a siginfo is found and copied to a temporary in preparation for being copied to userspace.  Prevent args.off from being truncated when being assigned to off by testing that off is <= the maximum possible value of off.  Convert off to an unsigned long so that we should not have to truncate args.off, we have well defined overflow behavior so if we add another check we won't risk fighting undefined compiler behavior, and so that we have a type whose maximum value is easy to test for.  ",f6e2aa91a46d2bc79fce9b93a988dbe7655c90c0,1
io_uring: ensure task_work gets run as part of cancelations,"If we successfully cancel a work item but that work item needs to be processed through task_work, then we can be sleeping uninterruptibly in io_uring_cancel_generic() and never process it. Hence we don't make forward progress and we end up with an uninterruptible sleep warning.  While in there, correct a comment that should be IFF, not IIF.  ",78a780602075d8b00c98070fa26e389b3b3efa72,0
fork: Annotate a data race in vm_area_dup(),"struct vm_area_struct could be accessed concurrently as noticed by KCSAN,   write to 0xffff9cf8bba08ad8 of 8 bytes by task 14263 on cpu 35:   vma_interval_tree_insert+0x101/0x150:   rb_insert_augmented_cached at include/linux/rbtree_augmented.h:58   (inlined by) vma_interval_tree_insert at mm/interval_tree.c:23   __vma_link_file+0x6e/0xe0   __vma_link_file at mm/mmap.c:629   vma_link+0xa2/0x120   mmap_region+0x753/0xb90   do_mmap+0x45c/0x710   vm_mmap_pgoff+0xc0/0x130   ksys_mmap_pgoff+0x1d1/0x300   __x64_sys_mmap+0x33/0x40   do_syscall_64+0x91/0xc44   entry_SYSCALL_64_after_hwframe+0x49/0xbe   read to 0xffff9cf8bba08a80 of 200 bytes by task 14262 on cpu 122:   vm_area_dup+0x6a/0xe0   vm_area_dup at kernel/fork.c:362   __split_vma+0x72/0x2a0   __split_vma at mm/mmap.c:2661   split_vma+0x5a/0x80   mprotect_fixup+0x368/0x3f0   do_mprotect_pkey+0x263/0x420   __x64_sys_mprotect+0x51/0x70   do_syscall_64+0x91/0xc44   entry_SYSCALL_64_after_hwframe+0x49/0xbe  vm_area_dup() blindly copies all fields of original VMA to the new one. This includes coping vm_area_struct::shared.rb which is normally protected by i_mmap_lock. But this is fine because the read value will be overwritten on the following __vma_link_file() under proper protection. Thus, mark it as an intentional data race and insert a few assertions for the fields that should not be modified concurrently.  ",cda099b37d7165fc73a63961739acf026444cde2,1
char: hpet: Fix out-of-bounds read bug,"Currently, there is an out-of-bounds read on array hpetp->hp_dev in the following for loop:  870         for (i = 0; i < hdp->hd_nirqs; i++) 871                 hpetp->hp_dev[i].hd_hdwirq = hdp->hd_irq[i];  This is due to the recent change from one-element array to flexible-array member in struct hpets:  104 struct hpets { 	... 113         struct hpet_dev hp_dev[]; 114 };  This change affected the total size of the dynamic memory allocation, decreasing it by one time the size of struct hpet_dev.  Fix this by adjusting the allocation size when calling struct_size().  ",98c49f1746ac44ccc164e914b9a44183fad09f51,1
phonet/pep: refuse to enable an unbound pipe,"This ioctl() implicitly assumed that the socket was already bound to a valid local socket name, i.e. Phonet object. If the socket was not bound, two separate problems would occur:  1) We'd send an pipe enablement request with an invalid source object. 2) Later socket calls could BUG on the socket unexpectedly being    connected yet not bound to a valid object.  ",75a2f31520095600f650597c0ac41f48b5ba0068,1
misc: vmw_vmci: fix kernel info-leak by initializing dbells in vmci_ctx_get_chkpt_doorbells(),"A kernel-infoleak was reported by syzbot, which was caused because dbells was left uninitialized. Using kzalloc() instead of kmalloc() fixes this issue.  ",31dcb6c30a26d32650ce134820f27de3c675a45a,1
io-wq: check for wq exit after adding new worker task_work,"We check IO_WQ_BIT_EXIT before attempting to create a new worker, and wq exit cancels pending work if we have any. But it's possible to have a race between the two, where creation checks exit finding it not set, but we're in the process of exiting. The exit side will cancel pending creation task_work, but there's a gap where we add task_work after we've canceled existing creations at exit time.  Fix this by checking the EXIT bit post adding the creation task_work. If it's set, run the same cancelation that exit does.  ",71a85387546e50b1a37b0fa45dadcae3bfb35cf6,1
mac80211_hwsim: drop pending frames on stop,"Syzbot reports that we may be able to get into a situation where mac80211 has pending ACK frames on shutdown with hwsim. It appears that the reason for this is that syzbot uses the wmediumd hooks to intercept/injection frames, and may shut down hwsim, removing the radio(s), while frames are pending in the air simulation.  Clean out the pending queue when the interface is stopped, after this the frames can't be reported back to mac80211 properly anyway.  ",bd18de517923903a177508fc8813f44e717b1c00,0
block: genhd: fix double kfree() in __alloc_disk_node(),"syzbot is reporting use-after-free read at bdev_free_inode() [1], for kfree() from __alloc_disk_node() is called before bdev_free_inode() (which is called after RCU grace period) reads bdev->bd_disk and calls kfree(bdev->bd_disk).  Fix use-after-free read followed by double kfree() problem by making sure that bdev->bd_disk is NULL when calling iput().  ",06cc978d3ff226072780f74897800b33e78abb57,1
hsr: implement dellink to clean up resources,"hsr_link_ops implements ->newlink() but not ->dellink(), which leads that resources not released after removing the device, particularly the entries in self_node_db and node_db.  So add ->dellink() implementation to replace the priv_destructor. This also makes the code slightly easier to understand.  ",b9a1e627405d68d475a3c1f35e685ccfb5bbe668,0
mm/hugetlb: fix deadlock in hugetlb_cow error path,"syzbot reported the deadlock here [1].  The issue is in hugetlb cow error handling when there are not enough huge pages for the faulting task which took the original reservation.  It is possible that other (child) tasks could have consumed pages associated with the reservation. In this case, we want the task which took the original reservation to succeed.  So, we unmap any associated pages in children so that they can be used by the faulting task that owns the reservation.  The unmapping code needs to hold i_mmap_rwsem in write mode.  However, due to commit c0d0381ade79 (""hugetlbfs: use i_mmap_rwsem for more pmd sharing synchronization"") we are already holding i_mmap_rwsem in read mode when hugetlb_cow is called.  Technically, i_mmap_rwsem does not need to be held in read mode for COW mappings as they can not share pmd's.  Modifying the fault code to not take i_mmap_rwsem in read mode for COW (and other non-sharable) mappings is too involved for a stable fix.  Instead, we simply drop the hugetlb_fault_mutex and i_mmap_rwsem before unmapping.  This is OK as it is technically not needed.  They are reacquired after unmapping as expected by calling code.  Since this is done in an uncommon error path, the overhead of dropping and reacquiring mutexes is acceptable.  While making changes, remove redundant BUG_ON after unmap_ref_private.  [1] https://lkml.kernel.org/r/000000000000b73ccc05b5cf8558@google.com  ",e7dd91c456a8cdbcd7066997d15e36d14276a949,1
ipv6: addrconf_f6i_alloc - fix non-null pointer check to !IS_ERR(),Fixes a stupid bug I recently introduced... ip6_route_info_create() returns an ERR_PTR(err) and not a NULL on error.  ,8652f17c658d03f5c87b8dee6e8e52480c6cd37d,0
bpf: Fix nested bpf_bprintf_prepare with more per-cpu buffers,"The bpf_seq_printf, bpf_trace_printk and bpf_snprintf helpers share one per-cpu buffer that they use to store temporary data (arguments to bprintf). They ""get"" that buffer with try_get_fmt_tmp_buf and ""put"" it by the end of their scope with bpf_bprintf_cleanup.  If one of these helpers gets called within the scope of one of these helpers, for example: a first bpf program gets called, uses bpf_trace_printk which calls raw_spin_lock_irqsave which is traced by another bpf program that calls bpf_snprintf, then the second ""get"" fails. Essentially, these helpers are not re-entrant. They would return -EBUSY and print a warning message once.  This patch triples the number of bprintf buffers to allow three levels of nesting. This is very similar to what was done for tracepoints in ""9594dc3c7e7 bpf: fix nested bpf tracepoints with per-cpu data""  ",e2d5b2bb769fa5f500760caba76436ba3a10a895,0
media: gspca: zero usb_buf,Allocate gspca_dev->usb_buf with kzalloc instead of kmalloc to ensure it is property zeroed. This fixes various syzbot errors about uninitialized data.  Syzbot links:  https://syzkaller.appspot.com/bug?extid=32310fc2aea76898d074 https://syzkaller.appspot.com/bug?extid=99706d6390be1ac542a2 https://syzkaller.appspot.com/bug?extid=64437af5c781a7f0e08e  ,de89d0864f66c2a1b75becfdd6bf3793c07ce870,1
rtnl: limit IFLA_NUM_TX_QUEUES and IFLA_NUM_RX_QUEUES to 4096,"We have an impressive number of syzkaller bugs that are linked to the fact that syzbot was able to create a networking device with millions of TX (or RX) queues.  Let's limit the number of RX/TX queues to 4096, this really should cover all known cases.  A separate patch will add various cond_resched() in the loops handling sysfs entries at device creation and dismantle.  Tested:  lpaa6:~# ip link add gre-4097 numtxqueues 4097 numrxqueues 4097 type ip6gretap RTNETLINK answers: Invalid argument  lpaa6:~# time ip link add gre-4096 numtxqueues 4096 numrxqueues 4096 type ip6gretap  real	0m0.180s user	0m0.000s sys	0m0.107s  ",0e1d6eca5113858ed2caea61a5adc03c595f6096,1
android: binder: Rate-limit debug and userspace triggered err msgs,Use rate-limited debug messages where userspace can trigger excessive log spams.  ,128f38041035001276e964cda1cf951f218d965d,0
mm/huge_memory: splitting set mapping+index before unfreeze,"Huge tmpfs stress testing has occasionally hit shmem_undo_range()'s VM_BUG_ON_PAGE(page_to_pgoff(page) != index, page).  Move the setting of mapping and index up before the page_ref_unfreeze() in __split_huge_page_tail() to fix this: so that a page cache lookup cannot get a reference while the tail's mapping and index are unstable.  In fact, might as well move them up before the smp_wmb(): I don't see an actual need for that, but if I'm missing something, this way round is safer than the other, and no less efficient.  You might argue that VM_BUG_ON_PAGE(page_to_pgoff(page) != index, page) is misplaced, and should be left until after the trylock_page(); but left as is has not crashed since, and gives more stringent assurance.  ",173d9d9fd3ddae84c110fea8aedf1f26af6be9ec,1
tipc: don't call sock_release() in atomic context,"syzbot reported a scheduling while atomic issue at netns destruction time:  BUG: sleeping function called from invalid context at net/core/sock.c:2769 in_atomic(): 1, irqs_disabled(): 0, pid: 85, name: kworker/u4:3 5 locks held by kworker/u4:3/85:   #0:  ((wq_completion)""%s""""netns""){+.+.}, at: [<00000000c9792deb>] process_one_work+0xaaf/0x1af0 kernel/workqueue.c:2084   #1:  (net_cleanup_work){+.+.}, at: [<00000000adc12e2a>] process_one_work+0xb01/0x1af0 kernel/workqueue.c:2088   #2:  (net_sem){++++}, at: [<000000009ccb5669>] cleanup_net+0x23f/0xd20 net/core/net_namespace.c:494   #3:  (net_mutex){+.+.}, at: [<00000000a92767d9>] cleanup_net+0xa7d/0xd20 net/core/net_namespace.c:496   #4:  (&(&srv->idr_lock)->rlock){+...}, at: [<000000001343e568>] spin_lock_bh include/linux/spinlock.h:315 [inline]   #4:  (&(&srv->idr_lock)->rlock){+...}, at: [<000000001343e568>] tipc_topsrv_stop+0x231/0x610 net/tipc/topsrv.c:685 CPU: 0 PID: 85 Comm: kworker/u4:3 Not tainted 4.16.0-rc1+ #230 Hardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 01/01/2011 Workqueue: netns cleanup_net Call Trace:   __dump_stack lib/dump_stack.c:17 [inline]   dump_stack+0x194/0x257 lib/dump_stack.c:53   ___might_sleep+0x2b2/0x470 kernel/sched/core.c:6128   __might_sleep+0x95/0x190 kernel/sched/core.c:6081   lock_sock_nested+0x37/0x110 net/core/sock.c:2769   lock_sock include/net/sock.h:1463 [inline]   tipc_release+0x103/0xff0 net/tipc/socket.c:572   sock_release+0x8d/0x1e0 net/socket.c:594   tipc_topsrv_stop+0x3c0/0x610 net/tipc/topsrv.c:696   tipc_exit_net+0x15/0x40 net/tipc/core.c:96   ops_exit_list.isra.6+0xae/0x150 net/core/net_namespace.c:148   cleanup_net+0x6ba/0xd20 net/core/net_namespace.c:529   process_one_work+0xbbf/0x1af0 kernel/workqueue.c:2113   worker_thread+0x223/0x1990 kernel/workqueue.c:2247   kthread+0x33c/0x400 kernel/kthread.c:238   ret_from_fork+0x3a/0x50 arch/x86/entry/entry_64.S:429  This is caused by tipc_topsrv_stop() releasing the listener socket with the idr lock held. This changeset addresses the issue moving the release operation outside such lock.  ",26736a08ee0fb89a4f09bfb2c9f0805028ff63aa,1
mac80211: mesh: fix mesh_pathtbl_init() error path,"If tbl_mpp can not be allocated, we call mesh_table_free(tbl_path) while tbl_path rhashtable has not yet been initialized, which causes panics.  Simply factorize the rhashtable_init() call into mesh_table_alloc()  ",905b2032fa424f253d9126271439cc1db2b01130,0
batman-adv: fix for leaked TVLV handler.,"A handler for BATADV_TVLV_ROAM was being registered when the translation-table was initialized, but not unregistered when the translation-table was freed.  Unregister it.  ",17f78dd1bd624a4dd78ed5db3284a63ee807fcc3,0
selinux: fix GPF on invalid policy,levdatum->level can be NULL if we encounter an error while loading the policy during sens_read prior to initializing it.  Make sure sens_destroy handles that case correctly.  ,5b0e7310a2a33c06edc7eb81ffc521af9b2c5610,0
bridge: mrp: Fix out-of-bounds read in br_mrp_parse,"The issue was reported by syzbot. When the function br_mrp_parse was called with a valid net_bridge_port, the net_bridge was an invalid pointer. Therefore the check br->stp_enabled could pass/fail depending where it was pointing in memory. The fix consists of setting the net_bridge pointer if the port is a valid pointer.  ",617504c67e01d30310558442777a4112ea6d587d,1
vfs: fix do_last() regression,"Brown paperbag time: fetching ->i_uid/->i_mode really should've been done from nd->inode.  I even suggested that, but the reason for that has slipped through the cracks and I went for dir->d_inode instead - made for more ""obvious"" patch.  Analysis:   - at the entry into do_last() and all the way to step_into(): dir (aka    nd->path.dentry) is known not to have been freed; so's nd->inode and    it's equal to dir->d_inode unless we are already doomed to -ECHILD.    inode of the file to get opened is not known.   - after step_into(): inode of the file to get opened is known; dir    might be pointing to freed memory/be negative/etc.   - at the call of may_create_in_sticky(): guaranteed to be out of RCU    mode; inode of the file to get opened is known and pinned; dir might    be garbage.  The last was the reason for the original patch.  Except that at the do_last() entry we can be in RCU mode and it is possible that nd->path.dentry->d_inode has already changed under us.  In that case we are going to fail with -ECHILD, but we need to be careful; nd->inode is pointing to valid struct inode and it's the same as nd->path.dentry->d_inode in ""won't fail with -ECHILD"" case, so we should use that.  ",6404674acd596de41fd3ad5f267b4525494a891a,0
net: fix uninit-value in __hw_addr_add_ex(),"syzbot complained :  BUG: KMSAN: uninit-value in memcmp+0x119/0x180 lib/string.c:861 CPU: 0 PID: 3 Comm: kworker/0:0 Not tainted 4.16.0+ #82 Hardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 01/01/2011 Workqueue: ipv6_addrconf addrconf_dad_work Call Trace:  __dump_stack lib/dump_stack.c:17 [inline]  dump_stack+0x185/0x1d0 lib/dump_stack.c:53  kmsan_report+0x142/0x240 mm/kmsan/kmsan.c:1067  __msan_warning_32+0x6c/0xb0 mm/kmsan/kmsan_instr.c:676  memcmp+0x119/0x180 lib/string.c:861  __hw_addr_add_ex net/core/dev_addr_lists.c:60 [inline]  __dev_mc_add+0x1c2/0x8e0 net/core/dev_addr_lists.c:670  dev_mc_add+0x6d/0x80 net/core/dev_addr_lists.c:687  igmp6_group_added+0x2db/0xa00 net/ipv6/mcast.c:662  ipv6_dev_mc_inc+0xe9e/0x1130 net/ipv6/mcast.c:914  addrconf_join_solict net/ipv6/addrconf.c:2078 [inline]  addrconf_dad_begin net/ipv6/addrconf.c:3828 [inline]  addrconf_dad_work+0x427/0x2150 net/ipv6/addrconf.c:3954  process_one_work+0x12c6/0x1f60 kernel/workqueue.c:2113  worker_thread+0x113c/0x24f0 kernel/workqueue.c:2247  kthread+0x539/0x720 kernel/kthread.c:239  ",77d36398d99f2565c0a8d43a86fd520a82e64bb8,1
block: don't warn when doing fsync on read-only devices,"It is possible to call fsync on a read-only handle (for example, fsck.ext2 does it when doing read-only check), and this call results in kernel warning.  The patch b089cfd95d32 (""block: don't warn for flush on read-only device"") attempted to disable the warning, but it is buggy and it doesn't (op_is_flush tests flags, but bio_op strips off the flags).  ",8b2ded1c94c06f841f8c1612bcfa33c85012a36b,0
io_uring: don't touch 'ctx' after installing file descriptor,"As soon as we install the file descriptor, we have to assume that it can get arbitrarily closed. We currently account memory (and note that we did) after installing the ring fd, which means that it could be a potential use-after-free condition if the fd is closed right after being installed, but before we fiddle with the ctx.  In fact, syzbot reported this exact scenario:  BUG: KASAN: use-after-free in io_account_mem fs/io_uring.c:7397 [inline] BUG: KASAN: use-after-free in io_uring_create fs/io_uring.c:8369 [inline] BUG: KASAN: use-after-free in io_uring_setup+0x2797/0x2910 fs/io_uring.c:8400 Read of size 1 at addr ffff888087a41044 by task syz-executor.5/18145  CPU: 0 PID: 18145 Comm: syz-executor.5 Not tainted 5.8.0-rc7-next-20200729-syzkaller #0 Hardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 01/01/2011 Call Trace:  __dump_stack lib/dump_stack.c:77 [inline]  dump_stack+0x18f/0x20d lib/dump_stack.c:118  print_address_description.constprop.0.cold+0xae/0x497 mm/kasan/report.c:383  __kasan_report mm/kasan/report.c:513 [inline]  kasan_report.cold+0x1f/0x37 mm/kasan/report.c:530  io_account_mem fs/io_uring.c:7397 [inline]  io_uring_create fs/io_uring.c:8369 [inline]  io_uring_setup+0x2797/0x2910 fs/io_uring.c:8400  do_syscall_64+0x2d/0x70 arch/x86/entry/common.c:46  entry_SYSCALL_64_after_hwframe+0x44/0xa9 ",d1719f70d0a5b83b12786a7dbc5b9fe396469016,1
"USB: Fix ""slab-out-of-bounds Write"" bug in usb_hcd_poll_rh_status","When the USB core code for getting root-hub status reports was originally written, it was assumed that the hub driver would be its only caller.  But this isn't true now; user programs can use usbfs to communicate with root hubs and get status reports.  When they do this, they may use a transfer_buffer that is smaller than the data returned by the HCD, which will lead to a buffer overflow error when usb_hcd_poll_rh_status() tries to store the status data.  This was discovered by syzbot:  BUG: KASAN: slab-out-of-bounds in memcpy include/linux/fortify-string.h:225 [inline] BUG: KASAN: slab-out-of-bounds in usb_hcd_poll_rh_status+0x5f4/0x780 drivers/usb/core/hcd.c:776 Write of size 2 at addr ffff88801da403c0 by task syz-executor133/4062  This patch fixes the bug by reducing the amount of status data if it won't fit in the transfer_buffer.  If some data gets discarded then the URB's completion status is set to -EOVERFLOW rather than 0, to let the user know what happened.  ",1d7d4c07932e04355d6e6528d44a2f2c9e354346,1
Fix root mounting with no mount options,"The ""trivial conversion"" in commit cccaa5e33525 (""init: use do_mount() instead of ksys_mount()"") was totally broken, since it didn't handle the case of a NULL mount data pointer.  And while I had ""tested"" it (and presumably Dominik had too) that bug was hidden by me having options.  ",7de7de7ca0ae0fc70515ee3154af33af75edae2c,0
tomoyo: Add a kernel config option for fuzzing testing.,"syzbot is reporting kernel panic triggered by memory allocation fault injection before loading TOMOYO's policy [1]. To make the fuzzing tests useful, we need to assign a profile other than ""disabled"" (no-op) mode. Therefore, let's allow syzbot to load TOMOYO's built-in policy for ""learning"" mode using a kernel config option. This option must not be enabled for kernels built for production system, for this option also disables domain/program checks when modifying policy configuration via /sys/kernel/security/tomoyo/ interface.  [1] https://syzkaller.appspot.com/bug?extid=29569ed06425fcf67a95  ",e80b18599a39a625bc8b2e39ba3004a62f78805a,1
media: vicodec: check type in g/s_selection,Check that the selection buf_type is valid before calling get_q_data() to avoid hitting the WARN(1) in that function if the buffer type is not valid.  ,db9a01b32ca9406394e6e7d19c4cdfcf1cbb5058,0
ethtool: strset: allow ETHTOOL_A_STRSET_COUNTS_ONLY attr,"The ETHTOOL_A_STRSET_COUNTS_ONLY flag attribute was previously not allowed to be used, but now due to the policy size reduction we would access the tb[] array out of bounds since we tried to check for the attribute despite it not being accepted.  Fix both issues by adding it correctly to the appropriate policy.  ",db972e5325183df1265bf851b32dc7530dd4393a,1
btrfs: fix overflow when copying corrupt csums for a message,Syzkaller reported a buffer overflow in btree_readpage_end_io_hook() when loop mounting a crafted image:    detected buffer overflow in memcpy   ,35be8851d172c6e3db836c0f28c19087b10c9e00,1
fork: return proper negative error code,"Make sure to return a proper negative error code from copy_process() when anon_inode_getfile() fails with CLONE_PIDFD. Otherwise _do_fork() will not detect an error and get_task_pid() will operator on a nonsensical pointer:  R10: 0000000000000000 R11: 0000000000000246 R12: 00000000006dbc2c R13: 00007ffc15fbb0ff R14: 00007ff07e47e9c0 R15: 0000000000000000 kasan: CONFIG_KASAN_INLINE enabled kasan: GPF could be caused by NULL-ptr deref or user memory access general protection fault: 0000 [#1] PREEMPT SMP KASAN CPU: 1 PID: 7990 Comm: syz-executor290 Not tainted 5.2.0-rc6+ #9 Hardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 01/01/2011 ",28dd29c06d0dede4b32b2c559cff21955a830928,1
perf/core: Fix use-after-free in uprobe_perf_close(),A use-after-free bug was caught by KASAN while running usdt related code (BCC project. bcc/tests/python/test_usdt2.py):  	,621b6d2ea297d0fb6030452c5bcd221f12165fcf,1
rxrpc: Fix bundle counting for exclusive connections,Fix rxrpc_unbundle_conn() to not drop the bundle usage count when cleaning up an exclusive connection.  Based on the suggested fix from Hillf Danton.  ,f3af4ad1e08a8a9e61878b9f72751a5b76b3baf9,0
mac80211: fix use of skb payload instead of header,"When ieee80211_skb_resize() is called from ieee80211_build_hdr() the skb has no 802.11 header yet, in fact it consist only of the payload as the ethernet frame is removed. As such, we're using the payload data for ieee80211_is_mgmt(), which is of course completely wrong. This didn't really hurt us because these are always data frames, so we could only have added more tailroom than we needed if we determined it was a management frame and sdata->crypto_tx_tailroom_needed_cnt was false.  However, syzbot found that of course there need not be any payload, so we're using at best uninitialized memory for the check.  Fix this to pass explicitly the kind of frame that we have instead of checking there, by replacing the ""bool may_encrypt"" argument with an argument that can carry the three possible states - it's not going to be encrypted, it's a management frame, or it's a data frame (and then we check sdata->crypto_tx_tailroom_needed_cnt).  ",14f46c1e5108696ec1e5a129e838ecedf108c7bf,1
rcu: Mark accesses to rcu_state.n_force_qs,"This commit marks accesses to the rcu_state.n_force_qs.  These data races are hard to make happen, but syzkaller was equal to the task.  ",2431774f04d1050292054c763070021bade7b151,1
l2tp: fix races in tunnel creation,"l2tp_tunnel_create() inserts the new tunnel into the namespace's tunnel list and sets the socket's ->sk_user_data field, before returning it to the caller. Therefore, there are two ways the tunnel can be accessed and freed, before the caller even had the opportunity to take a reference. In practice, syzbot could crash the module by closing the socket right after a new tunnel was returned to pppol2tp_create().  This patch moves tunnel registration out of l2tp_tunnel_create(), so that the caller can safely hold a reference before publishing the tunnel. This second step is done with the new l2tp_tunnel_register() function, which is now responsible for associating the tunnel to its socket and for inserting it into the namespace's list.  While moving the code to l2tp_tunnel_register(), a few modifications have been done. First, the socket validation tests are done in a helper function, for clarity. Also, modifying the socket is now done after having inserted the tunnel to the namespace's tunnels list. This will allow insertion to fail, without having to revert theses modifications in the error path (a followup patch will check for duplicate tunnels before insertion). Either the socket is a kernel socket which we control, or it is a user-space socket for which we have a reference on the file descriptor. In any case, the socket isn't going to be closed from under us.  ",6b9f34239b00e6956a267abed2bc559ede556ad6,1
ext4: add more paranoia checking in ext4_expand_extra_isize handling,"It's possible to specify a non-zero s_want_extra_isize via debugging option, and this can cause bad things(tm) to happen when using a file system with an inode size of 128 bytes.  Add better checking when the file system is mounted, as well as when we are actually doing the trying to do the inode expansion.  ",4ea99936a1630f51fc3a2d61a58ec4a1c4b7d55a,1
net_sched: hold rtnl lock in tcindex_partial_destroy_work(),"syzbot reported a use-after-free in tcindex_dump(). This is due to the lack of RTNL in the deferred rcu work. We queue this work with RTNL in tcindex_change(), later, tcindex_dump() is called:          fh = tp->ops->get(tp, t->tcm_handle); 	...         err = tp->ops->change(..., &fh, ...);         tfilter_notify(..., fh, ...);  but there is nothing to serialize the pending tcindex_partial_destroy_work() with tcindex_dump().  Fix this by simply holding RTNL in tcindex_partial_destroy_work(), so that it won't be called until RTNL is released after tc_new_tfilter() is completed.  ",b1be2e8cd290f620777bfdb8aa00890cd2fa02b5,1
ext4: make sure to reset inode lockdep class when quota enabling fails,"When we succeed in enabling some quota type but fail to enable another one with quota feature, we correctly disable all enabled quota types. However we forget to reset i_data_sem lockdep class. When the inode gets freed and reused, it will inherit this lockdep class (i_data_sem is initialized only when a slab is created) and thus eventually lockdep barfs about possible deadlocks.  ",4013d47a5307fdb5c13370b5392498b00fedd274,0
net: ieee802154: fix nl802154 del llsec dev,This patch fixes a nullpointer dereference if NL802154_ATTR_SEC_DEVICE is not set by the user. If this is the case nl802154 will return -EINVAL.  ,3d1eac2f45585690d942cf47fd7fbd04093ebd1b,1
NFC: nfcmrvl: fix gpio-handling regression,"Fix two reset-gpio sanity checks which were never converted to use gpio_is_valid(), and make sure to use -EINVAL to indicate a missing reset line also for the UART-driver module parameter and for the USB driver.  This specifically prevents the UART and USB drivers from incidentally trying to request and use gpio 0, and also avoids triggering a WARN() in gpio_to_desc() during probe when no valid reset line has been specified.  ",c3953a3c2d3175d2f9f0304c9a1ba89e7743c5e4,1
sctp: check and update stream->out_curr when allocating stream_out,"Now when using stream reconfig to add out streams, stream->out will get re-allocated, and all old streams' information will be copied to the new ones and the old ones will be freed.  So without stream->out_curr updated, next time when trying to send from stream->out_curr stream, a panic would be caused.  This patch is to check and update stream->out_curr when allocating stream_out.  v1->v2:   - define fa_index() to get elem index from stream->out_curr. v2->v3:   - repost with no change.  ",cfe4bd7a257f6d6f81d3458d8c9d9ec4957539e6,0
staging: android: ashmem: Fix lockdep issue during llseek,"ashmem_mutex create a chain of dependencies like so:  (1) mmap syscall ->   mmap_sem ->  (acquired)   ashmem_mmap   ashmem_mutex (try to acquire)   (block)  (2) llseek syscall ->   ashmem_llseek ->   ashmem_mutex ->  (acquired)   inode_lock ->   inode->i_rwsem (try to acquire)   (block)  (3) getdents ->   iterate_dir ->   inode_lock ->   inode->i_rwsem   (acquired)   copy_to_user ->   mmap_sem         (try to acquire)  There is a lock ordering created between mmap_sem and inode->i_rwsem causing a lockdep splat [2] during a syzcaller test, this patch fixes the issue by unlocking the mutex earlier. Functionally that's Ok since we don't need to protect vfs_llseek.  [1] https://patchwork.kernel.org/patch/10185031/ [2] https://lkml.org/lkml/2018/1/10/48  ",cb57469c9573f6018cd1302953dd45d6e05aba7b,0
selinux: fix NULL dereference in policydb_destroy(),"The conversion to kvmalloc() forgot to account for the possibility that p->type_attr_map_array might be null in policydb_destroy().  Fix this by destroying its contents only if it is not NULL.  Also make sure ebitmap_init() is called on all entries before policydb_destroy() can be called. Right now this is a no-op, because both kvcalloc() and ebitmap_init() just zero out the whole struct, but let's rather not rely on a specific implementation.  ",6a1afffb08ce5f9fb9ccc20f7ab24846c0142984,1
fs/ext4: fix integer overflow in s_log_groups_per_flex,"syzbot found UBSAN: shift-out-of-bounds in ext4_mb_init [1], when 1 << sbi->s_es->s_log_groups_per_flex is bigger than UINT_MAX, where sbi->s_mb_prefetch is unsigned integer type.  32 is the maximum allowed power of s_log_groups_per_flex. Following if check will also trigger UBSAN shift-out-of-bound:  if (1 << sbi->s_es->s_log_groups_per_flex >= UINT_MAX) {  So I'm checking it against the raw number, perhaps there is another way to calculate UINT_MAX max power. Also use min_t as to make sure it's uint type.  [1] UBSAN: shift-out-of-bounds in fs/ext4/mballoc.c:2713:24 shift exponent 60 is too large for 32-bit type 'int' Call Trace:  __dump_stack lib/dump_stack.c:79 [inline]  dump_stack+0x137/0x1be lib/dump_stack.c:120  ubsan_epilogue lib/ubsan.c:148 [inline]  __ubsan_handle_shift_out_of_bounds+0x432/0x4d0 lib/ubsan.c:395  ext4_mb_init_backend fs/ext4/mballoc.c:2713 [inline]  ext4_mb_init+0x19bc/0x19f0 fs/ext4/mballoc.c:2898  ext4_fill_super+0xc2ec/0xfbe0 fs/ext4/super.c:4983  ",f91436d55a279f045987e8b8c1385585dca54be9,1
fix array-index-out-of-bounds in taprio_change,"syzbot report an array-index-out-of-bounds in taprio_change index 16 is out of range for type '__u16 [16]' that's because mqprio->num_tc is lager than TC_MAX_QUEUE,so we check the return value of netdev_set_num_tc.  ",efe487fce3061d94222c6501d7be3aa549b3dc78,1
quota: clear padding in v2r1_mem2diskdqb(),"Freshly allocated memory contains garbage, better make sure to init all struct v2r1_disk_dqblk fields to avoid KMSAN report:  BUG: KMSAN: uninit-value in qtree_entry_unused+0x137/0x1b0 fs/quota/quota_tree.c:218 CPU: 0 PID: 23373 Comm: syz-executor.1 Not tainted 5.9.0-rc4-syzkaller #0 Hardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 01/01/2011 Call Trace:  __dump_stack lib/dump_stack.c:77 [inline]  dump_stack+0x21c/0x280 lib/dump_stack.c:118  kmsan_report+0xf7/0x1e0 mm/kmsan/kmsan_report.c:122  __msan_warning+0x58/0xa0 mm/kmsan/kmsan_instr.c:219  qtree_entry_unused+0x137/0x1b0 fs/quota/quota_tree.c:218  v2r1_mem2diskdqb+0x43d/0x710 fs/quota/quota_v2.c:285  qtree_write_dquot+0x226/0x870 fs/quota/quota_tree.c:394  v2_write_dquot+0x1ad/0x280 fs/quota/quota_v2.c:333  dquot_commit+0x4af/0x600 fs/quota/dquot.c:482  ext4_write_dquot fs/ext4/super.c:5934 [inline]  ext4_mark_dquot_dirty+0x4d8/0x6a0 fs/ext4/super.c:5985  mark_dquot_dirty fs/quota/dquot.c:347 [inline]  mark_all_dquot_dirty fs/quota/dquot.c:385 [inline]  dquot_alloc_inode+0xc05/0x12b0 fs/quota/dquot.c:1755  __ext4_new_inode+0x8204/0x9d70 fs/ext4/ialloc.c:1155  ext4_tmpfile+0x41a/0x850 fs/ext4/namei.c:2686  vfs_tmpfile+0x2a2/0x570 fs/namei.c:3283  do_tmpfile fs/namei.c:3316 [inline]  path_openat+0x4035/0x6a90 fs/namei.c:3359  do_filp_open+0x2b8/0x710 fs/namei.c:3395  do_sys_openat2+0xa88/0x1140 fs/open.c:1168  do_sys_open fs/open.c:1184 [inline]  __do_compat_sys_openat fs/open.c:1242 [inline]  __se_compat_sys_openat+0x2a4/0x310 fs/open.c:1240  __ia32_compat_sys_openat+0x56/0x70 fs/open.c:1240  do_syscall_32_irqs_on arch/x86/entry/common.c:80 [inline]  __do_fast_syscall_32+0x129/0x180 arch/x86/entry/common.c:139  do_fast_syscall_32+0x6a/0xc0 arch/x86/entry/common.c:162  do_SYSENTER_32+0x73/0x90 arch/x86/entry/common.c:205  entry_SYSENTER_compat_after_hwframe+0x4d/0x5c ",3d3dc274ce736227e3197868ff749cff2f175f63,1
USB: dummy-hcd: Fix failure to give back unlinked URBs,"The syzkaller USB fuzzer identified a failure mode in which dummy-hcd would never give back an unlinked URB.  This causes usb_kill_urb() to hang, leading to ",50896c410354432e8e7baf97fcdd7df265e683ae,1
USB: yurex: Fix protection fault after device removal,"The syzkaller USB fuzzer found a general-protection-fault bug in the yurex driver.  The fault occurs when a device has been unplugged; the driver's interrupt-URB handler logs an error message referring to the device by name, after the device has been unregistered and its name deallocated.  This problem is caused by the fact that the interrupt URB isn't cancelled until the driver's private data structure is released, which can happen long after the device is gone.  The cure is to make sure that the interrupt URB is killed before yurex_disconnect() returns; this is exactly the sort of thing that usb_poison_urb() was meant for.  ",ef61eb43ada6c1d6b94668f0f514e4c268093ff3,1
can: peak_usb: fix slab info leak,Fix a small slab info leak due to a failure to clear the command buffer at allocation.  The first 16 bytes of the command buffer are always sent to the device in pcan_usb_send_cmd() even though only the first two may have been initialised in case no argument payload is provided (e.g. when waiting for a response).  ,f7a1337f0d29b98733c8824e165fca3371d7d4fd,0
pipe: Fix pipe_full() test in opipe_prep().,"syzbot is reporting that splice()ing from non-empty read side to already-full write side causes unkillable task, for opipe_prep() is by error not inverting pipe_full() test.    CPU: 0 PID: 9460 Comm: syz-executor.5 Not tainted 5.6.0-rc3-next-20200228-syzkaller #0   Hardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 01/01/2011   ",566d136289dc57816ac290de87a9a0f7d9bd3cbb,1
n_tty: Fix stall at n_tty_receive_char_special().,"syzbot is reporting stalls at n_tty_receive_char_special() [1]. This is because comparison is not working as expected since ldata->read_head can change at any moment. Mitigate this by explicitly masking with buffer size when checking condition for ""while"" loops.  [1] https://syzkaller.appspot.com/bug?id=3d7481a346958d9469bebbeb0537d5f056bdd6e8  ",3d63b7e4ae0dc5e02d28ddd2fa1f945defc68d81,1
driver core: Fix probe_count imbalance in really_probe(),"syzbot is reporting hung task in wait_for_device_probe() [1]. At least, we always need to decrement probe_count if we incremented probe_count in really_probe().  However, since I can't find ""Resources present before probing"" message in the console log, both ""this message simply flowed off"" and ""syzbot is not hitting this path"" will be possible. Therefore, while we are at it, let's also prepare for concurrent wait_for_device_probe() calls by replacing wake_up() with wake_up_all().  [1] https://syzkaller.appspot.com/bug?id=25c833f1983c9c1d512f4ff860dd0d7f5a2e2c0f  ",b292b50b0efcc7095d8bf15505fba6909bb35dce,1
mm/madvise: fix memory leak from process_madvise,The early return in process_madvise() will produce a memory leak.  Fix it.  ,450677dcb0cce5cb751538360b7196c28b733f3e,1
usb: usbip: vhci_hcd: protect shift size,Fix shift out-of-bounds in vhci_hcd.c:    UBSAN: shift-out-of-bounds in ../drivers/usb/usbip/vhci_hcd.c:399:41   shift exponent 768 is too large for 32-bit type 'int'  ,718bf42b119de652ebcc93655a1f33a9c0d04b3c,1
CDC-NCM: handle incomplete transfer of MTU,A malicious device may give half an answer when asked for its MTU. The driver will proceed after this with a garbage MTU. Anything but a complete answer must be treated as an error.  V2: used sizeof as request by Alexander  ,332f989a3b0041b810836c5c3747e59aad7e9d0b,0
fuse: handle zero sized retrieve correctly,Dereferencing req->page_descs[0] will Oops if req->max_pages is zero.  ,97e1532ef81acb31c30f9e75bf00306c33a77812,0
perf: Ignore sigtrap for tracepoints destined for other tasks,"syzbot reported that the warning in perf_sigtrap() fires, saying that the event's task does not match current:   | ",73743c3b092277febbf69b250ce8ebbca0525aa2,0
io_uring: check kthread stopped flag when sq thread is unparked,syzbot reports following issue: INFO: task syz-executor.2:12399 can't die for more than 143 seconds. ,65b2b213484acd89a3c20dbb524e52a2f3793b78,0
mm/hugetlb: a page from buddy is not on any list,"The page allocated from buddy is not on any list, so just use list_add() is enough.  ",15a8d68e9dc23dc9def4bd7e9563db60f4f86580,0
xfrm: validate template mode,XFRM mode parameters passed as part of the user templates in the IP_XFRM_POLICY are never properly validated. Passing values other than valid XFRM modes can cause stack-out-of-bounds reads to occur later in the XFRM processing:  ,32bf94fb5c2ec4ec842152d0e5937cd4bb6738fa,1
skmsg: Pass psock pointer to ->psock_update_sk_prot(),"Using sk_psock() to retrieve psock pointer from sock requires RCU read lock, but we already get psock pointer before calling ->psock_update_sk_prot() in both cases, so we can just pass it without bothering sk_psock().  ",51e0158a54321a48d260e95998393934bb0de52c,0
netfilter: nf_tables: fix memory leak in nf_tables_parse_netdev_hooks(),"Syzbot detected a leak in nf_tables_parse_netdev_hooks().  If the hook already exists, then the error handling doesn't free the newest ""hook"".  ",cd77e75b5e4632d05d61fec5383052713c8ede2b,1
tipc: change to check tipc_own_id to return in tipc_net_stop,"When running a syz script, a panic occurred:  ",9926cb5f8b0f0aea535735185600d74db7608550,0
net: usb: rtl8150: set random MAC address when set_ethernet_addr() fails,"When get_registers() fails in set_ethernet_addr(),the uninitialized value of node_id gets copied over as the address. So, check the return value of get_registers().  If get_registers() executed successfully (i.e., it returns sizeof(node_id)), copy over the MAC address using ether_addr_copy() (instead of using memcpy()).  Else, if get_registers() failed instead, a randomly generated MAC address is set as the MAC address instead.  ",f45a4248ea4cc13ed50618ff066849f9587226b2,1
hfs: add lock nesting notation to hfs_find_init,"Syzbot reports a possible recursive lock in [1].  This happens due to missing lock nesting information.  From the logs, we see that a call to hfs_fill_super is made to mount the hfs filesystem. While searching for the root inode, the lock on the catalog btree is grabbed.  Then, when the parent of the root isn't found, a call to __hfs_bnode_create is made to create the parent of the root.  This eventually leads to a call to hfs_ext_read_extent which grabs a lock on the extents btree.  Since the order of locking is catalog btree -> extents btree, this lock hierarchy does not lead to a deadlock.  To tell lockdep that this locking is safe, we add nesting notation to distinguish between catalog btrees, extents btrees, and attributes btrees (for HFS+).  This has already been done in hfsplus.  ",b3b2177a2d795e35dc11597b2609eb1e7e57e570,0
9p/cache.c: Fix memory leak in v9fs_cache_session_get_cookie,"v9fs_cache_session_get_cookie assigns a random cachetag to v9ses->cachetag, if the cachetag is not assigned previously.  v9fs_random_cachetag allocates memory to v9ses->cachetag with kmalloc and uses scnprintf to fill it up with a cachetag.  But if scnprintf fails, v9ses->cachetag is not freed in the current code causing a memory leak.  Fix this by freeing v9ses->cachetag it v9fs_random_cachetag fails.  This was reported by syzbot, the link to the report is below: https://syzkaller.appspot.com/bug?id=f012bdf297a7a4c860c38a88b44fbee43fd9bbf3  ",962a991c5de18452d6c429d99f3039387cf5cbb0,1
ip6_gre: better validate user provided tunnel names,"Use dev_valid_name() to make sure user does not provide illegal device name.  syzbot caught the following bug :  BUG: KASAN: stack-out-of-bounds in strlcpy include/linux/string.h:300 [inline] BUG: KASAN: stack-out-of-bounds in ip6gre_tunnel_locate+0x334/0x860 net/ipv6/ip6_gre.c:339 Write of size 20 at addr ffff8801afb9f7b8 by task syzkaller851048/4466  CPU: 1 PID: 4466 Comm: syzkaller851048 Not tainted 4.16.0+ #1 Hardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 01/01/2011 Call Trace:  __dump_stack lib/dump_stack.c:17 [inline]  dump_stack+0x1b9/0x29f lib/dump_stack.c:53  print_address_description+0x6c/0x20b mm/kasan/report.c:256  kasan_report_error mm/kasan/report.c:354 [inline]  kasan_report.cold.7+0xac/0x2f5 mm/kasan/report.c:412  check_memory_region_inline mm/kasan/kasan.c:260 [inline]  check_memory_region+0x13e/0x1b0 mm/kasan/kasan.c:267  memcpy+0x37/0x50 mm/kasan/kasan.c:303  strlcpy include/linux/string.h:300 [inline]  ip6gre_tunnel_locate+0x334/0x860 net/ipv6/ip6_gre.c:339  ip6gre_tunnel_ioctl+0x69d/0x12e0 net/ipv6/ip6_gre.c:1195  dev_ifsioc+0x43e/0xb90 net/core/dev_ioctl.c:334  dev_ioctl+0x69a/0xcc0 net/core/dev_ioctl.c:525  sock_ioctl+0x47e/0x680 net/socket.c:1015  vfs_ioctl fs/ioctl.c:46 [inline]  file_ioctl fs/ioctl.c:500 [inline]  do_vfs_ioctl+0x1cf/0x1650 fs/ioctl.c:684  ksys_ioctl+0xa9/0xd0 fs/ioctl.c:701  SYSC_ioctl fs/ioctl.c:708 [inline]  SyS_ioctl+0x24/0x30 fs/ioctl.c:706  do_syscall_64+0x29e/0x9d0 arch/x86/entry/common.c:287  entry_SYSCALL_64_after_hwframe+0x42/0xb7  ",5f42df013b8bc1b6511af7a04bf93b014884ae2a,1
tipc: eliminate KMSAN: uninit-value in __tipc_nl_compat_dumpit error,syzbot found the following crash on: ,a7869e5f9174f246b662b2db6390bc128a351388,1
inetpeer: fix data-race in inet_putpeer / inet_putpeer,"We need to explicitely forbid read/store tearing in inet_peer_gc() and inet_putpeer().  The following syzbot report reminds us about inet_putpeer() running without a lock held.  BUG: KCSAN: data-race in inet_putpeer / inet_putpeer  write to 0xffff888121fb2ed0 of 4 bytes by interrupt on cpu 0:  inet_putpeer+0x37/0xa0 net/ipv4/inetpeer.c:240  ip4_frag_free+0x3d/0x50 net/ipv4/ip_fragment.c:102  inet_frag_destroy_rcu+0x58/0x80 net/ipv4/inet_fragment.c:228  __rcu_reclaim kernel/rcu/rcu.h:222 [inline]  rcu_do_batch+0x256/0x5b0 kernel/rcu/tree.c:2157  rcu_core+0x369/0x4d0 kernel/rcu/tree.c:2377  rcu_core_si+0x12/0x20 kernel/rcu/tree.c:2386  __do_softirq+0x115/0x33f kernel/softirq.c:292  invoke_softirq kernel/softirq.c:373 [inline]  irq_exit+0xbb/0xe0 kernel/softirq.c:413  exiting_irq arch/x86/include/asm/apic.h:536 [inline]  smp_apic_timer_interrupt+0xe6/0x280 arch/x86/kernel/apic/apic.c:1137  apic_timer_interrupt+0xf/0x20 arch/x86/entry/entry_64.S:830  native_safe_halt+0xe/0x10 arch/x86/kernel/paravirt.c:71  arch_cpu_idle+0x1f/0x30 arch/x86/kernel/process.c:571  default_idle_call+0x1e/0x40 kernel/sched/idle.c:94  cpuidle_idle_call kernel/sched/idle.c:154 [inline]  do_idle+0x1af/0x280 kernel/sched/idle.c:263  write to 0xffff888121fb2ed0 of 4 bytes by interrupt on cpu 1:  inet_putpeer+0x37/0xa0 net/ipv4/inetpeer.c:240  ip4_frag_free+0x3d/0x50 net/ipv4/ip_fragment.c:102  inet_frag_destroy_rcu+0x58/0x80 net/ipv4/inet_fragment.c:228  __rcu_reclaim kernel/rcu/rcu.h:222 [inline]  rcu_do_batch+0x256/0x5b0 kernel/rcu/tree.c:2157  rcu_core+0x369/0x4d0 kernel/rcu/tree.c:2377  rcu_core_si+0x12/0x20 kernel/rcu/tree.c:2386  __do_softirq+0x115/0x33f kernel/softirq.c:292  run_ksoftirqd+0x46/0x60 kernel/softirq.c:603  smpboot_thread_fn+0x37d/0x4a0 kernel/smpboot.c:165  kthread+0x1d4/0x200 drivers/block/aoe/aoecmd.c:1253  ret_from_fork+0x1f/0x30 arch/x86/entry/entry_64.S:352  Reported by Kernel Concurrency Sanitizer on: CPU: 1 PID: 16 Comm: ksoftirqd/1 Not tainted 5.4.0-rc3+ #0 Hardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 01/01/2011  ",71685eb4ce80ae9c49eff82ca4dd15acab215de9,1
ALSA: pcm: Remove WARN_ON() at snd_pcm_hw_params() error,"snd_pcm_hw_params() (more exactly snd_pcm_hw_params_choose()) contains a check of the return error from snd_pcm_hw_param_first() and _last() with snd_BUG_ON() -- i.e. it may trigger WARN_ON() depending on the kconfig.  This was a valid check in the past, as these functions shouldn't return any error if the parameters have been already refined via snd_pcm_hw_refine() beforehand.  However, the recent rewrite introduced a kmalloc() in snd_pcm_hw_refine() for removing VLA, and this brought a possibility to trigger an error.  As a result, syzbot caught lots of superfluous kernel WARN_ON() and paniced via fault injection.  As the WARN_ON() is no longer valid with the introduction of kmalloc(), let's drop snd_BUG_ON() check, in order to make the world peaceful place again.  ",e1a3a981e320a6916b30ff53571ba144274def0e,1
fix breakage in do_rmdir(),"syzbot reported and bisected a use-after-free due to the recent init cleanups.  The putname() should happen only after we'd *not* branched to retry, same as it's done in do_unlinkat().  ",24fb33d40d60bd7d196400e7d5b26ff566fd98b7,1
net: core: use list_del_init() instead of list_del() in netdev_run_todo(),"dev->unlink_list is reused unless dev is deleted. So, list_del() should not be used. Due to using list_del(), dev->unlink_list can't be reused so that dev->nested_level update logic doesn't work. In order to fix this bug, list_del_init() should be used instead of list_del().  Test commands:     ip link add bond0 type bond     ip link add bond1 type bond     ip link set bond0 master bond1     ip link set bond0 nomaster     ip link set bond1 master bond0     ip link set bond1 nomaster  Splat looks like: ",0e8b8d6a2d85344d80dda5beadd98f5f86e8d3d3,0
USB: CDC: fix sanity checks in CDC union parser,A few checks checked for the size of the pointer to a structure instead of the structure itself. Copy & paste issue presumably.  ,54364278fb3cabdea51d6398b07c87415065b3fc,1
wireguard: noise: take lock when removing handshake entry from table,Eric reported that syzkaller found a race of this variety:  CPU 1                                       CPU 2 ,9179ba31367bcf481c3c79b5f028c94faad9f30a,1
sctp: do not free asoc when it is already dead in sctp_sendmsg,"Now in sctp_sendmsg sctp_wait_for_sndbuf could schedule out without holding sock sk. It means the current asoc can be freed elsewhere, like when receiving an abort packet.  If the asoc is just created in sctp_sendmsg and sctp_wait_for_sndbuf returns err, the asoc will be freed again due to new_asoc is not nil. An use-after-free issue would be triggered by this.  This patch is to fix it by setting new_asoc with nil if the asoc is already dead when cpu schedules back, so that it will not be freed again in sctp_sendmsg.  v1->v2:   set new_asoc as nil in sctp_sendmsg instead of sctp_wait_for_sndbuf.  Suggested-by: Neil Horman <nhorman@tuxdriver.com> ",ca3af4dd28cff4e7216e213ba3b671fbf9f84758,1
netlink: check for null extack in cookie helpers,"Unlike NL_SET_ERR_* macros, nl_set_extack_cookie_u64() and nl_set_extack_cookie_u32() helpers do not check extack argument for null and neither do their callers, as syzbot recently discovered for ethnl_parse_header().  Instead of fixing the callers and leaving the trap in place, add check of null extack to both helpers to make them consistent with NL_SET_ERR_* macros.  v2: drop incorrect second Fixes tag  ",55b474c41e586a5c21c7ab81ff474eb6bacb4322,0
net/x25: fix a race in x25_bind(),"syzbot was able to trigger another soft lockup [1]  I first thought it was the O(N^2) issue I mentioned in my prior fix (f657d22ee1f ""net/x25: do not hold the cpu too long in x25_new_lci()""), but I eventually found that x25_bind() was not checking SOCK_ZAPPED state under socket lock protection.  This means that multiple threads can end up calling x25_insert_socket() for the same socket, and corrupt x25_list  [1] watchdog: BUG: soft lockup - CPU#0 stuck for 123s! [syz-executor.2:10492] ",797a22bd5298c2674d927893f46cadf619dad11d,1
blk-mq: move lockdep_assert_held() into elevator_exit,"Commit c48dac137a62 (""block: don't hold q->sysfs_lock in elevator_init_mq"") removes q->sysfs_lock from elevator_init_mq(), but forgot to deal with lockdep_assert_held() called in blk_mq_sched_free_requests() which is run in failure path of elevator_init_mq().  blk_mq_sched_free_requests() is called in the following 3 functions:  	elevator_init_mq() 	elevator_exit() 	blk_cleanup_queue()  In blk_cleanup_queue(), blk_mq_sched_free_requests() is followed exactly by 'mutex_lock(&q->sysfs_lock)'.  So moving the lockdep_assert_held() from blk_mq_sched_free_requests() into elevator_exit() for fixing the report by syzbot.  ",284b94be1925dbe035ce5218d8b5c197321262c7,0
blockdev: Fix livelocks on loop device,"bd_set_size() updates also block device's block size. This is somewhat unexpected from its name and at this point, only blkdev_open() uses this functionality. Furthermore, this can result in changing block size under a filesystem mounted on a loop device which leads to livelocks inside __getblk_gfp() like:  Sending NMI from CPU 0 to CPUs 1: NMI backtrace for cpu 1 CPU: 1 PID: 10863 Comm: syz-executor0 Not tainted 4.18.0-rc5+ #151 Hardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 01/01/2011 ",04906b2f542c23626b0ef6219b808406f8dddbe9,0
tls: Use correct sk->sk_prot for IPV6,"The tls ulp overrides sk->prot with a new tls specific proto structs. The tls specific structs were previously based on the ipv4 specific tcp_prot sturct. As a result, attaching the tls ulp to an ipv6 tcp socket replaced some ipv6 callback with the ipv4 equivalents.  This patch adds ipv6 tls proto structs and uses them when attached to ipv6 sockets.  ",c113187d38ff85dc302a1bb55864b203ebb2ba10,0
tcp: fix hang in tcp_sendpage_locked(),"syszkaller got a hang in tcp stack, related to a bug in tcp_sendpage_locked()  root",bd9dfc54e39266ff67521c09d37e838077385b21,0
ipv6: reset fn->rr_ptr when replacing route,"syzcaller reported the following use-after-free issue in rt6_select(): BUG: KASAN: use-after-free in rt6_select net/ipv6/route.c:755 [inline] at addr ffff8800bc6994e8 BUG: KASAN: use-after-free in ip6_pol_route.isra.46+0x1429/0x1470 net/ipv6/route.c:1084 at addr ffff8800bc6994e8 Read of size 4 by task syz-executor1/439628 CPU: 0 PID: 439628 Comm: syz-executor1 Not tainted 4.3.5+ #8 Hardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 01/01/2011  0000000000000000 ffff88018fe435b0 ffffffff81ca384d ffff8801d3588c00  ffff8800bc699380 ffff8800bc699500 dffffc0000000000 ffff8801d40a47c0  ffff88018fe435d8 ffffffff81735751 ffff88018fe43660 ffff8800bc699380 Call Trace:  [<ffffffff81ca384d>] __dump_stack lib/dump_stack.c:15 [inline]  [<ffffffff81ca384d>] dump_stack+0xc1/0x124 lib/dump_stack.c:51 sctp: [Deprecated]: syz-executor0 (pid 439615) Use of struct sctp_assoc_value in delayed_ack socket option. Use struct sctp_sack_info instead  [<ffffffff81735751>] kasan_object_err+0x21/0x70 mm/kasan/report.c:158  [<ffffffff817359c4>] print_address_description mm/kasan/report.c:196 [inline]  [<ffffffff817359c4>] kasan_report_error+0x1b4/0x4a0 mm/kasan/report.c:285  [<ffffffff81735d93>] kasan_report mm/kasan/report.c:305 [inline]  [<ffffffff81735d93>] __asan_report_load4_noabort+0x43/0x50 mm/kasan/report.c:325  [<ffffffff82a28e39>] rt6_select net/ipv6/route.c:755 [inline]  [<ffffffff82a28e39>] ip6_pol_route.isra.46+0x1429/0x1470 net/ipv6/route.c:1084  [<ffffffff82a28fb1>] ip6_pol_route_output+0x81/0xb0 net/ipv6/route.c:1203  [<ffffffff82ab0a50>] fib6_rule_action+0x1f0/0x680 net/ipv6/fib6_rules.c:95  [<ffffffff8265cbb6>] fib_rules_lookup+0x2a6/0x7a0 net/core/fib_rules.c:223  [<ffffffff82ab1430>] fib6_rule_lookup+0xd0/0x250 net/ipv6/fib6_rules.c:41  [<ffffffff82a22006>] ip6_route_output+0x1d6/0x2c0 net/ipv6/route.c:1224  [<ffffffff829e83d2>] ip6_dst_lookup_tail+0x4d2/0x890 net/ipv6/ip6_output.c:943  [<ffffffff829e889a>] ip6_dst_lookup_flow+0x9a/0x250 net/ipv6/ip6_output.c:1079  [<ffffffff82a9f7d8>] ip6_datagram_dst_update+0x538/0xd40 net/ipv6/datagram.c:91  [<ffffffff82aa0978>] __ip6_datagram_connect net/ipv6/datagram.c:251 [inline]  [<ffffffff82aa0978>] ip6_datagram_connect+0x518/0xe50 net/ipv6/datagram.c:272  [<ffffffff82aa1313>] ip6_datagram_connect_v6_only+0x63/0x90 net/ipv6/datagram.c:284  [<ffffffff8292f790>] inet_dgram_connect+0x170/0x1f0 net/ipv4/af_inet.c:564  [<ffffffff82565547>] SYSC_connect+0x1a7/0x2f0 net/socket.c:1582  [<ffffffff8256a649>] SyS_connect+0x29/0x30 net/socket.c:1563  [<ffffffff82c72032>] entry_SYSCALL_64_fastpath+0x12/0x17 Object at ffff8800bc699380, in cache ip6_dst_cache size: 384  The root cause of it is that in fib6_add_rt2node(), when it replaces an existing route with the new one, it does not update fn->rr_ptr. This commit resets fn->rr_ptr to NULL when it points to a route which is replaced in fib6_add_rt2node().  ",383143f31d7d3525a1dbff733d52fff917f82f15,1
ALSA: aloop: Fix inconsistent format due to incomplete rule,"The extra hw constraint rule for the formats the aloop driver introduced has a slight flaw, where it doesn't return a positive value when the mask got changed.  It came from the fact that it's basically a copy&paste from snd_hw_constraint_mask64().  The original code is supposed to be a single-shot and it modifies the mask bits only once and never after, while what we need for aloop is the dynamic hw rule that limits the mask bits.  This difference results in the inconsistent state, as the hw_refine doesn't apply the dependencies fully.  The worse and surprisingly result is that it causes a crash in OSS emulation when multiple full-duplex reads/writes are performed concurrently (I leave why it triggers Oops to readers as a homework).  For fixing this, replace a few open-codes with the standard snd_mask_*() macros.  ",b088b53e20c7d09b5ab84c5688e609f478e5c417,1
media: mxl111sf: change mutex_init() location,"Syzbot reported, that mxl111sf_ctrl_msg() uses uninitialized mutex. The problem was in wrong mutex_init() location.  Previous mutex_init(&state->msg_lock) call was in ->init() function, but dvb_usbv2_init() has ",44870a9e7a3c24acbb3f888b2a7cc22c9bdf7e7f,1
proc: io_accounting: Use new infrastructure to fix deadlocks in execve,"This changes do_io_accounting to use the new exec_update_mutex instead of cred_guard_mutex.  This fixes possible deadlocks when the trace is accessing /proc/$pid/io for instance.  This should be safe, as the credentials are only used for reading.  ",76518d3798855242817e8a8ed76b2d72f4415624,0
net/tls: remove close callback sock unlock/lock around TX work flush,"The tls close() callback currently drops the sock lock, makes a cancel_delayed_work_sync() call, and then relocks the sock.  By restructuring the code we can avoid droping lock and then reclaiming it. To simplify this we do the following,   tls_sk_proto_close  set_bit(CLOSING)  set_bit(SCHEDULE)  cancel_delay_work_sync() <- cancel workqueue  lock_sock(sk)  ...  release_sock(sk)  strp_done()  Setting the CLOSING bit prevents the SCHEDULE bit from being cleared by any workqueue items e.g. if one happens to be scheduled and run between when we set SCHEDULE bit and cancel work. Then because SCHEDULE bit is set now no new work will be scheduled.  Tested with net selftests and bpf selftests.  ",f87e62d45e51b12d48d2cb46b5cde8f83b866bc4,0
lapb: fixed leak of control-blocks.,"lapb_register calls lapb_create_cb, which initializes the control- block's ref-count to one, and __lapb_insert_cb, which increments it when adding the new block to the list of blocks.  lapb_unregister calls __lapb_remove_cb, which decrements the ref-count when removing control-block from the list of blocks, and calls lapb_put itself to decrement the ref-count before returning.  However, lapb_unregister also calls __lapb_devtostruct to look up the right control-block for the given net_device, and __lapb_devtostruct also bumps the ref-count, which means that when lapb_unregister returns the ref-count is still 1 and the control-block is leaked.  Call lapb_put after __lapb_devtostruct to fix leak.  ",6be8e297f9bcea666ea85ac7a6cd9d52d6deaf92,0
netfilter: nf_tables: Fix oversized kvmalloc() calls,"The commit 7661809d493b (""mm: don't allow oversized kvmalloc() calls"") limits the max allocatable memory via kvmalloc() to MAX_INT.  ",45928afe94a094bcda9af858b96673d59bc4a0e9,0
"net: Whitelist the skbuff_head_cache ""cb"" field","Most callers of put_cmsg() use a ""sizeof(foo)"" for the length argument. Within put_cmsg(), a copy_to_user() call is made with a dynamic size, as a result of the cmsg header calculations. This means that hardened usercopy will examine the copy, even though it was technically a fixed size and should be implicitly whitelisted. All the put_cmsg() calls being built from values in skbuff_head_cache are coming out of the protocol-defined ""cb"" field, so whitelist this field entirely instead of creating per-use bounce buffers, for which there are concerns about performance.  Original report was:  Bad or missing usercopy whitelist? Kernel memory exposure attempt detected from SLAB object 'skbuff_head_cache' (offset 64, size 16)! ",79a8a642bf05cd0dced20621f6fef9d884124abd,0
mm/page_counter: fix various data races at memsw,"Commit 3e32cb2e0a12 (""mm: memcontrol: lockless page counters"") could had memcg->memsw->watermark and memcg->memsw->failcnt been accessed concurrently as reported by KCSAN,   BUG: KCSAN: data-race in page_counter_try_charge / page_counter_try_charge   read to 0xffff8fb18c4cd190 of 8 bytes by task 1081 on cpu 59:   page_counter_try_charge+0x4d/0x150 mm/page_counter.c:138   try_charge+0x131/0xd50 mm/memcontrol.c:2405   __memcg_kmem_charge_memcg+0x58/0x140   __memcg_kmem_charge+0xcc/0x280   __alloc_pages_nodemask+0x1e1/0x450   alloc_pages_current+0xa6/0x120   pte_alloc_one+0x17/0xd0   __pte_alloc+0x3a/0x1f0   copy_p4d_range+0xc36/0x1990   copy_page_range+0x21d/0x360   dup_mmap+0x5f5/0x7a0   dup_mm+0xa2/0x240   copy_process+0x1b3f/0x3460   _do_fork+0xaa/0xa20   __x64_sys_clone+0x13b/0x170   do_syscall_64+0x91/0xb47   entry_SYSCALL_64_after_hwframe+0x49/0xbe   write to 0xffff8fb18c4cd190 of 8 bytes by task 1153 on cpu 120:   page_counter_try_charge+0x5b/0x150 mm/page_counter.c:139   try_charge+0x131/0xd50 mm/memcontrol.c:2405   mem_cgroup_try_charge+0x159/0x460   mem_cgroup_try_charge_delay+0x3d/0xa0   wp_page_copy+0x14d/0x930   do_wp_page+0x107/0x7b0   __handle_mm_fault+0xce6/0xd40   handle_mm_fault+0xfc/0x2f0   do_page_fault+0x263/0x6f9   page_fault+0x34/0x40   BUG: KCSAN: data-race in page_counter_try_charge / page_counter_try_charge   write to 0xffff88809bbf2158 of 8 bytes by task 11782 on cpu 0:   page_counter_try_charge+0x100/0x170 mm/page_counter.c:129   try_charge+0x185/0xbf0 mm/memcontrol.c:2405   __memcg_kmem_charge_memcg+0x4a/0xe0 mm/memcontrol.c:2837   __memcg_kmem_charge+0xcf/0x1b0 mm/memcontrol.c:2877   __alloc_pages_nodemask+0x26c/0x310 mm/page_alloc.c:4780   read to 0xffff88809bbf2158 of 8 bytes by task 11814 on cpu 1:   page_counter_try_charge+0xef/0x170 mm/page_counter.c:129   try_charge+0x185/0xbf0 mm/memcontrol.c:2405   __memcg_kmem_charge_memcg+0x4a/0xe0 mm/memcontrol.c:2837   __memcg_kmem_charge+0xcf/0x1b0 mm/memcontrol.c:2877   __alloc_pages_nodemask+0x26c/0x310 mm/page_alloc.c:4780  Since watermark could be compared or set to garbage due to a data race which would change the code logic, fix it by adding a pair of READ_ONCE() and WRITE_ONCE() in those places.  The ""failcnt"" counter is tolerant of some degree of inaccuracy and is only used to report stats, a data race will not be harmful, thus mark it as an intentional data race using the data_race() macro.  ",6e4bd50f3888fa8fea8bc66a0ad4ad5f1c862961,1
lib/generic-radix-tree.c: add kmemleak annotations,"Kmemleak is falsely reporting a leak of the slab allocation in sctp_stream_init_ext():    BUG: memory leak   unreferenced object 0xffff8881114f5d80 (size 96):    comm ""syz-executor934"", pid 7160, jiffies 4294993058 (age 31.950s)    ",3c52b0af059e11a063970aed1ad143b9284a79c7,1
cgroup: never call do_group_exit() with task->frozen bit set,I've got two independent reports that cgroup_task_frozen() check in cgroup_exit() has been triggered by lkp libhugetlbfs-test and LTP ptrace01 tests.  For example: ,f2b31bb598248c04721cb8485e6091a9feb045ac,0
ALSA: pcm: Avoid potential races between OSS ioctls and read/write,"Although we apply the params_lock mutex to the whole read and write operations as well as snd_pcm_oss_change_params(), we may still face some races.  First off, the params_lock is taken inside the read and write loop. This is intentional for avoiding the too long locking, but it allows the in-between parameter change, which might lead to invalid pointers.  We check the readiness of the stream and set up via snd_pcm_oss_make_ready() at the beginning of read and write, but it's called only once, by assuming that it remains ready in the rest.  Second, many ioctls that may change the actual parameters (i.e. setting runtime->oss.params=1) aren't protected, hence they can be processed in a half-baked state.  This patch is an attempt to plug these holes.  The stream readiness check is moved inside the read/write inner loop, so that the stream is always set up in a proper state before further processing.  Also, each ioctl that may change the parameter is wrapped with the params_lock for avoiding the races.  The issues were triggered by syzkaller in a few different scenarios, particularly the one below appearing as GPF in loopback_pos_update.  ",02a5d6925cd34c3b774bdb8eefb057c40a30e870,1
LSM: Check for NULL cred-security on free,From: Casey Schaufler <casey@schaufler-ca.com>  Check that the cred security blob has been set before trying to clean it up. There is a case during credential initialization that could result in this.  ,a5795fd38ee8194451ba3f281f075301a3696ce2,0
ALSA: pcm: Remove yet superfluous WARN_ON(),"muldiv32() contains a snd_BUG_ON() (which is morphed as WARN_ON() with debug option) for checking the case of 0 / 0.  This would be helpful if this happens only as a logical error; however, since the hw refine is performed with any data set provided by user, the inconsistent values that can trigger such a condition might be passed easily. Actually, syzbot caught this by passing some zero'ed old hw_params ioctl.  So, having snd_BUG_ON() there is simply superfluous and rather harmful to give unnecessary confusions.  Let's get rid of it.  ",23b19b7b50fe1867da8d431eea9cd3e4b6328c2c,1
staging: android: ion: Switch from WARN to pr_warn,Syzbot reported a warning with Ion:  ,e4e179a844f52e907e550f887d0a2171f1508af1,0
afs: Fix cell removal,"Fix cell removal by inserting a more final state than AFS_CELL_FAILED that indicates that the cell has been unpublished in case the manager is already requeued and will go through again.  The new AFS_CELL_REMOVED state will just immediately leave the manager function.  Going through a second time in the AFS_CELL_FAILED state will cause it to try to remove the cell again, potentially leading to the proc list being removed.  ",1d0e850a49a5b56f8f3cb51e74a11e2fedb96be6,0
cfg80211: remove WARN_ON() in cfg80211_sme_connect,"A WARN_ON(wdev->conn) would trigger in cfg80211_sme_connect(), if multiple send_msg(NL80211_CMD_CONNECT) system calls are made from the userland, which should be anticipated and handled by the wireless driver. Remove this WARN_ON() to prevent kernel panic if kernel is configured to ""panic_on_warn"".  Bug reported by syzbot.  ",1b5ab825d9acc0f27d2f25c6252f3526832a9626,0
ath9k_htc: fix NULL pointer dereference at ath9k_htc_tx_get_packet(),"syzbot is reporting lockdep warning at ath9k_wmi_event_tasklet() followed by kernel panic at get_htc_epid_queue() from ath9k_htc_tx_get_packet() from ath9k_htc_txstatus() [1], for ath9k_wmi_event_tasklet(WMI_TXSTATUS_EVENTID) depends on spin_lock_init() from ath9k_init_priv() being already completed.  Since ath9k_wmi_event_tasklet() is set by ath9k_init_wmi() from ath9k_htc_probe_device(), it is possible that ath9k_wmi_event_tasklet() is called via tasklet interrupt before spin_lock_init() from ath9k_init_priv()  from ath9k_init_device() from ath9k_htc_probe_device() is called.  Let's hold ath9k_wmi_event_tasklet(WMI_TXSTATUS_EVENTID) no-op until ath9k_tx_init() completes.  ",8b3046abc99eefe11438090bcc4ec3a3994b55d0,1
media: dvb-usb: fix wrong definition,syzbot reported ,c680ed46e418e9c785d76cf44eb33bfd1e8cf3f6,0
kcm: Fix use-after-free caused by clonned sockets,"(resend for properly queueing in patchwork)  kcm_clone() creates kernel socket, which does not take net counter. Thus, the net may die before the socket is completely destructed, i.e. kcm_exit_net() is executed before kcm_done().  ",eb7f54b90bd8f469834c5e86dcf72ebf9a629811,1
io_uring: fix recursive completion locking on oveflow flush,"syszbot reports a scenario where we recurse on the completion lock when flushing an overflow:  1 lock held by syz-executor287/6816:  #0: ffff888093cdb4d8 (&ctx->completion_lock){....}-{2:2}, at: io_cqring_overflow_flush+0xc6/0xab0 fs/io_uring.c:1333  stack backtrace: CPU: 1 PID: 6816 Comm: syz-executor287 Not tainted 5.8.0-syzkaller #0 Hardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 01/01/2011 Call Trace:  __dump_stack lib/dump_stack.c:77 [inline]  dump_stack+0x1f0/0x31e lib/dump_stack.c:118  print_deadlock_bug kernel/locking/lockdep.c:2391 [inline]  check_deadlock kernel/locking/lockdep.c:2432 [inline]  validate_chain+0x69a4/0x88a0 kernel/locking/lockdep.c:3202  __lock_acquire+0x1161/0x2ab0 kernel/locking/lockdep.c:4426  lock_acquire+0x160/0x730 kernel/locking/lockdep.c:5005  __raw_spin_lock_irq include/linux/spinlock_api_smp.h:128 [inline]  _raw_spin_lock_irq+0x67/0x80 kernel/locking/spinlock.c:167  spin_lock_irq include/linux/spinlock.h:379 [inline]  io_queue_linked_timeout fs/io_uring.c:5928 [inline]  __io_queue_async_work fs/io_uring.c:1192 [inline]  __io_queue_deferred+0x36a/0x790 fs/io_uring.c:1237  io_cqring_overflow_flush+0x774/0xab0 fs/io_uring.c:1359  io_ring_ctx_wait_and_kill+0x2a1/0x570 fs/io_uring.c:7808  io_uring_release+0x59/0x70 fs/io_uring.c:7829  __fput+0x34f/0x7b0 fs/file_table.c:281  task_work_run+0x137/0x1c0 kernel/task_work.c:135  exit_task_work include/linux/task_work.h:25 [inline]  do_exit+0x5f3/0x1f20 kernel/exit.c:806  do_group_exit+0x161/0x2d0 kernel/exit.c:903  __do_sys_exit_group+0x13/0x20 kernel/exit.c:914  __se_sys_exit_group+0x10/0x10 kernel/exit.c:912  __x64_sys_exit_group+0x37/0x40 kernel/exit.c:912  do_syscall_64+0x31/0x70 arch/x86/entry/common.c:46  entry_SYSCALL_64_after_hwframe+0x44/0xa9  Fix this by passing back the link from __io_queue_async_work(), and then let the caller handle the queueing of the link. Take care to also punt the submission reference put to the caller, as we're holding the completion lock for the __io_queue_defer() case. Hence we need to mark the io_kiocb appropriately for that case.  ",7271ef3a93a832180068c7aade3f130b7f39b17e,1
ALSA: pcm: oss: Fix negative period/buffer sizes,"The period size calculation in OSS layer may receive a negative value as an error, but the code there assumes only the positive values and handle them with size_t.  Due to that, a too big value may be passed to the lower layers.  This patch changes the code to handle with ssize_t and adds the proper error checks appropriately.  ",9d2479c960875ca1239bcb899f386970c13d9cfe,0
media: gspca: zero usb_buf on error,"If reg_r() fails, then gspca_dev->usb_buf was left uninitialized, and some drivers used the contents of that buffer in logic.  This caused several syzbot errors:  https://syzkaller.appspot.com/bug?extid=397fd082ce5143e2f67d https://syzkaller.appspot.com/bug?extid=1a35278dd0ebfb3a038a https://syzkaller.appspot.com/bug?extid=06ddf1788cfd048c5e82  I analyzed the gspca drivers and zeroed the buffer where needed.  ",4843a543fad3bf8221cf14e5d5f32d15cee89e84,1
net: hso: fix null-ptr-deref during tty device unregistration,"Multiple ttys try to claim the same the minor number causing a double unregistration of the same device. The first unregistration succeeds but the next one results in a null-ptr-deref.  The get_free_serial_index() function returns an available minor number but doesn't assign it immediately. The assignment is done by the caller later. But before this assignment, calls to get_free_serial_index() would return the same minor number.  Fix this by modifying get_free_serial_index to assign the minor number immediately after one is found to be and rename it to obtain_minor() to better reflect what it does. Similary, rename set_serial_by_index() to release_minor() and modify it to free up the minor number of the given hso_serial. Every obtain_minor() should have corresponding release_minor() call.  ",8a12f8836145ffe37e9c8733dce18c22fb668b66,0
xfrm: Copy policy family in clone_policy,"The syzbot found an ancient bug in the IPsec code.  When we cloned a socket policy (for example, for a child TCP socket derived from a listening socket), we did not copy the family field.  This results in a live policy with a zero family field.  This triggers a BUG_ON check in the af_key code when the cloned policy is retrieved.  This patch fixes it by copying the family field over.  ",0e74aa1d79a5bbc663e03a2804399cae418a0321,1
sunrpc: Fix latency trace point crashes,"If the rpc_task survived longer than the transport, task->tk_xprt points to freed memory by the time rpc_count_iostats_metrics runs. Replace the references to task->tk_xprt with references to the task's tk_client.  ",98eb6cf25f0317395d9a799d18f3d46ba26a00d3,1
xfrm: Fix warning in xfrm6_tunnel_net_exit.,We need to make sure that all states are really deleted before we check that the state lists are empty. Otherwise we trigger a warning.  ,b48c05ab5d32af2af4bc63851c153782d1c6ba42,0
net: bridge: fix ioctl locking,"Before commit ad2f99aedf8f (""net: bridge: move bridge ioctls out of .ndo_do_ioctl"") the bridge ioctl calls were divided in two parts: one was deviceless called by sock_ioctl and didn't expect rtnl to be held, the other was with a device called by dev_ifsioc() and expected rtnl to be held. After the commit above they were united in a single ioctl stub, but it didn't take care of the locking expectations. For sock_ioctl now we acquire  (1) br_ioctl_mutex, (2) rtnl and for dev_ifsioc we acquire  (1) rtnl,           (2) br_ioctl_mutex  The fix is to get a refcnt on the netdev for dev_ifsioc calls and drop rtnl then to reacquire it in the bridge ioctl stub after br_ioctl_mutex has been acquired. That will avoid playing locking games and make the rules straight-forward: we always take br_ioctl_mutex first, and then rtnl.  ",893b195875340cb44b54c9db99e708145f1210e8,0
staging: ion: remove from the tree,"The ION android code has long been marked to be removed, now that we dma-buf support merged into the real part of the kernel.  It was thought that we could wait to remove the ion kernel at a later time, but as the out-of-tree Android fork of the ion code has diverged quite a bit, and any Android device using the ion interface uses that forked version and not this in-tree version, the in-tree copy of the code is abandonded and not used by anyone.  Combine this abandoned codebase with the need to make changes to it in order to keep the kernel building properly, which then causes merge issues when merging those changes into the out-of-tree Android code, and you end up with two different groups of people (the in-kernel-tree developers, and the Android kernel developers) who are both annoyed at the current situation.  Because of this problem, just drop the in-kernel copy of the ion code now, as it's not used, and is only causing problems for everyone involved.  ",e722a295cf493388dae474745d30e91e1a2ec549,0
RDMA/rxe: Fix bug in rxe_alloc(),"A recent patch which added an 'unlocked' version of rxe_alloc introduced a bug causing kzalloc(..., GFP_KERNEL) to be called while holding a spin lock. This patch corrects that error.  rxe_alloc_nl() should always be called while holding the pool->pool_lock so the 2nd argument to kzalloc there should be GFP_ATOMIC.  rxe_alloc() prior to the change only locked the code around checking that pool->state is RXE_POOL_STATE_VALID to avoid races between working threads and a thread shutting down the rxe driver. This patch reverts rxe_alloc() to this behavior so the lock is not held when kzalloc() is called.  ",c4369575b2bc2993edf8223a8f5c9f510ee629d0,1
rcu: Don't invoke try_invoke_on_locked_down_task() with irqs disabled,"The try_invoke_on_locked_down_task() function requires that interrupts be enabled, but it is called with interrupts disabled from rcu_print_task_stall(), resulting in an ""IRQs not enabled as expected"" diagnostic.  This commit therefore updates rcu_print_task_stall() to accumulate a list of the first few tasks while holding the current leaf rcu_node structure's ->lock, then releases that lock and only then uses try_invoke_on_locked_down_task() to attempt to obtain per-task detailed information.  Of course, as soon as ->lock is released, the task might exit, so the get_task_struct() function is used to prevent the task structure from going away in the meantime.  ",c583bcb8f5edd48c1798798e341f78afb9bf4f6f,0
AX.25: Fix out-of-bounds read in ax25_connect(),"Checks on `addr_len` and `fsa->fsa_ax25.sax25_ndigis` are insufficient. ax25_connect() can go out of bounds when `fsa->fsa_ax25.sax25_ndigis` equals to 7 or 8. Fix it.  This issue has been reported as a KMSAN uninit-value bug, because in such a case, ax25_connect() reaches into the uninitialized portion of the `struct sockaddr_storage` statically allocated in __sys_connect().  It is safe to remove `fsa->fsa_ax25.sax25_ndigis > AX25_MAX_DIGIS` because `addr_len` is guaranteed to be less than or equal to `sizeof(struct full_sockaddr_ax25)`.  ",2f2a7ffad5c6cbf3d438e813cfdc88230e185ba6,1
printk: fix string termination for record_print_text(),"Commit f0e386ee0c0b (""printk: fix buffer overflow potential for print_text()"") added string termination in record_print_text(). However it used the wrong base pointer for adding the terminator. This led to a 0-byte being written somewhere beyond the buffer.  Use the correct base pointer when adding the terminator.  ",08d60e5999540110576e7c1346d486220751b7f9,1
bpf: cpumap: use GFP_KERNEL instead of GFP_ATOMIC in __cpu_map_entry_alloc(),"There're several implications after commit 0bf7800f1799 (""ptr_ring: try vmalloc() when kmalloc() fails"") with the using of vmalloc() since can't allow GFP_ATOMIC but mandate GFP_KERNEL. This will lead a WARN since cpumap try to call with GFP_ATOMIC. Fortunately, entry allocation of cpumap can only be done through syscall path which means GFP_ATOMIC is not necessary, so fixing this by replacing GFP_ATOMIC with GFP_KERNEL.  ",7fc17e909edfb9bf421ee04e981d3d474175c7c7,0
netfilter: ipt_CLUSTERIP: fix a race condition of proc file creation,"There is a race condition between clusterip_config_entry_put() and clusterip_config_init(), after we release the spinlock in clusterip_config_entry_put(), a new proc file with a same IP could be created immediately since it is already removed from the configs list, therefore it triggers this warning:  ",b3e456fce9f51d6276e576d00271e2813c1b8b67,1
net: nexthop: don't allow empty NHA_GROUP,"Currently the nexthop code will use an empty NHA_GROUP attribute, but it requires at least 1 entry in order to function properly. Otherwise we end up derefencing null or random pointers all over the place due to not having any nh_grp_entry members allocated, nexthop code relies on having at least the first member present. Empty NHA_GROUP doesn't make any sense so just disallow it. Also add a WARN_ON for any future users of nexthop_create_group().   BUG: kernel NULL pointer dereference, ",eeaac3634ee0e3f35548be35275efeca888e9b23,1
netfilter: nf_tables: autoload modules from the abort path,"This patch introduces a list of pending module requests. This new module list is composed of nft_module_request objects that contain the module name and one status field that tells if the module has been already loaded (the 'done' field).  In the first pass, from the preparation phase, the netlink command finds that a module is missing on this list. Then, a module request is allocated and added to this list and nft_request_module() returns -EAGAIN. This triggers the abort path with the autoload parameter set on from nfnetlink, request_module() is called and the module request enters the 'done' state. Since the mutex is released when loading modules from the abort phase, the module list is zapped so this is iteration occurs over a local list. Therefore, the request_module() calls happen when object lists are in consistent state (after fulling aborting the transaction) and the commit list is empty.  On the second pass, the netlink command will find that it already tried to load the module, so it does not request it again and nft_request_module() returns 0. Then, there is a look up to find the object that the command was missing. If the module was successfully loaded, the command proceeds normally since it finds the missing object in place, otherwise -ENOENT is reported to userspace.  This patch also updates nfnetlink to include the reason to enter the abort phase, which is required for this new autoload module rationale.  ",eb014de4fd418de1a277913cba244e47274fe392,0
ALSA: pcm: Fix memory leak at closing a stream without hw_free,"ALSA PCM core recently introduced a new managed PCM buffer allocation mode that does allocate / free automatically at hw_params and hw_free.  However, it overlooked the code path directly calling hw_free PCM ops at releasing the PCM substream, and it may result in a memory leak as spotted by syzkaller when no buffer preallocation is used (e.g. vmalloc buffer).  This patch papers over it with a slight refactoring.  The hw_free ops call and relevant tasks are unified in a new helper function, and call it from both places.  ",66f2d19f8116e16898f8d82e28573a384ddc430d,1
media: rc: uevent sysfs file races with rc_unregister_device(),"Only report uevent file contents if device still registered, else we might read freed memory.  ",4f0835d6677dc69263f90f976524cb92b257d9f4,1
vfs: Add a single-or-reconfig keying to vfs_get_super(),"Add an additional keying mode to vfs_get_super() to indicate that only a single superblock should exist in the system, and that, if it does, further mounts should invoke reconfiguration upon it.  This allows mount_single() to be replaced.  [Fix by Eric Biggers folded in]  ",43ce4c1feadbc84c772518a2d1974f6ba1b15089,0
USB: gadget: Reject endpoints with 0 maxpacket value,"Endpoints with a maxpacket length of 0 are probably useless.  They can't transfer any data, and it's not at all unlikely that a UDC will crash or hang when trying to handle a non-zero-length usb_request for such an endpoint.  Indeed, dummy-hcd gets a divide error when trying to calculate the remainder of a transfer length by the maxpacket value, as discovered by the syzbot fuzzer.  Currently the gadget core does not check for endpoints having a maxpacket value of 0.  This patch adds a check to usb_ep_enable(), preventing such endpoints from being used.  As far as I know, none of the gadget drivers in the kernel tries to create an endpoint with maxpacket = 0, but until now there has been nothing to prevent userspace programs under gadgetfs or configfs from doing it.  ",54f83b8c8ea9b22082a496deadf90447a326954e,1
aio: simplify - and fix - fget/fput for io_submit(),"Al Viro root-caused a race where the IOCB_CMD_POLL handling of fget/fput() could cause us to access the file pointer after it had already been freed:   ""In more details - normally IOCB_CMD_POLL handling looks so:     1) io_submit(2) allocates aio_kiocb instance and passes it to       aio_poll()     2) aio_poll() resolves the descriptor to struct file by req->file =       fget(iocb->aio_fildes)     3) aio_poll() sets ->woken to false and raises ->ki_refcnt of that       aio_kiocb to 2 (bumps by 1, that is).     4) aio_poll() calls vfs_poll(). After sanity checks (basically,       ""poll_wait() had been called and only once"") it locks the queue.       That's what the extra reference to iocb had been for - we know we       can safely access it.     5) With queue locked, we check if ->woken has already been set to       true (by aio_poll_wake()) and, if it had been, we unlock the       queue, drop a reference to aio_kiocb and bugger off - at that       point it's a responsibility to aio_poll_wake() and the stuff       called/scheduled by it. That code will drop the reference to file       in req->file, along with the other reference to our aio_kiocb.     6) otherwise, we see whether we need to wait. If we do, we unlock the       queue, drop one reference to aio_kiocb and go away - eventual       wakeup (or cancel) will deal with the reference to file and with       the other reference to aio_kiocb     7) otherwise we remove ourselves from waitqueue (still under the       queue lock), so that wakeup won't get us. No async activity will       be happening, so we can safely drop req->file and iocb ourselves.    If wakeup happens while we are in vfs_poll(), we are fine - aio_kiocb   won't get freed under us, so we can do all the checks and locking   safely. And we don't touch ->file if we detect that case.    However, vfs_poll() most certainly *does* touch the file it had been   given. So wakeup coming while we are still in ->poll() might end up   doing fput() on that file. That case is not too rare, and usually we   are saved by the still present reference from descriptor table - that   fput() is not the final one.    But if another thread closes that descriptor right after our fget()   and wakeup does happen before ->poll() returns, we are in trouble -   final fput() done while we are in the middle of a method:  Al also wrote a patch to take an extra reference to the file descriptor to fix this, but I instead suggested we just streamline the whole file pointer handling by submit_io() so that the generic aio submission code simply keeps the file pointer around until the aio has completed.  ",84c4e1f89fefe70554da0ab33be72c9be7994379,1
hsr: fix slab-out-of-bounds Read in hsr_debugfs_rename(),"hsr slave interfaces don't have debugfs directory. So, hsr_debugfs_rename() shouldn't be called when hsr slave interface name is changed.  Test commands:     ip link add dummy0 type dummy     ip link add dummy1 type dummy     ip link add hsr0 type hsr slave1 dummy0 slave2 dummy1     ip link set dummy0 name ap  Splat looks like: [21071.899367][T22666] ap: renamed from dummy0 [21071.914005][T22666] ",04b69426d846cd04ca9acefff1ea39e1c64d2714,1
usb: hso: check for return value in hso_serial_common_create(),"in case of an error tty_register_device_attr() returns ERR_PTR(), add IS_ERR() check  ",e911e99a0770f760377c263bc7bac1b1593c6147,0
ipvs: Fix uninit-value in do_ip_vs_set_ctl(),do_ip_vs_set_ctl() is referencing uninitialized stack value when `len` is zero. Fix it.  ,c5a8a8498eed1c164afc94f50a939c1a10abf8ad,1
ntfs: fix validity check for file name attribute,"When checking the file name attribute, we want to ensure that it fits within the bounds of ATTR_RECORD.  To do this, we should check that (attr record + file name offset + file name length) < (attr record + attr record length).  However, the original check did not include the file name offset in the calculation.  This means that corrupted on-disk metadata might not caught by the incorrect file name check, and lead to an invalid memory access.  An example can be seen in the crash report of a memory corruption error found by Syzbot: https://syzkaller.appspot.com/bug?id=a1a1e379b225812688566745c3e2f7242bffc246  Adding the file name offset to the validity check fixes this error and passes the Syzbot reproducer test.  ",d98e4d95411bbde2220a7afa38dcc9c14d71acbe,1
net/packet: fix race in tpacket_snd(),"packet_sendmsg() checks tx_ring.pg_vec to decide if it must call tpacket_snd().  Problem is that the check is lockless, meaning another thread can issue a concurrent setsockopt(PACKET_TX_RING ) to flip tx_ring.pg_vec back to NULL.  Given that tpacket_snd() grabs pg_vec_lock mutex, we can perform the check again to solve the race.  syzbot reported :  kasan: CONFIG_KASAN_INLINE enabled kasan: GPF could be caused by NULL-ptr deref or user memory access general protection fault: 0000 [#1] PREEMPT SMP KASAN CPU: 1 PID: 11429 Comm: syz-executor394 Not tainted 5.3.0-rc4+ #101 Hardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 01/01/2011 ",32d3182cd2cd29b2e7e04df7b0db350fbe11289f,1
kasan: fix crashes on access to memory mapped by vm_map_ram(),"With CONFIG_KASAN_VMALLOC=y any use of memory obtained via vm_map_ram() will crash because there is no shadow backing that memory.  Instead of sprinkling additional kasan_populate_vmalloc() calls all over the vmalloc code, move it into alloc_vmap_area(). This will fix vm_map_ram() and simplify the code a bit.  [aryabinin@virtuozzo.com: v2]   ",d98c9e83b5e7ca78175df1b13ac4a6d460d3962d,1
gre: fix uninit-value in __iptunnel_pull_header,"syzbot found an interesting case of the kernel reading an uninit-value [1]  Problem is in the handling of ETH_P_WCCP in gre_parse_header()  We look at the byte following GRE options to eventually decide if the options are four bytes longer.  Use skb_header_pointer() to not pull bytes if we found that no more bytes were needed.  All callers of gre_parse_header() are properly using pskb_may_pull() anyway before proceeding to next header.  [1] BUG: KMSAN: uninit-value in pskb_may_pull include/linux/skbuff.h:2303 [inline] BUG: KMSAN: uninit-value in __iptunnel_pull_header+0x30c/0xbd0 net/ipv4/ip_tunnel_core.c:94 CPU: 1 PID: 11784 Comm: syz-executor940 Not tainted 5.6.0-rc2-syzkaller #0 Hardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 01/01/2011 Call Trace:  __dump_stack lib/dump_stack.c:77 [inline]  dump_stack+0x1c9/0x220 lib/dump_stack.c:118  kmsan_report+0xf7/0x1e0 mm/kmsan/kmsan_report.c:118  __msan_warning+0x58/0xa0 mm/kmsan/kmsan_instr.c:215  pskb_may_pull include/linux/skbuff.h:2303 [inline]  __iptunnel_pull_header+0x30c/0xbd0 net/ipv4/ip_tunnel_core.c:94  iptunnel_pull_header include/net/ip_tunnels.h:411 [inline]  gre_rcv+0x15e/0x19c0 net/ipv6/ip6_gre.c:606  ip6_protocol_deliver_rcu+0x181b/0x22c0 net/ipv6/ip6_input.c:432  ip6_input_finish net/ipv6/ip6_input.c:473 [inline]  NF_HOOK include/linux/netfilter.h:307 [inline]  ip6_input net/ipv6/ip6_input.c:482 [inline]  ip6_mc_input+0xdf2/0x1460 net/ipv6/ip6_input.c:576  dst_input include/net/dst.h:442 [inline]  ip6_rcv_finish net/ipv6/ip6_input.c:76 [inline]  NF_HOOK include/linux/netfilter.h:307 [inline]  ipv6_rcv+0x683/0x710 net/ipv6/ip6_input.c:306  __netif_receive_skb_one_core net/core/dev.c:5198 [inline]  __netif_receive_skb net/core/dev.c:5312 [inline]  netif_receive_skb_internal net/core/dev.c:5402 [inline]  netif_receive_skb+0x66b/0xf20 net/core/dev.c:5461  tun_rx_batched include/linux/skbuff.h:4321 [inline]  tun_get_user+0x6aef/0x6f60 drivers/net/tun.c:1997  tun_chr_write_iter+0x1f2/0x360 drivers/net/tun.c:2026  call_write_iter include/linux/fs.h:1901 [inline]  new_sync_write fs/read_write.c:483 [inline]  __vfs_write+0xa5a/0xca0 fs/read_write.c:496  vfs_write+0x44a/0x8f0 fs/read_write.c:558  ksys_write+0x267/0x450 fs/read_write.c:611  __do_sys_write fs/read_write.c:623 [inline]  __se_sys_write fs/read_write.c:620 [inline]  __ia32_sys_write+0xdb/0x120 fs/read_write.c:620  do_syscall_32_irqs_on arch/x86/entry/common.c:339 [inline]  do_fast_syscall_32+0x3c7/0x6e0 arch/x86/entry/common.c:410  entry_SYSENTER_compat+0x68/0x77 arch/x86/entry/entry_64_compat.S:139 ",17c25cafd4d3e74c83dce56b158843b19c40b414,1
neighbor: gc_list changes should be protected by table lock,"Adding and removing neighbor entries to / from the gc_list need to be done while holding the table lock; a couple of places were missed in the original patch.  Move the list_add_tail in neigh_alloc to ___neigh_create where the lock is already obtained. Since neighbor entries should rarely be moved to/from PERMANENT state, add lock/unlock around the gc_list changes in neigh_change_state rather than extending the lock hold around all neighbor updates.  ",8cc196d6ef86bbab01dbf16f6c596cf56aa0839e,0
Bluetooth: hci_ldisc: Postpone HCI_UART_PROTO_READY bit set in hci_uart_set_proto(),"task A:                                task B: hci_uart_set_proto                     flush_to_ldisc  - p->open(hu) -> h5_open  //alloc h5  - receive_buf  - set_bit HCI_UART_PROTO_READY         - tty_port_default_receive_buf  - hci_uart_register_dev                 - tty_ldisc_receive_buf                                           - hci_uart_tty_receive 				           - test_bit HCI_UART_PROTO_READY 				            - h5_recv  - clear_bit HCI_UART_PROTO_READY             while() {  - p->open(hu) -> h5_close //free h5 				              - h5_rx_3wire_hdr 				               - h5_reset()  //use-after-free                                               }  It could use ioctl to set hci uart proto, but there is a use-after-free issue when hci_uart_register_dev() fail in hci_uart_set_proto(), see stack above, fix this by setting HCI_UART_PROTO_READY bit only when hci_uart_register_dev() return success.  ",56897b217a1d0a91c9920cb418d6b3fe922f590a,1
slip: make slhc_compress() more robust against malicious packets,"Before accessing various fields in IPV4 network header and TCP header, make sure the packet :  - Has IP version 4 (ip->version == 4) - Has not a silly network length (ip->ihl >= 5) - Is big enough to hold network and transport headers - Has not a silly TCP header size (th->doff >= sizeof(struct tcphdr) / 4)  syzbot reported :  BUG: KMSAN: uninit-value in slhc_compress+0x5b9/0x2e60 drivers/net/slip/slhc.c:270 CPU: 0 PID: 11728 Comm: syz-executor231 Not tainted 5.6.0-rc2-syzkaller #0 Hardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 01/01/2011 Call Trace:  __dump_stack lib/dump_stack.c:77 [inline]  dump_stack+0x1c9/0x220 lib/dump_stack.c:118  kmsan_report+0xf7/0x1e0 mm/kmsan/kmsan_report.c:118  __msan_warning+0x58/0xa0 mm/kmsan/kmsan_instr.c:215  slhc_compress+0x5b9/0x2e60 drivers/net/slip/slhc.c:270  ppp_send_frame drivers/net/ppp/ppp_generic.c:1637 [inline]  __ppp_xmit_process+0x1902/0x2970 drivers/net/ppp/ppp_generic.c:1495  ppp_xmit_process+0x147/0x2f0 drivers/net/ppp/ppp_generic.c:1516  ppp_write+0x6bb/0x790 drivers/net/ppp/ppp_generic.c:512  do_loop_readv_writev fs/read_write.c:717 [inline]  do_iter_write+0x812/0xdc0 fs/read_write.c:1000  compat_writev+0x2df/0x5a0 fs/read_write.c:1351  do_compat_pwritev64 fs/read_write.c:1400 [inline]  __do_compat_sys_pwritev fs/read_write.c:1420 [inline]  __se_compat_sys_pwritev fs/read_write.c:1414 [inline]  __ia32_compat_sys_pwritev+0x349/0x3f0 fs/read_write.c:1414  do_syscall_32_irqs_on arch/x86/entry/common.c:339 [inline]  do_fast_syscall_32+0x3c7/0x6e0 arch/x86/entry/common.c:410  entry_SYSENTER_compat+0x68/0x77 arch/x86/entry/entry_64_compat.S:139 ",110a40dfb708fe940a3f3704d470e431c368d256,1
crypto: algapi - fix NULL dereference in crypto_remove_spawns(),"syzkaller triggered a NULL pointer dereference in crypto_remove_spawns() via a program that repeatedly and concurrently requests AEADs ""authenc(cmac(des3_ede-asm),pcbc-aes-aesni)"" and hashes ""cmac(des3_ede)"" through AF_ALG, where the hashes are requested as ""untested"" (CRYPTO_ALG_TESTED is set in ->salg_mask but clear in ->salg_feat; this causes the template to be instantiated for every request).  Although AF_ALG users really shouldn't be able to request an ""untested"" algorithm, the NULL pointer dereference is actually caused by a longstanding race condition where crypto_remove_spawns() can encounter an instance which has had spawn(s) ""grabbed"" but hasn't yet been registered, resulting in ->cra_users still being NULL.  We probably should properly initialize ->cra_users earlier, but that would require updating many templates individually.  For now just fix the bug in a simple way that can easily be backported: make crypto_remove_spawns() treat a NULL ->cra_users list as empty.  ",9a00674213a3f00394f4e3221b88f2d21fc05789,1
HID: usbhid: fix info leak in hid_submit_ctrl,"In hid_submit_ctrl(), the way of calculating the report length doesn't take into account that report->size can be zero. When running the syzkaller reproducer, a report of size 0 causes hid_submit_ctrl) to calculate transfer_buffer_length as 16384. When this urb is passed to the usb core layer, KMSAN reports an info leak of 16384 bytes.  To fix this, first modify hid_report_len() to account for the zero report size case by using DIV_ROUND_UP for the division. Then, call it from hid_submit_ctrl().  ",6be388f4a35d2ce5ef7dbf635a8964a5da7f799f,1
tomoyo: ignore data race while checking quota,"syzbot is reporting that tomoyo's quota check is racy [1]. But this check is tolerant of some degree of inaccuracy. Thus, teach KCSAN to ignore this data race.  [1] https://syzkaller.appspot.com/bug?id=999533deec7ba6337f8aa25d8bd1a4d5f7e50476  ",5797e861e402fff2bedce4ec8b7c89f4248b6073,1
selinux: fix memory leak in policydb_init(),"Since roles_init() adds some entries to the role hash table, we need to destroy also its keys/values on error, otherwise we get a memory leak in the error path.  ",45385237f65aeee73641f1ef737d7273905a233f,1
KVM: x86: Initialize tdp_level during vCPU creation,Initialize vcpu->arch.tdp_level during vCPU creation to avoid consuming garbage if userspace calls KVM_RUN without first calling KVM_SET_CPUID.  ,7d2e8748af62b0de7c7bbcb0d62f937e88fd7027,0
reiserfs: add check for invalid 1st journal block,"syzbot reported divide error in reiserfs. The problem was in incorrect journal 1st block.  Syzbot's reproducer manualy generated wrong superblock with incorrect 1st block. In journal_init() wasn't any checks about this particular case.  For example, if 1st journal block is before superblock 1st block, it can cause zeroing important superblock members in do_journal_end().  ",a149127be52fa7eaf5b3681a0317a2bbb772d5a9,0
tcp: fix possible deadlock in TCP stack vs BPF filter,"Filtering the ACK packet was not put at the right place.  At this place, we already allocated a child and put it into accept queue.  We absolutely need to call tcp_child_process() to release its spinlock, or we will deadlock at accept() or close() time.  Found by syzkaller team (Thanks a lot !)  ",d624d276d1ddacbcb12ad96832ce0c7b82cd25db,1
"bpf: mark dst unknown on inconsistent {s, u}bounds adjustments","syzkaller generated a BPF proglet and triggered a warning with the following:    0: (b7) r0 = 0   1: (d5) if r0 s<= 0x0 goto pc+0    R0=inv0 R1=ctx(id=0,off=0,imm=0) R10=fp0   2: (1f) r0 -= r1    R0=inv0 R1=ctx(id=0,off=0,imm=0) R10=fp0   verifier internal error: known but bad sbounds  What happens is that in the first insn, r0's min/max value are both 0 due to the immediate assignment, later in the jsle test the bounds are updated for the min value in the false path, meaning, they yield smin_val = 1, smax_val = 0, and when ctx pointer is subtracted from r0, verifier bails out with the internal error and throwing a WARN since smin_val != smax_val for the known constant.  For min_val > max_val scenario it means that reg_set_min_max() and reg_set_min_max_inv() (which both refine existing bounds) demonstrated that such branch cannot be taken at runtime.  In above scenario for the case where it will be taken, the existing [0, 0] bounds are kept intact. Meaning, the rejection is not due to a verifier internal error, and therefore the WARN() is not necessary either.  We could just reject such cases in adjust_{ptr,scalar}_min_max_vals() when either known scalars have smin_val != smax_val or umin_val != umax_val or any scalar reg with bounds smin_val > smax_val or umin_val > umax_val. However, there may be a small risk of breakage of buggy programs, so handle this more gracefully and in adjust_{ptr,scalar}_min_max_vals() just taint the dst reg as unknown scalar when we see ops with such kind of src reg.  ",6f16101e6a8b4324c36e58a29d9e0dbb287cdedb,1
Staging: remove wusbcore and UWB from the kernel tree.,"It's been over 6 months, and no one has noticed that these drivers are deleted, probably because no one actually has this hardware.  As no one has volunteered to maintain the code, let's drop it for good.  ",caa6772db4c1deb5d9add48e95d6eab50699ee5e,0
usb: raw-gadget: fix memory leak in gadget_setup,"When fetch 'event' from event queue, after copy its address space content to user space, the 'event' the memory space pointed to by the 'event' pointer need be freed.  BUG: memory leak unreferenced object 0xffff888110622660 (size 32):   comm ""softirq"", pid 0, jiffies 4294941981 (age 12.480s)   ",129aa9734559a17990ee933351c7b6956f1dba62,1
fuse: don't dereference req->args on finished request,Move the check for async request after check for the request being already finished and done with.  ,2b319d1f6f92a4ced9897678113d176ee16ae85d,1
crypto: morus640 - Fix out-of-bounds access,"We must load the block from the temporary variable here, not directly from the input.  Also add forgotten zeroing-out of the uninitialized part of the temporary block (as is done correctly in morus1280.c).  ",a81ae8095712d1513fe8d58527c92c439b43233e,1
ppp: remove the PPPIOCDETACH ioctl,"The PPPIOCDETACH ioctl effectively tries to ""close"" the given ppp file before f_count has reached 0, which is fundamentally a bad idea.  It does check 'f_count < 2', which excludes concurrent operations on the file since they would only be possible with a shared fd table, in which case each fdget() would take a file reference.  However, it fails to account for the fact that even with 'f_count == 1' the file can still be linked into epoll instances.  As reported by syzbot, this can trivially be used to cause a use-after-free.  Yet, the only known user of PPPIOCDETACH is pppd versions older than ppp-2.4.2, which was released almost 15 years ago (November 2003). Also, PPPIOCDETACH apparently stopped working reliably at around the same time, when the f_count check was added to the kernel, e.g. see https://lkml.org/lkml/2002/12/31/83.  Also, the current 'f_count < 2' check makes PPPIOCDETACH only work in single-threaded applications; it always fails if called from a multithreaded application.  All pppd versions released in the last 15 years just close() the file descriptor instead.  Therefore, instead of hacking around this bug by exporting epoll internals to modules, and probably missing other related bugs, just remove the PPPIOCDETACH ioctl and see if anyone actually notices.  Leave a stub in place that prints a one-time warning and returns EINVAL.  ",af8d3c7c001ae7df1ed2b2715f058113efc86187,1
fat: fix fat_ra_init() for data clusters == 0,"If data clusters == 0, fat_ra_init() calls the ->ent_blocknr() for the cluster beyond ->max_clusters.  This checks the limit before initialization to suppress the warning.  ",a090a5a7d73f79a9ae2dcc6e60d89bfc6864a65a,0
netlink: reset extack earlier in netlink_rcv_skb,"Move up the extack reset/initialization in netlink_rcv_skb, so that those 'goto ack' will not skip it. Otherwise, later on netlink_ack may use the uninitialized extack and cause kernel crash.  ",cd443f1e91ca600a092e780e8250cd6a2954b763,1
sch_red: fix off-by-one checks in red_check_params(),"This fixes following syzbot report:  UBSAN: shift-out-of-bounds in ./include/net/red.h:237:23 shift exponent 32 is too large for 32-bit type 'unsigned int' CPU: 1 PID: 8418 Comm: syz-executor170 Not tainted 5.12.0-rc4-next-20210324-syzkaller #0 Hardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 01/01/2011 Call Trace:  __dump_stack lib/dump_stack.c:79 [inline]  dump_stack+0x141/0x1d7 lib/dump_stack.c:120  ubsan_epilogue+0xb/0x5a lib/ubsan.c:148  __ubsan_handle_shift_out_of_bounds.cold+0xb1/0x181 lib/ubsan.c:327  red_set_parms include/net/red.h:237 [inline]  choke_change.cold+0x3c/0xc8 net/sched/sch_choke.c:414  qdisc_create+0x475/0x12f0 net/sched/sch_api.c:1247  tc_modify_qdisc+0x4c8/0x1a50 net/sched/sch_api.c:1663  rtnetlink_rcv_msg+0x44e/0xad0 net/core/rtnetlink.c:5553  netlink_rcv_skb+0x153/0x420 net/netlink/af_netlink.c:2502  netlink_unicast_kernel net/netlink/af_netlink.c:1312 [inline]  netlink_unicast+0x533/0x7d0 net/netlink/af_netlink.c:1338  netlink_sendmsg+0x856/0xd90 net/netlink/af_netlink.c:1927  sock_sendmsg_nosec net/socket.c:654 [inline]  sock_sendmsg+0xcf/0x120 net/socket.c:674  ____sys_sendmsg+0x6e8/0x810 net/socket.c:2350  ___sys_sendmsg+0xf3/0x170 net/socket.c:2404  __sys_sendmsg+0xe5/0x1b0 net/socket.c:2433  do_syscall_64+0x2d/0x70 arch/x86/entry/common.c:46  entry_SYSCALL_64_after_hwframe+0x44/0xae ",3a87571f0ffc51ba3bf3ecdb6032861d0154b164,1
rtnetlink: fix rtnl_valid_stats_req() nlmsg_len check,"Jakub forgot to either use nlmsg_len() or nlmsg_msg_size(), allowing KMSAN to detect a possible uninit-value in rtnl_stats_get  BUG: KMSAN: uninit-value in rtnl_stats_get+0x6d9/0x11d0 net/core/rtnetlink.c:4997 CPU: 0 PID: 10428 Comm: syz-executor034 Not tainted 5.1.0-rc2+ #24 Hardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 01/01/2011 Call Trace:  __dump_stack lib/dump_stack.c:77 [inline]  dump_stack+0x173/0x1d0 lib/dump_stack.c:113  kmsan_report+0x131/0x2a0 mm/kmsan/kmsan.c:619  __msan_warning+0x7a/0xf0 mm/kmsan/kmsan_instr.c:310  rtnl_stats_get+0x6d9/0x11d0 net/core/rtnetlink.c:4997  rtnetlink_rcv_msg+0x115b/0x1550 net/core/rtnetlink.c:5192  netlink_rcv_skb+0x431/0x620 net/netlink/af_netlink.c:2485  rtnetlink_rcv+0x50/0x60 net/core/rtnetlink.c:5210  netlink_unicast_kernel net/netlink/af_netlink.c:1310 [inline]  netlink_unicast+0xf3e/0x1020 net/netlink/af_netlink.c:1336  netlink_sendmsg+0x127f/0x1300 net/netlink/af_netlink.c:1925  sock_sendmsg_nosec net/socket.c:622 [inline]  sock_sendmsg net/socket.c:632 [inline]  ___sys_sendmsg+0xdb3/0x1220 net/socket.c:2137  __sys_sendmsg net/socket.c:2175 [inline]  __do_sys_sendmsg net/socket.c:2184 [inline]  __se_sys_sendmsg+0x305/0x460 net/socket.c:2182  __x64_sys_sendmsg+0x4a/0x70 net/socket.c:2182  do_syscall_64+0xbc/0xf0 arch/x86/entry/common.c:291  entry_SYSCALL_64_after_hwframe+0x63/0xe7  ",69f23a09daf9790acb801aaef4bc7aea6f69eec1,1
io_uring: unpark SQPOLL thread for cancelation,"We park SQPOLL task before going into io_uring_cancel_files(), so the task won't run task_works including those that might be important for the cancellation passes. In this case it's io_poll_remove_one(), which frees requests via io_put_req_deferred().  Unpark it for while waiting, it's ok as we disable submissions beforehand, so no new requests will be generated.  INFO: task syz-executor893:8493 blocked for more than 143 seconds. Call Trace:  context_switch kernel/sched/core.c:4327 [inline]  __schedule+0x90c/0x21a0 kernel/sched/core.c:5078  schedule+0xcf/0x270 kernel/sched/core.c:5157  io_uring_cancel_files fs/io_uring.c:8912 [inline]  io_uring_cancel_task_requests+0xe70/0x11a0 fs/io_uring.c:8979  __io_uring_files_cancel+0x110/0x1b0 fs/io_uring.c:9067  io_uring_files_cancel include/linux/io_uring.h:51 [inline]  do_exit+0x2fe/0x2ae0 kernel/exit.c:780  do_group_exit+0x125/0x310 kernel/exit.c:922  __do_sys_exit_group kernel/exit.c:933 [inline]  __se_sys_exit_group kernel/exit.c:931 [inline]  __x64_sys_exit_group+0x3a/0x50 kernel/exit.c:931  do_syscall_64+0x2d/0x70 arch/x86/entry/common.c:46  entry_SYSCALL_64_after_hwframe+0x44/0xa9  ",34343786ecc5ff493ca4d1f873b4386759ba52ee,0
blktrace: fix debugfs use after free,"On commit 6ac93117ab00 (""blktrace: use existing disk debugfs directory"") merged on v4.12 Omar fixed the original blktrace code for request-based drivers (multiqueue). This however left in place a possible crash, if you happen to abuse blktrace while racing to remove / add a device.  We used to use asynchronous removal of the request_queue, and with that the issue was easier to reproduce. Now that we have reverted to synchronous removal of the request_queue, the issue is still possible to reproduce, its however just a bit more difficult.  We essentially run two instances of break-blktrace which add/remove a loop device, and setup a blktrace and just never tear the blktrace down. We do this twice in parallel. This is easily reproduced with the script run_0004.sh from break-blktrace [0].  We can end up with two types of panics each reflecting where we race, one a failed blktrace setup:  ",bad8e64fb19d3a0de5e564d9a7271c31bd684369,1
vfs: Implement a filesystem superblock creation/configuration context,"[AV - unfuck kern_mount_data(); we want non-NULL ->mnt_ns on long-living mounts] [AV - reordering fs/namespace.c is badly overdue, but let's keep it separate from that series] [AV - drop simple_pin_fs() change] [AV - clean vfs_kern_mount() failure exits up]  Implement a filesystem context concept to be used during superblock creation for mount and superblock reconfiguration for remount.  The mounting procedure then becomes:   (1) Allocate new fs_context context.   (2) Configure the context.   (3) Create superblock.   (4) Query the superblock.   (5) Create a mount for the superblock.   (6) Destroy the context.  Rather than calling fs_type->mount(), an fs_context struct is created and fs_type->init_fs_context() is called to set it up.  Pointers exist for the filesystem and LSM to hang their private data off.  A set of operations has to be set by ->init_fs_context() to provide freeing, duplication, option parsing, binary data parsing, validation, mounting and superblock filling.  Legacy filesystems are supported by the provision of a set of legacy fs_context operations that build up a list of mount options and then invoke fs_type->mount() from within the fs_context ->get_tree() operation.  This allows all filesystems to be accessed using fs_context.  It should be noted that, whilst this patch adds a lot of lines of code, there is quite a bit of duplication with existing code that can be eliminated should all filesystems be converted over.  ",3e1aeb00e6d132efc151dacc062b38269bc9eccc,0
KVM: x86: fix size of x86_fpu_cache objects,"The memory allocation in b666a4b69739 (""kvm: x86: Dynamically allocate guest_fpu"", 2018-11-06) is wrong, there are other members in struct fpu before the fpregs_state union and the patch should be doing something similar to the code in fpu__init_task_struct_size.  It's enough to run a guest and then rmmod kvm to see slub errors which are actually caused by memory corruption.  For now let's revert it to sizeof(struct fpu), which is conservative. I have plans to move fsave/fxsave/xsave directly in KVM, without using the kernel FPU helpers, and once it's done, the size of the object in the cache will be something like kvm_xstate_size.  ",ed8e48122728acfaf7bfa904cba034d83905b43a,1
bpf: Forbid bpf_ktime_get_coarse_ns and bpf_timer_* in tracing progs,Use of bpf_ktime_get_coarse_ns() and bpf_timer_* helpers in tracing progs may result in locking issues.  bpf_ktime_get_coarse_ns() uses ktime_get_coarse_ns() time accessor that isn't safe for any context: ,5e0bc3082e2e403ac0753e099c2b01446bb35578,0
netfilter: ipset: call ip_set_free() instead of kfree(),"Whenever ip_set_alloc() is used, allocated memory can either use kmalloc() or vmalloc(). We should call kvfree() or ip_set_free()  invalid opcode: 0000 [#1] PREEMPT SMP KASAN CPU: 0 PID: 21935 Comm: syz-executor.3 Not tainted 5.8.0-rc2-syzkaller #0 Hardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 01/01/2011 ",c4e8fa9074ad94f80e5c0dcaa16b313e50e958c5,1
block: brd: associate with queue until adding disk,"brd_free() may be called in failure path on one brd instance which disk isn't added yet, so release handler of gendisk may free the associated request_queue early and causes the following use-after-free[1].  This patch fixes this issue by associating gendisk with request_queue just before adding disk.  [1] KASAN: use-after-free Read in del_timer_syncNon-volatile memory driver v1.3 Linux agpgart interface v0.103 [drm] Initialized vgem 1.0.0 20120112 for virtual device on minor 0 usbcore: registered new interface driver udl ",153fcd5f6d93b8e1e4040b1337f564a10f8d93af,1
usbnet: sanity check for maxpacket,maxpacket of 0 makes no sense and oopses as we need to divide by it. Give up.  V2: fixed typo in log and stylistic issues  ,397430b50a363d8b7bdda00522123f82df6adc5e,1
sctp: fix error handling on stream scheduler initialization,"It allocates the extended area for outbound streams only on sendmsg calls, if they are not yet allocated.  When using the priority stream scheduler, this initialization may imply into a subsequent allocation, which may fail.  In this case, it was aborting the stream scheduler initialization but leaving the ->ext pointer (allocated) in there, thus in a partially initialized state.  On a subsequent call to sendmsg, it would notice the ->ext pointer in there, and trip on uninitialized stuff when trying to schedule the data chunk.  The fix is undo the ->ext initialization if the stream scheduler initialization fails and avoid the partially initialized state.  Although syzkaller bisected this to commit 4ff40b86262b (""sctp: set chunk transport correctly when it's a new asoc""), this bug was actually introduced on the commit I marked below.  ",4d1415811e492d9a8238f8a92dd0d51612c788e9,1
media: em28xx: modules workqueue not inited for 2nd device,"syzbot reports an error on flush_request_modules() for the second device. This workqueue was never initialised so simply remove the offending line.  usb 1-1: USB disconnect, device number 2 em28xx 1-1:1.153: Disconnecting em28xx #1 ",46e4a26615cc7854340e4b69ca59ee78d6f20c8b,0
net: sched: potential NULL dereference in tcf_block_find(),The error code isn't set on this path so it would result in returning ERR_PTR(0) and a NULL dereference in the caller.  ,af736bf071e8ccf395fa7f7d9d105e020cf609cc,1
ptrace: fix task_join_group_stop() for the case when current is traced,"This testcase  	#include <stdio.h> 	#include <unistd.h> 	#include <signal.h> 	#include <sys/ptrace.h> 	#include <sys/wait.h> 	#include <pthread.h> 	#include <assert.h>  	void *tf(void *arg) 	{ 		return NULL; 	}  	int main(void) 	{ 		int pid = fork(); 		if (!pid) { 			kill(getpid(), SIGSTOP);  			pthread_t th; 			pthread_create(&th, NULL, tf, NULL);  			return 0; 		}  		waitpid(pid, NULL, WSTOPPED);  		ptrace(PTRACE_SEIZE, pid, 0, PTRACE_O_TRACECLONE); 		waitpid(pid, NULL, 0);  		ptrace(PTRACE_CONT, pid, 0,0); 		waitpid(pid, NULL, 0);  		int status; 		int thread = waitpid(-1, &status, 0); 		assert(thread > 0 && thread != pid); 		assert(status == 0x80137f);  		return 0; 	}  fails and triggers WARN_ON_ONCE(!signr) in do_jobctl_trap().  This is because task_join_group_stop() has 2 problems when current is traced:  	1. We can't rely on the ""JOBCTL_STOP_PENDING"" check, a stopped tracee 	   can be woken up by debugger and it can clone another thread which 	   should join the group-stop.  	   We need to check group_stop_count || SIGNAL_STOP_STOPPED.  	2. If SIGNAL_STOP_STOPPED is already set, we should not increment 	   sig->group_stop_count and add JOBCTL_STOP_CONSUME. The new thread 	   should stop without another do_notify_parent_cldstop() report.  To clarify, the problem is very old and we should blame ptrace_init_task().  But now that we have task_join_group_stop() it makes more sense to fix this helper to avoid the code duplication.  ",7b3c36fc4c231ca532120bbc0df67a12f09c1d96,0
ext4: fix argument checking in EXT4_IOC_MOVE_EXT,"If the starting block number of either the source or destination file exceeds the EOF, EXT4_IOC_MOVE_EXT should return EINVAL.  Also fixed the helper function mext_check_coverage() so that if the logical block is beyond EOF, make it return immediately, instead of looping until the block number wraps all the away around.  This takes long enough that if there are multiple threads trying to do pound on an the same inode doing non-sensical things, it can end up triggering the kernel's soft lockup detector.  ",f18b2b83a727a3db208308057d2c7945f368e625,0
io-wq: fix memory leak in create_io_worker(),"BUG: memory leak unreferenced object 0xffff888126fcd6c0 (size 192):   comm ""syz-executor.1"", pid 11934, jiffies 4294983026 (age 15.690s)   backtrace:     [<ffffffff81632c91>] kmalloc_node include/linux/slab.h:609 [inline]     [<ffffffff81632c91>] kzalloc_node include/linux/slab.h:732 [inline]     [<ffffffff81632c91>] create_io_worker+0x41/0x1e0 fs/io-wq.c:739     [<ffffffff8163311e>] io_wqe_create_worker fs/io-wq.c:267 [inline]     [<ffffffff8163311e>] io_wqe_enqueue+0x1fe/0x330 fs/io-wq.c:866     [<ffffffff81620b64>] io_queue_async_work+0xc4/0x200 fs/io_uring.c:1473     [<ffffffff8162c59c>] __io_queue_sqe+0x34c/0x510 fs/io_uring.c:6933     [<ffffffff8162c7ab>] io_req_task_submit+0x4b/0xa0 fs/io_uring.c:2233     [<ffffffff8162cb48>] io_async_task_func+0x108/0x1c0 fs/io_uring.c:5462     [<ffffffff816259e3>] tctx_task_work+0x1b3/0x3a0 fs/io_uring.c:2158     [<ffffffff81269b43>] task_work_run+0x73/0xb0 kernel/task_work.c:164     [<ffffffff812dcdd1>] tracehook_notify_signal include/linux/tracehook.h:212 [inline]     [<ffffffff812dcdd1>] handle_signal_work kernel/entry/common.c:146 [inline]     [<ffffffff812dcdd1>] exit_to_user_mode_loop kernel/entry/common.c:172 [inline]     [<ffffffff812dcdd1>] exit_to_user_mode_prepare+0x151/0x180 kernel/entry/common.c:209     [<ffffffff843ff25d>] __syscall_exit_to_user_mode_work kernel/entry/common.c:291 [inline]     [<ffffffff843ff25d>] syscall_exit_to_user_mode+0x1d/0x40 kernel/entry/common.c:302     [<ffffffff843fa4a2>] do_syscall_64+0x42/0xb0 arch/x86/entry/common.c:86     [<ffffffff84600068>] entry_SYSCALL_64_after_hwframe+0x44/0xae  when create_io_thread() return error, and not retry, the worker object need to be freed.  ",66e70be722886e4f134350212baa13f217e39e42,1
tipc: fix use-after-free,"syszkaller reported use-after-free in tipc [1]  When msg->rep skb is freed, set the pointer to NULL, so that caller does not free it again.  [1]  ",5bfd37b4de5c98e86b12bd13be5aa46c7484a125,1
KVM: nVMX: Fix bad cleanup on error of get/set nested state IOCTLs,"The handlers of IOCTLs in kvm_arch_vcpu_ioctl() are expected to set their return value in ""r"" local var and break out of switch block when they encounter some error. This is because vcpu_load() is called before the switch block which have a proper cleanup of vcpu_put() afterwards.  However, KVM_{GET,SET}_NESTED_STATE IOCTLs handlers just return immediately on error without performing above mentioned cleanup.  Thus, change these handlers to behave as expected.  ",26b471c7e2f7befd0f59c35b257749ca57e0ed70,0
netfilter: nf_tables: fix nat hook table deletion,"sybot came up with following transaction:  add table ip syz0  add chain ip syz0 syz2 { type nat hook prerouting priority 0; policy accept; }  add table ip syz0 { flags dormant; }  delete chain ip syz0 syz2  delete table ip syz0  which yields: hook not found, pf 2 num 0 ",1e9451cbda456a170518b2bfd643e2cb980880bf,0
net: 9p: initialize sun_server.sun_path to have addr's value only when addr is valid,"In p9_fd_create_unix, checking is performed to see if the addr (passed as an argument) is NULL or not. However, no check is performed to see if addr is a valid address, i.e., it doesn't entirely consist of only 0's. The initialization of sun_server.sun_path to be equal to this faulty addr value leads to an uninitialized variable, as detected by KMSAN. Checking for this (faulty addr) and returning a negative error number appropriately, resolves this issue.  ",7ca1db21ef8e0e6725b4d25deed1ca196f7efb28,1
tun: add a missing rcu_read_unlock() in error path,"In my latest patch I missed one rcu_read_unlock(), in case device is down.  ",9180bb4f046064dfa4541488102703b402bb04e1,0
ipv6: mcast: fix a use-after-free in inet6_mc_check,"syzbot found a use-after-free in inet6_mc_check [1]  The problem here is that inet6_mc_check() uses rcu and read_lock(&iml->sflock)  So the fact that ip6_mc_leave_src() is called under RTNL and the socket lock does not help us, we need to acquire iml->sflock in write mode.  In the future, we should convert all this stuff to RCU.  [1] BUG: KASAN: use-after-free in ipv6_addr_equal include/net/ipv6.h:521 [inline] BUG: KASAN: use-after-free in inet6_mc_check+0xae7/0xb40 net/ipv6/mcast.c:649 Read of size 8 at addr ffff8801ce7f2510 by task syz-executor0/22432  CPU: 1 PID: 22432 Comm: syz-executor0 Not tainted 4.19.0-rc7+ #280 Hardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 01/01/2011 Call Trace:  __dump_stack lib/dump_stack.c:77 [inline]  dump_stack+0x1c4/0x2b4 lib/dump_stack.c:113  print_address_description.cold.8+0x9/0x1ff mm/kasan/report.c:256  kasan_report_error mm/kasan/report.c:354 [inline]  kasan_report.cold.9+0x242/0x309 mm/kasan/report.c:412  __asan_report_load8_noabort+0x14/0x20 mm/kasan/report.c:433  ipv6_addr_equal include/net/ipv6.h:521 [inline]  inet6_mc_check+0xae7/0xb40 net/ipv6/mcast.c:649  __raw_v6_lookup+0x320/0x3f0 net/ipv6/raw.c:98  ipv6_raw_deliver net/ipv6/raw.c:183 [inline]  raw6_local_deliver+0x3d3/0xcb0 net/ipv6/raw.c:240  ip6_input_finish+0x467/0x1aa0 net/ipv6/ip6_input.c:345  NF_HOOK include/linux/netfilter.h:289 [inline]  ip6_input+0xe9/0x600 net/ipv6/ip6_input.c:426  ip6_mc_input+0x48a/0xd20 net/ipv6/ip6_input.c:503  dst_input include/net/dst.h:450 [inline]  ip6_rcv_finish+0x17a/0x330 net/ipv6/ip6_input.c:76  NF_HOOK include/linux/netfilter.h:289 [inline]  ipv6_rcv+0x120/0x640 net/ipv6/ip6_input.c:271  __netif_receive_skb_one_core+0x14d/0x200 net/core/dev.c:4913  __netif_receive_skb+0x2c/0x1e0 net/core/dev.c:5023  netif_receive_skb_internal+0x12c/0x620 net/core/dev.c:5126  napi_frags_finish net/core/dev.c:5664 [inline]  napi_gro_frags+0x75a/0xc90 net/core/dev.c:5737  tun_get_user+0x3189/0x4250 drivers/net/tun.c:1923  tun_chr_write_iter+0xb9/0x154 drivers/net/tun.c:1968  call_write_iter include/linux/fs.h:1808 [inline]  do_iter_readv_writev+0x8b0/0xa80 fs/read_write.c:680  do_iter_write+0x185/0x5f0 fs/read_write.c:959  vfs_writev+0x1f1/0x360 fs/read_write.c:1004  do_writev+0x11a/0x310 fs/read_write.c:1039  __do_sys_writev fs/read_write.c:1112 [inline]  __se_sys_writev fs/read_write.c:1109 [inline]  __x64_sys_writev+0x75/0xb0 fs/read_write.c:1109  do_syscall_64+0x1b9/0x820 arch/x86/entry/common.c:290  entry_SYSCALL_64_after_hwframe+0x49/0xbe ",dc012f3628eaecfb5ba68404a5c30ef501daf63d,1
RDMA/siw: Fix passive connection establishment,"Holding the rtnl_lock while iterating a devices interface address list potentially causes deadlocks with the cma_netdev_callback. While this was implemented to limit the scope of a wildcard listen to addresses of the current device only, a better solution limits the scope of the socket to the device. This completely avoiding locking, and also results in significant code simplification.  ",33fb27fd54465c74cbffba6315b2f043e90cec4c,0
net: fix up truesize of cloned skb in skb_prepare_for_shift(),"Avoid the assumption that ksize(kmalloc(S)) == ksize(kmalloc(S)): when cloning an skb, save and restore truesize after pskb_expand_head(). This can occur if the allocator decides to service an allocation of the same size differently (e.g. use a different size class, or pass the allocation on to KFENCE).  Because truesize is used for bookkeeping (such as sk_wmem_queued), a modified truesize of a cloned skb may result in corrupt bookkeeping and relevant warnings (such as in sk_stream_kill_queues()).  ",097b9146c0e26aabaa6ff3e5ea536a53f5254a79,0
ipv4: fix uninit-value in ip_route_output_key_hash_rcu(),"syzbot complained that res.type could be used while not initialized.  Using RTN_UNSPEC as initial value seems better than using garbage.  BUG: KMSAN: uninit-value in __mkroute_output net/ipv4/route.c:2200 [inline] BUG: KMSAN: uninit-value in ip_route_output_key_hash_rcu+0x31f0/0x3940 net/ipv4/route.c:2493 CPU: 1 PID: 12207 Comm: syz-executor0 Not tainted 4.16.0+ #81 Hardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 01/01/2011 Call Trace:  __dump_stack lib/dump_stack.c:17 [inline]  dump_stack+0x185/0x1d0 lib/dump_stack.c:53  kmsan_report+0x142/0x240 mm/kmsan/kmsan.c:1067  __msan_warning_32+0x6c/0xb0 mm/kmsan/kmsan_instr.c:676  __mkroute_output net/ipv4/route.c:2200 [inline]  ip_route_output_key_hash_rcu+0x31f0/0x3940 net/ipv4/route.c:2493  ip_route_output_key_hash net/ipv4/route.c:2322 [inline]  __ip_route_output_key include/net/route.h:126 [inline]  ip_route_output_flow+0x1eb/0x3c0 net/ipv4/route.c:2577  raw_sendmsg+0x1861/0x3ed0 net/ipv4/raw.c:653  inet_sendmsg+0x48d/0x740 net/ipv4/af_inet.c:764  sock_sendmsg_nosec net/socket.c:630 [inline]  sock_sendmsg net/socket.c:640 [inline]  SYSC_sendto+0x6c3/0x7e0 net/socket.c:1747  SyS_sendto+0x8a/0xb0 net/socket.c:1715  do_syscall_64+0x309/0x430 arch/x86/entry/common.c:287  entry_SYSCALL_64_after_hwframe+0x3d/0xa2 ",d0ea2b12500543535be3f54e17920fffc9bb45f6,1
net: hsr: Reset MAC header for Tx path,"Reset MAC header in HSR Tx path. This is needed, because direct packet transmission, e.g. by specifying PACKET_QDISC_BYPASS does not reset the MAC header.  This has been observed using the following setup:  |$ ip link add name hsr0 type hsr slave1 lan0 slave2 lan1 supervision 45 version 1 |$ ifconfig hsr0 up |$ ./test hsr0  The test binary is using mmap'ed sockets and is specifying the PACKET_QDISC_BYPASS socket option.  This patch resolves the following warning on a non-patched kernel:  |",9d6803921a16f4d768dc41a75375629828f4d91e,0
ALSA: timer: Fix the breakage of slave link open,"A silly mistake was made while applying the fix for potential races in commit 6a34367e52ca (""ALSA: timer: Fix possible race at assigning a timer instance""): when a slave PCM is opened and succeeds, it doesn't return but proceeds to the master timer open code instead.  Plug the hole and beautify a bit.  ",0c4f09ceec3d7afbef6ad4077d96e36e0fad4028,1
net: fix GSO for SG-enabled devices,"The commit dbd50f238dec (""net: move the hsize check to the else block in skb_segment"") introduced a data corruption for devices supporting scatter-gather.  The problem boils down to signed/unsigned comparison given unexpected results: if signed 'hsize' is negative, it will be considered greater than a positive 'len', which is unsigned.  This commit addresses resorting to the old checks order, so that 'hsize' never has a negative value when compared with 'len'.  v1 -> v2:  - reorder hsize checks instead of explicit cast (Alex)  Bisected-by: Matthieu Baerts <matthieu.baerts@tessares.net> ",00b229f762b020eebf55a52b984aec76ae0ad966,1
can: slcan: Fix use-after-free Read in slcan_open,Slcan_open doesn't clean-up device which registration failed from the slcan_devs device list. On next open this list is iterated and freed device is accessed. Fix this by calling slc_free_netdev in error path.  Driver/net/can/slcan.c is derived from slip.c. Use-after-free error was identified in slip_open by syzboz. Same bug is in slcan.c. Here is the trace from the Syzbot slip report:  __dump_stack lib/dump_stack.c:77 [inline] dump_stack+0x197/0x210 lib/dump_stack.c:118 print_address_description.constprop.0.cold+0xd4/0x30b mm/kasan/report.c:374 __kasan_report.cold+0x1b/0x41 mm/kasan/report.c:506 kasan_report+0x12/0x20 mm/kasan/common.c:634 __asan_report_load8_noabort+0x14/0x20 mm/kasan/generic_report.c:132 sl_sync drivers/net/slip/slip.c:725 [inline] slip_open+0xecd/0x11b7 drivers/net/slip/slip.c:801 tty_ldisc_open.isra.0+0xa3/0x110 drivers/tty/tty_ldisc.c:469 tty_set_ldisc+0x30e/0x6b0 drivers/tty/tty_ldisc.c:596 tiocsetd drivers/tty/tty_io.c:2334 [inline] tty_ioctl+0xe8d/0x14f0 drivers/tty/tty_io.c:2594 vfs_ioctl fs/ioctl.c:46 [inline] file_ioctl fs/ioctl.c:509 [inline] do_vfs_ioctl+0xdb6/0x13e0 fs/ioctl.c:696 ksys_ioctl+0xab/0xd0 fs/ioctl.c:713 __do_sys_ioctl fs/ioctl.c:720 [inline] __se_sys_ioctl fs/ioctl.c:718 [inline] __x64_sys_ioctl+0x73/0xb0 fs/ioctl.c:718 do_syscall_64+0xfa/0x760 arch/x86/entry/common.c:290 entry_SYSCALL_64_after_hwframe+0x49/0xbe  ,9ebd796e24008f33f06ebea5a5e6aceb68b51794,1
l2tp: fix tunnel lookup use-after-free race,"l2tp_tunnel_get walks the tunnel list to find a matching tunnel instance and if a match is found, its refcount is increased before returning the tunnel pointer. But when tunnel objects are destroyed, they are on the tunnel list after their refcount hits zero. Fix this by moving the code that removes the tunnel from the tunnel list from the tunnel socket destructor into in the l2tp_tunnel_delete path, before the tunnel refcount is decremented.  refcount_t: increment on 0; use-after-free. ",28f5bfb819195ad9c2eb9486babe7b0e4efe925f,1
"vdpa: Define vdpa mgmt device, ops and a netlink interface","To add one or more VDPA devices, define a management device which allows adding or removing vdpa device. A management device defines set of callbacks to manage vdpa devices.  To begin with, it defines add and remove callbacks through which a user defined vdpa device can be added or removed.  A unique management device is identified by its unique handle identified by management device name and optionally the bus name.  Hence, introduce routine through which driver can register a management device and its callback operations for adding and remove a vdpa device.  Introduce vdpa netlink socket family so that user can query management device and its attributes.  Example of show vdpa management device which allows creating vdpa device of networking class (device id = 0x1) of virtio specification 1.1 section 5.1.1.  $ vdpa mgmtdev show vdpasim_net:   supported_classes:     net  Example of showing vdpa management device in JSON format.  $ vdpa mgmtdev show -jp {     ""show"": {         ""vdpasim_net"": {             ""supported_classes"": ",33b347503f014ebf76257327cbc7001c6b721956,0
ptr_ring: wrap back ->producer in __ptr_ring_swap_queue(),"__ptr_ring_swap_queue() tries to move pointers from the old ring to the new one, but it forgets to check if ->producer is beyond the new size at the end of the operation. This leads to an out-of-bound access in __ptr_ring_produce() as reported by syzbot.  ",aff6db454599d62191aabc208930e891748e4322,1
crypto: hmac - require that the underlying hash algorithm is unkeyed,"Because the HMAC template didn't check that its underlying hash algorithm is unkeyed, trying to use ""hmac(hmac(sha3-512-generic))"" through AF_ALG or through KEYCTL_DH_COMPUTE resulted in the inner HMAC being used without having been keyed, resulting in sha3_update() being called without sha3_init(), causing a stack buffer overflow.  This is a very old bug, but it seems to have only started causing real problems when SHA-3 support was added (requires CONFIG_CRYPTO_SHA3) because the innermost hash's state is ->import()ed from a zeroed buffer, and it just so happens that other hash algorithms are fine with that, but SHA-3 is not.  However, there could be arch or hardware-dependent hash algorithms also affected; I couldn't test everything.  Fix the bug by introducing a function crypto_shash_alg_has_setkey() which tests whether a shash algorithm is keyed.  Then update the HMAC template to require that its underlying hash algorithm is unkeyed.  Here is a reproducer:      #include <linux/if_alg.h>     #include <sys/socket.h>      int main()     {         int algfd;         struct sockaddr_alg addr = {             .salg_type = ""hash"",             .salg_name = ""hmac(hmac(sha3-512-generic))"",         };         char key[4096] = { 0 };          algfd = socket(AF_ALG, SOCK_SEQPACKET, 0);         bind(algfd, (const struct sockaddr *)&addr, sizeof(addr));         setsockopt(algfd, SOL_ALG, ALG_SET_KEY, key, sizeof(key));     }  Here was the KASAN report from syzbot:      BUG: KASAN: stack-out-of-bounds in memcpy include/linux/string.h:341  [inline]     BUG: KASAN: stack-out-of-bounds in sha3_update+0xdf/0x2e0  crypto/sha3_generic.c:161     Write of size 4096 at addr ffff8801cca07c40 by task syzkaller076574/3044      CPU: 1 PID: 3044 Comm: syzkaller076574 Not tainted 4.14.0-mm1+ #25     Hardware name: Google Google Compute Engine/Google Compute Engine, BIOS  Google 01/01/2011     Call Trace:       __dump_stack lib/dump_stack.c:17 [inline]       dump_stack+0x194/0x257 lib/dump_stack.c:53       print_address_description+0x73/0x250 mm/kasan/report.c:252       kasan_report_error mm/kasan/report.c:351 [inline]       kasan_report+0x25b/0x340 mm/kasan/report.c:409       check_memory_region_inline mm/kasan/kasan.c:260 [inline]       check_memory_region+0x137/0x190 mm/kasan/kasan.c:267       memcpy+0x37/0x50 mm/kasan/kasan.c:303       memcpy include/linux/string.h:341 [inline]       sha3_update+0xdf/0x2e0 crypto/sha3_generic.c:161       crypto_shash_update+0xcb/0x220 crypto/shash.c:109       shash_finup_unaligned+0x2a/0x60 crypto/shash.c:151       crypto_shash_finup+0xc4/0x120 crypto/shash.c:165       hmac_finup+0x182/0x330 crypto/hmac.c:152       crypto_shash_finup+0xc4/0x120 crypto/shash.c:165       shash_digest_unaligned+0x9e/0xd0 crypto/shash.c:172       crypto_shash_digest+0xc4/0x120 crypto/shash.c:186       hmac_setkey+0x36a/0x690 crypto/hmac.c:66       crypto_shash_setkey+0xad/0x190 crypto/shash.c:64       shash_async_setkey+0x47/0x60 crypto/shash.c:207       crypto_ahash_setkey+0xaf/0x180 crypto/ahash.c:200       hash_setkey+0x40/0x90 crypto/algif_hash.c:446       alg_setkey crypto/af_alg.c:221 [inline]       alg_setsockopt+0x2a1/0x350 crypto/af_alg.c:254       SYSC_setsockopt net/socket.c:1851 [inline]       SyS_setsockopt+0x189/0x360 net/socket.c:1830       entry_SYSCALL_64_fastpath+0x1f/0x96  ",af3ff8045bbf3e32f1a448542e73abb4c8ceb6f1,1
net: sched: sch_sfb: don't call qdisc_put() while holding tree lock,"Recent changes that removed rtnl dependency from rules update path of tc also made tcf_block_put() function sleeping. This function is called from ops->destroy() of several Qdisc implementations, which in turn is called by qdisc_put(). Some Qdiscs call qdisc_put() while holding sch tree spinlock, which results sleeping-while-atomic BUG.  Steps to reproduce for sfb:  tc qdisc add dev ens1f0 handle 1: root sfb tc qdisc add dev ens1f0 parent 1:10 handle 50: sfq perturb 10 tc qdisc change dev ens1f0 root handle 1: sfb  Resulting dmesg:  ",e3ae1f96accd21405715fe9c56b4d83bc7d96d44,1
x86_64: increase stack size for KASAN_EXTRA,"If the kernel is configured with KASAN_EXTRA, the stack size is increasted significantly because this option sets ""-fstack-reuse"" to ""none"" in GCC [1].  As a result, it triggers stack overrun quite often with 32k stack size compiled using GCC 8.  For example, this reproducer    https://github.com/linux-test-project/ltp/blob/master/testcases/kernel/syscalls/madvise/madvise06.c  triggers a ""corrupted stack end detected inside scheduler"" very reliably with CONFIG_SCHED_STACK_END_CHECK enabled.  There are just too many functions that could have a large stack with KASAN_EXTRA due to large local variables that have been called over and over again without being able to reuse the stacks.  Some noticiable ones are    size   7648 shrink_page_list   3584 xfs_rmap_convert   3312 migrate_page_move_mapping   3312 dev_ethtool   3200 migrate_misplaced_transhuge_page   3168 copy_process  There are other 49 functions are over 2k in size while compiling kernel with ""-Wframe-larger-than="" even with a related minimal config on this machine.  Hence, it is too much work to change Makefiles for each object to compile without ""-fsanitize-address-use-after-scope"" individually.  [1] https://gcc.gnu.org/bugzilla/show_bug.cgi?id=81715#c23  Although there is a patch in GCC 9 to help the situation, GCC 9 probably won't be released in a few months and then it probably take another 6-month to 1-year for all major distros to include it as a default. Hence, the stack usage with KASAN_EXTRA can be revisited again in 2020 when GCC 9 is everywhere.  Until then, this patch will help users avoid stack overrun.  This has already been fixed for arm64 for the same reason via 6e8830674ea (""arm64: kasan: Increase stack size for KASAN_EXTRA"").  ",a8e911d13540487942d53137c156bd7707f66e5d,1
net/smc: fix refcount non-blocking connect() -part 2,"If an SMC socket is immediately terminated after a non-blocking connect() has been called, a memory leak is possible. Due to the sock_hold move in commit 301428ea3708 (""net/smc: fix refcounting for non-blocking connect()"") an extra sock_put() is needed in smc_connect_work(), if the internal TCP socket is aborted and cancels the sk_stream_wait_connect() of the connect worker.  ",6d6dd528d5af05dc2d0c773951ed68d630a0c3f1,1
crypto: drbg - set freed buffers to NULL,"During freeing of the internal buffers used by the DRBG, set the pointer to NULL. It is possible that the context with the freed buffers is reused. In case of an error during initialization where the pointers do not yet point to allocated memory, the NULL value prevents a double free.  ",eea0d3ea7546961f69f55b26714ac8fd71c7c020,1
ipv6: take rcu lock in rawv6_send_hdrinc(),"In rawv6_send_hdrinc(), in order to avoid an extra dst_hold(), we directly assign the dst to skb and set passed in dst to NULL to avoid double free. However, in error case, we free skb and then do stats update with the dst pointer passed in. This causes use-after-free on the dst. Fix it by taking rcu read lock right before dst could get released to make sure dst does not get freed until the stats update is done. Note: we don't have this issue in ipv4 cause dst is not used for stats update in v4.  Syzkaller reported following crash: BUG: KASAN: use-after-free in rawv6_send_hdrinc net/ipv6/raw.c:692 [inline] BUG: KASAN: use-after-free in rawv6_sendmsg+0x4421/0x4630 net/ipv6/raw.c:921 Read of size 8 at addr ffff8801d95ba730 by task syz-executor0/32088  CPU: 1 PID: 32088 Comm: syz-executor0 Not tainted 4.19.0-rc2+ #93 Hardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 01/01/2011 Call Trace:  __dump_stack lib/dump_stack.c:77 [inline]  dump_stack+0x1c4/0x2b4 lib/dump_stack.c:113  print_address_description.cold.8+0x9/0x1ff mm/kasan/report.c:256  kasan_report_error mm/kasan/report.c:354 [inline]  kasan_report.cold.9+0x242/0x309 mm/kasan/report.c:412  __asan_report_load8_noabort+0x14/0x20 mm/kasan/report.c:433  rawv6_send_hdrinc net/ipv6/raw.c:692 [inline]  rawv6_sendmsg+0x4421/0x4630 net/ipv6/raw.c:921  inet_sendmsg+0x1a1/0x690 net/ipv4/af_inet.c:798  sock_sendmsg_nosec net/socket.c:621 [inline]  sock_sendmsg+0xd5/0x120 net/socket.c:631  ___sys_sendmsg+0x7fd/0x930 net/socket.c:2114  __sys_sendmsg+0x11d/0x280 net/socket.c:2152  __do_sys_sendmsg net/socket.c:2161 [inline]  __se_sys_sendmsg net/socket.c:2159 [inline]  __x64_sys_sendmsg+0x78/0xb0 net/socket.c:2159  do_syscall_64+0x1b9/0x820 arch/x86/entry/common.c:290  entry_SYSCALL_64_after_hwframe+0x49/0xbe ",a688caa34beb2fd2a92f1b6d33e40cde433ba160,1
fuse: Fix oops at process_init_reply(),syzbot is hitting NULL pointer dereference at process_init_reply(). This is because deactivate_locked_super() is called before response for initial request is processed.  Fix this by aborting and waiting for all requests (including FUSE_INIT) before resetting fc->sb.  Original patch by Tetsuo Handa <penguin-kernel@I-love.SKAURA.ne.jp>.  ,e8f3bd773d22f488724dffb886a1618da85c2966,1
drm: Require __GFP_NOFAIL for the legacy drm_modeset_lock_all,"To acquire all modeset locks requires a ww_ctx to be allocated. As this is the legacy path and the allocation small, to reduce the changes required (and complex untested error handling) to the legacy drivers, we simply assume that the allocation succeeds. At present, it relies on the too-small-to-fail rule, but syzbot found that by injecting a failure here we would hit the WARN. Document that this allocation must succeed with __GFP_NOFAIL.  ",d18d1a5ac811d12f7ebc1129230312b5f2c50cb8,1
xfs: don't iunlock the quota ip when quota block,"In xfs_qm_dqalloc, we join the locked quota inode to the transaction we use to allocate blocks.  If the allocation or mapping fails, we're not allowed to unlock the inode because the transaction code is in charge of unlocking it for us.  Therefore, remove the iunlock call to avoid blowing asserts about unbalanced locking + mount hang.  Found by corrupting the AGF and allocating space in the filesystem (quotacheck) immediately after mount.  The upcoming agfl wrapping fixup test will trigger this scenario.  ",8241f7f983b972823431d762f7c3c9fe0f2a7b00,0
ALSA: pcm: Remove incorrect snd_BUG_ON() usages,syzkaller triggered kernel warnings through PCM OSS emulation at closing a stream:   ,fe08f34d066f4404934a509b6806db1a4f700c86,1
net: openvswitch: silence suspicious RCU usage warning,"Silence suspicious RCU usage warning in ovs_flow_tbl_masks_cache_resize() by replacing rcu_dereference() with rcu_dereference_ovsl().  In addition, when creating a new datapath, make sure it's configured under the ovs_lock.  ",fea07a487c6dd422dc8837237c9d2bc7c33119af,1
net/ipv6: add rcu locking to ip6_negative_advice,syzbot reported a suspicious rcu_dereference_check:   __dump_stack lib/dump_stack.c:77 [inline]   dump_stack+0x1b9/0x294 lib/dump_stack.c:113   lockdep_rcu_suspicious+0x14a/0x153 kernel/locking/lockdep.c:4592   rt6_check_expired+0x38b/0x3e0 net/ipv6/route.c:410   ip6_negative_advice+0x67/0xc0 net/ipv6/route.c:2204   dst_negative_advice include/net/sock.h:1786 [inline]   sock_setsockopt+0x138f/0x1fe0 net/core/sock.c:1051   __sys_setsockopt+0x2df/0x390 net/socket.c:1899   SYSC_setsockopt net/socket.c:1914 [inline]   SyS_setsockopt+0x34/0x50 net/socket.c:1911  Add rcu locking around call to rt6_check_expired in ip6_negative_advice.  ,c3c14da0288de79ccef2c2380cf5737077fa64ed,1
ALSA: timer: Limit max instances per timer,"Currently we allow unlimited number of timer instances, and it may bring the system hogging way too much CPU when too many timer instances are opened and processed concurrently.  This may end up with a soft-lockup report as triggered by syzkaller, especially when hrtimer backend is deployed.  Since such insane number of instances aren't demanded by the normal use case of ALSA sequencer and it merely  opens a risk only for abuse, this patch introduces the upper limit for the number of instances per timer backend.  As default, it's set to 1000, but for the fine-grained timer like hrtimer, it's set to 100.  ",9b7d869ee5a77ed4a462372bb89af622e705bfb8,1
net/tls: fix sk_msg trim on fallback to copy mode,"sk_msg_trim() tries to only update curr pointer if it falls into the trimmed region. The logic, however, does not take into the account pointer wrapping that sk_msg_iter_var_prev() does nor (as John points out) the fact that msg->sg is a ring buffer.  This means that when the message was trimmed completely, the new curr pointer would have the value of MAX_MSG_FRAGS - 1, which is neither smaller than any other value, nor would it actually be correct.  Special case the trimming to 0 length a little bit and rework the comparison between curr and end to take into account wrapping.  This bug caused the TLS code to not copy all of the message, if zero copy filled in fewer sg entries than memcopy would need.  Big thanks to Alexander Potapenko for the non-KMSAN reproducer.  v2:  - take into account that msg->sg is a ring buffer (John).   ",683916f6a84023407761d843048f1aea486b2612,0
rxrpc: Fix race between recvmsg and sendmsg on immediate call failure,"There's a race between rxrpc_sendmsg setting up a call, but then failing to send anything on it due to an error, and recvmsg() seeing the call completion occur and trying to return the state to the user.  An assertion fails in rxrpc_recvmsg() because the call has already been released from the socket and is about to be released again as recvmsg deals with it.  (The recvmsg_q queue on the socket holds a ref, so there's no problem with use-after-free.)  We also have to be careful not to end up reporting an error twice, in such a way that both returns indicate to userspace that the user ID supplied with the call is no longer in use - which could cause the client to malfunction if it recycles the user ID fast enough.  Fix this by the following means:   (1) When sendmsg() creates a call after the point that the call has been      successfully added to the socket, don't return any errors through      sendmsg(), but rather complete the call and let recvmsg() retrieve      them.  Make sendmsg() return 0 at this point.  Further calls to      sendmsg() for that call will fail with ESHUTDOWN.       Note that at this point, we haven't send any packets yet, so the      server doesn't yet know about the call.   (2) If sendmsg() returns an error when it was expected to create a new      call, it means that the user ID wasn't used.   (3) Mark the call disconnected before marking it completed to prevent an      oops in rxrpc_release_call().   (4) recvmsg() will then retrieve the error and set MSG_EOR to indicate      that the user ID is no longer known by the kernel.  An oops like the following is produced:  	kernel BUG at net/rxrpc/recvmsg.c:605! 	... 	",65550098c1c4db528400c73acf3e46bfa78d9264,1
tcp: fix data-race in tcp_recvmsg(),"Reading tp->recvmsg_inq after socket lock is released raises a KCSAN warning [1]  Replace has_tss & has_cmsg by cmsg_flags and make sure to not read tp->recvmsg_inq a second time.  [1] BUG: KCSAN: data-race in tcp_chrono_stop / tcp_recvmsg  write to 0xffff888126adef24 of 2 bytes by interrupt on cpu 0:  tcp_chrono_set net/ipv4/tcp_output.c:2309 [inline]  tcp_chrono_stop+0x14c/0x280 net/ipv4/tcp_output.c:2338  tcp_clean_rtx_queue net/ipv4/tcp_input.c:3165 [inline]  tcp_ack+0x274f/0x3170 net/ipv4/tcp_input.c:3688  tcp_rcv_established+0x37e/0xf50 net/ipv4/tcp_input.c:5696  tcp_v4_do_rcv+0x381/0x4e0 net/ipv4/tcp_ipv4.c:1561  tcp_v4_rcv+0x19dc/0x1bb0 net/ipv4/tcp_ipv4.c:1942  ip_protocol_deliver_rcu+0x4d/0x420 net/ipv4/ip_input.c:204  ip_local_deliver_finish+0x110/0x140 net/ipv4/ip_input.c:231  NF_HOOK include/linux/netfilter.h:305 [inline]  NF_HOOK include/linux/netfilter.h:299 [inline]  ip_local_deliver+0x133/0x210 net/ipv4/ip_input.c:252  dst_input include/net/dst.h:442 [inline]  ip_rcv_finish+0x121/0x160 net/ipv4/ip_input.c:413  NF_HOOK include/linux/netfilter.h:305 [inline]  NF_HOOK include/linux/netfilter.h:299 [inline]  ip_rcv+0x18f/0x1a0 net/ipv4/ip_input.c:523  __netif_receive_skb_one_core+0xa7/0xe0 net/core/dev.c:5010  __netif_receive_skb+0x37/0xf0 net/core/dev.c:5124  netif_receive_skb_internal+0x59/0x190 net/core/dev.c:5214  napi_skb_finish net/core/dev.c:5677 [inline]  napi_gro_receive+0x28f/0x330 net/core/dev.c:5710  read to 0xffff888126adef25 of 1 bytes by task 7275 on cpu 1:  tcp_recvmsg+0x77b/0x1a30 net/ipv4/tcp.c:2187  inet_recvmsg+0xbb/0x250 net/ipv4/af_inet.c:838  sock_recvmsg_nosec net/socket.c:871 [inline]  sock_recvmsg net/socket.c:889 [inline]  sock_recvmsg+0x92/0xb0 net/socket.c:885  sock_read_iter+0x15f/0x1e0 net/socket.c:967  call_read_iter include/linux/fs.h:1889 [inline]  new_sync_read+0x389/0x4f0 fs/read_write.c:414  __vfs_read+0xb1/0xc0 fs/read_write.c:427  vfs_read fs/read_write.c:461 [inline]  vfs_read+0x143/0x2c0 fs/read_write.c:446  ksys_read+0xd5/0x1b0 fs/read_write.c:587  __do_sys_read fs/read_write.c:597 [inline]  __se_sys_read fs/read_write.c:595 [inline]  __x64_sys_read+0x4c/0x60 fs/read_write.c:595  do_syscall_64+0xcc/0x370 arch/x86/entry/common.c:290  entry_SYSCALL_64_after_hwframe+0x44/0xa9  Reported by Kernel Concurrency Sanitizer on: CPU: 1 PID: 7275 Comm: sshd Not tainted 5.4.0-rc3+ #0 Hardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 01/01/2011  ",a5a7daa52edb5197a3b696afee13ef174dc2e993,1
ext4: validate the debug_want_extra_isize mount option at parse time,"Instead of setting s_want_extra_size and then making sure that it is a valid value afterwards, validate the field before we set it.  This avoids races and other problems when remounting the file system.  ",9803387c55f7d2ce69aa64340c5fdc6b3027dbc8,1
ALSA: seq: Avoid concurrent access to queue flags,"The queue flags are represented in bit fields and the concurrent access may result in unexpected results.  Although the current code should be mostly OK as it's only reading a field while writing other fields as KCSAN reported, it's safer to cover both with a proper spinlock protection.  This patch fixes the possible concurrent read by protecting with q->owner_lock.  Also the queue owner field is protected as well since it's the field to be protected by the lock itself.  ",bb51e669fa49feb5904f452b2991b240ef31bc97,0
KVM: x86: hyper-v: Fix Hyper-V context null-ptr-deref,Reported by syzkaller:      KASAN: null-ptr-deref in range [0x0000000000000140-0x0000000000000147]     CPU: 1 PID: 8370 Comm: syz-executor859 Not tainted 5.11.0-syzkaller #0     ,919f4ebc598701670e80e31573a58f1f2d2bf918,1
net: add and use skb_unclone_keeptruesize() helper,"While commit 097b9146c0e2 (""net: fix up truesize of cloned skb in skb_prepare_for_shift()"") fixed immediate issues found when KFENCE was enabled/tested, there are still similar issues, when tcp_trim_head() hits KFENCE while the master skb is cloned.  This happens under heavy networking TX workloads, when the TX completion might be delayed after incoming ACK.  This patch fixes the ",c4777efa751d293e369aec464ce6875e957be255,0
ceph: canonicalize server path in place,"syzbot reported that 4fbc0c711b24 (""ceph: remove the extra slashes in the server path"") had caused a regression where an allocation could be done under a spinlock -- compare_mount_options() is called by sget_fc() with sb_lock held.  We don't really need the supplied server path, so canonicalize it in place and compare it directly.  To make this work, the leading slash is kept around and the logic in ceph_real_mount() to skip it is restored.  CEPH_MSG_CLIENT_SESSION now reports the same (i.e. canonicalized) path, with the leading slash of course.  ",b27a939e8376a3f1ed09b9c33ef44d20f18ec3d0,0
bpf: Extend BTF_ID_LIST_GLOBAL with parameter for number of IDs,"syzbot reported the following BUG w/o CONFIG_DEBUG_INFO_BTF  BUG: KASAN: global-out-of-bounds in task_iter_init+0x212/0x2e7 kernel/bpf/task_iter.c:661 Read of size 4 at addr ffffffff90297404 by task swapper/0/1  CPU: 1 PID: 1 Comm: swapper/0 Not tainted 5.15.0-syzkaller #0 Hardware name: ... Google Compute Engine, BIOS Google 01/01/2011 Call Trace: <TASK> __dump_stack lib/dump_stack.c:88 [inline] dump_stack_lvl+0xcd/0x134 lib/dump_stack.c:106 print_address_description.constprop.0.cold+0xf/0x309 mm/kasan/report.c:256 __kasan_report mm/kasan/report.c:442 [inline] kasan_report.cold+0x83/0xdf mm/kasan/report.c:459 task_iter_init+0x212/0x2e7 kernel/bpf/task_iter.c:661 do_one_initcall+0x103/0x650 init/main.c:1295 do_initcall_level init/main.c:1368 [inline] do_initcalls init/main.c:1384 [inline] do_basic_setup init/main.c:1403 [inline] kernel_init_freeable+0x6b1/0x73a init/main.c:1606 kernel_init+0x1a/0x1d0 init/main.c:1497 ret_from_fork+0x1f/0x30 arch/x86/entry/entry_64.S:295 </TASK>  This is caused by hard-coded name[1] in BTF_ID_LIST_GLOBAL (w/o CONFIG_DEBUG_INFO_BTF). Fix this by adding a parameter n to BTF_ID_LIST_GLOBAL. This avoids ifdef CONFIG_DEBUG_INFO_BTF in btf.c and filter.c.  ",9e2ad638ae3632ef916ceb39f70e3104bf8fdc97,1
bpf: Avoid overflows involving hash elem_size,"Use of bpf_map_charge_init() was making sure hash tables would not use more than 4GB of memory.  Since the implicit check disappeared, we have to be more careful about overflows, to support big hash tables.  syzbot triggers a panic using :  bpf(BPF_MAP_CREATE, {map_type=BPF_MAP_TYPE_LRU_HASH, key_size=16384, value_size=8,                      max_entries=262200, map_flags=0, inner_map_fd=-1, map_name="""",                      map_ifindex=0, btf_fd=-1, btf_key_type_id=0, btf_value_type_id=0,                      btf_vmlinux_value_type_id=0}, 64) = ...  BUG: KASAN: vmalloc-out-of-bounds in bpf_percpu_lru_populate kernel/bpf/bpf_lru_list.c:594 [inline] BUG: KASAN: vmalloc-out-of-bounds in bpf_lru_populate+0x4ef/0x5e0 kernel/bpf/bpf_lru_list.c:611 Write of size 2 at addr ffffc90017e4a020 by task syz-executor.5/19786  CPU: 0 PID: 19786 Comm: syz-executor.5 Not tainted 5.10.0-rc3-syzkaller #0 Hardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 01/01/2011 Call Trace:  __dump_stack lib/dump_stack.c:77 [inline]  dump_stack+0x107/0x163 lib/dump_stack.c:118  print_address_description.constprop.0.cold+0x5/0x4c8 mm/kasan/report.c:385  __kasan_report mm/kasan/report.c:545 [inline]  kasan_report.cold+0x1f/0x37 mm/kasan/report.c:562  bpf_percpu_lru_populate kernel/bpf/bpf_lru_list.c:594 [inline]  bpf_lru_populate+0x4ef/0x5e0 kernel/bpf/bpf_lru_list.c:611  prealloc_init kernel/bpf/hashtab.c:319 [inline]  htab_map_alloc+0xf6e/0x1230 kernel/bpf/hashtab.c:507  find_and_alloc_map kernel/bpf/syscall.c:123 [inline]  map_create kernel/bpf/syscall.c:829 [inline]  __do_sys_bpf+0xa81/0x5170 kernel/bpf/syscall.c:4336  do_syscall_64+0x2d/0x70 arch/x86/entry/common.c:46  entry_SYSCALL_64_after_hwframe+0x44/0xa9 ",e1868b9e36d0ca52e4e7c6c06953f191446e44df,1
net: sched: fix uses after free,"syzbot reported one use-after-free in pfifo_fast_enqueue() [1]  Issue here is that we can not reuse skb after a successful skb_array_produce() since another cpu might have consumed it already.  I believe a similar problem exists in try_bulk_dequeue_skb_slow() in case we put an skb into qdisc_enqueue_skb_bad_txq() for lockless qdisc.  [1] BUG: KASAN: use-after-free in qdisc_pkt_len include/net/sch_generic.h:610 [inline] BUG: KASAN: use-after-free in qdisc_qstats_cpu_backlog_inc include/net/sch_generic.h:712 [inline] BUG: KASAN: use-after-free in pfifo_fast_enqueue+0x4bc/0x5e0 net/sched/sch_generic.c:639 Read of size 4 at addr ffff8801cede37e8 by task syzkaller717588/5543  CPU: 1 PID: 5543 Comm: syzkaller717588 Not tainted 4.16.0-rc4+ #265 Hardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 01/01/2011 Call Trace:  __dump_stack lib/dump_stack.c:17 [inline]  dump_stack+0x194/0x24d lib/dump_stack.c:53  print_address_description+0x73/0x250 mm/kasan/report.c:256  kasan_report_error mm/kasan/report.c:354 [inline]  kasan_report+0x23c/0x360 mm/kasan/report.c:412  __asan_report_load4_noabort+0x14/0x20 mm/kasan/report.c:432  qdisc_pkt_len include/net/sch_generic.h:610 [inline]  qdisc_qstats_cpu_backlog_inc include/net/sch_generic.h:712 [inline]  pfifo_fast_enqueue+0x4bc/0x5e0 net/sched/sch_generic.c:639  __dev_xmit_skb net/core/dev.c:3216 [inline]  ",cce6294cc2eaa083482e1d85d8db5845c82a7e14,1
net: ipv6: fix listify ip6_rcv_finish in case of forwarding,"We need a similar fix for ipv6 as Commit 0761680d5215 (""net: ipv4: fix listify ip_rcv_finish in case of forwarding"") does for ipv4.  This issue can be reprocuded by syzbot since Commit 323ebb61e32b (""net: use listified RX for handling GRO_NORMAL skbs"") on net-next. The call trace was:    kernel BUG at include/linux/skbuff.h:2225!   ",c7a42eb49212f93a800560662d17d5293960d3c3,1
ipv6: restrict IPV6_ADDRFORM operation,"IPV6_ADDRFORM is able to transform IPv6 socket to IPv4 one. While this operation sounds illogical, we have to support it.  One of the things it does for TCP socket is to switch sk->sk_prot to tcp_prot.  We now have other layers playing with sk->sk_prot, so we should make sure to not interfere with them.  This patch makes sure sk_prot is the default pointer for TCP IPv6 socket.  syzbot reported : BUG: kernel NULL pointer dereference, ",b6f6118901d1e867ac9177bbff3b00b185bd4fdc,1
ALSA: seq: Fix race of get-subscription call vs port-delete ioctls,"The snd_seq_ioctl_get_subscription() retrieves the port subscriber information as a pointer, while the object isn't protected, hence it may be deleted before the actual reference.  This race was spotted by syzkaller and may lead to a UAF.  The fix is simply copying the data in the lookup function that performs in the rwsem to protect against the deletion.  ",2eabc5ec8ab4d4748a82050dfcb994119b983750,1
net: tun: set tun->dev->addr_len during TUNSETLINK processing,"When changing type with TUNSETLINK ioctl command, set tun->dev->addr_len to match the appropriate type, using new tun_get_addr_len utility function which returns appropriate address length for given type. Fixes a KMSAN-found uninit-value bug reported by syzbot at: https://syzkaller.appspot.com/bug?id=0766d38c656abeace60621896d705743aeefed51  ",cca8ea3b05c972ffb5295367e6c544369b45fbdd,1
geneve: pull IP header before ECN decapsulation,"IP_ECN_decapsulate() and IP6_ECN_decapsulate() assume IP header is already pulled.  geneve does not ensure this yet.  Fixing this generically in IP_ECN_decapsulate() and IP6_ECN_decapsulate() is not possible, since callers pass a pointer that might be freed by pskb_may_pull()  syzbot reported :  BUG: KMSAN: uninit-value in __INET_ECN_decapsulate include/net/inet_ecn.h:238 [inline] BUG: KMSAN: uninit-value in INET_ECN_decapsulate+0x345/0x1db0 include/net/inet_ecn.h:260 CPU: 1 PID: 8941 Comm: syz-executor.0 Not tainted 5.10.0-rc4-syzkaller #0 Hardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 01/01/2011 Call Trace:  <IRQ>  __dump_stack lib/dump_stack.c:77 [inline]  dump_stack+0x21c/0x280 lib/dump_stack.c:118  kmsan_report+0xf7/0x1e0 mm/kmsan/kmsan_report.c:118  __msan_warning+0x5f/0xa0 mm/kmsan/kmsan_instr.c:197  __INET_ECN_decapsulate include/net/inet_ecn.h:238 [inline]  INET_ECN_decapsulate+0x345/0x1db0 include/net/inet_ecn.h:260  geneve_rx+0x2103/0x2980 include/net/inet_ecn.h:306  geneve_udp_encap_recv+0x105c/0x1340 drivers/net/geneve.c:377  udp_queue_rcv_one_skb+0x193a/0x1af0 net/ipv4/udp.c:2093  udp_queue_rcv_skb+0x282/0x1050 net/ipv4/udp.c:2167  udp_unicast_rcv_skb net/ipv4/udp.c:2325 [inline]  __udp4_lib_rcv+0x399d/0x5880 net/ipv4/udp.c:2394  udp_rcv+0x5c/0x70 net/ipv4/udp.c:2564  ip_protocol_deliver_rcu+0x572/0xc50 net/ipv4/ip_input.c:204  ip_local_deliver_finish net/ipv4/ip_input.c:231 [inline]  NF_HOOK include/linux/netfilter.h:301 [inline]  ip_local_deliver+0x583/0x8d0 net/ipv4/ip_input.c:252  dst_input include/net/dst.h:449 [inline]  ip_rcv_finish net/ipv4/ip_input.c:428 [inline]  NF_HOOK include/linux/netfilter.h:301 [inline]  ip_rcv+0x5c3/0x840 net/ipv4/ip_input.c:539  __netif_receive_skb_one_core net/core/dev.c:5315 [inline]  __netif_receive_skb+0x1ec/0x640 net/core/dev.c:5429  process_backlog+0x523/0xc10 net/core/dev.c:6319  napi_poll+0x420/0x1010 net/core/dev.c:6763  net_rx_action+0x35c/0xd40 net/core/dev.c:6833  __do_softirq+0x1a9/0x6fa kernel/softirq.c:298  asm_call_irq_on_stack+0xf/0x20  </IRQ>  __run_on_irqstack arch/x86/include/asm/irq_stack.h:26 [inline]  run_on_irqstack_cond arch/x86/include/asm/irq_stack.h:77 [inline]  do_softirq_own_stack+0x6e/0x90 arch/x86/kernel/irq_64.c:77  do_softirq kernel/softirq.c:343 [inline]  __local_bh_enable_ip+0x184/0x1d0 kernel/softirq.c:195  local_bh_enable+0x36/0x40 include/linux/bottom_half.h:32  rcu_read_unlock_bh include/linux/rcupdate.h:730 [inline]  __dev_queue_xmit+0x3a9b/0x4520 net/core/dev.c:4167  dev_queue_xmit+0x4b/0x60 net/core/dev.c:4173  packet_snd net/packet/af_packet.c:2992 [inline]  packet_sendmsg+0x86f9/0x99d0 net/packet/af_packet.c:3017  sock_sendmsg_nosec net/socket.c:651 [inline]  sock_sendmsg net/socket.c:671 [inline]  __sys_sendto+0x9dc/0xc80 net/socket.c:1992  __do_sys_sendto net/socket.c:2004 [inline]  __se_sys_sendto+0x107/0x130 net/socket.c:2000  __x64_sys_sendto+0x6e/0x90 net/socket.c:2000  do_syscall_64+0x9f/0x140 arch/x86/entry/common.c:48  entry_SYSCALL_64_after_hwframe+0x44/0xa9  ",4179b00c04d18ea7013f68d578d80f3c9d13150a,1
block/scsi-ioctl: Fix kernel-infoleak in scsi_put_cdrom_generic_arg(),"scsi_put_cdrom_generic_arg() is copying uninitialized stack memory to userspace, since the compiler may leave a 3-byte hole in the middle of `cgc32`. Fix it by adding a padding field to `struct compat_cdrom_generic_command`.  ",6d53a9fe5a1983490bc14b3a64d49fabb4ccc651,1
KVM: vmx: use local variable for current_vmptr when emulating VMPTRST,"Do not expose the address of vmx->nested.current_vmptr to kvm_write_guest_virt_system() as the resulting __copy_to_user() call will trigger a WARN when CONFIG_HARDENED_USERCOPY is enabled.  Opportunistically clean up variable names in handle_vmptrst() to improve readability, e.g. vmcs_gva is misleading as the memory operand of VMPTRST is plain memory, not a VMCS.  ",0a06d4256674c4e041945b52044941995fee237d,0
sctp: do not leak kernel memory to user space,"syzbot produced a nice report [1]  Issue here is that a recvmmsg() managed to leak 8 bytes of kernel memory to user space, because sin_zero (padding field) was not properly cleared.  [1] BUG: KMSAN: uninit-value in copy_to_user include/linux/uaccess.h:184 [inline] BUG: KMSAN: uninit-value in move_addr_to_user+0x32e/0x530 net/socket.c:227 CPU: 1 PID: 3586 Comm: syzkaller481044 Not tainted 4.16.0+ #82 Hardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 01/01/2011 Call Trace:  __dump_stack lib/dump_stack.c:17 [inline]  dump_stack+0x185/0x1d0 lib/dump_stack.c:53  kmsan_report+0x142/0x240 mm/kmsan/kmsan.c:1067  kmsan_internal_check_memory+0x164/0x1d0 mm/kmsan/kmsan.c:1176  kmsan_copy_to_user+0x69/0x160 mm/kmsan/kmsan.c:1199  copy_to_user include/linux/uaccess.h:184 [inline]  move_addr_to_user+0x32e/0x530 net/socket.c:227  ___sys_recvmsg+0x4e2/0x810 net/socket.c:2211  __sys_recvmmsg+0x54e/0xdb0 net/socket.c:2313  SYSC_recvmmsg+0x29b/0x3e0 net/socket.c:2394  SyS_recvmmsg+0x76/0xa0 net/socket.c:2378  do_syscall_64+0x309/0x430 arch/x86/entry/common.c:287  entry_SYSCALL_64_after_hwframe+0x3d/0xa2 ",6780db244d6b1537d139dea0ec8aad10cf9e4adb,1
f2fs: fix shift-out-of-bounds in sanity_check_raw_super(),"syzbot reported a bug which could cause shift-out-of-bounds issue, fix it.  Call Trace:  __dump_stack lib/dump_stack.c:79 [inline]  dump_stack+0x107/0x163 lib/dump_stack.c:120  ubsan_epilogue+0xb/0x5a lib/ubsan.c:148  __ubsan_handle_shift_out_of_bounds.cold+0xb1/0x181 lib/ubsan.c:395  sanity_check_raw_super fs/f2fs/super.c:2812 [inline]  read_raw_super_block fs/f2fs/super.c:3267 [inline]  f2fs_fill_super.cold+0x16c9/0x16f6 fs/f2fs/super.c:3519  mount_bdev+0x34d/0x410 fs/super.c:1366  legacy_get_tree+0x105/0x220 fs/fs_context.c:592  vfs_get_tree+0x89/0x2f0 fs/super.c:1496  do_new_mount fs/namespace.c:2896 [inline]  path_mount+0x12ae/0x1e70 fs/namespace.c:3227  do_mount fs/namespace.c:3240 [inline]  __do_sys_mount fs/namespace.c:3448 [inline]  __se_sys_mount fs/namespace.c:3425 [inline]  __x64_sys_mount+0x27f/0x300 fs/namespace.c:3425  do_syscall_64+0x2d/0x70 arch/x86/entry/common.c:46  entry_SYSCALL_64_after_hwframe+0x44/0xa9  ",e584bbe821229a3e7cc409eecd51df66f9268c21,1
bpf: Fix a potential deadlock with bpf_map_do_batch,"Commit 057996380a42 (""bpf: Add batch ops to all htab bpf map"") added lookup_and_delete batch operation for hash table. The current implementation has bpf_lru_push_free() inside the bucket lock, which may cause a deadlock.  syzbot reports:    -> #2 (&htab->buckets[i].lock#2){....}:        __raw_spin_lock_irqsave include/linux/spinlock_api_smp.h:110 [inline]        _raw_spin_lock_irqsave+0x95/0xcd kernel/locking/spinlock.c:159        htab_lru_map_delete_node+0xce/0x2f0 kernel/bpf/hashtab.c:593        __bpf_lru_list_shrink_inactive kernel/bpf/bpf_lru_list.c:220 [inline]        __bpf_lru_list_shrink+0xf9/0x470 kernel/bpf/bpf_lru_list.c:266        bpf_lru_list_pop_free_to_local kernel/bpf/bpf_lru_list.c:340 [inline]        bpf_common_lru_pop_free kernel/bpf/bpf_lru_list.c:447 [inline]        bpf_lru_pop_free+0x87c/0x1670 kernel/bpf/bpf_lru_list.c:499        prealloc_lru_pop+0x2c/0xa0 kernel/bpf/hashtab.c:132        __htab_lru_percpu_map_update_elem+0x67e/0xa90 kernel/bpf/hashtab.c:1069        bpf_percpu_hash_update+0x16e/0x210 kernel/bpf/hashtab.c:1585        bpf_map_update_value.isra.0+0x2d7/0x8e0 kernel/bpf/syscall.c:181        generic_map_update_batch+0x41f/0x610 kernel/bpf/syscall.c:1319        bpf_map_do_batch+0x3f5/0x510 kernel/bpf/syscall.c:3348        __do_sys_bpf+0x9b7/0x41e0 kernel/bpf/syscall.c:3460        __se_sys_bpf kernel/bpf/syscall.c:3355 [inline]        __x64_sys_bpf+0x73/0xb0 kernel/bpf/syscall.c:3355        do_syscall_64+0xfa/0x790 arch/x86/entry/common.c:294        entry_SYSCALL_64_after_hwframe+0x49/0xbe     -> #0 (&loc_l->lock){....}:        check_prev_add kernel/locking/lockdep.c:2475 [inline]        check_prevs_add kernel/locking/lockdep.c:2580 [inline]        validate_chain kernel/locking/lockdep.c:2970 [inline]        __lock_acquire+0x2596/0x4a00 kernel/locking/lockdep.c:3954        lock_acquire+0x190/0x410 kernel/locking/lockdep.c:4484        __raw_spin_lock_irqsave include/linux/spinlock_api_smp.h:110 [inline]        _raw_spin_lock_irqsave+0x95/0xcd kernel/locking/spinlock.c:159        bpf_common_lru_push_free kernel/bpf/bpf_lru_list.c:516 [inline]        bpf_lru_push_free+0x250/0x5b0 kernel/bpf/bpf_lru_list.c:555        __htab_map_lookup_and_delete_batch+0x8d4/0x1540 kernel/bpf/hashtab.c:1374        htab_lru_map_lookup_and_delete_batch+0x34/0x40 kernel/bpf/hashtab.c:1491        bpf_map_do_batch+0x3f5/0x510 kernel/bpf/syscall.c:3348        __do_sys_bpf+0x1f7d/0x41e0 kernel/bpf/syscall.c:3456        __se_sys_bpf kernel/bpf/syscall.c:3355 [inline]        __x64_sys_bpf+0x73/0xb0 kernel/bpf/syscall.c:3355        do_syscall_64+0xfa/0x790 arch/x86/entry/common.c:294        entry_SYSCALL_64_after_hwframe+0x49/0xbe      Possible unsafe locking scenario:            CPU0                    CPU2           ",b9aff38de2cb166476988020428985c5f7412ffc,0
media: af9005: uninitialized variable printked,"If usb_bulk_msg() fails, actual_length can be uninitialized.  ",51d0c99b391f0cac61ad7b827c26f549ee55672c,1
tty: protect tty_write from odd low-level tty disciplines,"Al root-caused a new warning from syzbot to the ttyprintk tty driver returning a write count larger than the data the tty layer actually gave it.  Which confused the tty write code mightily, and with the new iov_iter based code, caused a ",3342ff2698e9720f4040cc458a2744b2b32f5c3a,0
RDMA/ucma: Check that user doesn't overflow QP state,"The QP state is limited and declared in enum ib_qp_state, but ucma user was able to supply any possible (u32) value.  ",a5880b84430316e3e1c1f5d23aa32ec6000cc717,1
ipv6: prevent possible fib6 leaks,"At ipv6 route dismantle, fib6_drop_pcpu_from() is responsible for finding all percpu routes and set their ->from pointer to NULL, so that fib6_ref can reach its expected value (1).  The problem right now is that other cpus can still catch the route being deleted, since there is no rcu grace period between the route deletion and call to fib6_drop_pcpu_from()  This can leak the fib6 and associated resources, since no notifier will take care of removing the last reference(s).  I decided to add another boolean (fib6_destroying) instead of reusing/renaming exception_bucket_flushed to ease stable backports, and properly document the memory barriers used to implement this fix.  This patch has been co-developped with Wei Wang.  ",61fb0d01680771f72cc9d39783fb2c122aaad51e,0
media: technisat-usb2: break out of loop at end of buffer,Ensure we do not access the buffer beyond the end if no 0xff byte is encountered.  ,0c4df39e504bf925ab666132ac3c98d6cbbe380b,0
ipv6: fixes rt6_probe() and fib6_nh->last_probe init,"While looking at a syzbot KCSAN report [1], I found multiple issues in this code :  1) fib6_nh->last_probe has an initial value of 0.     While probably okay on 64bit kernels, this causes an issue    on 32bit kernels since the time_after(jiffies, 0 + interval)    might be false ~24 days after boot (for HZ=1000)  2) The data-race found by KCSAN    I could use READ_ONCE() and WRITE_ONCE(), but we also can    take the opportunity of not piling-up too many rt6_probe_deferred()    works by using instead cmpxchg() so that only one cpu wins the race.  [1] BUG: KCSAN: data-race in find_match / find_match  write to 0xffff8880bb7aabe8 of 8 bytes by interrupt on cpu 1:  rt6_probe net/ipv6/route.c:663 [inline]  find_match net/ipv6/route.c:757 [inline]  find_match+0x5bd/0x790 net/ipv6/route.c:733  __find_rr_leaf+0xe3/0x780 net/ipv6/route.c:831  find_rr_leaf net/ipv6/route.c:852 [inline]  rt6_select net/ipv6/route.c:896 [inline]  fib6_table_lookup+0x383/0x650 net/ipv6/route.c:2164  ip6_pol_route+0xee/0x5c0 net/ipv6/route.c:2200  ip6_pol_route_output+0x48/0x60 net/ipv6/route.c:2452  fib6_rule_lookup+0x3d6/0x470 net/ipv6/fib6_rules.c:117  ip6_route_output_flags_noref+0x16b/0x230 net/ipv6/route.c:2484  ip6_route_output_flags+0x50/0x1a0 net/ipv6/route.c:2497  ip6_dst_lookup_tail+0x25d/0xc30 net/ipv6/ip6_output.c:1049  ip6_dst_lookup_flow+0x68/0x120 net/ipv6/ip6_output.c:1150  inet6_csk_route_socket+0x2f7/0x420 net/ipv6/inet6_connection_sock.c:106  inet6_csk_xmit+0x91/0x1f0 net/ipv6/inet6_connection_sock.c:121  __tcp_transmit_skb+0xe81/0x1d60 net/ipv4/tcp_output.c:1169  tcp_transmit_skb net/ipv4/tcp_output.c:1185 [inline]  tcp_xmit_probe_skb+0x19b/0x1d0 net/ipv4/tcp_output.c:3735  read to 0xffff8880bb7aabe8 of 8 bytes by interrupt on cpu 0:  rt6_probe net/ipv6/route.c:657 [inline]  find_match net/ipv6/route.c:757 [inline]  find_match+0x521/0x790 net/ipv6/route.c:733  __find_rr_leaf+0xe3/0x780 net/ipv6/route.c:831  find_rr_leaf net/ipv6/route.c:852 [inline]  rt6_select net/ipv6/route.c:896 [inline]  fib6_table_lookup+0x383/0x650 net/ipv6/route.c:2164  ip6_pol_route+0xee/0x5c0 net/ipv6/route.c:2200  ip6_pol_route_output+0x48/0x60 net/ipv6/route.c:2452  fib6_rule_lookup+0x3d6/0x470 net/ipv6/fib6_rules.c:117  ip6_route_output_flags_noref+0x16b/0x230 net/ipv6/route.c:2484  ip6_route_output_flags+0x50/0x1a0 net/ipv6/route.c:2497  ip6_dst_lookup_tail+0x25d/0xc30 net/ipv6/ip6_output.c:1049  ip6_dst_lookup_flow+0x68/0x120 net/ipv6/ip6_output.c:1150  inet6_csk_route_socket+0x2f7/0x420 net/ipv6/inet6_connection_sock.c:106  inet6_csk_xmit+0x91/0x1f0 net/ipv6/inet6_connection_sock.c:121  __tcp_transmit_skb+0xe81/0x1d60 net/ipv4/tcp_output.c:1169  Reported by Kernel Concurrency Sanitizer on: CPU: 0 PID: 18894 Comm: udevd Not tainted 5.4.0-rc3+ #0 Hardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 01/01/2011  ",1bef4c223b8588cf50433bdc2c6953d82949b3b3,1
bonding: validate ip header before check IPPROTO_IGMP,bond_xmit_roundrobin() checks for IGMP packets but it parses the IP header even before checking skb->protocol.  We should validate the IP header with pskb_may_pull() before using iph->protocol.  ,9d1bc24b52fb8c5d859f9a47084bf1179470e04c,0
tcp: md5: reject TCP_MD5SIG or TCP_MD5SIG_EXT on established sockets,"syzbot/KMSAN reported an uninit-value in tcp_parse_options() [1]  I believe this was caused by a TCP_MD5SIG being set on live flow.  This is highly unexpected, since TCP option space is limited.  For instance, presence of TCP MD5 option automatically disables TCP TimeStamp option at SYN/SYNACK time, which we can not do once flow has been established.  Really, adding/deleting an MD5 key only makes sense on sockets in CLOSE or LISTEN state.  [1] BUG: KMSAN: uninit-value in tcp_parse_options+0xd74/0x1a30 net/ipv4/tcp_input.c:3720 CPU: 1 PID: 6177 Comm: syzkaller192004 Not tainted 4.16.0+ #83 Hardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 01/01/2011 Call Trace:  __dump_stack lib/dump_stack.c:17 [inline]  dump_stack+0x185/0x1d0 lib/dump_stack.c:53  kmsan_report+0x142/0x240 mm/kmsan/kmsan.c:1067  __msan_warning_32+0x6c/0xb0 mm/kmsan/kmsan_instr.c:676  tcp_parse_options+0xd74/0x1a30 net/ipv4/tcp_input.c:3720  tcp_fast_parse_options net/ipv4/tcp_input.c:3858 [inline]  tcp_validate_incoming+0x4f1/0x2790 net/ipv4/tcp_input.c:5184  tcp_rcv_established+0xf60/0x2bb0 net/ipv4/tcp_input.c:5453  tcp_v4_do_rcv+0x6cd/0xd90 net/ipv4/tcp_ipv4.c:1469  sk_backlog_rcv include/net/sock.h:908 [inline]  __release_sock+0x2d6/0x680 net/core/sock.c:2271  release_sock+0x97/0x2a0 net/core/sock.c:2786  tcp_sendmsg+0xd6/0x100 net/ipv4/tcp.c:1464  inet_sendmsg+0x48d/0x740 net/ipv4/af_inet.c:764  sock_sendmsg_nosec net/socket.c:630 [inline]  sock_sendmsg net/socket.c:640 [inline]  SYSC_sendto+0x6c3/0x7e0 net/socket.c:1747  SyS_sendto+0x8a/0xb0 net/socket.c:1715  do_syscall_64+0x309/0x430 arch/x86/entry/common.c:287  entry_SYSCALL_64_after_hwframe+0x3d/0xa2 ",7212303268918b9a203aebeacfdbd83b5e87b20d,1
HID: core: detect and skip invalid inputs to snto32(),"Prevent invalid (0, 0) inputs to hid-core's snto32() function.  Maybe it is just the dummy device here that is causing this, but there are hundreds of calls to snto32(0, 0). Having n (bits count) of 0 is causing the current UBSAN trap with a shift value of 0xffffffff (-1, or n - 1 in this function).  Either of the value to shift being 0 or the bits count being 0 can be handled by just returning 0 to the caller, avoiding the following complex shift + OR operations:  	return value & (1 << (n - 1)) ? value | (~0U << n) : value;  ",a0312af1f94d13800e63a7d0a66e563582e39aec,0
net_sched: let qdisc_put() accept NULL pointer,"When tcf_block_get() fails in sfb_init(), q->qdisc is still a NULL pointer which leads to a crash in sfb_destroy(). Similar for sch_dsmark.  Instead of fixing each separately, Linus suggested to just accept NULL pointer in qdisc_put(), which would make callers easier.  (For sch_dsmark, the bug probably exists long before commit 6529eaba33f0.)  ",6efb971ba8edfbd80b666f29de12882852f095ae,1
mm/hugetlb: fix refs calculation from unaligned @vaddr,"Commit 82e5d378b0e47 (""mm/hugetlb: refactor subpage recording"") refactored the count of subpages but missed an edge case when @vaddr is not aligned to PAGE_SIZE e.g.  when close to vma->vm_end.  It would then errousnly set @refs to 0 and record_subpages_vmas() wouldn't set the @pages array element to its value, consequently causing the reported null-deref by syzbot.  Fix it by aligning down @vaddr by PAGE_SIZE in @refs calculation.  ",d08af0a59684e18a51aa4bfd24c658994ea3fc5b,0
vfs: fsmount: add missing mntget(),"sys_fsmount() needs to take a reference to the new mount when adding it to the anonymous mount namespace.  Otherwise the filesystem can be unmounted while it's still in use, as found by syzkaller.  ",1b0b9cc8d3793e31b313e6c9685513b08cd883c4,1
ext4: fix leaking sysfs kobject after failed mount,"ext4_unregister_sysfs() only deletes the kobject.  The reference to it needs to be put separately, like ext4_put_super() does.  This addresses the syzbot report ""memory leak in kobject_set_name_vargs (3)"" (https://syzkaller.appspot.com/bug?extid=9f864abad79fae7c17e1).  ",cb8d53d2c97369029cc638c9274ac7be0a316c75,1
mm/rmap: fix new bug: premature return from page_mlock_one(),"In the unlikely race case that page_mlock_one() finds VM_LOCKED has been cleared by the time it got page table lock, page_vma_mapped_walk_done() must be called before returning, either explicitly, or by a final call to page_vma_mapped_walk() - otherwise the page table remains locked.  ",023e1a8dd502405ba378a7fbb1ce62beb0616708,1
media: gspca/sq905.c: fix uninitialized variable,act_len can be uninitialized if usb_bulk_msg() returns an error. Set it to 0 to avoid a KMSAN error.  ,eaaea4681984c79d2b2b160387b297477f0c1aab,1
inet_diag: validate INET_DIAG_REQ_PROTOCOL attribute,"User space could send an invalid INET_DIAG_REQ_PROTOCOL attribute as caught by syzbot.  BUG: KMSAN: uninit-value in inet_diag_lock_handler net/ipv4/inet_diag.c:55 [inline] BUG: KMSAN: uninit-value in __inet_diag_dump+0x58c/0x720 net/ipv4/inet_diag.c:1147 CPU: 0 PID: 8505 Comm: syz-executor174 Not tainted 5.9.0-rc4-syzkaller #0 Hardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 01/01/2011 Call Trace:  __dump_stack lib/dump_stack.c:77 [inline]  dump_stack+0x21c/0x280 lib/dump_stack.c:118  kmsan_report+0xf7/0x1e0 mm/kmsan/kmsan_report.c:122  __msan_warning+0x58/0xa0 mm/kmsan/kmsan_instr.c:219  inet_diag_lock_handler net/ipv4/inet_diag.c:55 [inline]  __inet_diag_dump+0x58c/0x720 net/ipv4/inet_diag.c:1147  inet_diag_dump_compat+0x2a5/0x380 net/ipv4/inet_diag.c:1254  netlink_dump+0xb73/0x1cb0 net/netlink/af_netlink.c:2246  __netlink_dump_start+0xcf2/0xea0 net/netlink/af_netlink.c:2354  netlink_dump_start include/linux/netlink.h:246 [inline]  inet_diag_rcv_msg_compat+0x5da/0x6c0 net/ipv4/inet_diag.c:1288  sock_diag_rcv_msg+0x24f/0x620 net/core/sock_diag.c:256  netlink_rcv_skb+0x6d7/0x7e0 net/netlink/af_netlink.c:2470  sock_diag_rcv+0x63/0x80 net/core/sock_diag.c:275  netlink_unicast_kernel net/netlink/af_netlink.c:1304 [inline]  netlink_unicast+0x11c8/0x1490 net/netlink/af_netlink.c:1330  netlink_sendmsg+0x173a/0x1840 net/netlink/af_netlink.c:1919  sock_sendmsg_nosec net/socket.c:651 [inline]  sock_sendmsg net/socket.c:671 [inline]  ____sys_sendmsg+0xc82/0x1240 net/socket.c:2353  ___sys_sendmsg net/socket.c:2407 [inline]  __sys_sendmsg+0x6d1/0x820 net/socket.c:2440  __do_sys_sendmsg net/socket.c:2449 [inline]  __se_sys_sendmsg+0x97/0xb0 net/socket.c:2447  __x64_sys_sendmsg+0x4a/0x70 net/socket.c:2447  do_syscall_64+0x9f/0x140 arch/x86/entry/common.c:48  entry_SYSCALL_64_after_hwframe+0x44/0xa9 ",d5e4d0a5e692a942f0c212e37dc6aeac47ecbdea,1
Bluetooth: schedule SCO timeouts with delayed_work,"struct sock.sk_timer should be used as a sock cleanup timer. However, SCO uses it to implement sock timeouts.  This causes issues because struct sock.sk_timer's callback is run in an IRQ context, and the timer callback function sco_sock_timeout takes a spin lock on the socket. However, other functions such as sco_conn_del and sco_conn_ready take the spin lock with interrupts enabled.  This inconsistent {SOFTIRQ-ON-W} -> {IN-SOFTIRQ-W} lock usage could lead to deadlocks as reported by Syzbot [1]:        CPU0        ",ba316be1b6a00db7126ed9a39f9bee434a508043,0
ip6_tunnel: be careful when accessing the inner header,"the ip6 tunnel xmit ndo assumes that the processed skb always contains an ip[v6] header, but syzbot has found a way to send frames that fall short of this assumption, leading to the following splat:  BUG: KMSAN: uninit-value in ip6ip6_tnl_xmit net/ipv6/ip6_tunnel.c:1307 [inline] BUG: KMSAN: uninit-value in ip6_tnl_start_xmit+0x7d2/0x1ef0 net/ipv6/ip6_tunnel.c:1390 CPU: 0 PID: 4504 Comm: syz-executor558 Not tainted 4.16.0+ #87 Hardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 01/01/2011 Call Trace:   __dump_stack lib/dump_stack.c:17 [inline]   dump_stack+0x185/0x1d0 lib/dump_stack.c:53   kmsan_report+0x142/0x240 mm/kmsan/kmsan.c:1067   __msan_warning_32+0x6c/0xb0 mm/kmsan/kmsan_instr.c:683   ip6ip6_tnl_xmit net/ipv6/ip6_tunnel.c:1307 [inline]   ip6_tnl_start_xmit+0x7d2/0x1ef0 net/ipv6/ip6_tunnel.c:1390   __netdev_start_xmit include/linux/netdevice.h:4066 [inline]   netdev_start_xmit include/linux/netdevice.h:4075 [inline]   xmit_one net/core/dev.c:3026 [inline]   dev_hard_start_xmit+0x5f1/0xc70 net/core/dev.c:3042   __dev_queue_xmit+0x27ee/0x3520 net/core/dev.c:3557   dev_queue_xmit+0x4b/0x60 net/core/dev.c:3590   packet_snd net/packet/af_packet.c:2944 [inline]   packet_sendmsg+0x7c70/0x8a30 net/packet/af_packet.c:2969   sock_sendmsg_nosec net/socket.c:630 [inline]   sock_sendmsg net/socket.c:640 [inline]   ___sys_sendmsg+0xec0/0x1310 net/socket.c:2046   __sys_sendmmsg+0x42d/0x800 net/socket.c:2136   SYSC_sendmmsg+0xc4/0x110 net/socket.c:2167   SyS_sendmmsg+0x63/0x90 net/socket.c:2162   do_syscall_64+0x309/0x430 arch/x86/entry/common.c:287   entry_SYSCALL_64_after_hwframe+0x3d/0xa2 ",76c0ddd8c3a683f6e2c6e60e11dc1a1558caf4bc,1
netfilter: flowtable: skip offload setup if disabled,"nftables test case tests/shell/testcases/flowtable/0001flowtable_0  results in a crash. After the refactor, if we leave early via nf_flowtable_hw_offload(), then ""struct flow_block_offload"" is left in an uninitialized state, but later users assume its initialised.  ",a7da92c2c8a1faf253a3b3e292fda6910deba540,1
xfrm: Validate address prefix lengths in the xfrm selector.,We don't validate the address prefix lengths in the xfrm selector we got from userspace. This can lead to undefined behaviour in the address matching functions if the prefix is too big for the given address family. Fix this by checking the prefixes and refuse SA/policy insertation when a prefix is invalid.  ,07bf7908950a8b14e81aa1807e3c667eab39287a,0
bpf: Dont allow vmlinux BTF to be used in map_create and prog_load.,The syzbot got FD of vmlinux BTF and passed it into map_create which caused crash in btf_type_id_size() when it tried to access resolved_ids. The vmlinux BTF doesn't have 'resolved_ids' and 'resolved_sizes' initialized to save memory. To avoid such issues disallow using vmlinux BTF in prog_load and map_create commands.  ,350a5c4dd2452ea999cc5e1d4a8dbf12de2f97ef,1
ipvs: initialize tbl->entries after allocation,"tbl->entries is not initialized after kmalloc(), therefore causes an uninit-value warning in ip_vs_lblc_check_expire() as reported by syzbot.  ",3aa1409a7b160f9444945c0df1cb079df82be84e,0
"Revert ""net/sctp: fix race condition in sctp_destroy_sock""","This reverts commit b166a20b07382b8bc1dcee2a448715c9c2c81b5b.  This one has to be reverted as it introduced a dead lock, as ",01bfe5e8e428b475982a98a46cca5755726f3f7f,1
fsnotify: Fix NULL ptr deref in fanotify_get_fsid(),fanotify_get_fsid() is reading mark->connector->fsid under srcu. It can happen that it sees mark not fully initialized or mark that is already detached from the object list. In these cases mark->connector can be NULL leading to NULL ptr dereference. Fix the problem by being careful when reading mark->connector and check it for being NULL. Also use WRITE_ONCE when writing the mark just to prevent compiler from doing something stupid.  ,b1da6a51871c6929dced1a7fad81990988b36ed6,1
io_uring: clear request count when freeing caches,"BUG: KASAN: double-free or invalid-free in io_req_caches_free.constprop.0+0x3ce/0x530 fs/io_uring.c:8709  Workqueue: events_unbound io_ring_exit_work Call Trace:  [...]  __cache_free mm/slab.c:3424 [inline]  kmem_cache_free_bulk+0x4b/0x1b0 mm/slab.c:3744  io_req_caches_free.constprop.0+0x3ce/0x530 fs/io_uring.c:8709  io_ring_ctx_free fs/io_uring.c:8764 [inline]  io_ring_exit_work+0x518/0x6b0 fs/io_uring.c:8846  process_one_work+0x98d/0x1600 kernel/workqueue.c:2275  worker_thread+0x64c/0x1120 kernel/workqueue.c:2421  kthread+0x3b1/0x4a0 kernel/kthread.c:292  ret_from_fork+0x1f/0x30 arch/x86/entry/entry_64.S:294  Freed by task 11900:  [...]  kmem_cache_free_bulk+0x4b/0x1b0 mm/slab.c:3744  io_req_caches_free.constprop.0+0x3ce/0x530 fs/io_uring.c:8709  io_uring_flush+0x483/0x6e0 fs/io_uring.c:9237  filp_close+0xb4/0x170 fs/open.c:1286  close_files fs/file.c:403 [inline]  put_files_struct fs/file.c:418 [inline]  put_files_struct+0x1d0/0x350 fs/file.c:415  exit_files+0x7e/0xa0 fs/file.c:435  do_exit+0xc27/0x2ae0 kernel/exit.c:820  do_group_exit+0x125/0x310 kernel/exit.c:922  [...]  io_req_caches_free() doesn't zero submit_state->free_reqs, so io_uring considers just freed requests to be good and sound and will reuse or double free them. Zero the counter.  ",8e5c66c485a8af3f39a8b0358e9e09f002016d92,1
fs/userfaultfd.c: disable irqs for fault_pending and event locks,"When IOCB_CMD_POLL is used on a userfaultfd, aio_poll() disables IRQs and takes kioctx::ctx_lock, then userfaultfd_ctx::fd_wqh.lock.  This may have to wait for userfaultfd_ctx::fd_wqh.lock to be released by userfaultfd_ctx_read(), which in turn can be waiting for userfaultfd_ctx::fault_pending_wqh.lock or userfaultfd_ctx::event_wqh.lock.  But elsewhere the fault_pending_wqh and event_wqh locks are taken with IRQs enabled.  Since the IRQ handler may take kioctx::ctx_lock, lockdep reports that a deadlock is possible.  Fix it by always disabling IRQs when taking the fault_pending_wqh and event_wqh locks.  Commit ae62c16e105a (""userfaultfd: disable irqs when taking the waitqueue lock"") didn't fix this because it only accounted for the fd_wqh lock, not the other locks nested inside it.  ",cbcfa130a911c613a1d9d921af2eea171c414172,0
do_move_mount(): fix an unsafe use of is_anon_ns(),"What triggers it is a race between mount --move and umount -l of the source; we should reject it (the source is parentless *and* not the root of anon namespace at that), but the check for namespace being an anon one is broken in that case - is_anon_ns() needs ns to be non-NULL.  Better fixed here than in is_anon_ns(), since the rest of the callers is guaranteed to get a non-NULL argument...  ",05883eee857eab4693e7d13ebab06716475c5754,1
btrfs: promote debugging asserts to full-fledged checks in validate_super,Syzbot managed to trigger this assert while performing its fuzzing. Turns out it's better to have those asserts turned into full-fledged checks so that in case buggy btrfs images are mounted the users gets an error and mounting is stopped. Alternatively with CONFIG_BTRFS_ASSERT disabled such image would have been erroneously allowed to be mounted.  ,aefd7f7065567a4666f42c0fc8cdb379d2e036bf,0
ila: make lockdep happy again,"Previously, alloc_ila_locks() and bucket_table_alloc() call spin_lock_init() separately, therefore they have two different lock names and lock class keys. However, after commit b893281715ab (""ila: Call library function alloc_bucket_locks"") they both call helper alloc_bucket_spinlocks() which now only has one lock name and lock class key. This causes a few bogus lockdep warnings as reported by syzbot.  Fix this by making alloc_bucket_locks() a macro and pass declaration name as lock name and a static lock class key inside the macro.  ",ff93bca769925a2d8fd7f910cdf543d992e17f07,0
ext4: prevent right-shifting extents beyond EXT_MAX_BLOCKS,"During the ""insert range"" fallocate operation, extents starting at the range offset are shifted ""right"" (to a higher file offset) by the range length.  But, as shown by syzbot, it's not validated that this doesn't cause extents to be shifted beyond EXT_MAX_BLOCKS.  In that case ->ee_block can wrap around, corrupting the extent tree.  Fix it by returning an error if the space between the end of the last extent and EXT4_MAX_BLOCKS is smaller than the range being inserted.  This bug can be reproduced by running the following commands when the current directory is on an ext4 filesystem with a 4k block size:          fallocate -l 8192 file         fallocate --keep-size -o 0xfffffffe000 -l 4096 -n file         fallocate --insert-range -l 8192 file  Then after unmounting the filesystem, e2fsck reports corruption.  ",349fa7d6e1935f49bf4161c4900711b2989180a9,1
fork: do not release lock that wasn't taken,"Avoid calling cgroup_threadgroup_change_end() without having called cgroup_threadgroup_change_begin() first.  During process creation we need to check whether the cgroup we are in allows us to fork. To perform this check the cgroup needs to guard itself against threadgroup changes and takes a lock. Prior to CLONE_PIDFD the cleanup target ""bad_fork_free_pid"" would also need to call cgroup_threadgroup_change_end() because said lock had already been taken. However, this is not the case anymore with the addition of CLONE_PIDFD. We are now allocating a pidfd before we check whether the cgroup we're in can fork and thus prior to taking the lock. So when copy_process() fails at the right step it would release a lock we haven't taken. This bug is not even very subtle to be honest. It's just not very clear from the naming of cgroup_threadgroup_change_{begin,end}() that a lock is taken.  Here's the relevant splat:  entry_SYSENTER_compat+0x70/0x7f arch/x86/entry/entry_64_compat.S:139 ",c3b7112df86b769927a60a6d7175988ca3d60f09,0
mld: fix memory leak in mld_del_delrec(),"Similar to the fix done for IPv4 in commit e5b1c6c6277d (""igmp: fix memory leak in igmpv3_del_delrec()""), we need to make sure mca_tomb and mca_sources are not blindly overwritten.  Using swap() then a call to ip6_mc_clear_src() will take care of the missing free.  BUG: memory leak unreferenced object 0xffff888117d9db00 (size 64):   comm ""syz-executor247"", pid 6918, jiffies 4294943989 (age 25.350s)   ",a84d016479896b5526a2cc54784e6ffc41c9d6f6,1
y2038: time: avoid timespec usage in settimeofday(),"The compat_get_timeval() and timeval_valid() interfaces are deprecated and getting removed along with the definition of struct timeval itself.  Change the two implementations of the settimeofday() system call to open-code these helpers and completely avoid references to timeval.  The timeval_valid() call is not needed any more here, only a check to avoid overflowing tv_nsec during the multiplication, as there is another range check in do_sys_settimeofday64().  ",5e0fb1b57bea8d11fe77da2bc80f4c9a67e28318,1
kobject: don't use WARN for registration failures,This ,3e14c6abbfb5c94506edda9d8e2c145d79375798,0
khugepaged: adjust VM_BUG_ON_MM() in __khugepaged_enter(),"syzbot crashes on the VM_BUG_ON_MM(khugepaged_test_exit(mm), mm) in __khugepaged_enter(): yes, when one thread is about to dump core, has set core_state, and is waiting for others, another might do something calling __khugepaged_enter(), which now crashes because I lumped the core_state test (known as ""mmget_still_valid"") into khugepaged_test_exit().  I still think it's best to lump them together, so just in this exceptional case, check mm->mm_users directly instead of khugepaged_test_exit().  ",f3f99d63a8156c7a4a6b20aac22b53c5579c7dc1,1
cfg80211: call cfg80211_destroy_ifaces() with wiphy lock held,"This is needed since it calls into the driver, which must have the same context as if we got to destroy an interface through nl80211. Fix this, and add a direct lockdep assertion so we don't see it pop up only when the driver calls back to cfg80211.  ",776a39b8196dbca4afb69669db0d9926ffac29ab,0
usb: hso: fix error handling code of hso_create_net_device,"The current error handling code of hso_create_net_device is hso_free_net_device, no matter which errors lead to. For example, ",788e67f18d797abbd48a96143511261f4f3b4f21,1
net: provide dev_lstats_read() helper,"Many network drivers use hand-coded implementation of the same thing, let's factorize things so that u64_stats_t adoption is done once.  ",de7d5084d82794a8e83afb994fcb07f82da3cd7b,0
ppp: fix out-of-bounds access in bpf_prog_create(),"sock_fprog_kern::len is in units of struct sock_filter, not bytes.  ",0033b34a03ec5cf747cdaf9b1f9dceb91c020f17,1
net: qrtr: fix memory leaks,"Syzbot reported memory leak in qrtr. The problem was in unputted struct sock. qrtr_local_enqueue() function calls qrtr_port_lookup() which takes sock reference if port was found. Then there is the following check:  if (!ipc || &ipc->sk == skb->sk) { 	... 	return -ENODEV; }  Since we should drop the reference before returning from this function and ipc can be non-NULL inside this if, we should add qrtr_port_put() inside this if.  The similar corner case is in qrtr_endpoint_post() as Manivannan reported. In case of sock_queue_rcv_skb() failure we need to put port reference to avoid leaking struct sock pointer.  ",52f3456a96c06760b9bfae460e39596fec7af22e,1
simple_recursive_removal(): kernel-side rm -rf for ramfs-style filesystems,two requirements: no file creations in IS_DEADDIR and no cross-directory renames whatsoever.  ,a3d1e7eb5abe3aa1095bc75d1a6760d3809bd672,0
tracepoint: Do not warn on ENOMEM,"Tracepoint should only warn when a kernel API user does not respect the required preconditions (e.g. same tracepoint enabled twice, or called to remove a tracepoint that does not exist).  Silence warning in out-of-memory conditions, given that the error is returned to the caller.  This ensures that out-of-memory error-injection testing does not trigger warnings in tracepoint.c, which were seen by syzbot.   CC: Peter Zijlstra <peterz@infradead.org> CC: Jiri Olsa <jolsa@redhat.com> CC: Arnaldo Carvalho de Melo <acme@kernel.org> CC: Alexander Shishkin <alexander.shishkin@linux.intel.com> CC: Namhyung Kim <namhyung@kernel.org> CC: stable@vger.kernel.org ",d66a270be3310d7aa132fec0cea77d3d32a0ff75,0
bpf: net: Avoid incorrect bpf_sk_reuseport_detach call,"bpf_sk_reuseport_detach is currently called when sk->sk_user_data is not NULL.  It is incorrect because sk->sk_user_data may not be managed by the bpf's reuseport_array.  It has been reported in [1] that, the bpf_sk_reuseport_detach() which is called from udp_lib_unhash() has corrupted the sk_user_data managed by l2tp.  This patch solves it by using another bit (defined as SK_USER_DATA_BPF) of the sk_user_data pointer value.  It marks that a sk_user_data is managed/owned by BPF.  The patch depends on a PTRMASK introduced in commit f1ff5ce2cd5e (""net, sk_msg: Clear sk_user_data pointer on clone if tagged"").  ",c9a368f1c0fbe2e3a21ebf231caeae58b18b2681,0
net/802/mrp: fix memleak in mrp_request_join(),"I got kmemleak report when doing fuzz test:  BUG: memory leak unreferenced object 0xffff88810c239500 (size 64): comm ""syz-executor940"", pid 882, jiffies 4294712870 (age 14.631s) ",996af62167d0e0ec69b938a3561e96f84ffff1aa,1
llc: fix out-of-bound array index in llc_sk_dev_hash(),"Both ifindex and LLC_SK_DEV_HASH_ENTRIES are signed.  This means that (ifindex % LLC_SK_DEV_HASH_ENTRIES) is negative if @ifindex is negative.  We could simply make LLC_SK_DEV_HASH_ENTRIES unsigned.  In this patch I chose to use hash_32() to get more entropy from @ifindex, like llc_sk_laddr_hashfn().  UBSAN: array-index-out-of-bounds in ./include/net/llc.h:75:26 index -43 is out of range for type 'hlist_head [64]' CPU: 1 PID: 20999 Comm: syz-executor.3 Not tainted 5.15.0-syzkaller #0 Hardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 01/01/2011 Call Trace:  <TASK>  __dump_stack lib/dump_stack.c:88 [inline]  dump_stack_lvl+0xcd/0x134 lib/dump_stack.c:106  ubsan_epilogue+0xb/0x5a lib/ubsan.c:151  __ubsan_handle_out_of_bounds.cold+0x62/0x6c lib/ubsan.c:291  llc_sk_dev_hash include/net/llc.h:75 [inline]  llc_sap_add_socket+0x49c/0x520 net/llc/llc_conn.c:697  llc_ui_bind+0x680/0xd70 net/llc/af_llc.c:404  __sys_bind+0x1e9/0x250 net/socket.c:1693  __do_sys_bind net/socket.c:1704 [inline]  __se_sys_bind net/socket.c:1702 [inline]  __x64_sys_bind+0x6f/0xb0 net/socket.c:1702  do_syscall_x64 arch/x86/entry/common.c:50 [inline]  do_syscall_64+0x35/0xb0 arch/x86/entry/common.c:80  entry_SYSCALL_64_after_hwframe+0x44/0xae ",8ac9dfd58b138f7e82098a4e0a0d46858b12215b,1
RDMA/ucma: Don't allow join attempts for unsupported AF family,"Users can provide garbage while calling to ucma_join_ip_multicast(), it will indirectly cause to rdma_addr_size() return 0, making the call to ucma_process_join(), which had the right checks, but it is better to check the input as early as possible.  The following crash from syzkaller revealed it.  kernel BUG at lib/string.c:1052! invalid opcode: 0000 [#1] SMP KASAN Dumping ftrace buffer:    (ftrace buffer empty) ",0c81ffc60d5280991773d17e84bda605387148b1,1
ipv6: fix potential crash in ip6_datagram_dst_update(),"Willem forgot to change one of the calls to fl6_sock_lookup(), which can now return an error or NULL.  syzbot reported :  kasan: CONFIG_KASAN_INLINE enabled kasan: GPF could be caused by NULL-ptr deref or user memory access general protection fault: 0000 [#1] PREEMPT SMP KASAN CPU: 1 PID: 31763 Comm: syz-executor.0 Not tainted 5.2.0-rc6+ #63 Hardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 01/01/2011 ",8975a3abc3030bc8cdc3c94b988bcf819a14ed41,1
reiserfs: Fix oops during mount,With suitably crafted reiserfs image and mount command reiserfs will crash when trying to verify that XATTR_ROOT directory can be looked up in / as that recurses back to xattr code like:   xattr_lookup+0x24/0x280 fs/reiserfs/xattr.c:395  reiserfs_xattr_get+0x89/0x540 fs/reiserfs/xattr.c:677  reiserfs_get_acl+0x63/0x690 fs/reiserfs/xattr_acl.c:209  get_acl+0x152/0x2e0 fs/posix_acl.c:141  check_acl fs/namei.c:277 [inline]  acl_permission_check fs/namei.c:309 [inline]  generic_permission+0x2ba/0x550 fs/namei.c:353  do_inode_permission fs/namei.c:398 [inline]  inode_permission+0x234/0x4a0 fs/namei.c:463  lookup_one_len+0xa6/0x200 fs/namei.c:2557  reiserfs_lookup_privroot+0x85/0x1e0 fs/reiserfs/xattr.c:972  reiserfs_fill_super+0x2b51/0x3240 fs/reiserfs/super.c:2176  mount_bdev+0x24f/0x360 fs/super.c:1417  Fix the problem by bailing from reiserfs_xattr_get() when xattrs are not yet initialized.  CC: stable@vger.kernel.org ,c2bb80b8bdd04dfe32364b78b61b6a47f717af52,1
sctp: hold transport before accessing its asoc in sctp_transport_get_next,"As Marcelo noticed, in sctp_transport_get_next, it is iterating over transports but then also accessing the association directly, without checking any refcnts before that, which can cause an use-after-free Read.  So fix it by holding transport before accessing the association. With that, sctp_transport_hold calls can be removed in the later places.  ",bab1be79a5169ac748d8292b20c86d874022d7ba,1
"Revert ""net: sched: make newly activated qdiscs visible""","This reverts commit 4cda75275f9f89f9485b0ca4d6950c95258a9bce from net-next.  Brown bag time.  Michal noticed that this change doesn't work at all when netif_set_real_num_tx_queues() gets called prior to an initial dev_activate(), as for instance igb does.  Doing so dies with:  ",7c4046b1c53bba3a0315f04bb0bb5f36888a747b,0
USB: serial: option: add interface-number sanity check to flag handling,Add an interface-number sanity check before testing the device flags to avoid relying on undefined behaviour when left shifting in case a device uses an interface number greater than or equal to BITS_PER_LONG (i.e. 64 or 32).  ,a251963f76fa0226d0fdf0c4f989496f18d9ae7f,1
binder: return errors from buffer copy functions,The buffer copy functions assumed the caller would ensure correct alignment and that the memory to be copied was completely within the binder buffer. There have been a few cases discovered by syzkallar where a malformed transaction created by a user could violated the assumptions and resulted in a BUG_ON.  The fix is to remove the BUG_ON and always return the error to be handled appropriately by the caller.  ,bb4a2e48d5100ed3ff614df158a636bca3c6bf9f,1
ALSA: pcm: Fix endless loop for XRUN recovery in OSS emulation,"The commit 02a5d6925cd3 (""ALSA: pcm: Avoid potential races between OSS ioctls and read/write"") split the PCM preparation code to a locked version, and it added a sanity check of runtime->oss.prepare flag along with the change.  This leaded to an endless loop when the stream gets XRUN: namely, snd_pcm_oss_write3() and co call snd_pcm_oss_prepare() without setting runtime->oss.prepare flag and the loop continues until the PCM state reaches to another one.  As the function is supposed to execute the preparation unconditionally, drop the invalid state check there.  The bug was triggered by syzkaller.  ",e15dc99dbb9cf99f6432e8e3c0b3a8f7a3403a86,1
net: sched: fix memory leak in tcindex_partial_destroy_work,"Syzbot reported memory leak in tcindex_set_parms(). The problem was in non-freed perfect hash in tcindex_partial_destroy_work().  In tcindex_set_parms() new tcindex_data is allocated and some fields from old one are copied to new one, but not the perfect hash. Since tcindex_partial_destroy_work() is the destroy function for old tcindex_data, we need to free perfect hash to avoid memory leak.  ",f5051bcece50140abd1a11a2d36dc3ec5484fc32,1
USB: microtek: fix info-leak at probe,Add missing bulk-in endpoint sanity check to prevent uninitialised stack data from being reported to the system log and used as endpoint addresses.  ,177238c3d47d54b2ed8f0da7a4290db492f4a057,1
Bluetooth: hci_uart: fix GPF in h5_recv,"Syzbot hit general protection fault in h5_recv(). The problem was in missing NULL check.  hu->serdev can be NULL and we cannot blindly pass &serdev->dev somewhere, since it can cause GPF.  ",2fc7acb69fa3573d4bf7a90c323296d840daf330,0
gtp: make sure only SOCK_DGRAM UDP sockets are accepted,"A malicious user could use RAW sockets and fool GTP using them as standard SOCK_DGRAM UDP sockets.  BUG: KMSAN: uninit-value in udp_tunnel_encap_enable include/net/udp_tunnel.h:174 [inline] BUG: KMSAN: uninit-value in setup_udp_tunnel_sock+0x45e/0x6f0 net/ipv4/udp_tunnel.c:85 CPU: 0 PID: 11262 Comm: syz-executor613 Not tainted 5.5.0-rc5-syzkaller #0 Hardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 01/01/2011 Call Trace:  __dump_stack lib/dump_stack.c:77 [inline]  dump_stack+0x1c9/0x220 lib/dump_stack.c:118  kmsan_report+0xf7/0x1e0 mm/kmsan/kmsan_report.c:118  __msan_warning+0x58/0xa0 mm/kmsan/kmsan_instr.c:215  udp_tunnel_encap_enable include/net/udp_tunnel.h:174 [inline]  setup_udp_tunnel_sock+0x45e/0x6f0 net/ipv4/udp_tunnel.c:85  gtp_encap_enable_socket+0x37f/0x5a0 drivers/net/gtp.c:827  gtp_encap_enable drivers/net/gtp.c:844 [inline]  gtp_newlink+0xfb/0x1e50 drivers/net/gtp.c:666  __rtnl_newlink net/core/rtnetlink.c:3305 [inline]  rtnl_newlink+0x2973/0x3920 net/core/rtnetlink.c:3363  rtnetlink_rcv_msg+0x1153/0x1570 net/core/rtnetlink.c:5424  netlink_rcv_skb+0x451/0x650 net/netlink/af_netlink.c:2477  rtnetlink_rcv+0x50/0x60 net/core/rtnetlink.c:5442  netlink_unicast_kernel net/netlink/af_netlink.c:1302 [inline]  netlink_unicast+0xf9e/0x1100 net/netlink/af_netlink.c:1328  netlink_sendmsg+0x1248/0x14d0 net/netlink/af_netlink.c:1917  sock_sendmsg_nosec net/socket.c:639 [inline]  sock_sendmsg net/socket.c:659 [inline]  ____sys_sendmsg+0x12b6/0x1350 net/socket.c:2330  ___sys_sendmsg net/socket.c:2384 [inline]  __sys_sendmsg+0x451/0x5f0 net/socket.c:2417  __do_sys_sendmsg net/socket.c:2426 [inline]  __se_sys_sendmsg+0x97/0xb0 net/socket.c:2424  __x64_sys_sendmsg+0x4a/0x70 net/socket.c:2424  do_syscall_64+0xb8/0x160 arch/x86/entry/common.c:296  entry_SYSCALL_64_after_hwframe+0x44/0xa9 ",940ba14986657a50c15f694efca1beba31fa568f,1
crypto: x86/sha256-avx2 - Fix RBP usage,"Using RBP as a temporary register breaks frame pointer convention and breaks stack traces when unwinding from an interrupt in the crypto code.  There's no need to use RBP as a temporary register for the TBL value, because it always stores the same value: the address of the K256 table. Instead just reference the address of K256 directly.  ",d3dfbfe2e6e7ecd620531d5201314ad14c4ed5b3,0
perf/core: Fix race between close() and fork(),"Syzcaller reported the following Use-after-Free bug:  	close()						clone()  							  copy_process() 							    perf_event_init_task() 							      perf_event_init_context() 							        mutex_lock(parent_ctx->mutex) 								inherit_task_group() 								  inherit_group() 								    inherit_event() 								      mutex_lock(event->child_mutex) 								      // expose event on child list 								      list_add_tail() 								      mutex_unlock(event->child_mutex) 							        mutex_unlock(parent_ctx->mutex)  							    ... 							    goto bad_fork_*  							  bad_fork_cleanup_perf: 							    perf_event_free_task()  	  perf_release() 	    perf_event_release_kernel() 	      list_for_each_entry() 		mutex_lock(ctx->mutex) 		mutex_lock(event->child_mutex) 		// event is from the failing inherit 		// on the other CPU 		perf_remove_from_context() 		list_move() 		mutex_unlock(event->child_mutex) 		mutex_unlock(ctx->mutex)  							      mutex_lock(ctx->mutex) 							      list_for_each_entry_safe() 							        // event already stolen 							      mutex_unlock(ctx->mutex)  							    delayed_free_task() 							      free_task()  	     list_for_each_entry_safe() 	       list_del() 	       free_event() 	         _free_event() 		   // and so event->hw.target 		   // is the already freed failed clone() 		   if (event->hw.target) 		     put_task_struct(event->hw.target) 		       // WHOOPSIE, already quite dead  Which puts the lie to the the comment on perf_event_free_task(): 'unexposed, unused context' not so much.  Which is a 'fun' confluence of fail; copy_process() doing an unconditional free_task() and not respecting refcounts, and perf having creative locking. In particular:    82d94856fa22 (""perf/core: Fix lock inversion between perf,trace,cpuhp"")  seems to have overlooked this 'fun' parade.  Solve it by using the fact that detached events still have a reference count on their (previous) context. With this perf_event_free_task() can detect when events have escaped and wait for their destruction.  Debugged-by: Alexander Shishkin <alexander.shishkin@linux.intel.com> ",1cf8dfe8a661f0462925df943140e9f6d1ea5233,1
netlink: disable IRQs for netlink_lock_table(),"Syzbot reports that in mac80211 we have a potential deadlock between our ""local->stop_queue_reasons_lock"" (spinlock) and netlink's nl_table_lock (rwlock). This is because there's at least one situation in which we might try to send a netlink message with this spinlock held while it is also possible to take the spinlock from a hardirq context, resulting in the following deadlock scenario reported by lockdep:         CPU0                    CPU1        ",1d482e666b8e74c7555dbdfbfb77205eeed3ff2d,0
xsk: Fix crash in poll when device does not support ndo_xsk_wakeup,Fixes a crash in poll() when an AF_XDP socket is opened in copy mode and the bound device does not have ndo_xsk_wakeup defined. Avoid trying to call the non-existing ndo and instead call the internal xsk sendmsg function to send packets in the same way (from the application's point of view) as calling sendmsg() in any mode or poll() in zero-copy mode would have done. The application should behave in the same way independent on if zero-copy mode or copy mode is used.  ,df551058f7a303bd3a17a4cef001349974962ce8,1
netdevsim: Fix use-after-free during device dismantle,"Commit da58f90f11f5 (""netdevsim: Add devlink-trap support"") added delayed work to netdevsim that periodically iterates over the registered netdevsim ports and reports various packet traps via devlink.  While the delayed work takes the 'port_list_lock' mutex to protect against concurrent addition / deletion of ports, during device creation / dismantle ports are added / deleted without this lock, which can result in a use-after-free [1].  Fix this by making sure that the ports list is always modified under the lock.  [1] ",6d6f0383b697f004c65823c2b64240912f18515d,1
fs/locks: always delete_block after waiting.,"Now that requests can block other requests, we need to be careful to always clean up those blocked requests. Any time that we wait for a request, we might have other requests attached, and when we stop waiting, we must clean them up. If the lock was granted, the requests might have been moved to the new lock, though when merged with a pre-exiting lock, this might not happen. In all cases we don't want blocked locks to remain attached, so we remove them to be safe.  ",16306a61d3b7c433c7a127ec6224867b88ece687,0
staging: wlan-ng: fix use-after-free Read in hfa384x_usbin_callback,"We can't handle the case length > WLAN_DATA_MAXLEN. Because the size of rxfrm->data is WLAN_DATA_MAXLEN(2312), and we can't read more than that.  Thanks-to: Hillf Danton <hdanton@sina.com> ",1165dd73e811a07d947aee218510571f516081f6,1
netfilter: nf_tables: initialize set before expression setup,nft_set_elem_expr_alloc() needs an initialized set if expression sets on the NFT_EXPR_GC flag. Move set fields initialization before expression setup.  [4512935.019450] ,ad9f151e560b016b6ad3280b48e42fa11e1a5440,0
block: Fix wrong offset in bio_truncate(),"bio_truncate() clears the buffer outside of last block of bdev, however current bio_truncate() is using the wrong offset of page. So it can return the uninitialized data.  This happened when both of truncated/corrupted FS and userspace (via bdev) are trying to read the last of bdev.  ",3ee859e384d453d6ac68bfd5971f630d9fa46ad3,1
net: bridge: validate the NUD_PERMANENT bit when adding an extern_learn FDB entry,"Currently it is possible to add broken extern_learn FDB entries to the bridge in two ways:  1. Entries pointing towards the bridge device that are not local/permanent:  ip link add br0 type bridge bridge fdb add 00:01:02:03:04:05 dev br0 self extern_learn static  2. Entries pointing towards the bridge device or towards a port that are marked as local/permanent, however the bridge does not process the 'permanent' bit in any way, therefore they are recorded as though they aren't permanent:  ip link add br0 type bridge bridge fdb add 00:01:02:03:04:05 dev br0 self extern_learn permanent  Since commit 52e4bec15546 (""net: bridge: switchdev: treat local FDBs the same as entries towards the bridge""), these incorrect FDB entries can even trigger NULL pointer dereferences inside the kernel.  This is because that commit made the assumption that all FDB entries that are not local/permanent have a valid destination port. For context, local / permanent FDB entries either have fdb->dst == NULL, and these point towards the bridge device and are therefore local and not to be used for forwarding, or have fdb->dst == a net_bridge_port structure (but are to be treated in the same way, i.e. not for forwarding).  That assumption _is_ correct as long as things are working correctly in the bridge driver, i.e. we cannot logically have fdb->dst == NULL under any circumstance for FDB entries that are not local. However, the extern_learn code path where FDB entries are managed by a user space controller show that it is possible for the bridge kernel driver to misinterpret the NUD flags of an entry transmitted by user space, and end up having fdb->dst == NULL while not being a local entry. This is invalid and should be rejected.  Before, the two commands listed above both crashed the kernel in this check from br_switchdev_fdb_notify:  	struct net_device *dev = info.is_local ? br->dev : dst->dev;  info.is_local == false, dst == NULL.  After this patch, the invalid entry added by the first command is rejected:  ip link add br0 type bridge && bridge fdb add 00:01:02:03:04:05 dev br0 self extern_learn static; ip link del br0 Error: bridge: FDB entry towards bridge must be permanent.  and the valid entry added by the second command is properly treated as a local address and does not crash br_switchdev_fdb_notify anymore:  ip link add br0 type bridge && bridge fdb add 00:01:02:03:04:05 dev br0 self extern_learn permanent; ip link del br0  ",0541a6293298fb52789de389dfb27ef54df81f73,1
x86/kvm: Fix broken irq restoration in kvm_wait,"After commit 997acaf6b4b59c (lockdep: report broken irq restoration), the guest splatting below during boot:   raw_local_irq_restore() called with IRQs enabled  ",f4e61f0c9add3b00bd5f2df3c814d688849b8707,0
RDMA/ucma: Fix access to non-initialized CM_ID object,The attempt to join multicast group without ensuring that CMA device exists will lead to the following crash reported by syzkaller.  ,7688f2c3bbf55e52388e37ac5d63ca471a7712e1,1
ptr_ring: fail early if queue occupies more than KMALLOC_MAX_SIZE,"To avoid slab to warn about exceeded size, fail early if queue occupies more than KMALLOC_MAX_SIZE.  ",6e6e41c3112276288ccaf80c70916779b84bb276,0
fou6: Prevent unbounded recursion in GUE error handler,"I forgot to deal with IPv6 in commit 11789039da53 (""fou: Prevent unbounded recursion in GUE error handler"").  Now syzbot reported what might be the same type of issue, caused by gue6_err(), that is, handling exceptions for direct UDP encapsulation in GUE (UDP-in-UDP) leads to unbounded recursion in the GUE exception handler.  As it probably doesn't make sense to set up GUE this way, and it's currently not even possible to configure this, skip exception handling for UDP (or UDP-Lite) packets encapsulated in UDP (or UDP-Lite) packets with GUE on IPv6.  ",44039e00171b0fe930c07ff7b43e6023eaf1ed31,1
cfg80211: limit wiphy names to 128 bytes,"There's currently no limit on wiphy names, other than netlink message size and memory limitations, but that causes issues when, for example, the wiphy name is used in a uevent, e.g. in rfkill where we use the same name for the rfkill instance, and then the buffer there is ""only"" 2k for the environment variables.  This was reported by syzkaller, which used a 4k name.  Limit the name to something reasonable, I randomly picked 128.  ",a7cfebcb7594a24609268f91299ab85ba064bf82,1
ipv6: avoid lockdep issue in fib6_del(),"syzbot reported twice a lockdep issue in fib6_del() [1] which I think is caused by net->ipv6.fib6_null_entry having a NULL fib6_table pointer.  fib6_del() already checks for fib6_null_entry special case, we only need to return earlier.  Bug seems to occur very rarely, I have thus chosen a 'bug origin' that makes backports not too complex.  [1] ",843d926b003ea692468c8cc5bea1f9f58dfa8c75,0
io_uring: fix double io_uring free,"Once we created a file for current context during setup, we should not call io_ring_ctx_wait_and_kill() directly as it'll be done by fput(file)  ",9faadcc8abe4b83d0263216dc3a6321d5bbd616b,0
"io_uring: fix possible deadlock between io_uring_{enter,register}","If we have multiple threads, one doing io_uring_enter() while the other is doing io_uring_register(), we can run into a deadlock between the two. io_uring_register() must wait for existing users of the io_uring instance to exit. But it does so while holding the io_uring mutex. Callers of io_uring_enter() may need this mutex to make progress (and eventually exit). If we wait for users to exit in io_uring_register(), we can't do so with the io_uring mutex held without potentially risking a deadlock.  Drop the io_uring mutex while waiting for existing callers to exit. This is safe and guaranteed to make forward progress, since we already killed the percpu ref before doing so. Hence later callers of io_uring_enter() will be rejected.  ",b19062a567266ee1f10f6709325f766bbcc07d1c,0
crypto: af_alg - remove locking in async callback,"The code paths protected by the socket-lock do not use or modify the socket in a non-atomic fashion. The actions pertaining the socket do not even need to be handled as an atomic operation. Thus, the socket-lock can be safely ignored.  This fixes a bug regarding scheduling in atomic as the callback function may be invoked in interrupt context.  In addition, the sock_hold is moved before the AIO encrypt/decrypt operation to ensure that the socket is always present. This avoids a tiny race window where the socket is unprotected and yet used by the AIO operation.  Finally, the release of resources for a crypto operation is moved into a common function of af_alg_free_resources.  ",7d2c3f54e6f646887d019faa45f35d6fe9fe82ce,1
KVM: x86: Handle SRCU initialization failure during page track init,"Check the return of init_srcu_struct(), which can fail due to OOM, when initializing the page track mechanism.  Lack of checking leads to a NULL pointer deref found by a modified syzkaller.  ",eb7511bf9182292ef1df1082d23039e856d1ddfb,1
ipv4: ensure rcu_read_lock() in ipv4_link_failure(),fib_compute_spec_dst() needs to be called under rcu protection.  syzbot reported :  ,c543cb4a5f07e09237ec0fc2c60c9f131b2c79ad,0
"can, slip: Protect tty->disc_data in write_wakeup and close with RCU","write_wakeup can happen in parallel with close/hangup where tty->disc_data is set to NULL and the netdevice is freed thus also freeing disc_data. write_wakeup accesses disc_data so we must prevent close from freeing the netdev while write_wakeup has a non-NULL view of tty->disc_data.  We also need to make sure that accesses to disc_data are atomic. Which can all be done with RCU.  This problem was found by Syzkaller on SLCAN, but the same issue is reproducible with the SLIP line discipline using an LTP test based on the Syzkaller reproducer.  A fix which didn't use RCU was posted by Hillf Danton.  ",0ace17d56824165c7f4c68785d6b58971db954dd,0
ext4: Add error handling for io_end_vec struct allocation,This patch adds the error handling in case of any memory allocation failure for io_end_vec. This was missing in original patch series which enables dioread_nolock for blocksize < pagesize.  ,4d06bfb97ecb0df4f5b057a73db002e28c22c35c,1
xfrm: policy: avoid warning splat when merging nodes,"syzbot reported a splat:  xfrm_policy_inexact_list_reinsert+0x625/0x6e0 net/xfrm/xfrm_policy.c:877  CPU: 1 PID: 6756 Comm: syz-executor.1 Not tainted 5.3.0-rc2+ #57  Call Trace:   xfrm_policy_inexact_node_reinsert net/xfrm/xfrm_policy.c:922 [inline]   xfrm_policy_inexact_node_merge net/xfrm/xfrm_policy.c:958 [inline]   xfrm_policy_inexact_insert_node+0x537/0xb50 net/xfrm/xfrm_policy.c:1023   xfrm_policy_inexact_alloc_chain+0x62b/0xbd0 net/xfrm/xfrm_policy.c:1139   xfrm_policy_inexact_insert+0xe8/0x1540 net/xfrm/xfrm_policy.c:1182   xfrm_policy_insert+0xdf/0xce0 net/xfrm/xfrm_policy.c:1574   xfrm_add_policy+0x4cf/0x9b0 net/xfrm/xfrm_user.c:1670   xfrm_user_rcv_msg+0x46b/0x720 net/xfrm/xfrm_user.c:2676   netlink_rcv_skb+0x1f0/0x460 net/netlink/af_netlink.c:2477   xfrm_netlink_rcv+0x74/0x90 net/xfrm/xfrm_user.c:2684   netlink_unicast_kernel net/netlink/af_netlink.c:1302 [inline]   netlink_unicast+0x809/0x9a0 net/netlink/af_netlink.c:1328   netlink_sendmsg+0xa70/0xd30 net/netlink/af_netlink.c:1917   sock_sendmsg_nosec net/socket.c:637 [inline]   sock_sendmsg net/socket.c:657 [inline]  There is no reproducer, however, the warning can be reproduced by adding rules with ever smaller prefixes.  The sanity check (""does the policy match the node"") uses the prefix value of the node before its updated to the smaller value.  To fix this, update the prefix earlier.  The bug has no impact on tree correctness, this is only to prevent a false warning.  ",769a807d0b41df4201dbeb01c22eaeb3e5905532,1
crypto: dh - Fix double free of ctx->p,"When setting the secret with the software Diffie-Hellman implementation, if allocating 'g' failed (e.g. if it was longer than MAX_EXTERN_MPI_BITS), then 'p' was freed twice: once immediately, and once later when the crypto_kpp tfm was destroyed.  Fix it by using dh_free_ctx() (renamed to dh_clear_ctx()) in the error paths, as that correctly sets the pointers to NULL.  KASAN report:      MPI: mpi too large (32760 bits)     ",12d41a023efb01b846457ccdbbcbe2b65a87d530,1
xfrm: interface: not xfrmi_ipv6/ipip_handler twice,"As we did in the last 2 patches for vti(6), this patch is to define a new xfrm_tunnel object 'xfrmi_ipip6_handler' to register for AF_INET6, and a new xfrm6_tunnel object 'xfrmi_ip6ip_handler' to register for AF_INET.  ",8b404f46dd6ab845d0fa794679329d4089281ccb,0
oom: decouple mems_allowed from oom_unkillable_task,"Commit ef08e3b4981a (""[PATCH] cpusets: confine oom_killer to mem_exclusive cpuset"") introduces a heuristic where a potential oom-killer victim is skipped if the intersection of the potential victim and the current (the process triggered the oom) is empty based on the reason that killing such victim most probably will not help the current allocating process.  However the commit 7887a3da753e (""[PATCH] oom: cpuset hint"") changed the heuristic to just decrease the oom_badness scores of such potential victim based on the reason that the cpuset of such processes might have changed and previously they may have allocated memory on mems where the current allocating process can allocate from.  Unintentionally 7887a3da753e (""[PATCH] oom: cpuset hint"") introduced a side effect as the oom_badness is also exposed to the user space through /proc/[pid]/oom_score, so, readers with different cpusets can read different oom_score of the same process.  Later, commit 6cf86ac6f36b (""oom: filter tasks not sharing the same cpuset"") fixed the side effect introduced by 7887a3da753e by moving the cpuset intersection back to only oom-killer context and out of oom_badness.  However the combination of ab290adbaf8f (""oom: make oom_unkillable_task() helper function"") and 26ebc984913b (""oom: /proc/<pid>/oom_score treat kernel thread honestly"") unintentionally brought back the cpuset intersection check into the oom_badness calculation function.  Other than doing cpuset/mempolicy intersection from oom_badness, the memcg oom context is also doing cpuset/mempolicy intersection which is quite wrong and is caught by syzcaller with the following report:  kasan: CONFIG_KASAN_INLINE enabled kasan: GPF could be caused by NULL-ptr deref or user memory access general protection fault: 0000 [#1] PREEMPT SMP KASAN CPU: 0 PID: 28426 Comm: syz-executor.5 Not tainted 5.2.0-rc3-next-20190607 Hardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 01/01/2011 ",ac311a14c682dcd8a120a6244d0542ec654e3d93,1
"workqueue, lockdep: Fix an alloc_workqueue() error path","This patch fixes a use-after-free and a memory leak in an alloc_workqueue() error path.  Repoted by syzkaller and KASAN:    BUG: KASAN: use-after-free in __read_once_size include/linux/compiler.h:197 [inline]   BUG: KASAN: use-after-free in lockdep_register_key+0x3b9/0x490 kernel/locking/lockdep.c:1023   Read of size 8 at addr ffff888090fc2698 by task syz-executor134/7858    CPU: 1 PID: 7858 Comm: syz-executor134 Not tainted 5.0.0-rc8-next-20190301 #1   Hardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 01/01/2011   Call Trace:    __dump_stack lib/dump_stack.c:77 [inline]    dump_stack+0x172/0x1f0 lib/dump_stack.c:113    print_address_description.cold+0x7c/0x20d mm/kasan/report.c:187    kasan_report.cold+0x1b/0x40 mm/kasan/report.c:317    __asan_report_load8_noabort+0x14/0x20 mm/kasan/generic_report.c:132    __read_once_size include/linux/compiler.h:197 [inline]    lockdep_register_key+0x3b9/0x490 kernel/locking/lockdep.c:1023    wq_init_lockdep kernel/workqueue.c:3444 [inline]    alloc_workqueue+0x427/0xe70 kernel/workqueue.c:4263    ucma_open+0x76/0x290 drivers/infiniband/core/ucma.c:1732    misc_open+0x398/0x4c0 drivers/char/misc.c:141    chrdev_open+0x247/0x6b0 fs/char_dev.c:417    do_dentry_open+0x488/0x1160 fs/open.c:771    vfs_open+0xa0/0xd0 fs/open.c:880    do_last fs/namei.c:3416 [inline]    path_openat+0x10e9/0x46e0 fs/namei.c:3533    do_filp_open+0x1a1/0x280 fs/namei.c:3563    do_sys_open+0x3fe/0x5d0 fs/open.c:1063    __do_sys_openat fs/open.c:1090 [inline]    __se_sys_openat fs/open.c:1084 [inline]    __x64_sys_openat+0x9d/0x100 fs/open.c:1084    do_syscall_64+0x103/0x610 arch/x86/entry/common.c:290    entry_SYSCALL_64_after_hwframe+0x49/0xbe    Allocated by task 7789:    save_stack+0x45/0xd0 mm/kasan/common.c:75    set_track mm/kasan/common.c:87 [inline]    __kasan_kmalloc mm/kasan/common.c:497 [inline]    __kasan_kmalloc.constprop.0+0xcf/0xe0 mm/kasan/common.c:470    kasan_kmalloc+0x9/0x10 mm/kasan/common.c:511    __do_kmalloc mm/slab.c:3726 [inline]    __kmalloc+0x15c/0x740 mm/slab.c:3735    kmalloc include/linux/slab.h:553 [inline]    kzalloc include/linux/slab.h:743 [inline]    alloc_workqueue+0x13c/0xe70 kernel/workqueue.c:4236    ucma_open+0x76/0x290 drivers/infiniband/core/ucma.c:1732    misc_open+0x398/0x4c0 drivers/char/misc.c:141    chrdev_open+0x247/0x6b0 fs/char_dev.c:417    do_dentry_open+0x488/0x1160 fs/open.c:771    vfs_open+0xa0/0xd0 fs/open.c:880    do_last fs/namei.c:3416 [inline]    path_openat+0x10e9/0x46e0 fs/namei.c:3533    do_filp_open+0x1a1/0x280 fs/namei.c:3563    do_sys_open+0x3fe/0x5d0 fs/open.c:1063    __do_sys_openat fs/open.c:1090 [inline]    __se_sys_openat fs/open.c:1084 [inline]    __x64_sys_openat+0x9d/0x100 fs/open.c:1084    do_syscall_64+0x103/0x610 arch/x86/entry/common.c:290    entry_SYSCALL_64_after_hwframe+0x49/0xbe    Freed by task 7789:    save_stack+0x45/0xd0 mm/kasan/common.c:75    set_track mm/kasan/common.c:87 [inline]    __kasan_slab_free+0x102/0x150 mm/kasan/common.c:459    kasan_slab_free+0xe/0x10 mm/kasan/common.c:467    __cache_free mm/slab.c:3498 [inline]    kfree+0xcf/0x230 mm/slab.c:3821    alloc_workqueue+0xc3e/0xe70 kernel/workqueue.c:4295    ucma_open+0x76/0x290 drivers/infiniband/core/ucma.c:1732    misc_open+0x398/0x4c0 drivers/char/misc.c:141    chrdev_open+0x247/0x6b0 fs/char_dev.c:417    do_dentry_open+0x488/0x1160 fs/open.c:771    vfs_open+0xa0/0xd0 fs/open.c:880    do_last fs/namei.c:3416 [inline]    path_openat+0x10e9/0x46e0 fs/namei.c:3533    do_filp_open+0x1a1/0x280 fs/namei.c:3563    do_sys_open+0x3fe/0x5d0 fs/open.c:1063    __do_sys_openat fs/open.c:1090 [inline]    __se_sys_openat fs/open.c:1084 [inline]    __x64_sys_openat+0x9d/0x100 fs/open.c:1084    do_syscall_64+0x103/0x610 arch/x86/entry/common.c:290    entry_SYSCALL_64_after_hwframe+0x49/0xbe    The buggy address belongs to the object at ffff888090fc2580    which belongs to the cache kmalloc-512 of size 512   The buggy address is located 280 bytes inside of    512-byte region [ffff888090fc2580, ffff888090fc2780)  ",009bb421b6ceb7916ce627023d0eb7ced04c8910,1
ipv6: remove extra dev_hold() for fallback tunnels,"My previous commits added a dev_hold() in tunnels ndo_init(), but forgot to remove it from special functions setting up fallback tunnels.  Fallback tunnels do call their respective ndo_init()  This leads to various reports like :  unregister_netdevice: waiting for ip6gre0 to become free. Usage count = 2  ",0d7a7b2014b1a499a0fe24c9f3063d7856b5aaaf,0
drm/fb-helper: only unmap if buffer not null,"drm_fbdev_cleanup() can be called when fb_helper->buffer is null, hence fb_helper->buffer should be checked before calling drm_client_buffer_vunmap(). This buffer is also checked in drm_client_framebuffer_delete(), so we should also do the same thing for drm_client_buffer_vunmap().  ",874a52f9b693ed8bf7a92b3592a547ce8a684e6f,0
mm/gup: Mark lock taken only after a successful retake,It's definitely incorrect to mark the lock as taken even if down_read_killable() failed.  This wass overlooked when we switched from down_read() to down_read_killable() because down_read() won't fail while down_read_killable() could.  ,c7b6a566b98524baea6a244186e665d22b633545,0
USB: rio500: Remove Rio 500 kernel driver,The Rio500 kernel driver has not been used by Rio500 owners since 2001 not long after the rio500 project added support for a user-space USB stack through the very first versions of usbdevfs and then libusb.  Support for the kernel driver was removed from the upstream utilities in 2008: https://gitlab.freedesktop.org/hadess/rio500/commit/943f624ab721eb8281c287650fcc9e2026f6f5db  ,015664d15270a112c2371d812f03f7c579b35a73,0
udp: segment looped gso packets correctly,"Multicast and broadcast packets can be looped from egress to ingress pre segmentation with dev_loopback_xmit. That function unconditionally sets ip_summed to CHECKSUM_UNNECESSARY.  udp_rcv_segment segments gso packets in the udp rx path. Segmentation usually executes on egress, and does not expect packets of this type. __udp_gso_segment interprets !CHECKSUM_PARTIAL as CHECKSUM_NONE. But the offsets are not correct for gso_make_checksum.  UDP GSO packets are of type CHECKSUM_PARTIAL, with their uh->check set to the correct pseudo header checksum. Reset ip_summed to this type. (CHECKSUM_PARTIAL is allowed on ingress, see comments in skbuff.h)  ",6cd021a58c18a1731f7e47f83e172c0c302d65e5,0
mtd: break circular locks in register_mtd_blktrans,"Syzbot reported a circular locking dependency: https://syzkaller.appspot.com/bug?id=7bd106c28e846d1023d4ca915718b1a0905444cb  This happens because of the following lock dependencies:  1. loop_ctl_mutex -> bdev->bd_mutex (when loop_control_ioctl calls loop_remove, which then calls del_gendisk; this also happens in loop_exit which eventually calls loop_remove)  2. bdev->bd_mutex -> mtd_table_mutex (when blkdev_get_by_dev calls __blkdev_get, which then calls blktrans_open)  3. mtd_table_mutex -> major_names_lock (when register_mtd_blktrans calls __register_blkdev)  4. major_names_lock -> loop_ctl_mutex (when blk_request_module calls loop_probe)  Hence there's an overall dependency of:  loop_ctl_mutex   ",962bf783ef65d15b0f8ca9c33342cf3b20bf0d2e,1
"mm, mempolicy: fix uninit memory access",Syzbot with KMSAN reports (excerpt):  ,2e25644e8da4ed3a27e7b8315aaae74660be72dc,0
bpf: in __bpf_redirect_no_mac pull mac only if present,"Syzkaller was able to construct a packet of negative length by redirecting from bpf_prog_test_run_skb with BPF_PROG_TYPE_LWT_XMIT:      BUG: KASAN: slab-out-of-bounds in memcpy include/linux/string.h:345 [inline]     BUG: KASAN: slab-out-of-bounds in skb_copy_from_linear_data include/linux/skbuff.h:3421 [inline]     BUG: KASAN: slab-out-of-bounds in __pskb_copy_fclone+0x2dd/0xeb0 net/core/skbuff.c:1395     Read of size 4294967282 at addr ffff8801d798009c by task syz-executor2/12942      kasan_report.cold.9+0x242/0x309 mm/kasan/report.c:412     check_memory_region_inline mm/kasan/kasan.c:260 [inline]     check_memory_region+0x13e/0x1b0 mm/kasan/kasan.c:267     memcpy+0x23/0x50 mm/kasan/kasan.c:302     memcpy include/linux/string.h:345 [inline]     skb_copy_from_linear_data include/linux/skbuff.h:3421 [inline]     __pskb_copy_fclone+0x2dd/0xeb0 net/core/skbuff.c:1395     __pskb_copy include/linux/skbuff.h:1053 [inline]     pskb_copy include/linux/skbuff.h:2904 [inline]     skb_realloc_headroom+0xe7/0x120 net/core/skbuff.c:1539     ipip6_tunnel_xmit net/ipv6/sit.c:965 [inline]     sit_tunnel_xmit+0xe1b/0x30d0 net/ipv6/sit.c:1029     __netdev_start_xmit include/linux/netdevice.h:4325 [inline]     netdev_start_xmit include/linux/netdevice.h:4334 [inline]     xmit_one net/core/dev.c:3219 [inline]     dev_hard_start_xmit+0x295/0xc90 net/core/dev.c:3235     __dev_queue_xmit+0x2f0d/0x3950 net/core/dev.c:3805     dev_queue_xmit+0x17/0x20 net/core/dev.c:3838     __bpf_tx_skb net/core/filter.c:2016 [inline]     __bpf_redirect_common net/core/filter.c:2054 [inline]     __bpf_redirect+0x5cf/0xb20 net/core/filter.c:2061     ____bpf_clone_redirect net/core/filter.c:2094 [inline]     bpf_clone_redirect+0x2f6/0x490 net/core/filter.c:2066     bpf_prog_41f2bcae09cd4ac3+0xb25/0x1000  The generated test constructs a packet with mac header, network header, skb->data pointing to network header and skb->len 0.  Redirecting to a sit0 through __bpf_redirect_no_mac pulls the mac length, even though skb->data already is at skb->network_header. bpf_prog_test_run_skb has already pulled it as LWT_XMIT !is_l2.  Update the offset calculation to pull only if skb->data differs from skb->network_header, which is not true in this case.  The test itself can be run only from commit 1cf1cae963c2 (""bpf: introduce BPF_PROG_TEST_RUN command""), but the same type of packets with skb at network header could already be built from lwt xmit hooks, so this fix is more relevant to that commit.  Also set the mac header on redirect from LWT_XMIT, as even after this change to __bpf_redirect_no_mac that field is expected to be set, but is not yet in ip_finish_output2.  ",e7c87bd6cc4ec7b0ac1ed0a88a58f8206c577488,1
ALSA: seq: Avoid invalid lockdep class warning,"The recent fix for adding rwsem nesting annotation was using the given ""hop"" argument as the lock subclass key.  Although the idea itself works, it may trigger a kernel warning like:   BUG: looking up invalid subclass: 8   .... since the lockdep has a smaller number of subclasses (8) than we currently allow for the hops there (10).  The current definition is merely a sanity check for avoiding the too deep delivery paths, and the 8 hops are already enough.  So, as a quick fix, just follow the max hops as same as the max lockdep subclasses.  ",3510c7aa069aa83a2de6dab2b41401a198317bdc,1
sctp: change to hold sk after auth shkey is created successfully,"Now in sctp_endpoint_init(), it holds the sk then creates auth shkey. But when the creation fails, it doesn't release the sk, which causes a sk defcnf leak,  Here to fix it by only holding the sk when auth shkey is created successfully.  ",25bff6d5478b2a02368097015b7d8eb727c87e16,0
net: use listified RX for handling GRO_NORMAL skbs,"When GRO decides not to coalesce a packet, in napi_frags_finish(), instead  of passing it to the stack immediately, place it on a list in the napi  struct.  Then, at flush time (napi_complete_done(), napi_poll(), or  napi_busy_loop()), call netif_receive_skb_list_internal() on the list. We'd like to do that in napi_gro_flush(), but it's not called if  !napi->gro_bitmask, so we have to do it in the callers instead.  (There are  a handful of drivers that call napi_gro_flush() themselves, but it's not  clear why, or whether this will affect them.) Because a full 64 packets is an inefficiently large batch, also consume the  list whenever it exceeds gro_normal_batch, a new net/core sysctl that  defaults to 8.  ",323ebb61e32b478e2432c5a3cbf9e2ca678a9609,1
batman-adv: Don't schedule OGM for disabled interface,A transmission scheduling for an interface which is currently dropped by batadv_iv_ogm_iface_disable could still be in progress. The B.A.T.M.A.N. V is simply cancelling the workqueue item in an synchronous way but this is not possible with B.A.T.M.A.N. IV because the OGM submissions are intertwined.  Instead it has to stop submitting the OGM when it detect that the buffer pointer is set to NULL.  ,8e8ce08198de193e3d21d42e96945216e3d9ac7f,0
mm/page_alloc: avoid page allocator recursion with pagesets.lock held,"Syzbot is reporting potential deadlocks due to pagesets.lock when PAGE_OWNER is enabled.  One example from Desmond Cheong Zhi Xi is as follows    __alloc_pages_bulk()     local_lock_irqsave(&pagesets.lock, flags) <",187ad460b8413e863c951998cb321a117a717868,0
fuse: set FR_SENT while locked,"Otherwise fuse_dev_do_write() could come in and finish off the request, and the set_bit(FR_SENT, ...) could trigger the WARN_ON(test_bit(FR_SENT, ...)) in request_end().  ",4c316f2f3ff315cb48efb7435621e5bfb81df96d,0
tipc: fix using smp_processor_id() in preemptible,"The 'this_cpu_ptr()' is used to obtain the AEAD key' TFM on the current CPU for encryption, however the execution can be preemptible since it's actually user-space context, so the 'using smp_processor_id() in preemptible' has been observed.  We fix the issue by using the 'get/put_cpu_ptr()' API which consists of a 'preempt_disable()' instead.  ",bb8872a1e6bc911869a729240781076ed950764b,0
btrfs: fix mount and ioctl device scan ioctl race,Technically this extends the critical section covered by uuid_mutex to:  - parse early mount options -- here we can call device scan on paths   that can be passed as 'device=/dev/...'  - scan the device passed to mount  - open the devices related to the fs_devices -- this increases   fs_devices::opened  The race can happen when mount calls one of the scans and there's another one called eg. by mkfs or 'btrfs dev scan':  Mount                                  Scan ,81ffd56b5745355b70d54ca4e1bdd0d64a66ff9f,1
media: em28xx: add missing em28xx_close_extension,"If em28xx dev has ->dev_next pointer, we need to delete ->dev_next list node from em28xx_extension_devlist on disconnect to avoid UAF bugs and corrupted list bugs, since driver frees this pointer on disconnect.  ",2c98b8a3458df03abdc6945bbef67ef91d181938,0
net/smc: cancel event worker during device removal,"During IB device removal, cancel the event worker before the device structure is freed.  ",ece0d7bd74615773268475b6b64d6f1ebbd4b4c6,0
net_sched: fix a memory leak in atm_tc_init(),"When tcf_block_get() fails inside atm_tc_init(), atm_tc_put() is called to release the qdisc p->link.q. But the flow->ref prevents it to do so, as the flow->ref is still zero.  Fix this by moving the p->link.ref initialization before tcf_block_get().  ",306381aec7c2b5a658eebca008c8a1b666536cba,1
netfilter: ipv6: fix use-after-free Write in nf_nat_ipv6_manip_pkt,l4proto->manip_pkt() can cause reallocation of skb head so pointer to the ipv6 header must be reloaded.  ,b078556aecd791b0e5cb3a59f4c3a14273b52121,1
ethtool: fix null-ptr-deref on ref tracker,"dev can be a NULL here, not all requests set require_dev.  ",0976b888a150476ba955ce4765858824c633cfd2,0
sctp: use memdup_user instead of vmemdup_user,"In sctp_setsockopt_bindx()/__sctp_setsockopt_connectx(), it allocates memory with addrs_size which is passed from userspace. We used flag GFP_USER to put some more restrictions on it in Commit cacc06215271 (""sctp: use GFP_USER for user-controlled kmalloc"").  However, since Commit c981f254cc82 (""sctp: use vmemdup_user() rather than badly open-coding memdup_user()""), vmemdup_user() has been used, which doesn't check GFP_USER flag when goes to vmalloc_*(). So when addrs_size is a huge value, it could exhaust memory and even trigger oom killer.  This patch is to use memdup_user() instead, in which GFP_USER would work to limit the memory allocation with a huge addrs_size.  Note we can't fix it by limiting 'addrs_size', as there's no demand for it from RFC.  ",ef82bcfa671b9a635bab5fa669005663d8b177c5,0
media: v4l2-tpg: array index could become negative,"text[s] is a signed char, so using that as index into the font8x16 array can result in negative indices. Cast it to u8 to be safe.  ",e5f71a27fa12c1a1b02ad478a568e76260f1815e,0
mptcp: add dummy icsk_sync_mss(),"syzbot noted that the master MPTCP socket lacks the icsk_sync_mss callback, and was able to trigger a null pointer dereference:  BUG: kernel NULL pointer dereference, ",dc24f8b4ecd3d6c4153a1ec1bc2006ab32a41b8d,1
io_uring: check for validity of ->rings in teardown,"Normally the rings are always valid, the exception is if we failed to allocate the rings at setup time. syzbot reports this:  ",15dff286d0e0087d4dcd7049911f179e4e4cfd94,0
net: dccp: avoid crash in ccid3_hc_rx_send_feedback(),"On fast hosts or malicious bots, we trigger a DCCP_BUG() which seems excessive.  syzbot reported :  BUG: delta (-6195) <= 0 at net/dccp/ccids/ccid3.c:628/ccid3_hc_rx_send_feedback() CPU: 1 PID: 18 Comm: ksoftirqd/1 Not tainted 4.18.0-rc1+ #112 Hardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 01/01/2011 Call Trace:  __dump_stack lib/dump_stack.c:77 [inline]  dump_stack+0x1c9/0x2b4 lib/dump_stack.c:113  ccid3_hc_rx_send_feedback net/dccp/ccids/ccid3.c:628 [inline]  ccid3_hc_rx_packet_recv.cold.16+0x38/0x71 net/dccp/ccids/ccid3.c:793  ccid_hc_rx_packet_recv net/dccp/ccid.h:185 [inline]  dccp_deliver_input_to_ccids+0xf0/0x280 net/dccp/input.c:180  dccp_rcv_established+0x87/0xb0 net/dccp/input.c:378  dccp_v4_do_rcv+0x153/0x180 net/dccp/ipv4.c:654  sk_backlog_rcv include/net/sock.h:914 [inline]  __sk_receive_skb+0x3ba/0xd80 net/core/sock.c:517  dccp_v4_rcv+0x10f9/0x1f58 net/dccp/ipv4.c:875  ip_local_deliver_finish+0x2eb/0xda0 net/ipv4/ip_input.c:215  NF_HOOK include/linux/netfilter.h:287 [inline]  ip_local_deliver+0x1e9/0x750 net/ipv4/ip_input.c:256  dst_input include/net/dst.h:450 [inline]  ip_rcv_finish+0x823/0x2220 net/ipv4/ip_input.c:396  NF_HOOK include/linux/netfilter.h:287 [inline]  ip_rcv+0xa18/0x1284 net/ipv4/ip_input.c:492  __netif_receive_skb_core+0x2488/0x3680 net/core/dev.c:4628  __netif_receive_skb+0x2c/0x1e0 net/core/dev.c:4693  process_backlog+0x219/0x760 net/core/dev.c:5373  napi_poll net/core/dev.c:5771 [inline]  net_rx_action+0x7da/0x1980 net/core/dev.c:5837  __do_softirq+0x2e8/0xb17 kernel/softirq.c:284  run_ksoftirqd+0x86/0x100 kernel/softirq.c:645  smpboot_thread_fn+0x417/0x870 kernel/smpboot.c:164  kthread+0x345/0x410 kernel/kthread.c:240  ret_from_fork+0x3a/0x50 arch/x86/entry/entry_64.S:412  ",74174fe5634ffbf645a7ca5a261571f700b2f332,1
io_uring: cleanup fixed file data table references,"syzbot reports a use-after-free in io_ring_file_ref_switch() when it tries to switch back to percpu mode. When we put the final reference to the table by calling percpu_ref_kill_and_confirm(), we don't want the zero reference to queue async work for flushing the potentially queued up items. We currently do a few flush_work(), but they merely paper around the issue, since the work item may not have been queued yet depending on the when the percpu-ref callback gets run.  Coming into the file unregister, we know we have the ring quiesced. io_ring_file_ref_switch() can check for whether or not the ref is dying or not, and not queue anything async at that point. Once the ref has been confirmed killed, flush any potential items manually.  ",2faf852d1be8a4960d328492298da6448cca0279,1
net: ensure mac header is set in virtio_net_hdr_to_skb(),"Commit 924a9bc362a5 (""net: check if protocol extracted by virtio_net_hdr_set_proto is correct"") added a call to dev_parse_header_protocol() but mac_header is not yet set.  This means that eth_hdr() reads complete garbage, and syzbot complained about it [1]  This patch resets mac_header earlier, to get more coverage about this change.  Audit of virtio_net_hdr_to_skb() callers shows that this change should be safe.  [1]  BUG: KASAN: use-after-free in eth_header_parse_protocol+0xdc/0xe0 net/ethernet/eth.c:282 Read of size 2 at addr ffff888017a6200b by task syz-executor313/8409  CPU: 1 PID: 8409 Comm: syz-executor313 Not tainted 5.12.0-rc2-syzkaller #0 Hardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 01/01/2011 Call Trace:  __dump_stack lib/dump_stack.c:79 [inline]  dump_stack+0x141/0x1d7 lib/dump_stack.c:120  print_address_description.constprop.0.cold+0x5b/0x2f8 mm/kasan/report.c:232  __kasan_report mm/kasan/report.c:399 [inline]  kasan_report.cold+0x7c/0xd8 mm/kasan/report.c:416  eth_header_parse_protocol+0xdc/0xe0 net/ethernet/eth.c:282  dev_parse_header_protocol include/linux/netdevice.h:3177 [inline]  virtio_net_hdr_to_skb.constprop.0+0x99d/0xcd0 include/linux/virtio_net.h:83  packet_snd net/packet/af_packet.c:2994 [inline]  packet_sendmsg+0x2325/0x52b0 net/packet/af_packet.c:3031  sock_sendmsg_nosec net/socket.c:654 [inline]  sock_sendmsg+0xcf/0x120 net/socket.c:674  sock_no_sendpage+0xf3/0x130 net/core/sock.c:2860  kernel_sendpage.part.0+0x1ab/0x350 net/socket.c:3631  kernel_sendpage net/socket.c:3628 [inline]  sock_sendpage+0xe5/0x140 net/socket.c:947  pipe_to_sendpage+0x2ad/0x380 fs/splice.c:364  splice_from_pipe_feed fs/splice.c:418 [inline]  __splice_from_pipe+0x43e/0x8a0 fs/splice.c:562  splice_from_pipe fs/splice.c:597 [inline]  generic_splice_sendpage+0xd4/0x140 fs/splice.c:746  do_splice_from fs/splice.c:767 [inline]  do_splice+0xb7e/0x1940 fs/splice.c:1079  __do_splice+0x134/0x250 fs/splice.c:1144  __do_sys_splice fs/splice.c:1350 [inline]  __se_sys_splice fs/splice.c:1332 [inline]  __x64_sys_splice+0x198/0x250 fs/splice.c:1332  do_syscall_64+0x2d/0x70 arch/x86/entry/common.c:46  ",61431a5907fc36d0738e9a547c7e1556349a03e9,1
net/smc: postpone release of clcsock,According to RFC7609 (http://www.rfc-editor.org/info/rfc7609) first the SMC-R connection is shut down and then the normal TCP connection FIN processing drives cleanup of the internal TCP connection. The unconditional release of the clcsock during active socket closing has to be postponed if the peer has not yet signalled socket closing.  ,b03faa1fafc8018295401dc558bdc76362d860a4,0
vhost: fix info leak due to uninitialized memory,"struct vhost_msg within struct vhost_msg_node is copied to userspace. Unfortunately it turns out on 64 bit systems vhost_msg has padding after type which gcc doesn't initialize, leaking 4 uninitialized bytes to userspace.  This padding also unfortunately means 32 bit users of this interface are broken on a 64 bit kernel which will need to be fixed separately.  ",670ae9caaca467ea1bfd325cb2a5c98ba87f94ad,1
sctp: check policy more carefully when getting pr status,"When getting pr_assocstatus and pr_streamstatus by sctp_getsockopt, it doesn't correctly process the case when policy is set with SCTP_PR_SCTP_ALL | SCTP_PR_SCTP_MASK. It even causes a slab-out-of-bounds in sctp_getsockopt_pr_streamstatus().  This patch fixes it by return -EINVAL for this case.  ",713358369382cebf92f6e98ce2005f94e7344931,1
bdev: Fixup error handling in blkdev_get(),"Commit 89e524c04fa9 (""loop: Fix mount(2) failure due to race with LOOP_SET_FD"") converted blkdev_get() to use the new helpers for finishing claiming of a block device. However the conversion botched the error handling in blkdev_get() and thus the bdev has been marked as held even in case __blkdev_get() returned error. This led to occasional warnings with block/001 test from blktests like:  kernel: ",e91455bad5cff40a8c232f2204a5104127e3fec2,1
bonding: remove useless stats_lock_key,"After commit b3e80d44f5b1 (""bonding: fix lockdep warning in bond_get_stats()"") the dynamic key is no longer necessary, as we compute nest level at run-time. So, we can just remove it to save some lockdep key entries.  Test commands:  ip link add bond0 type bond  ip link add bond1 type bond  ip link set bond0 master bond1  ip link set bond0 nomaster  ip link set bond1 master bond0  ",e7511f560f5499c664c1ba9181c76044e2af578d,0
nbd: handle device refs for DESTROY_ON_DISCONNECT properly,"There exists a race where we can be attempting to create a new nbd configuration while a previous configuration is going down, both configured with DESTROY_ON_DISCONNECT.  Normally devices all have a reference of 1, as they won't be cleaned up until the module is torn down.  However with DESTROY_ON_DISCONNECT we'll make sure that there is only 1 reference (generally) on the device for the config itself, and then once the config is dropped, the device is torn down.  The race that exists looks like this  TASK1					TASK2 nbd_genl_connect()   idr_find()     refcount_inc_not_zero(nbd)       * count is 2 here ^^ 					nbd_config_put() 					  nbd_put(nbd) (count is 1)     setup new config       check DESTROY_ON_DISCONNECT 	put_dev = true     if (put_dev) nbd_put(nbd) 	* free'd here ^^  In nbd_genl_connect() we assume that the nbd ref count will be 2, however clearly that won't be true if the nbd device had been setup as DESTROY_ON_DISCONNECT with its prior configuration.  Fix this by getting rid of the runtime flag to check if we need to mess with the nbd device refcount, and use the device NBD_DESTROY_ON_DISCONNECT flag to check if we need to adjust the ref counts.  This was reported by syzkaller with the following kasan dump  BUG: KASAN: use-after-free in instrument_atomic_read include/linux/instrumented.h:71 [inline] BUG: KASAN: use-after-free in atomic_read include/asm-generic/atomic-instrumented.h:27 [inline] BUG: KASAN: use-after-free in refcount_dec_not_one+0x71/0x1e0 lib/refcount.c:76 Read of size 4 at addr ffff888143bf71a0 by task systemd-udevd/8451  CPU: 0 PID: 8451 Comm: systemd-udevd Not tainted 5.11.0-rc7-syzkaller #0 Hardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 01/01/2011 Call Trace:  __dump_stack lib/dump_stack.c:79 [inline]  dump_stack+0x107/0x163 lib/dump_stack.c:120  print_address_description.constprop.0.cold+0x5b/0x2f8 mm/kasan/report.c:230  __kasan_report mm/kasan/report.c:396 [inline]  kasan_report.cold+0x79/0xd5 mm/kasan/report.c:413  check_memory_region_inline mm/kasan/generic.c:179 [inline]  check_memory_region+0x13d/0x180 mm/kasan/generic.c:185  instrument_atomic_read include/linux/instrumented.h:71 [inline]  atomic_read include/asm-generic/atomic-instrumented.h:27 [inline]  refcount_dec_not_one+0x71/0x1e0 lib/refcount.c:76  refcount_dec_and_mutex_lock+0x19/0x140 lib/refcount.c:115  nbd_put drivers/block/nbd.c:248 [inline]  nbd_release+0x116/0x190 drivers/block/nbd.c:1508  __blkdev_put+0x548/0x800 fs/block_dev.c:1579  blkdev_put+0x92/0x570 fs/block_dev.c:1632  blkdev_close+0x8c/0xb0 fs/block_dev.c:1640  __fput+0x283/0x920 fs/file_table.c:280  task_work_run+0xdd/0x190 kernel/task_work.c:140  tracehook_notify_resume include/linux/tracehook.h:189 [inline]  exit_to_user_mode_loop kernel/entry/common.c:174 [inline]  exit_to_user_mode_prepare+0x249/0x250 kernel/entry/common.c:201  __syscall_exit_to_user_mode_work kernel/entry/common.c:283 [inline]  syscall_exit_to_user_mode+0x19/0x50 kernel/entry/common.c:294  entry_SYSCALL_64_after_hwframe+0x44/0xa9 ",c9a2f90f4d6b9d42b9912f7aaf68e8d748acfffd,1
drm/vkms: fix misuse of WARN_ON,"vkms_vblank_simulate() uses WARN_ON for timing-dependent condition (timer overrun). This is a mis-use of WARN_ON, WARN_ON must be used to denote kernel bugs. Use pr_warn() instead.  ",b4142fc4d52d051d4d8df1fb6c569e5b445d369e,0
io_uring: Check current->io_uring in io_uring_cancel_sqpoll,"syzkaller identified KASAN: null-ptr-deref Write in io_uring_cancel_sqpoll.  io_uring_cancel_sqpoll is called by io_sq_thread before calling io_uring_alloc_task_context. This leads to current->io_uring being NULL. io_uring_cancel_sqpoll should not have to deal with threads where current->io_uring is NULL.  In order to cast a wider safety net, perform input sanitisation directly in io_uring_cancel_sqpoll and return for NULL value of current->io_uring. This is safe since if current->io_uring isn't set, then there's no way for the task to have submitted any requests.  ",6d042ffb598ed83e7d5623cc961d249def5b9829,1
erofs: fix shift-out-of-bounds of blkszbits,syzbot generated a crafted bitszbits which can be shifted out-of-bounds[1]. So directly print unsupported blkszbits instead of blksize.  [1] https://lore.kernel.org/r/000000000000c72ddd05b9444d2f@google.com  ,bde545295b710bdd13a0fcd4b9fddd2383eeeb3a,1
drm/vkms: Hold gem object while still in-use,"We need to keep the reference to the drm_gem_object until the last access by vkms_dumb_create.  Therefore, the put the object after it is used.  This fixes a use-after-free issue reported by syzbot.  While here, change vkms_gem_create() symbol to static.  ",0ea2ea42b31abc1141f2fd3911f952a97d401fcb,1
tcp: fix error recovery in tcp_zerocopy_receive(),"If user provides wrong virtual address in TCP_ZEROCOPY_RECEIVE operation we want to return -EINVAL error.  But depending on zc->recv_skip_hint content, we might return -EIO error if the socket has SOCK_DONE set.  Make sure to return -EINVAL in this case.  BUG: KMSAN: uninit-value in tcp_zerocopy_receive net/ipv4/tcp.c:1833 [inline] BUG: KMSAN: uninit-value in do_tcp_getsockopt+0x4494/0x6320 net/ipv4/tcp.c:3685 CPU: 1 PID: 625 Comm: syz-executor.0 Not tainted 5.7.0-rc4-syzkaller #0 Hardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 01/01/2011 Call Trace:  __dump_stack lib/dump_stack.c:77 [inline]  dump_stack+0x1c9/0x220 lib/dump_stack.c:118  kmsan_report+0xf7/0x1e0 mm/kmsan/kmsan_report.c:121  __msan_warning+0x58/0xa0 mm/kmsan/kmsan_instr.c:215  tcp_zerocopy_receive net/ipv4/tcp.c:1833 [inline]  do_tcp_getsockopt+0x4494/0x6320 net/ipv4/tcp.c:3685  tcp_getsockopt+0xf8/0x1f0 net/ipv4/tcp.c:3728  sock_common_getsockopt+0x13f/0x180 net/core/sock.c:3131  __sys_getsockopt+0x533/0x7b0 net/socket.c:2177  __do_sys_getsockopt net/socket.c:2192 [inline]  __se_sys_getsockopt+0xe1/0x100 net/socket.c:2189  __x64_sys_getsockopt+0x62/0x80 net/socket.c:2189  do_syscall_64+0xb8/0x160 arch/x86/entry/common.c:297  entry_SYSCALL_64_after_hwframe+0x44/0xa9 ",e776af608f692a7a647455106295fa34469e7475,1
net: ieee802154: forbid monitor for del llsec seclevel,This patch forbids to del llsec seclevel for monitor interfaces which we don't support yet. Otherwise we will access llsec mib which isn't initialized for monitors.  ,9dde130937e95b72adfae64ab21d6e7e707e2dac,0
mac80211: always wind down STA state,"When (for example) an IBSS station is pre-moved to AUTHORIZED before it's inserted, and then the insertion fails, we don't clean up the fast RX/TX states that might already have been created, since we don't go through all the state transitions again on the way down.  Do that, if it hasn't been done already, when the station is freed. I considered only freeing the fast TX/RX state there, but we might add more state so it's more robust to wind down the state properly.  Note that we warn if the station was ever inserted, it should have been properly cleaned up in that case, and the driver will probably not like things happening out of order.  ",dcd479e10a0510522a5d88b29b8f79ea3467d501,0
bpf: fix use after free in bpf_evict_inode,"syzkaller was able to generate the following UAF in bpf:    BUG: KASAN: use-after-free in lookup_last fs/namei.c:2269 [inline]   BUG: KASAN: use-after-free in path_lookupat.isra.43+0x9f8/0xc00 fs/namei.c:2318   Read of size 1 at addr ffff8801c4865c47 by task syz-executor2/9423    CPU: 0 PID: 9423 Comm: syz-executor2 Not tainted 4.20.0-rc1-next-20181109+   #110   Hardware name: Google Google Compute Engine/Google Compute Engine, BIOS   Google 01/01/2011   Call Trace:     __dump_stack lib/dump_stack.c:77 [inline]     dump_stack+0x244/0x39d lib/dump_stack.c:113     print_address_description.cold.7+0x9/0x1ff mm/kasan/report.c:256     kasan_report_error mm/kasan/report.c:354 [inline]     kasan_report.cold.8+0x242/0x309 mm/kasan/report.c:412     __asan_report_load1_noabort+0x14/0x20 mm/kasan/report.c:430     lookup_last fs/namei.c:2269 [inline]     path_lookupat.isra.43+0x9f8/0xc00 fs/namei.c:2318     filename_lookup+0x26a/0x520 fs/namei.c:2348     user_path_at_empty+0x40/0x50 fs/namei.c:2608     user_path include/linux/namei.h:62 [inline]     do_mount+0x180/0x1ff0 fs/namespace.c:2980     ksys_mount+0x12d/0x140 fs/namespace.c:3258     __do_sys_mount fs/namespace.c:3272 [inline]     __se_sys_mount fs/namespace.c:3269 [inline]     __x64_sys_mount+0xbe/0x150 fs/namespace.c:3269     do_syscall_64+0x1b9/0x820 arch/x86/entry/common.c:290     entry_SYSCALL_64_after_hwframe+0x49/0xbe   ",1da6c4d9140cb7c13e87667dc4e1488d6c8fc10f,1
squashfs: avoid out of bounds writes in decompressors,"Patch series ""Squashfs: fix BIO migration regression and add sanity checks"".  Patch [1/4] fixes a regression introduced by the ""migrate from ll_rw_block usage to BIO"" patch, which has produced a number of Sysbot/Syzkaller reports.  Patches [2/4], [3/4], and [4/4] fix a number of filesystem corruption issues which have produced Sysbot reports in the id, inode and xattr lookup code.  Each patch has been tested against the Sysbot reproducers using the given kernel configuration.  They have the appropriate """,e812cbbbbbb15adbbbee176baa1e8bda53059bf0,1
mm/mempolicy: Allow lookup_node() to handle fatal signal,"lookup_node() uses gup to pin the page and get node information.  It checks against ret>=0 assuming the page will be filled in.  However it's also possible that gup will return zero, for example, when the thread is quickly killed with a fatal signal.  Teach lookup_node() to gracefully return an error -EFAULT if it happens.  Meanwhile, initialize ""page"" to NULL to avoid potential risk of exploiting the pointer.  ",ba841078cd0557b43b59c63f5c048b12168f0db2,0
bpf: fix sock_map_alloc() error path,"In case user program provides silly parameters, we want a map_alloc() handler to return an error, not a NULL pointer, otherwise we crash later in find_and_alloc_map()  ",952fad8e323975c4e826b659087d2648777594a6,1
vhost: fix vhost_vq_access_ok() log check,"Commit d65026c6c62e7d9616c8ceb5a53b68bcdc050525 (""vhost: validate log when IOTLB is enabled"") introduced a regression.  The logic was originally:    if (vq->iotlb)       return 1;   return A && B;  After the patch the short-circuit logic for A was inverted:    if (A || vq->iotlb)       return A;   return B;  This patch fixes the regression by rewriting the checks in the obvious way, no longer returning A when vq->iotlb is non-NULL (which is hard to understand).  ",d14d2b78090c7de0557362b26a4ca591aa6a9faa,0
dccp: initialize ireq->ir_mark,syzbot reported an uninit-value read of skb->mark in iptable_mangle_hook()  ,b855ff827476adbdc2259e9895681d82b7b26065,0
profiling: fix shift-out-of-bounds bugs,"Syzbot reported shift-out-of-bounds bug in profile_init(). The problem was in incorrect prof_shift. Since prof_shift value comes from userspace we need to clamp this value into [0, BITS_PER_LONG -1] boundaries.  Second possible shiht-out-of-bounds was found by Tetsuo: sample_step local variable in read_profile() had ""unsigned int"" type, but prof_shift allows to make a BITS_PER_LONG shift. So, to prevent possible shiht-out-of-bounds sample_step type was changed to ""unsigned long"".  Also, ""unsigned short int"" will be sufficient for storing [0, BITS_PER_LONG] value, that's why there is no need for ""unsigned long"" prof_shift.  ",2d186afd04d669fe9c48b994c41a7405a3c9f16d,1
ALSA: seq: virmidi: Fix discarding the unsubscribed output,"The recent change to move the virmidi output processing to a work slightly modified the code to discard the unsubscribed outputs so that it works without a temporary buffer.  However, this is actually buggy, and may spew a kernel warning due to the unexpected call of snd_rawmidi_transmit_ack(), as triggered by syzbot.  This patch takes back to the original code in that part, use a temporary buffer and simply repeat snd_rawmidi_transmit(), in order to address the regression.  ",82fd4b05d704623a0e4aa7fda48e272a9889337d,0
media: usbvision: Fix invalid accesses after device disconnect,"The syzbot fuzzer found two invalid-access bugs in the usbvision driver.  These bugs occur when userspace keeps the device file open after the device has been disconnected and usbvision_disconnect() has set usbvision->dev to NULL:  	When the device file is closed, usbvision_radio_close() tries 	to issue a usb_set_interface() call, passing the NULL pointer 	as its first argument.  	If userspace performs a querycap ioctl call, vidioc_querycap() 	calls usb_make_path() with the same NULL pointer.  This patch fixes the problems by making the appropriate tests beforehand.  Note that vidioc_querycap() is protected by usbvision->v4l2_lock, acquired in a higher layer of the V4L2 subsystem.  ",c7a191464078262bf799136317c95824e26a222b,0
nbd: protect cmd->status with cmd->lock,"We already do this for the most part, except in timeout and clear_req. For the timeout case we take the lock after we grab a ref on the config, but that isn't really necessary because we're safe to touch the cmd at this point, so just move the order around.  For the clear_req cause this is initiated by the user, so again is safe.  ",de6346ecbc8f5591ebd6c44ac164e8b8671d71d7,0
"bpf, xdp: fix crash in xdp_umem_unaccount_pages","syzkaller was able to trigger the following panic for AF_XDP:    BUG: KASAN: null-ptr-deref in atomic64_sub include/asm-generic/atomic-instrumented.h:144 [inline]   BUG: KASAN: null-ptr-deref in atomic_long_sub include/asm-generic/atomic-long.h:199 [inline]   BUG: KASAN: null-ptr-deref in xdp_umem_unaccount_pages.isra.4+0x3d/0x80 net/xdp/xdp_umem.c:135   Write of size 8 at addr 0000000000000060 by task syz-executor246/4527    CPU: 1 PID: 4527 Comm: syz-executor246 Not tainted 4.17.0+ #89   Hardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 01/01/2011   Call Trace:    __dump_stack lib/dump_stack.c:77 [inline]    dump_stack+0x1b9/0x294 lib/dump_stack.c:113    kasan_report_error mm/kasan/report.c:352 [inline]    kasan_report.cold.7+0x6d/0x2fe mm/kasan/report.c:412    check_memory_region_inline mm/kasan/kasan.c:260 [inline]    check_memory_region+0x13e/0x1b0 mm/kasan/kasan.c:267    kasan_check_write+0x14/0x20 mm/kasan/kasan.c:278    atomic64_sub include/asm-generic/atomic-instrumented.h:144 [inline]    atomic_long_sub include/asm-generic/atomic-long.h:199 [inline]    xdp_umem_unaccount_pages.isra.4+0x3d/0x80 net/xdp/xdp_umem.c:135    xdp_umem_reg net/xdp/xdp_umem.c:334 [inline]    xdp_umem_create+0xd6c/0x10f0 net/xdp/xdp_umem.c:349    xsk_setsockopt+0x443/0x550 net/xdp/xsk.c:531    __sys_setsockopt+0x1bd/0x390 net/socket.c:1935    __do_sys_setsockopt net/socket.c:1946 [inline]    __se_sys_setsockopt net/socket.c:1943 [inline]    __x64_sys_setsockopt+0xbe/0x150 net/socket.c:1943    do_syscall_64+0x1b1/0x800 arch/x86/entry/common.c:287    entry_SYSCALL_64_after_hwframe+0x49/0xbe  In xdp_umem_reg() the call to xdp_umem_account_pages() passed with CAP_IPC_LOCK where we didn't need to end up charging rlimit on memlock for the current user and therefore umem->user continues to be NULL. Later on through fault injection syzkaller triggered a failure in either umem->pgs or umem->pages allocation such that we bail out and undo accounting in xdp_umem_unaccount_pages() where we eventually hit the panic since it tries to deref the umem->user.  The code is pretty close to mm_account_pinned_pages() and mm_unaccount_pinned_pages() pair and potentially could reuse it even in a later cleanup, and it appears that the initial commit c0c77d8fb787 (""xsk: add user memory registration support sockopt"") got this right while later follow-up introduced the bug via a49049ea2576 (""xsk: simplified umem setup"").  ",c09290c5637692a9bfe7740e4c5e693efff12810,1
"net: dccp: initialize (addr,port) listening hashtable","Commit d9fbc7f6431f ""net: tcp: prefer listeners bound to an address"" removes port-only listener lookups. This caused segfaults in DCCP lookups because DCCP did not initialize the (addr,port) hashtable.  This patch adds said initialization.  The only non-trivial issue here is the size of the new hashtable. It seemed reasonable to make it match the size of the port-only hashtable (= INET_LHTABLE_SIZE) that was used previously. Other parameters to inet_hashinfo2_init() match those used in TCP.  V2 changes: marked inet_hashinfo2_init as an exported symbol so that DCCP compiles when configured as a module.  Tested: syzcaller issues fixed; the second patch in the patchset         tests that DCCP lookups work correctly.  ",eedbbb0d98b2a89250a8bb83d9c71b77881e5247,0
batman-adv: Force mac header to start of data on xmit,"The caller of ndo_start_xmit may not already have called skb_reset_mac_header. The returned value of skb_mac_header/eth_hdr therefore can be in the wrong position and even outside the current skbuff. This for example happens when the user binds to the device using a PF_PACKET-SOCK_RAW with enabled qdisc-bypass:    int opt = 4;   setsockopt(sock, SOL_PACKET, PACKET_QDISC_BYPASS, &opt, sizeof(opt));  Since eth_hdr is used all over the codebase, the batadv_interface_tx function must always take care of resetting it.  ",9114daa825fc3f335f9bea3313ce667090187280,0
io_uring: fix io_drain_req(),"io_drain_req() return whether the request has been consumed or not, not an error code. Fix a stupid mistake slipped from optimisation patches.  ",1b48773f9fd09f311d1166ce1dd50652ebe05218,0
ALSA: pcm: Fix UAF in snd_pcm_oss_get_formats(),"snd_pcm_oss_get_formats() has an obvious use-after-free around snd_mask_test() calls, as spotted by syzbot.  The passed format_mask argument is a pointer to the hw_params object that is freed before the loop.  What a surprise that it has been present since the original code of decades ago...  ",01c0b4265cc16bc1f43f475c5944c55c10d5768f,1
net: fix premature exit from NAPI state polling in napi_disable(),"Commit 719c57197010 (""net: make napi_disable() symmetric with enable"") accidentally introduced a bug sometimes leading to a kernel BUG when bringing an iface up/down under heavy traffic load.  Prior to this commit, napi_disable() was polling n->state until none of (NAPIF_STATE_SCHED | NAPIF_STATE_NPSVC) is set and then always flip them. Now there's a possibility to get away with the NAPIF_STATE_SCHE unset as 'continue' drops us to the cmpxchg() call with an uninitialized variable, rather than straight to another round of the state check.  Error path looks like:  napi_disable(): unsigned long val, new; ",0315a075f1343966ea2d9a085666a88a69ea6a3d,1
NFS: fs_context: validate UDP retrans to prevent shift out-of-bounds,"Fix shift out-of-bounds in xprt_calc_majortimeo(). This is caused by a garbage timeout (retrans) mount option being passed to nfs mount, in this case from syzkaller.  If the protocol is XPRT_TRANSPORT_UDP, then 'retrans' is a shift value for a 64-bit long integer, so 'retrans' cannot be >= 64. If it is >= 64, fail the mount and return an error.  ",c09f11ef35955785f92369e25819bf0629df2e59,1
9p: clear dangling pointers in p9stat_free,p9stat_free is more of a cleanup function than a 'free' function as it only frees the content of the struct; there are chances of use-after-free if it is improperly used (e.g. p9stat_free called twice as it used to be possible to)  Clearing dangling pointers makes the function idempotent and safer to use.  ,62e3941776fea8678bb8120607039410b1b61a65,1
xfrm: defer daddr pointer assignment after spi parsing,"syzbot reports: BUG: KASAN: use-after-free in __xfrm_state_lookup+0x695/0x6b0 Read of size 4 at addr ffff8801d434e538 by task syzkaller647520/2991 [..] __xfrm_state_lookup+0x695/0x6b0 net/xfrm/xfrm_state.c:833 xfrm_state_lookup+0x8a/0x160 net/xfrm/xfrm_state.c:1592 xfrm_input+0x8e5/0x22f0 net/xfrm/xfrm_input.c:302  The use-after-free is the ipv4 destination address, which points to an skb head area that has been reallocated:   pskb_expand_head+0x36b/0x1210 net/core/skbuff.c:1494   __pskb_pull_tail+0x14a/0x17c0 net/core/skbuff.c:1877   pskb_may_pull include/linux/skbuff.h:2102 [inline]   xfrm_parse_spi+0x3d3/0x4d0 net/xfrm/xfrm_input.c:170   xfrm_input+0xce2/0x22f0 net/xfrm/xfrm_input.c:291  so the real bug is that xfrm_parse_spi() uses pskb_may_pull, but for now do smaller workaround that makes xfrm_input fetch daddr after spi parsing.  ",cb79a180f2e7eb51de5a4848652893197637bccb,1
USB: legotower: fix logical error in recent commit,"Commit d9f0d82f06c6 (""USB: legousbtower: use usb_control_msg_recv()"") contained an elementary logical error.  The check of the return code from the new usb_control_msg_recv() function was inverted.  ",b175d273d4e4100b66e68f0675fef7a3c07a7957,0
fix proc_fill_cache() in case of d_alloc_parallel() failure,"If d_alloc_parallel() returns ERR_PTR(...), we don't want to dput() that.  Small reorganization allows to have all error-in-lookup cases rejoin the main codepath after dput(child), avoiding the entire problem.  Spotted-by: Tetsuo Handa <penguin-kernel@i-love.sakura.ne.jp> ",d85b399b64e85a311c09205c675d4ae1c5af6246,0
bpf: Avoid races in __bpf_prog_run() for 32bit arches,"__bpf_prog_run() can run from non IRQ contexts, meaning it could be re entered if interrupted.  This calls for the irq safe variant of u64_stats_update_{begin|end}, or risk a deadlock.  This patch is a nop on 64bit arches, fortunately.  syzbot report:  ",f941eadd8d6d4ee2f8c9aeab8e1da5e647533a7d,1
tcp: annotate tp->rcv_nxt lockless reads,"There are few places where we fetch tp->rcv_nxt while this field can change from IRQ or other cpu.  We need to add READ_ONCE() annotations, and also make sure write sides use corresponding WRITE_ONCE() to avoid store-tearing.  Note that tcp_inq_hint() was already using READ_ONCE(tp->rcv_nxt)  syzbot reported :  BUG: KCSAN: data-race in tcp_poll / tcp_queue_rcv  write to 0xffff888120425770 of 4 bytes by interrupt on cpu 0:  tcp_rcv_nxt_update net/ipv4/tcp_input.c:3365 [inline]  tcp_queue_rcv+0x180/0x380 net/ipv4/tcp_input.c:4638  tcp_rcv_established+0xbf1/0xf50 net/ipv4/tcp_input.c:5616  tcp_v4_do_rcv+0x381/0x4e0 net/ipv4/tcp_ipv4.c:1542  tcp_v4_rcv+0x1a03/0x1bf0 net/ipv4/tcp_ipv4.c:1923  ip_protocol_deliver_rcu+0x51/0x470 net/ipv4/ip_input.c:204  ip_local_deliver_finish+0x110/0x140 net/ipv4/ip_input.c:231  NF_HOOK include/linux/netfilter.h:305 [inline]  NF_HOOK include/linux/netfilter.h:299 [inline]  ip_local_deliver+0x133/0x210 net/ipv4/ip_input.c:252  dst_input include/net/dst.h:442 [inline]  ip_rcv_finish+0x121/0x160 net/ipv4/ip_input.c:413  NF_HOOK include/linux/netfilter.h:305 [inline]  NF_HOOK include/linux/netfilter.h:299 [inline]  ip_rcv+0x18f/0x1a0 net/ipv4/ip_input.c:523  __netif_receive_skb_one_core+0xa7/0xe0 net/core/dev.c:5004  __netif_receive_skb+0x37/0xf0 net/core/dev.c:5118  netif_receive_skb_internal+0x59/0x190 net/core/dev.c:5208  napi_skb_finish net/core/dev.c:5671 [inline]  napi_gro_receive+0x28f/0x330 net/core/dev.c:5704  receive_buf+0x284/0x30b0 drivers/net/virtio_net.c:1061  read to 0xffff888120425770 of 4 bytes by task 7254 on cpu 1:  tcp_stream_is_readable net/ipv4/tcp.c:480 [inline]  tcp_poll+0x204/0x6b0 net/ipv4/tcp.c:554  sock_poll+0xed/0x250 net/socket.c:1256  vfs_poll include/linux/poll.h:90 [inline]  ep_item_poll.isra.0+0x90/0x190 fs/eventpoll.c:892  ep_send_events_proc+0x113/0x5c0 fs/eventpoll.c:1749  ep_scan_ready_list.constprop.0+0x189/0x500 fs/eventpoll.c:704  ep_send_events fs/eventpoll.c:1793 [inline]  ep_poll+0xe3/0x900 fs/eventpoll.c:1930  do_epoll_wait+0x162/0x180 fs/eventpoll.c:2294  __do_sys_epoll_pwait fs/eventpoll.c:2325 [inline]  __se_sys_epoll_pwait fs/eventpoll.c:2311 [inline]  __x64_sys_epoll_pwait+0xcd/0x170 fs/eventpoll.c:2311  do_syscall_64+0xcf/0x2f0 arch/x86/entry/common.c:296  entry_SYSCALL_64_after_hwframe+0x44/0xa9  Reported by Kernel Concurrency Sanitizer on: CPU: 1 PID: 7254 Comm: syz-fuzzer Not tainted 5.3.0+ #0 Hardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 01/01/2011  ",dba7d9b8c739df27ff3a234c81d6c6b23e3986fa,1
bfs: extra sanity checking and static inode bitmap,"Strengthen validation of BFS superblock against corruption.  Make in-core inode bitmap static part of superblock info structure.  Print a warning when mounting a BFS filesystem created with ""-N 512"" option as only 510 files can be created in the root directory.  Make the kernel messages more uniform.  Update the 'prefix' passed to bfs_dump_imap() to match the current naming of operations.  White space and comments cleanup.  ",d1877155891020cb26ad4fba45bfee52d8da9951,1
lockdep: Fix lockdep recursion,"Steve reported that lockdep_assert*irq*(), when nested inside lockdep itself, will trigger a false-positive.  One example is the stack-trace code, as called from inside lockdep, triggering tracing, which in turn calls RCU, which then uses lockdep_assert_irqs_disabled().  ",4d004099a668c41522242aa146a38cc4eb59cb1e,0
staging: android: ion: Return an ERR_PTR in ion_map_kernel,"The expected return value from ion_map_kernel is an ERR_PTR. The error path for a vmalloc failure currently just returns NULL, triggering a warning in ion_buffer_kmap_get. Encode the vmalloc failure as an ERR_PTR.  ",0a2bc00341dcfcc793c0dbf4f8d43adf60458b05,0
media: dvb-usb: fix uninit-value in dvb_usb_adapter_dvb_init,"If dibusb_read_eeprom_byte fails, the mac address is not initialized. And nova_t_read_mac_address does not handle this failure, which leads to the uninit-value in dvb_usb_adapter_dvb_init.  Fix this by handling the failure of dibusb_read_eeprom_byte.  ",c5453769f77ce19a5b03f1f49946fd3f8a374009,1
tun: make tun_build_skb() thread safe,"tun_build_skb() is not thread safe since it uses per queue page frag, this will break things when multiple threads are sending through same queue. Switch to use per-thread generator (no lock involved).  ",0bbd7dad34f81e5e724cb08252160a1796c388b2,0
Bluetooth: hci_uart: check for missing tty operations,"Certain ttys operations (pty_unix98_ops) lack tiocmget() and tiocmset() functions which are called by the certain HCI UART protocols (hci_ath, hci_bcm, hci_intel, hci_mrvl, hci_qca) via hci_uart_set_flow_control() or directly. This leads to an execution at NULL and can be triggered by an unprivileged user. Fix this by adding a helper function and a check for the missing tty operations in the protocols code.  This fixes CVE-2019-10207. The ",b36a1552d7319bbfd5cf7f08726c23c5c66d4f73,1
relay: check return of create_buf_file() properly,"If create_buf_file() returns an error, don't try to reference it later as a valid dentry pointer.  This problem was exposed when debugfs started to return errors instead of just NULL for some calls when they do not succeed properly.  Also, the check for WARN_ON(dentry) was just wrong :)  ",2c1cf00eeacb784781cf1c9896b8af001246d339,0
vt: fix unicode console freeing with a common interface,"By directly using kfree() in different places we risk missing one if it is switched to using vfree(), especially if the corresponding vmalloc() is hidden away within a common abstraction.  Oh wait, that's exactly what happened here.  So let's fix this by creating a common abstraction for the free case as well.  ",57d38f26d81e4275748b69372f31df545dcd9b71,0
xfs: clear PF_MEMALLOC before exiting xfsaild thread,"Leaving PF_MEMALLOC set when exiting a kthread causes it to remain set during do_exit().  That can confuse things.  In particular, if BSD process accounting is enabled, then do_exit() writes data to an accounting file.  If that file has FS_SYNC_FL set, then this write occurs synchronously and can misbehave if PF_MEMALLOC is set.  For example, if the accounting file is located on an XFS filesystem, then a WARN_ON_ONCE() in iomap_do_writepage() is triggered and the data doesn't get written when it should.  Or if the accounting file is located on an ext4 filesystem without a journal, then a WARN_ON_ONCE() in ext4_write_inode() is triggered and the inode doesn't get written.  Fix this in xfsaild() by using the helper functions to save and restore PF_MEMALLOC.  This can be reproduced as follows in the kvm-xfstests test appliance modified to add the 'acct' Debian package, and with kvm-xfstests's recommended kconfig modified to add CONFIG_BSD_PROCESS_ACCT=y:          mkfs.xfs -f /dev/vdb         mount /vdb         touch /vdb/file         chattr +S /vdb/file         accton /vdb/file         mkfs.xfs -f /dev/vdc         mount /vdc         umount /vdc  It causes: 	",10a98cb16d80be3595fdb165fad898bb28b8b6d2,0
netfilter: egress: avoid a lockdep splat,"include/linux/netfilter_netdev.h:97 suspicious rcu_dereference_check() usage! 2 locks held by sd-resolve/1100:  0: ..(rcu_read_lock_bh){1:3}, at: ip_finish_output2  1: ..(rcu_read_lock_bh){1:3}, at: __dev_queue_xmit  __dev_queue_xmit+0 ..  The helper has two callers, one uses rcu_read_lock, the other rcu_read_lock_bh().  Annotate the dereference to reflect this.  ",6316136ec6e3dd1c302f7e7289a9ee46ecc610ae,1
io-wq: drop wqe lock before creating new worker,"We have two io-wq creation paths:  - On queue enqueue - When a worker goes to sleep  The latter invokes worker creation with the wqe->lock held, but that can run into problems if we end up exiting and need to cancel the queued work. syzbot caught this:  ",d800c65c2d4eccebb27ffb7808e842d5b533823c,0
inet: do not call sublist_rcv on empty list,syzbot triggered struct net NULL deref in NF_HOOK_LIST: ,51210ad5a558dcc7511d0c083f5cd796077b4e4d,0
tipc: Fix namespace violation in tipc_sk_fill_sock_diag,"To fetch UID info for socket diagnostics, we determine the namespace of user context using tipc socket instance. This may cause namespace violation, as the kernel will remap based on UID.  We fix this by fetching namespace info using the calling userspace netlink socket.  ",4b2e6877b8793b60abb75c15abaaa4377807a358,0
io_uring: Fix use of XArray in __io_uring_files_cancel,"We have to drop the lock during each iteration, so there's no advantage to using the advanced API.  Convert this to a standard xa_for_each() loop.  ",ce765372bc443573d1d339a2bf4995de385dea3a,0
can: j1939: j1939_sk_bind(): take priv after lock is held,syzbot reproduced following crash:  ,00d4e14d2e4caf5f7254a505fee5eeca8cd37bd4,1
rxrpc: Fix notification call on completion of discarded calls,"When preallocated service calls are being discarded, they're passed to ->discard_new_call() to have the caller clean up any attached higher-layer preallocated pieces before being marked completed.  However, the act of marking them completed now invokes the call's notification function - which causes a problem because that function might assume that the previously freed pieces of memory are still there.  Fix this by setting a dummy notification function on the socket after calling ->discard_new_call().  This results in the following kasan message when the kafs module is removed.  ",0041cd5a50442db6e456b145892a0eaf2dff061f,0
mm: add Kernel Electric-Fence infrastructure,"Patch series ""KFENCE: A low-overhead sampling-based memory safety error detector"", v7.  This adds the Kernel Electric-Fence (KFENCE) infrastructure. KFENCE is a low-overhead sampling-based memory safety error detector of heap use-after-free, invalid-free, and out-of-bounds access errors.  This series enables KFENCE for the x86 and arm64 architectures, and adds KFENCE hooks to the SLAB and SLUB allocators.  KFENCE is designed to be enabled in production kernels, and has near zero performance overhead. Compared to KASAN, KFENCE trades performance for precision. The main motivation behind KFENCE's design, is that with enough total uptime KFENCE will detect bugs in code paths not typically exercised by non-production test workloads. One way to quickly achieve a large enough total uptime is when the tool is deployed across a large fleet of machines.  KFENCE objects each reside on a dedicated page, at either the left or right page boundaries. The pages to the left and right of the object page are ""guard pages"", whose attributes are changed to a protected state, and cause page faults on any attempted access to them. Such page faults are then intercepted by KFENCE, which handles the fault gracefully by reporting a memory access error.  Guarded allocations are set up based on a sample interval (can be set via kfence.sample_interval). After expiration of the sample interval, the next allocation through the main allocator (SLAB or SLUB) returns a guarded allocation from the KFENCE object pool. At this point, the timer is reset, and the next allocation is set up after the expiration of the interval.  To enable/disable a KFENCE allocation through the main allocator's fast-path without overhead, KFENCE relies on static branches via the static keys infrastructure. The static branch is toggled to redirect the allocation to KFENCE.  The KFENCE memory pool is of fixed size, and if the pool is exhausted no further KFENCE allocations occur. The default config is conservative with only 255 objects, resulting in a pool size of 2 MiB (with 4 KiB pages).  We have verified by running synthetic benchmarks (sysbench I/O, hackbench) and production server-workload benchmarks that a kernel with KFENCE (using sample intervals 100-500ms) is performance-neutral compared to a non-KFENCE baseline kernel.  KFENCE is inspired by GWP-ASan [1], a userspace tool with similar properties. The name ""KFENCE"" is a homage to the Electric Fence Malloc Debugger [2].  For more details, see Documentation/dev-tools/kfence.rst added in the series -- also viewable here:  	https://raw.githubusercontent.com/google/kasan/kfence/Documentation/dev-tools/kfence.rst  [1] http://llvm.org/docs/GwpAsan.html [2] https://linux.die.net/man/3/efence  This patch (of 9):  This adds the Kernel Electric-Fence (KFENCE) infrastructure. KFENCE is a low-overhead sampling-based memory safety error detector of heap use-after-free, invalid-free, and out-of-bounds access errors.  KFENCE is designed to be enabled in production kernels, and has near zero performance overhead. Compared to KASAN, KFENCE trades performance for precision. The main motivation behind KFENCE's design, is that with enough total uptime KFENCE will detect bugs in code paths not typically exercised by non-production test workloads. One way to quickly achieve a large enough total uptime is when the tool is deployed across a large fleet of machines.  KFENCE objects each reside on a dedicated page, at either the left or right page boundaries. The pages to the left and right of the object page are ""guard pages"", whose attributes are changed to a protected state, and cause page faults on any attempted access to them. Such page faults are then intercepted by KFENCE, which handles the fault gracefully by reporting a memory access error. To detect out-of-bounds writes to memory within the object's page itself, KFENCE also uses pattern-based redzones. The following figure illustrates the page layout:    ",0ce20dd840897b12ae70869c69f1ba34d6d16965,1
net: usb: pegasus: fix improper read if get_registers() fail,get_registers() may fail with -ENOMEM and in this case we can read a garbage from the status variable tmp.  ,224c04973db1125fcebefffd86115f99f50f8277,0
tipc: check link name with right length in tipc_nl_compat_link_set,"A similar issue as fixed by Patch ""tipc: check bearer name with right length in tipc_nl_compat_bearer_enable"" was also found by syzbot in tipc_nl_compat_link_set().  The length to check with should be 'TLV_GET_DATA_LEN(msg->req) - offsetof(struct tipc_link_config, name)'.  ",8c63bf9ab4be8b83bd8c34aacfd2f1d2c8901c8a,0
ANDROID: binder: prevent transactions into own process.,"This can't happen with normal nodes (because you can't get a ref to a node you own), but it could happen with the context manager; to make the behavior consistent with regular nodes, reject transactions into the context manager by the process owning it.  ",7aa135fcf26377f92dc0680a57566b4c7f3e281b,0
crypto: salsa20 - fix blkcipher_walk API usage,"When asked to encrypt or decrypt 0 bytes, both the generic and x86 implementations of Salsa20 crash in blkcipher_walk_done(), either when doing 'kfree(walk->buffer)' or 'free_page((unsigned long)walk->page)', because walk->buffer and walk->page have not been initialized.  The bug is that Salsa20 is calling blkcipher_walk_done() even when nothing is in 'walk.nbytes'.  But blkcipher_walk_done() is only meant to be called when a nonzero number of bytes have been provided.  The broken code is part of an optimization that tries to make only one call to salsa20_encrypt_bytes() to process inputs that are not evenly divisible by 64 bytes.  To fix the bug, just remove this ""optimization"" and use the blkcipher_walk API the same way all the other users do.  Reproducer:      #include <linux/if_alg.h>     #include <sys/socket.h>     #include <unistd.h>      int main()     {             int algfd, reqfd;             struct sockaddr_alg addr = {                     .salg_type = ""skcipher"",                     .salg_name = ""salsa20"",             };             char key[16] = { 0 };              algfd = socket(AF_ALG, SOCK_SEQPACKET, 0);             bind(algfd, (void *)&addr, sizeof(addr));             reqfd = accept(algfd, 0, 0);             setsockopt(algfd, SOL_ALG, ALG_SET_KEY, key, sizeof(key));             read(reqfd, key, sizeof(key));     }  ",ecaaab5649781c5a0effdaf298a925063020500e,1
KVM: x86: fix out-of-bounds write in KVM_GET_EMULATED_CPUID (CVE-2019-19332),The bounds check was present in KVM_GET_SUPPORTED_CPUID but not KVM_GET_EMULATED_CPUID.  ,433f4ba1904100da65a311033f17a9bf586b287e,1
io_uring: drop req/tctx io_identity separately,"We can't bundle this into one operation, as the identity may not have originated from the tctx to begin with. Drop one ref for each of them separately, if they don't match the static assignment. If we don't, then if the identity is a lookup from registered credentials, we could be freeing that identity as we're dropping a reference assuming it came from the tctx. syzbot reports this as a use-after-free, as the identity is still referencable from idr lookup:  ",cb8a8ae310741d743fd02982307797f6a126f614,1
net/af_unix: fix a data-race in unix_dgram_poll,"syzbot reported another data-race in af_unix [1]  Lets change __skb_insert() to use WRITE_ONCE() when changing skb head qlen.  Also, change unix_dgram_poll() to use lockless version of unix_recvq_full()  It is verry possible we can switch all/most unix_recvq_full() to the lockless version, this will be done in a future kernel version.  [1] HEAD commit: 8596e589b787732c8346f0482919e83cc9362db1  BUG: KCSAN: data-race in skb_queue_tail / unix_dgram_poll  write to 0xffff88814eeb24e0 of 4 bytes by task 25815 on cpu 0:  __skb_insert include/linux/skbuff.h:1938 [inline]  __skb_queue_before include/linux/skbuff.h:2043 [inline]  __skb_queue_tail include/linux/skbuff.h:2076 [inline]  skb_queue_tail+0x80/0xa0 net/core/skbuff.c:3264  unix_dgram_sendmsg+0xff2/0x1600 net/unix/af_unix.c:1850  sock_sendmsg_nosec net/socket.c:703 [inline]  sock_sendmsg net/socket.c:723 [inline]  ____sys_sendmsg+0x360/0x4d0 net/socket.c:2392  ___sys_sendmsg net/socket.c:2446 [inline]  __sys_sendmmsg+0x315/0x4b0 net/socket.c:2532  __do_sys_sendmmsg net/socket.c:2561 [inline]  __se_sys_sendmmsg net/socket.c:2558 [inline]  __x64_sys_sendmmsg+0x53/0x60 net/socket.c:2558  do_syscall_x64 arch/x86/entry/common.c:50 [inline]  do_syscall_64+0x3d/0x90 arch/x86/entry/common.c:80  entry_SYSCALL_64_after_hwframe+0x44/0xae  read to 0xffff88814eeb24e0 of 4 bytes by task 25834 on cpu 1:  skb_queue_len include/linux/skbuff.h:1869 [inline]  unix_recvq_full net/unix/af_unix.c:194 [inline]  unix_dgram_poll+0x2bc/0x3e0 net/unix/af_unix.c:2777  sock_poll+0x23e/0x260 net/socket.c:1288  vfs_poll include/linux/poll.h:90 [inline]  ep_item_poll fs/eventpoll.c:846 [inline]  ep_send_events fs/eventpoll.c:1683 [inline]  ep_poll fs/eventpoll.c:1798 [inline]  do_epoll_wait+0x6ad/0xf00 fs/eventpoll.c:2226  __do_sys_epoll_wait fs/eventpoll.c:2238 [inline]  __se_sys_epoll_wait fs/eventpoll.c:2233 [inline]  __x64_sys_epoll_wait+0xf6/0x120 fs/eventpoll.c:2233  do_syscall_x64 arch/x86/entry/common.c:50 [inline]  do_syscall_64+0x3d/0x90 arch/x86/entry/common.c:80  entry_SYSCALL_64_after_hwframe+0x44/0xae  value changed: 0x0000001b -> 0x00000001  Reported by Kernel Concurrency Sanitizer on: CPU: 1 PID: 25834 Comm: syz-executor.1 Tainted: G        W         5.14.0-syzkaller #0 Hardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 01/01/2011  ",04f08eb44b5011493d77b602fdec29ff0f5c6cd5,1
KVM: VMX: don't allow memory operands for inline asm that modifies SP,"THUNK_TARGET defines [thunk_target] as having ""rm"" input constraints when CONFIG_RETPOLINE is not set, which isn't constrained enough for this specific case.  For inline assembly that modifies the stack pointer before using this input, the underspecification of constraints is dangerous, and results in an indirect call to a previously pushed flags register.  In this case `entry`'s stack slot is good enough to satisfy the ""m"" constraint in ""rm"", but the inline assembly in handle_external_interrupt_irqoff() modifies the stack pointer via push+pushf before using this input, which in this case results in calling what was the previous state of the flags register, rather than `entry`.  Be more specific in the constraints by requiring `entry` be in a register, and not a memory operand.  ",428b8f1d9f92f838b73997adc10046d3c6e05790,0
fs/open.c: allow opening only regular files during execve(),"syzbot is hitting lockdep warning [1] due to trying to open a fifo during an execve() operation.  But we don't need to open non regular files during an execve() operation, for all files which we will need are the executable file itself and the interpreter programs like /bin/sh and ld-linux.so.2 .  Since the manpage for execve(2) says that execve() returns EACCES when the file or a script interpreter is not a regular file, and the manpage for uselib(2) says that uselib() can return EACCES, and we use FMODE_EXEC when opening for execve()/uselib(), we can bail out if a non regular file is requested with FMODE_EXEC set.  Since this deadlock followed by khungtaskd warnings is trivially reproducible by a local unprivileged user, and syzbot's frequent crash due to this deadlock defers finding other bugs, let's workaround this deadlock until we get a chance to find a better solution.  [1] https://syzkaller.appspot.com/bug?id=b5095bfec44ec84213bac54742a82483aad578ce  ",73601ea5b7b18eb234219ae2adf77530f389da79,1
net/smc: fix access to parent of an ib device,"The parent of an ib device is used to retrieve the PCI device attributes. It turns out that there are possible cases when an ib device has no parent set in the device structure, which may lead to page faults when trying to access this memory. Fix that by checking the parent pointer and consolidate the pci device specific processing in a new function.  ",995433b795cec0a4ef6c8603e7642903c621943a,0
mptcp: remove tcp ulp setsockopt support,TCP_ULP setsockopt cannot be used for mptcp because its already used internally to plumb subflow (tcp) sockets to the mptcp layer.  syzbot managed to trigger a crash for mptcp connections that are in fallback mode:  KASAN: null-ptr-deref in range [0x0000000000000020-0x0000000000000027] CPU: 1 PID: 1083 Comm: syz-executor.3 Not tainted 5.16.0-rc2-syzkaller #0 ,404cd9a22150f24acf23a8df2ad0c094ba379f57,1
n_tty: fix EXTPROC vs ICANON interaction with TIOCINQ (aka FIONREAD),"We added support for EXTPROC back in 2010 in commit 26df6d13406d (""tty: Add EXTPROC support for LINEMODE"") and the intent was to allow it to override some (all?) ICANON behavior.  Quoting from that original commit message:           There is a new bit in the termios local flag word, EXTPROC.          When this bit is set, several aspects of the terminal driver          are disabled.  Input line editing, character echo, and mapping          of signals are all disabled.  This allows the telnetd to turn          off these functions when in linemode, but still keep track of          what state the user wants the terminal to be in.  but the problem turns out that ""several aspects of the terminal driver are disabled"" is a bit ambiguous, and you can really confuse the n_tty layer by setting EXTPROC and then causing some of the ICANON invariants to no longer be maintained.  This fixes at least one such case (TIOCINQ) becoming unhappy because of the confusion over whether ICANON really means ICANON when EXTPROC is set.  This basically makes TIOCINQ match the case of read: if EXTPROC is set, we ignore ICANON.  Also, make sure to reset the ICANON state ie EXTPROC changes, not just if ICANON changes.  ",966031f340185eddd05affcf72b740549f056348,0
drm/vkms: Fix flush_work() without INIT_WORK().,"syzbot is hitting a lockdep warning [1] because flush_work() is called without INIT_WORK() after kzalloc() at vkms_atomic_crtc_reset().  Commit 6c234fe37c57627a (""drm/vkms: Implement CRC debugfs API"") added INIT_WORK() to only vkms_atomic_crtc_duplicate_state() side. Assuming that lifecycle of crc_work is appropriately managed, fix this problem by adding INIT_WORK() to vkms_atomic_crtc_reset() side.  [1] https://syzkaller.appspot.com/bug?id=a5954455fcfa51c29ca2ab55b203076337e1c770  ",b30b61ff6b1dc37f276cf56a8328b80086a3ffca,1
mac80211_hwsim: require at least one channel,"Syzbot continues to try to create mac80211_hwsim radios, and manages to pass parameters that are later checked with WARN_ON in cfg80211 - catch another one in hwsim directly.  ",484004339d4514fde425f6e8a9f6a6cc979bb0c3,0
signal: Don't send signals to tasks that don't exist,Recently syzbot reported crashes in send_sigio_to_task and send_sigurg_to_task in linux-next.  Despite finding a reproducer syzbot apparently did not bisected this or otherwise track down the offending commit in linux-next.  I happened to see this report and examined the code because I had recently changed these functions as part of making PIDTYPE_TGID a real pid type so that fork would does not need to restart when receiving a signal.  By examination I see that I spotted a bug in the code that could explain the reported crashes.  When I took Oleg's suggestion and optimized send_sigurg and send_sigio to only send to a single task when type is PIDTYPE_PID or PIDTYPE_TGID I failed to handle pids that no longer point to tasks.  The macro do_each_pid_task simply iterates for zero iterations.  With pid_task an explicit NULL test is needed.  Update the code to include the missing NULL test.  ,84fe4cc09abc1a5ef3a282db3ed10f4d3f1e6a0b,1
usb: cdc-acm: make sure a refcount is taken early enough,"destroy() will decrement the refcount on the interface, so that it needs to be taken so early that it never undercounts.  ",c52873e5a1ef72f845526d9f6a50704433f9c625,0
can: bcm: delay release of struct bcm_op after synchronize_rcu(),"can_rx_register() callbacks may be called concurrently to the call to can_rx_unregister(). The callbacks and callback data, though, are protected by RCU and the struct sock reference count.  So the callback data is really attached to the life of sk, meaning that it should be released on sk_destruct. However, bcm_remove_op() calls tasklet_kill(), and RCU callbacks may be called under RCU softirq, so that cannot be used on kernels before the introduction of HRTIMER_MODE_SOFT.  However, bcm_rx_handler() is called under RCU protection, so after calling can_rx_unregister(), we may call synchronize_rcu() in order to wait for any RCU read-side critical sections to finish. That is, bcm_rx_handler() won't be called anymore for those ops. So, we only free them, after we do that synchronize_rcu().  ",d5f9023fa61ee8b94f37a93f08e94b136cf1e463,0
r8152: check the informaton of the device,"Verify some fields of the USB descriptor to make sure the driver could be used by the device.  Besides, remove the check of endpoint number in rtl8152_probe(). usb_find_common_endpoints() includes it.  Bug",1a44fb38cc65bc30bac490291412aa1940659fe1,0
llc: delete timers synchronously in llc_sk_free(),"The connection timers of an llc sock could be still flying after we delete them in llc_sk_free(), and even possibly after we free the sock. We could just wait synchronously here in case of troubles.  Note, I leave other call paths as they are, since they may not have to wait, at least we can change them to synchronously when needed.  Also, move the code to net/llc/llc_conn.c, which is apparently a better place.  ",b905ef9ab90115d001c1658259af4b1c65088779,0
sctp: initialize _pad of sockaddr_in before copying to user memory,Syzbot report a kernel-infoleak:    BUG: KMSAN: kernel-infoleak in _copy_to_user+0x16b/0x1f0 lib/usercopy.c:32   Call Trace:     _copy_to_user+0x16b/0x1f0 lib/usercopy.c:32     copy_to_user include/linux/uaccess.h:174 [inline]     sctp_getsockopt_peer_addrs net/sctp/socket.c:5911 [inline]     sctp_getsockopt+0x1668e/0x17f70 net/sctp/socket.c:7562     ...   ,09279e615c81ce55e04835970601ae286e3facbe,1
