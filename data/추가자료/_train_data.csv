title,desc,number,label
sunrpc: handle ENOMEM in rpcb_getport_async,If we ignore the error we'll hit a null dereference a little later.  ,81c88b18de1f11f70c97f28ced8d642c00bb3955,1
md: fix a lock order reversal in md_alloc,"Commit b0140891a8cea3 (""md: Fix race when creating a new md device."") not only moved assigning mddev->gendisk before calling add_disk, which fixes the races described in the commit log, but also added a mddev->open_mutex critical section over add_disk and creation of the md kobj.  Adding a kobject after add_disk is racy vs deleting the gendisk right after adding it, but md already prevents against that by holding a mddev->active reference.  On the other hand taking this lock added a lock order reversal with what is not disk->open_mutex (used to be bdev->bd_mutex when the commit was added) for partition devices, which need that lock for the internal open for the partition scan, and a recent commit also takes it for non-partitioned devices, leading to further lockdep splatter.  ",7df835a32a8bedf7ce88efcfa7c9b245b52ff139,1
tls: Stricter error checking in zerocopy sendmsg path,"In the zerocopy sendmsg() path, there are error checks to revert the zerocopy if we get any error code.  syzkaller has discovered that tls_push_record can return -ECONNRESET, which is fatal, and happens after the point at which it is safe to revert the iter, as we've already passed the memory to do_tcp_sendpages.  Previously this code could return -ENOMEM and we would want to revert the iter, but AFAIK this no longer returns ENOMEM after a447da7d004 (""tls: fix waitall behavior in tls_sw_recvmsg""), so we fail for all error codes.  ",32da12216e467dea70a09cd7094c30779ce0f9db,1
netfilter: ipset: Fix forceadd evaluation path,"When the forceadd option is enabled, the hash:* types should find and replace the first entry in the bucket with the new one if there are no reuseable (deleted or timed out) entries. However, the position index was just not set to zero and remained the invalid -1 if there were no reuseable entries.  ",8af1c6fbd9239877998c7f5a591cb2c88d41fb66,0
cpufreq: Add QoS requests for userspace constraints,This implements QoS requests to manage userspace configuration of min and max frequency.  ,18c49926c4bf4915e5194d1de3299c0537229f9f,0
dccp: purge write queue in dccp_destroy_sock(),syzkaller reported that DCCP could have a non empty write queue at dismantle time.  ,7749d4ff88d31b0be17c8683143135adaaadc6a7,1
KVM: x86: fix vcpu initialization with userspace lapic,Moving the code around broke this rare configuration. Use this opportunity to finally call lapic reset from vcpu reset.  ,b7e31be385584afe7f073130e8e570d53c95f7fe,0
mm: support THPs in zero_user_segments,"We can only kmap() one subpage of a THP at a time, so loop over all relevant subpages, skipping ones which don't need to be zeroed.  This is too large to inline when THPs are enabled and we actually need highmem, so put it in highmem.c.  [willy@infradead.org: start1 was allowed to be less than start2]  ",0060ef3b4e6dd1410da164d48a595eadb2fb02f7,0
hrtimer: Annotate lockless access to timer->state,"syzbot reported various data-race caused by hrtimer_is_queued() reading timer->state. A READ_ONCE() is required there to silence the warning.  Also add the corresponding WRITE_ONCE() when timer->state is set.  In remove_hrtimer() the hrtimer_is_queued() helper is open coded to avoid loading timer->state twice.  KCSAN reported these cases:  BUG: KCSAN: data-race in __remove_hrtimer / tcp_pacing_check  write to 0xffff8880b2a7d388 of 1 bytes by interrupt on cpu 0:  __remove_hrtimer+0x52/0x130 kernel/time/hrtimer.c:991  __run_hrtimer kernel/time/hrtimer.c:1496 [inline]  __hrtimer_run_queues+0x250/0x600 kernel/time/hrtimer.c:1576  hrtimer_run_softirq+0x10e/0x150 kernel/time/hrtimer.c:1593  __do_softirq+0x115/0x33f kernel/softirq.c:292  run_ksoftirqd+0x46/0x60 kernel/softirq.c:603  smpboot_thread_fn+0x37d/0x4a0 kernel/smpboot.c:165  kthread+0x1d4/0x200 drivers/block/aoe/aoecmd.c:1253  ret_from_fork+0x1f/0x30 arch/x86/entry/entry_64.S:352  read to 0xffff8880b2a7d388 of 1 bytes by task 24652 on cpu 1:  tcp_pacing_check net/ipv4/tcp_output.c:2235 [inline]  tcp_pacing_check+0xba/0x130 net/ipv4/tcp_output.c:2225  tcp_xmit_retransmit_queue+0x32c/0x5a0 net/ipv4/tcp_output.c:3044  tcp_xmit_recovery+0x7c/0x120 net/ipv4/tcp_input.c:3558  tcp_ack+0x17b6/0x3170 net/ipv4/tcp_input.c:3717  tcp_rcv_established+0x37e/0xf50 net/ipv4/tcp_input.c:5696  tcp_v4_do_rcv+0x381/0x4e0 net/ipv4/tcp_ipv4.c:1561  sk_backlog_rcv include/net/sock.h:945 [inline]  __release_sock+0x135/0x1e0 net/core/sock.c:2435  release_sock+0x61/0x160 net/core/sock.c:2951  sk_stream_wait_memory+0x3d7/0x7c0 net/core/stream.c:145  tcp_sendmsg_locked+0xb47/0x1f30 net/ipv4/tcp.c:1393  tcp_sendmsg+0x39/0x60 net/ipv4/tcp.c:1434  inet_sendmsg+0x6d/0x90 net/ipv4/af_inet.c:807  sock_sendmsg_nosec net/socket.c:637 [inline]  sock_sendmsg+0x9f/0xc0 net/socket.c:657  BUG: KCSAN: data-race in __remove_hrtimer / __tcp_ack_snd_check  write to 0xffff8880a3a65588 of 1 bytes by interrupt on cpu 0:  __remove_hrtimer+0x52/0x130 kernel/time/hrtimer.c:991  __run_hrtimer kernel/time/hrtimer.c:1496 [inline]  __hrtimer_run_queues+0x250/0x600 kernel/time/hrtimer.c:1576  hrtimer_run_softirq+0x10e/0x150 kernel/time/hrtimer.c:1593  __do_softirq+0x115/0x33f kernel/softirq.c:292  invoke_softirq kernel/softirq.c:373 [inline]  irq_exit+0xbb/0xe0 kernel/softirq.c:413  exiting_irq arch/x86/include/asm/apic.h:536 [inline]  smp_apic_timer_interrupt+0xe6/0x280 arch/x86/kernel/apic/apic.c:1137  apic_timer_interrupt+0xf/0x20 arch/x86/entry/entry_64.S:830  read to 0xffff8880a3a65588 of 1 bytes by task 22891 on cpu 1:  __tcp_ack_snd_check+0x415/0x4f0 net/ipv4/tcp_input.c:5265  tcp_ack_snd_check net/ipv4/tcp_input.c:5287 [inline]  tcp_rcv_established+0x750/0xf50 net/ipv4/tcp_input.c:5708  tcp_v4_do_rcv+0x381/0x4e0 net/ipv4/tcp_ipv4.c:1561  sk_backlog_rcv include/net/sock.h:945 [inline]  __release_sock+0x135/0x1e0 net/core/sock.c:2435  release_sock+0x61/0x160 net/core/sock.c:2951  sk_stream_wait_memory+0x3d7/0x7c0 net/core/stream.c:145  tcp_sendmsg_locked+0xb47/0x1f30 net/ipv4/tcp.c:1393  tcp_sendmsg+0x39/0x60 net/ipv4/tcp.c:1434  inet_sendmsg+0x6d/0x90 net/ipv4/af_inet.c:807  sock_sendmsg_nosec net/socket.c:637 [inline]  sock_sendmsg+0x9f/0xc0 net/socket.c:657  __sys_sendto+0x21f/0x320 net/socket.c:1952  __do_sys_sendto net/socket.c:1964 [inline]  __se_sys_sendto net/socket.c:1960 [inline]  __x64_sys_sendto+0x89/0xb0 net/socket.c:1960  do_syscall_64+0xcc/0x370 arch/x86/entry/common.c:290  Reported by Kernel Concurrency Sanitizer on: CPU: 1 PID: 24652 Comm: syz-executor.3 Not tainted 5.4.0-rc3+ #0 Hardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 01/01/2011  ",56144737e67329c9aaed15f942d46a6302e2e3d8,1
batman-adv: fix uninit-value in batadv_interface_tx(),"KMSAN reported batadv_interface_tx() was possibly using a garbage value [1]  batadv_get_vid() does have a pskb_may_pull() call but batadv_interface_tx() does not actually make sure this did not fail.  [1] BUG: KMSAN: uninit-value in batadv_interface_tx+0x908/0x1e40 net/batman-adv/soft-interface.c:231 CPU: 0 PID: 10006 Comm: syz-executor469 Not tainted 4.20.0-rc7+ #5 Hardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 01/01/2011 Call Trace:  __dump_stack lib/dump_stack.c:77 [inline]  dump_stack+0x173/0x1d0 lib/dump_stack.c:113  kmsan_report+0x12e/0x2a0 mm/kmsan/kmsan.c:613  __msan_warning+0x82/0xf0 mm/kmsan/kmsan_instr.c:313  batadv_interface_tx+0x908/0x1e40 net/batman-adv/soft-interface.c:231  __netdev_start_xmit include/linux/netdevice.h:4356 [inline]  netdev_start_xmit include/linux/netdevice.h:4365 [inline]  xmit_one net/core/dev.c:3257 [inline]  dev_hard_start_xmit+0x607/0xc40 net/core/dev.c:3273  __dev_queue_xmit+0x2e42/0x3bc0 net/core/dev.c:3843  dev_queue_xmit+0x4b/0x60 net/core/dev.c:3876  packet_snd net/packet/af_packet.c:2928 [inline]  packet_sendmsg+0x8306/0x8f30 net/packet/af_packet.c:2953  sock_sendmsg_nosec net/socket.c:621 [inline]  sock_sendmsg net/socket.c:631 [inline]  __sys_sendto+0x8c4/0xac0 net/socket.c:1788  __do_sys_sendto net/socket.c:1800 [inline]  __se_sys_sendto+0x107/0x130 net/socket.c:1796  __x64_sys_sendto+0x6e/0x90 net/socket.c:1796  do_syscall_64+0xbc/0xf0 arch/x86/entry/common.c:291  entry_SYSCALL_64_after_hwframe+0x63/0xe7 ",4ffcbfac60642f63ae3d80891f573ba7e94a265c,1
SUNRPC: Destroy transport from the system workqueue,"The transport may need to flush transport connect and receive tasks that are running on rpciod. In order to do so safely, we need to ensure that the caller of cancel_work_sync() etc is not itself running on rpciod. Do so by running the destroy task from the system workqueue.  ",528fd3547bad0bdd31c8f987e5bd00c83df8af39,0
net/packet: annotate accesses to po->ifindex,"Like prior patch, we need to annotate lockless accesses to po->ifindex For instance, packet_getname() is reading po->ifindex (twice) while another thread is able to change po->ifindex.  KCSAN reported:  BUG: KCSAN: data-race in packet_do_bind / packet_getname  write to 0xffff888143ce3cbc of 4 bytes by task 25573 on cpu 1:  packet_do_bind+0x420/0x7e0 net/packet/af_packet.c:3191  packet_bind+0xc3/0xd0 net/packet/af_packet.c:3255  __sys_bind+0x200/0x290 net/socket.c:1637  __do_sys_bind net/socket.c:1648 [inline]  __se_sys_bind net/socket.c:1646 [inline]  __x64_sys_bind+0x3d/0x50 net/socket.c:1646  do_syscall_64+0x4a/0x90 arch/x86/entry/common.c:47  entry_SYSCALL_64_after_hwframe+0x44/0xae  read to 0xffff888143ce3cbc of 4 bytes by task 25578 on cpu 0:  packet_getname+0x5b/0x1a0 net/packet/af_packet.c:3525  __sys_getsockname+0x10e/0x1a0 net/socket.c:1887  __do_sys_getsockname net/socket.c:1902 [inline]  __se_sys_getsockname net/socket.c:1899 [inline]  __x64_sys_getsockname+0x3e/0x50 net/socket.c:1899  do_syscall_64+0x4a/0x90 arch/x86/entry/common.c:47  entry_SYSCALL_64_after_hwframe+0x44/0xae  value changed: 0x00000000 -> 0x00000001  Reported by Kernel Concurrency Sanitizer on: CPU: 0 PID: 25578 Comm: syz-executor.5 Not tainted 5.13.0-rc6-syzkaller #0 Hardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 01/01/2011  ",e032f7c9c7cefffcfb79b9fc16c53011d2d9d11f,1
ALSA: rawmidi: Access runtime->avail always in spinlock,"The runtime->avail field may be accessed concurrently while some places refer to it without taking the runtime->lock spinlock, as detected by KCSAN.  Usually this isn't a big problem, but for consistency and safety, we should take the spinlock at each place referencing this field.  ",88a06d6fd6b369d88cec46c62db3e2604a2f50d5,0
sctp: not copy sctp_sock pd_lobby in sctp_copy_descendant,"Now sctp_copy_descendant() copies pd_lobby from old sctp scok to new sctp sock. If sctp_sock_migrate() returns error, it will panic when releasing new sock and trying to purge pd_lobby due to the incorrect pointers in pd_lobby.    ",636d25d557d1073281013c43e4ff4737692da2d4,0
tun: fix data-race in gro_normal_list(),"There is a race in the TUN driver between napi_busy_loop and napi_gro_frags. This commit resolves the race by adding the NAPI struct via netif_tx_napi_add, instead of netif_napi_add, which disables polling for the NAPI struct.  KCSAN reported: BUG: KCSAN: data-race in gro_normal_list.part.0 / napi_busy_loop  write to 0xffff8880b5d474b0 of 4 bytes by task 11205 on cpu 0:  gro_normal_list.part.0+0x77/0xb0 net/core/dev.c:5682  gro_normal_list net/core/dev.c:5678 [inline]  gro_normal_one net/core/dev.c:5692 [inline]  napi_frags_finish net/core/dev.c:5705 [inline]  napi_gro_frags+0x625/0x770 net/core/dev.c:5778  tun_get_user+0x2150/0x26a0 drivers/net/tun.c:1976  tun_chr_write_iter+0x79/0xd0 drivers/net/tun.c:2022  call_write_iter include/linux/fs.h:1895 [inline]  do_iter_readv_writev+0x487/0x5b0 fs/read_write.c:693  do_iter_write fs/read_write.c:970 [inline]  do_iter_write+0x13b/0x3c0 fs/read_write.c:951  vfs_writev+0x118/0x1c0 fs/read_write.c:1015  do_writev+0xe3/0x250 fs/read_write.c:1058  __do_sys_writev fs/read_write.c:1131 [inline]  __se_sys_writev fs/read_write.c:1128 [inline]  __x64_sys_writev+0x4e/0x60 fs/read_write.c:1128  do_syscall_64+0xcc/0x370 arch/x86/entry/common.c:290  entry_SYSCALL_64_after_hwframe+0x44/0xa9  read to 0xffff8880b5d474b0 of 4 bytes by task 11168 on cpu 1:  gro_normal_list net/core/dev.c:5678 [inline]  napi_busy_loop+0xda/0x4f0 net/core/dev.c:6126  sk_busy_loop include/net/busy_poll.h:108 [inline]  __skb_recv_udp+0x4ad/0x560 net/ipv4/udp.c:1689  udpv6_recvmsg+0x29e/0xe90 net/ipv6/udp.c:288  inet6_recvmsg+0xbb/0x240 net/ipv6/af_inet6.c:592  sock_recvmsg_nosec net/socket.c:871 [inline]  sock_recvmsg net/socket.c:889 [inline]  sock_recvmsg+0x92/0xb0 net/socket.c:885  sock_read_iter+0x15f/0x1e0 net/socket.c:967  call_read_iter include/linux/fs.h:1889 [inline]  new_sync_read+0x389/0x4f0 fs/read_write.c:414  __vfs_read+0xb1/0xc0 fs/read_write.c:427  vfs_read fs/read_write.c:461 [inline]  vfs_read+0x143/0x2c0 fs/read_write.c:446  ksys_read+0xd5/0x1b0 fs/read_write.c:587  __do_sys_read fs/read_write.c:597 [inline]  __se_sys_read fs/read_write.c:595 [inline]  __x64_sys_read+0x4c/0x60 fs/read_write.c:595  do_syscall_64+0xcc/0x370 arch/x86/entry/common.c:290  entry_SYSCALL_64_after_hwframe+0x44/0xa9  Reported by Kernel Concurrency Sanitizer on: CPU: 1 PID: 11168 Comm: syz-executor.0 Not tainted 5.4.0-rc6+ #0 Hardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 01/01/2011  ",c39e342a050a4425348e6fe7f75827c0a1a7ebc5,1
usbip: vhci_hcd fix shift out-of-bounds in vhci_hub_control(),Fix shift out-of-bounds in vhci_hub_control() SetPortFeature handling.  UBSAN: shift-out-of-bounds in drivers/usb/usbip/vhci_hcd.c:605:42 shift exponent 768 is too large for 32-bit type 'int'  ,1cc5ed25bdade86de2650a82b2730108a76de20c,1
media: digitv: don't continue if remote control state can't be read,This results in an uninitialized variable read.  ,eecc70d22ae51225de1ef629c1159f7116476b2e,1
media: vivid: use vfree() instead of kfree() for dev->bitmap_cap,"syzkaller reported crashes on kfree() called from vivid_vid_cap_s_selection(). This looks like a simple typo, as dev->bitmap_cap is allocated with vzalloc() throughout the file.  ",dad7e270ba712ba1c99cd2d91018af6044447a06,1
net: erspan: fix use-after-free,"When building the erspan header for either v1 or v2, the eth_hdr() does not point to the right inner packet's eth_hdr, causing kasan report use-after-free and slab-out-of-bouds read.  The patch fixes the following syzkaller issues: [1] BUG: KASAN: slab-out-of-bounds in erspan_xmit+0x22d4/0x2430 net/ipv4/ip_gre.c:735 [2] BUG: KASAN: slab-out-of-bounds in erspan_build_header+0x3bf/0x3d0 net/ipv4/ip_gre.c:698 [3] BUG: KASAN: use-after-free in erspan_xmit+0x22d4/0x2430 net/ipv4/ip_gre.c:735 [4] BUG: KASAN: use-after-free in erspan_build_header+0x3bf/0x3d0 net/ipv4/ip_gre.c:698  [2] CPU: 0 PID: 3654 Comm: syzkaller377964 Not tainted 4.15.0-rc9+ #185 Hardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 01/01/2011 Call Trace:  __dump_stack lib/dump_stack.c:17 [inline]  dump_stack+0x194/0x257 lib/dump_stack.c:53  print_address_description+0x73/0x250 mm/kasan/report.c:252  kasan_report_error mm/kasan/report.c:351 [inline]  kasan_report+0x25b/0x340 mm/kasan/report.c:409  __asan_report_load_n_noabort+0xf/0x20 mm/kasan/report.c:440  erspan_build_header+0x3bf/0x3d0 net/ipv4/ip_gre.c:698  erspan_xmit+0x3b8/0x13b0 net/ipv4/ip_gre.c:740  __netdev_start_xmit include/linux/netdevice.h:4042 [inline]  netdev_start_xmit include/linux/netdevice.h:4051 [inline]  packet_direct_xmit+0x315/0x6b0 net/packet/af_packet.c:266  packet_snd net/packet/af_packet.c:2943 [inline]  packet_sendmsg+0x3aed/0x60b0 net/packet/af_packet.c:2968  sock_sendmsg_nosec net/socket.c:638 [inline]  sock_sendmsg+0xca/0x110 net/socket.c:648  SYSC_sendto+0x361/0x5c0 net/socket.c:1729  SyS_sendto+0x40/0x50 net/socket.c:1697  do_syscall_32_irqs_on arch/x86/entry/common.c:327 [inline]  do_fast_syscall_32+0x3ee/0xf9d arch/x86/entry/common.c:389  entry_SYSENTER_compat+0x54/0x63 arch/x86/entry/entry_64_compat.S:129 ",b423d13c08a656c719fa56324a8f4279c835d90c,1
mm: mmap: Fix general protection fault in unlink_file_vma(),"The syzbot reported the below general protection fault:    general protection fault, probably for non-canonical address   0xe00eeaee0000003b: 0000 [#1] PREEMPT SMP KASAN   KASAN: maybe wild-memory-access in range [0x00777770000001d8-0x00777770000001df]   CPU: 1 PID: 10488 Comm: syz-executor721 Not tainted 5.9.0-rc3-syzkaller #0   ",bc4fe4cdd602b3bee5eeb49d843bd6b3296cfc86,1
NFS: Cleanup if nfs_match_client is interrupted,Don't bail out before cleaning up a new allocation if the wait for searching for a matching nfs client is interrupted.  Memory leaks.  ,9f7761cf0409465075dadb875d5d4b8ef2f890c8,0
tipc: pass tunnel dev as NULL to udp_tunnel(6)_xmit_skb,"udp_tunnel(6)_xmit_skb() called by tipc_udp_xmit() expects a tunnel device to count packets on dev->tstats, a perpcu variable. However, TIPC is using udp tunnel with no tunnel device, and pass the lower dev, like veth device that only initializes dev->lstats(a perpcu variable) when creating it.  Later iptunnel_xmit_stats() called by ip(6)tunnel_xmit() thinks the dev as a tunnel device, and uses dev->tstats instead of dev->lstats. tstats' each pointer points to a bigger struct than lstats, so when tstats->tx_bytes is increased, other percpu variable's members could be overwritten.  syzbot has reported quite a few crashes due to fib_nh_common percpu member 'nhc_pcpu_rth_output' overwritten, call traces are like:    BUG: KASAN: slab-out-of-bounds in rt_cache_valid+0x158/0x190   net/ipv4/route.c:1556     rt_cache_valid+0x158/0x190 net/ipv4/route.c:1556     __mkroute_output net/ipv4/route.c:2332 [inline]     ip_route_output_key_hash_rcu+0x819/0x2d50 net/ipv4/route.c:2564     ip_route_output_key_hash+0x1ef/0x360 net/ipv4/route.c:2393     __ip_route_output_key include/net/route.h:125 [inline]     ip_route_output_flow+0x28/0xc0 net/ipv4/route.c:2651     ip_route_output_key include/net/route.h:135 [inline]   ...  or:    kasan: GPF could be caused by NULL-ptr deref or user memory access   ",c3bcde026684c62d7a2b6f626dc7cf763833875c,1
net/smc: simplify wait when closing listen socket,"Closing of a listen socket wakes up kernel_accept() of smc_tcp_listen_worker(), and then has to wait till smc_tcp_listen_worker() gives up the internal clcsock. The wait logic introduced with commit 127f49705823 (""net/smc: release clcsock from tcp_listen_worker"") might wait longer than necessary. This patch implements the idea to implement the wait just with flush_work(), and gets rid of the extra smc_close_wait_listen_clcsock() function.  ",3d502067599f0db12e74e6646aee8728efe3e5be,0
drivers: net: hamradio: Fix suspicious RCU usage warning in bpqether.c,This patch fixes the following warning: ,95f59bf88bb75281cc626e283ecefdd5d5641427,0
USB: ldusb: fix control-message timeout,"USB control-message timeouts are specified in milliseconds, not jiffies. Waiting 83 minutes for a transfer to complete is a bit excessive.  ",52403cfbc635d28195167618690595013776ebde,0
netfilter: nft_osf: add missing check for DREG attribute,syzbot reports just another NULL deref crash because of missing test for presence of the attribute.  ,7eaecf7963c1c8f62d62c6a8e7c439b0e7f2d365,1
ALSA: info: Drop WARN_ON() from buffer NULL sanity check,"snd_info_get_line() has a sanity check of NULL buffer -- both buffer itself being NULL and buffer->buffer being NULL.  Basically both checks are valid and necessary, but the problem is that it's with snd_BUG_ON() macro that triggers WARN_ON().  The latter condition (NULL buffer->buffer) can be met arbitrarily by user since the buffer is allocated at the first write, so it means that user can trigger WARN_ON() at will.  This patch addresses it by simply moving buffer->buffer NULL check out of snd_BUG_ON() so that spurious ",60379ba08532eca861e933b389526a4dc89e0c42,1
net_sched: fix a missing refcnt in tcindex_init(),"The initial refcnt of struct tcindex_data should be 1, it is clear that I forgot to set it to 1 in tcindex_init(). This leads to a dec-after-zero warning.  ",a8eab6d35e22f4f21471f16147be79529cd6aaf7,0
ovl: relax WARN_ON() on rename to self,"In ovl_rename(), if new upper is hardlinked to old upper underneath overlayfs before upper dirs are locked, user will get an ESTALE error and a WARN_ON will be printed.  Changes to underlying layers while overlayfs is mounted may result in unexpected behavior, but it shouldn't crash the kernel and it shouldn't trigger WARN_ON() either, so relax this WARN_ON().  ",6889ee5a53b8d969aa542047f5ac8acdc0e79a91,1
netfilter: nf_tables: add __nft_chain_type_get(),This new helper function validates that unknown family and chain type coming from userspace do not trigger an out-of-bound array access. Bail out in case __nft_chain_type_get() returns NULL from nft_chain_parse_hook().  ,826035498ec14b77b62a44f0cb6b94d45530db6f,1
"Revert ""net: ptr_ring: otherwise safe empty checks can overrun array bounds""","This reverts commit bcecb4bbf88aa03171c30652bca761cf27755a6b.  If we try to allocate an extra entry as the above commit did, and when the requested size is UINT_MAX, addition overflows causing zero size to be passed to kmalloc().  kmalloc then returns ZERO_SIZE_PTR with a subsequent crash.  ",9fb582b67072bea6cbfe1aefc2be13c62c7681bf,1
alarmtimer: Init nanosleep alarm timer on stack,"syszbot reported the following debugobjects splat:   ODEBUG: object is on stack, but not annotated  ",bd03143007eb9b03a7f2316c677780561b68ba2a,1
reimplement path_mountpoint() with less magic,"... and get rid of a bunch of bugs in it.  Background: the reason for path_mountpoint() is that umount() really doesn't want attempts to revalidate the root of what it's trying to umount. The thing we want to avoid actually happen from complete_walk(); solution was to do something parallel to normal path_lookupat() and it both went overboard and got the boilerplate subtly (and not so subtly) wrong.  A better solution is to do pretty much what the normal path_lookupat() does, but instead of complete_walk() do unlazy_walk().  All it takes to avoid that ->d_weak_revalidate() call...  mountpoint_last() goes away, along with everything it got wrong, and so does the magic around LOOKUP_NO_REVAL.  Another source of bugs is that when we traverse mounts at the final location (and we need to do that - umount . expects to get whatever's overmounting ., if any, out of the lookup) we really ought to take care of ->d_manage() - as it is, manual umount of autofs automount in progress can lead to unpleasant surprises for the daemon.  Easily solved by using handle_lookup_down() instead of follow_mount().  ",c64cd6e34ea340adbb2a0a2f99cc884b96dcdca5,0
net/smc: Avoid warning of possible recursive locking,Possible recursive locking is detected by lockdep when SMC falls back to TCP. The corresponding warnings are as follows:   ,7a61432dc81375be06b02f0061247d3efbdfce3a,0
squashfs: add more sanity checks in xattr id lookup,"Sysbot has reported a warning where a kmalloc() attempt exceeds the maximum limit.  This has been identified as corruption of the xattr_ids count when reading the xattr id lookup table.  This patch adds a number of additional sanity checks to detect this corruption and others.  1. It checks for a corrupted xattr index read from the inode.  This could    be because the metadata block is uncompressed, or because the    ""compression"" bit has been corrupted (turning a compressed block    into an uncompressed block).  This would cause an out of bounds read.  2. It checks against corruption of the xattr_ids count.  This can either    lead to the above kmalloc failure, or a smaller than expected    table to be read.  3. It checks the contents of the index table for corruption.  [phillip@squashfs.org.uk: fix checkpatch issue]    ",506220d2ba21791314af569211ffd8870b8208fa,1
media: dtv5100: fix control-request directions,The direction of the pipe argument must match the request-type direction bit or control requests may fail depending on the host-controller-driver implementation.  Fix the control requests which erroneously used usb_rcvctrlpipe().  ,8c8b9a9be2afa8bd6a72ad1130532baab9fab89d,0
ext4: fix EXT4_MAX_LOGICAL_BLOCK macro,"ext4 supports max number of logical blocks in a file to be 0xffffffff. (This is since ext4_extent's ee_block is __le32). This means that EXT4_MAX_LOGICAL_BLOCK should be 0xfffffffe (starting from 0 logical offset). This patch fixes this.  The issue was seen when ext4 moved to iomap_fiemap API and when overlayfs was mounted on top of ext4. Since overlayfs was missing filemap_check_ranges(), so it could pass a arbitrary huge length which lead to overflow of map.m_len logic.  This patch fixes that.  ",175efa81feb8405676e0136d97b10380179c92e0,1
mptcp: fix DSS map generation on fin retransmission,"The RFC 8684 mandates that no-data DATA FIN packets should carry a DSS with 0 sequence number and data len equal to 1. Currently, on FIN retransmission we re-use the existing mapping; if the previous fin transmission was part of a partially acked data packet, we could end-up writing in the egress packet a non-compliant DSS.  The above will be detected by a ""Bad mapping"" warning on the receiver side.  This change addresses the issue explicitly checking for 0 len packet when adding the DATA_FIN option.  ",9c29e36152748fd623fcff6cc8f538550f9eeafc,0
NFC: nci: fix memory leak in nci_allocate_device,"nfcmrvl_disconnect fails to free the hci_dev field in struct nci_dev. Fix this by freeing hci_dev in nci_free_device.  BUG: memory leak unreferenced object 0xffff888111ea6800 (size 1024):   comm ""kworker/1:0"", pid 19, jiffies 4294942308 (age 13.580s)   ",e0652f8bb44d6294eeeac06d703185357f25d50b,1
tipc: fix race between poll() and setsockopt(),"Letting tipc_poll() dereference a socket's pointer to struct tipc_group entails a race risk, as the group item may be deleted in a concurrent tipc_sk_join() or tipc_sk_leave() thread.  We now move the 'open' flag in struct tipc_group to struct tipc_sock, and let the former retain only a pointer to the moved field. This will eliminate the race risk.  ",60c2530696320ee6ffe4491c17079fa403790c98,1
Bluetooth: Fix null pointer dereference in amp_read_loc_assoc_final_data,kernel panic trace looks like:   #5 [ffffb9e08698fc80] do_page_fault at ffffffffb666e0d7  #6 [ffffb9e08698fcb0] page_fault at ffffffffb70010fe     [exception ,e8bd76ede155fd54d8c41d045dda43cd3174d506,1
mm: mempolicy: handle vma with unmovable pages mapped correctly in mbind,"When running syzkaller internally, we ran into the below bug on 4.9.x kernel:    kernel BUG at mm/huge_memory.c:2124!   invalid opcode: 0000 [#1] SMP KASAN   CPU: 0 PID: 1518 Comm: syz-executor107 Not tainted 4.9.168+ #2   Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS 0.5.1 01/01/2011   ",a53190a4aaa36494f4d7209fd1fcc6f2ee08e0e0,1
KVM: X86: Fix userspace set invalid CR4,Reported by syzkaller:  	,3ca94192278ca8de169d78c085396c424be123b3,1
tipc: fix an use-after-free issue in tipc_recvmsg,"syzbot reported an use-after-free crash:    BUG: KASAN: use-after-free in tipc_recvmsg+0xf77/0xf90 net/tipc/socket.c:1979   Call Trace:    tipc_recvmsg+0xf77/0xf90 net/tipc/socket.c:1979    sock_recvmsg_nosec net/socket.c:943 [inline]    sock_recvmsg net/socket.c:961 [inline]    sock_recvmsg+0xca/0x110 net/socket.c:957    tipc_conn_rcv_from_sock+0x162/0x2f0 net/tipc/topsrv.c:398    tipc_conn_recv_work+0xeb/0x190 net/tipc/topsrv.c:421    process_one_work+0x98d/0x1630 kernel/workqueue.c:2276    worker_thread+0x658/0x11f0 kernel/workqueue.c:2422  As Hoang pointed out, it was caused by skb_cb->bytes_read still accessed after calling tsk_advance_rx_queue() to free the skb in tipc_recvmsg().  This patch is to fix it by accessing skb_cb->bytes_read earlier than calling tsk_advance_rx_queue().  ",cc19862ffe454a5b632ca202e5a51bfec9f89fd2,1
strparser: Call sock_owned_by_user_nocheck,"strparser wants to check socket ownership without producing any warnings. As indicated by the comment in the code, it is permissible for owned_by_user to return true.  ",d66fa9ec53c43bba9fa973c16419f6061b7cc3ea,0
bpf: fix bpf_prog_array_copy_to_user warning from perf event prog query,"syzkaller tried to perform a prog query in perf_event_query_prog_array() where struct perf_event_query_bpf had an ids_len of 1,073,741,353 and thus causing a warning due to failed kcalloc() allocation out of the bpf_prog_array_copy_to_user() helper. Given we cannot attach more than 64 programs to a perf event, there's no point in allowing huge ids_len. Therefore, allow a buffer that would fix the maximum number of ids and also add a __GFP_NOWARN to the temporary ids buffer.  ",9c481b908b011398b1491752271cd1e2c9ad5758,1
hwrng: virtio - don't wait on cleanup,"When virtio-rng device was dropped by the hwrng core we were forced to wait the buffer to come back from the device to not have remaining ongoing operation that could spoil the buffer.  But now, as the buffer is internal to the virtio-rng we can release the waiting loop immediately, the buffer will be retrieve and use when the virtio-rng driver will be selected again.  This avoids to hang on an rng_current write command if the virtio-rng device is blocked by a lack of entropy. This allows to select another entropy source if the current one is empty.  ",2bb31abdbe55742c89f4dc0cc26fcbc8467364f6,0
l2tp: fix races with ipv4-mapped ipv6 addresses,"The l2tp_tunnel_create() function checks for v4mapped ipv6 sockets and cache that flag, so that l2tp core code can reusing it at xmit time.  If the socket is provided by the userspace, the connection status of the tunnel sockets can change between the tunnel creation and the xmit call, so that syzbot is able to trigger the following splat:  BUG: KASAN: use-after-free in ip6_dst_idev include/net/ip6_fib.h:192 [inline] BUG: KASAN: use-after-free in ip6_xmit+0x1f76/0x2260 net/ipv6/ip6_output.c:264 Read of size 8 at addr ffff8801bd949318 by task syz-executor4/23448  CPU: 0 PID: 23448 Comm: syz-executor4 Not tainted 4.16.0-rc4+ #65 Hardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 01/01/2011 Call Trace:   __dump_stack lib/dump_stack.c:17 [inline]   dump_stack+0x194/0x24d lib/dump_stack.c:53   print_address_description+0x73/0x250 mm/kasan/report.c:256   kasan_report_error mm/kasan/report.c:354 [inline]   kasan_report+0x23c/0x360 mm/kasan/report.c:412   __asan_report_load8_noabort+0x14/0x20 mm/kasan/report.c:433   ip6_dst_idev include/net/ip6_fib.h:192 [inline]   ip6_xmit+0x1f76/0x2260 net/ipv6/ip6_output.c:264   inet6_csk_xmit+0x2fc/0x580 net/ipv6/inet6_connection_sock.c:139   l2tp_xmit_core net/l2tp/l2tp_core.c:1053 [inline]   l2tp_xmit_skb+0x105f/0x1410 net/l2tp/l2tp_core.c:1148   pppol2tp_sendmsg+0x470/0x670 net/l2tp/l2tp_ppp.c:341   sock_sendmsg_nosec net/socket.c:630 [inline]   sock_sendmsg+0xca/0x110 net/socket.c:640   ___sys_sendmsg+0x767/0x8b0 net/socket.c:2046   __sys_sendmsg+0xe5/0x210 net/socket.c:2080   SYSC_sendmsg net/socket.c:2091 [inline]   SyS_sendmsg+0x2d/0x50 net/socket.c:2087   do_syscall_64+0x281/0x940 arch/x86/entry/common.c:287   entry_SYSCALL_64_after_hwframe+0x42/0xb7 ",b954f94023dcc61388c8384f0f14eb8e42c863c5,1
seg6: fix seg6_validate_srh() to avoid slab-out-of-bounds,"The seg6_validate_srh() is used to validate SRH for three cases:  case1: SRH of data-plane SRv6 packets to be processed by the Linux kernel. Case2: SRH of the netlink message received  from user-space (iproute2) Case3: SRH injected into packets through setsockopt  In case1, the SRH can be encoded in the Reduced way (i.e., first SID is carried in DA only and not represented as SID in the SRH) and the seg6_validate_srh() now handles this case correctly.  In case2 and case3, the SRH shouldnâ€™t be encoded in the Reduced way otherwise we lose the first segment (i.e., the first hop).  The current implementation of the seg6_validate_srh() allow SRH of case2 and case3 to be encoded in the Reduced way. This leads a slab-out-of-bounds problem.  This patch verifies SRH of case1, case2 and case3. Allowing case1 to be reduced while preventing SRH of case2 and case3 from being reduced .  ",bb986a50421a11bf31a81afb15b9b8f45a4a3a11,1
net: sched: validate stab values,"iproute2 package is well behaved, but malicious user space can provide illegal shift values and trigger UBSAN reports.  Add stab parameter to red_check_params() to validate user input.  ",e323d865b36134e8c5c82c834df89109a5c60dab,0
squashfs: fix divide error in calculate_skip(),"Sysbot has reported a ""divide error"" which has been identified as being caused by a corrupted file_size value within the file inode.  This value has been corrupted to a much larger value than expected.  Calculate_skip() is passed i_size_read(inode) >> msblk->block_log.  Due to the file_size value corruption this overflows the int argument/variable in that function, leading to the divide error.  This patch changes the function to use u64.  This will accommodate any unexpectedly large values due to corruption.  The value returned from calculate_skip() is clamped to be never more than SQUASHFS_CACHED_BLKS - 1, or 7.  So file_size corruption does not lead to an unexpectedly large return result here.  ",d6e621de1fceb3b098ebf435ef7ea91ec4838a1a,1
sch_sfq: validate silly quantum values,"syzbot managed to set up sfq so that q->scaled_quantum was zero, triggering an infinite loop in sfq_dequeue()  More generally, we must only accept quantum between 1 and 2^18 - 7, meaning scaled_quantum must be in [1, 0x7FFF] range.  Otherwise, we also could have a loop in sfq_dequeue() if scaled_quantum happens to be 0x8000, since slot->allot could indefinitely switch between 0 and 0x8000.  ",df4953e4e997e273501339f607b77953772e3559,1
tcp: repaired skbs must init their tso_segs,syzbot reported a WARN_ON(!tcp_skb_pcount(skb)) in tcp_send_loss_probe() [1]  This was caused by TCP_REPAIR sent skbs that inadvertenly were missing a call to tcp_init_tso_segs()  [1] ,bf50b606cfd85ac8d3d0adb711f3e22204059848,0
sctp: fix sctp_auth_init_hmacs() error path,"After freeing ep->auth_hmacs we have to clear the pointer or risk use-after-free as reported by syzbot:  BUG: KASAN: use-after-free in sctp_auth_destroy_hmacs net/sctp/auth.c:509 [inline] BUG: KASAN: use-after-free in sctp_auth_destroy_hmacs net/sctp/auth.c:501 [inline] BUG: KASAN: use-after-free in sctp_auth_free+0x17e/0x1d0 net/sctp/auth.c:1070 Read of size 8 at addr ffff8880a8ff52c0 by task syz-executor941/6874  CPU: 0 PID: 6874 Comm: syz-executor941 Not tainted 5.9.0-rc8-syzkaller #0 Hardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 01/01/2011 Call Trace:  __dump_stack lib/dump_stack.c:77 [inline]  dump_stack+0x198/0x1fd lib/dump_stack.c:118  print_address_description.constprop.0.cold+0xae/0x497 mm/kasan/report.c:383  __kasan_report mm/kasan/report.c:513 [inline]  kasan_report.cold+0x1f/0x37 mm/kasan/report.c:530  sctp_auth_destroy_hmacs net/sctp/auth.c:509 [inline]  sctp_auth_destroy_hmacs net/sctp/auth.c:501 [inline]  sctp_auth_free+0x17e/0x1d0 net/sctp/auth.c:1070  sctp_endpoint_destroy+0x95/0x240 net/sctp/endpointola.c:203  sctp_endpoint_put net/sctp/endpointola.c:236 [inline]  sctp_endpoint_free+0xd6/0x110 net/sctp/endpointola.c:183  sctp_destroy_sock+0x9c/0x3c0 net/sctp/socket.c:4981  sctp_v6_destroy_sock+0x11/0x20 net/sctp/socket.c:9415  sk_common_release+0x64/0x390 net/core/sock.c:3254  sctp_close+0x4ce/0x8b0 net/sctp/socket.c:1533  inet_release+0x12e/0x280 net/ipv4/af_inet.c:431  inet6_release+0x4c/0x70 net/ipv6/af_inet6.c:475  __sock_release+0xcd/0x280 net/socket.c:596  sock_close+0x18/0x20 net/socket.c:1277  __fput+0x285/0x920 fs/file_table.c:281  task_work_run+0xdd/0x190 kernel/task_work.c:141  exit_task_work include/linux/task_work.h:25 [inline]  do_exit+0xb7d/0x29f0 kernel/exit.c:806  do_group_exit+0x125/0x310 kernel/exit.c:903  __do_sys_exit_group kernel/exit.c:914 [inline]  __se_sys_exit_group kernel/exit.c:912 [inline]  __x64_sys_exit_group+0x3a/0x50 kernel/exit.c:912  do_syscall_64+0x2d/0x70 arch/x86/entry/common.c:46  entry_SYSCALL_64_after_hwframe+0x44/0xa9 ",d42ee76ecb6c49d499fc5eb32ca34468d95dbc3e,1
blktrace: fix trace mutex deadlock,"A previous commit changed the locking around registration/cleanup, but direct callers of blk_trace_remove() were missed. This means that if we hit the error path in setup, we will deadlock on attempting to re-acquire the queue trace mutex.  ",2967acbb257a6a9bf912f4778b727e00972eac9b,0
fq_codel: reject silly quantum parameters,"syzbot found that forcing a big quantum attribute would crash hosts fast, essentially using this:  tc qd replace dev eth0 root fq_codel quantum 4294967295  This is because fq_codel_dequeue() would have to loop ~2^31 times in :  	if (flow->deficit <= 0) { 		flow->deficit += q->quantum; 		list_move_tail(&flow->flowchain, &q->old_flows); 		goto begin; 	}  SFQ max quantum is 2^19 (half a megabyte) Lets adopt a max quantum of one megabyte for FQ_CODEL.  ",c7c5e6ff533fe1f9afef7d2fa46678987a1335a7,1
ceph: fix use-after-free for fsc->mdsc,"If the ceph_mdsc_init() fails, it will free the mdsc already.  ",a7caa88f8b72c136f9a401f498471b8a8e35370d,1
ntfs: check for valid standard information attribute,Mounting a corrupted filesystem with NTFS resulted in a kernel crash.  We should check for valid STANDARD_INFORMATION attribute offset and length before trying to access it  ,4dfe6bd94959222e18d512bdf15f6bf9edb9c27c,1
fat: fix uninit-memory access for partial initialized inode,"When get an error in the middle of reading an inode, some fields in the inode might be still not initialized.  And then the evict_inode path may access those fields via iput().  To fix, this makes sure that inode fields are initialized.  ",bc87302a093f0eab45cd4e250c2021299f712ec6,0
fuse: change interrupt requests allocation algorithm,"Using of two unconnected IDs req->in.h.unique and req->intr_unique does not allow to link requests to a hash table. We need can't use none of them as a key to calculate hash.  This patch changes the algorithm of allocation of IDs for a request. Plain requests obtain even ID, while interrupt requests are encoded in the low bit. So, in next patches we will be able to use the rest of ID bits to calculate hash, and the hash will be the same for plain and interrupt requests.  ",c59fd85e4fd07fdf0ab523a5e9734f5338d6aa19,0
ALSA: mixer: oss: Fix racy access to slots,"The OSS mixer can reassign the mapping slots dynamically via proc file.  Although the addition and deletion of those slots are protected by mixer->reg_mutex, the access to slots aren't, hence this may cause UAF when the slots in use are deleted concurrently.  This patch applies the mixer->reg_mutex in all appropriate code paths (i.e. the ioctl functions) that may access slots.  ",411cef6adfb38a5bb6bd9af3941b28198e7fb680,0
taskstats: fix data-race,When assiging and testing taskstats in taskstats_exit() there's a race when setting up and reading sig->stats when a thread-group with more than one thread exits:  write to 0xffff8881157bbe10 of 8 bytes by task 7951 on cpu 0:  taskstats_tgid_alloc kernel/taskstats.c:567 [inline]  taskstats_exit+0x6b7/0x717 kernel/taskstats.c:596  do_exit+0x2c2/0x18e0 kernel/exit.c:864  do_group_exit+0xb4/0x1c0 kernel/exit.c:983  get_signal+0x2a2/0x1320 kernel/signal.c:2734  do_signal+0x3b/0xc00 arch/x86/kernel/signal.c:815  exit_to_usermode_loop+0x250/0x2c0 arch/x86/entry/common.c:159  prepare_exit_to_usermode arch/x86/entry/common.c:194 [inline]  syscall_return_slowpath arch/x86/entry/common.c:274 [inline]  do_syscall_64+0x2d7/0x2f0 arch/x86/entry/common.c:299  entry_SYSCALL_64_after_hwframe+0x44/0xa9  read to 0xffff8881157bbe10 of 8 bytes by task 7949 on cpu 1:  taskstats_tgid_alloc kernel/taskstats.c:559 [inline]  taskstats_exit+0xb2/0x717 kernel/taskstats.c:596  do_exit+0x2c2/0x18e0 kernel/exit.c:864  do_group_exit+0xb4/0x1c0 kernel/exit.c:983  __do_sys_exit_group kernel/exit.c:994 [inline]  __se_sys_exit_group kernel/exit.c:992 [inline]  __x64_sys_exit_group+0x2e/0x30 kernel/exit.c:992  do_syscall_64+0xcf/0x2f0 arch/x86/entry/common.c:296  entry_SYSCALL_64_after_hwframe+0x44/0xa9  Fix this by using smp_load_acquire() and smp_store_release().  ,0b8d616fb5a8ffa307b1d3af37f55c15dae14f28,1
tipc: eliminate KMSAN uninit-value in strcmp complaint,"When we get link properties through netlink interface with tipc_nl_node_get_link(), we don't validate TIPC_NLA_LINK_NAME attribute at all, instead we directly use it. As a consequence, KMSAN detected the TIPC_NLA_LINK_NAME attribute was an uninitialized value, and then posted the following complaint:  ",94f6a80c0c11828cb7b3d79294459dd8d761ca89,1
tcp: cleanup copied_seq and urg_data in tcp_disconnect,"tcp_zerocopy_receive() relies on tcp_inq() to limit number of bytes requested by user.  syzbot found that after tcp_disconnect(), tcp_inq() was returning a stale value (number of bytes in queue before the disconnect).  Note that after this patch, ioctl(fd, SIOCINQ, &val) is also fixed and returns 0, so this might be a candidate for all known linux kernels.  While we are at this, we probably also should clear urg_data to avoid other syzkaller reports after it discovers how to deal with urgent data.  syzkaller repro :  socket(PF_INET, SOCK_STREAM, IPPROTO_IP) = 3 bind(3, {sa_family=AF_INET, sin_port=htons(20000), sin_addr=inet_addr(""224.0.0.1"")}, 16) = 0 connect(3, {sa_family=AF_INET, sin_port=htons(20000), sin_addr=inet_addr(""127.0.0.1"")}, 16) = 0 send(3, ..., 4096, 0) = 4096 connect(3, {sa_family=AF_UNSPEC, sa_data=""\0\0\0\0\0\0\0\0\0\0\0\0\0\0""}, 128) = 0 getsockopt(3, SOL_TCP, TCP_ZEROCOPY_RECEIVE, ..., [16]) = 0 // CRASH  ",6508b6781be076f889e3077a1a5fadf1930a569d,1
bpf: arsh is not supported in 32 bit alu thus reject it,"The following snippet was throwing an 'unknown opcode cc' warning in BPF interpreter:    0: (18) r0 = 0x0   2: (7b) *(u64 *)(r10 -16) = r0   3: (cc) (u32) r0 s>>= (u32) r0   4: (95) exit  Although a number of JITs do support BPF_ALU | BPF_ARSH | BPF_{K,X} generation, not all of them do and interpreter does neither. We can leave existing ones and implement it later in bpf-next for the remaining ones, but reject this properly in verifier for the time being.  ",7891a87efc7116590eaba57acc3c422487802c6f,0
x86/entry: Fix assumptions that the HW TSS is at the beginning of cpu_tss,"A future patch will move SYSENTER_stack to the beginning of cpu_tss to help detect overflow.  Before this can happen, fix several code paths that hardcode assumptions about the old layout.  ",7fb983b4dd569e08564134a850dfd4eb1c63d9b8,1
blkcg: fix memory leak in blk_iolatency_init,"BUG: memory leak unreferenced object 0xffff888129acdb80 (size 96):   comm ""syz-executor.1"", pid 12661, jiffies 4294962682 (age 15.220s)   ",6f5ddde41069fcd1f0993ec76c9dbbf9d021fd4d,1
HID: hiddev: Fix slab-out-of-bounds write in hiddev_ioctl_usage(),"`uref->usage_index` is not always being properly checked, causing hiddev_ioctl_usage() to go out of bounds under some cases. Fix it.  ",25a097f5204675550afb879ee18238ca917cba7a,1
staging: gigaset: fix general protection fault on probe,Fix a general protection fault when accessing the endpoint descriptors which could be triggered by a malicious device due to missing sanity checks on the number of endpoints.  ,53f35a39c3860baac1e5ca80bf052751cfb24a99,1
KVM: fix placement of refcount initialization,Reported by syzkaller:     ,e2d3fcaf939dded3da604a25ebbea9fb954c2280,1
cfg80211: fix netdev registration deadlock,"If register_netdevice() fails after having called cfg80211's netdev notifier (cfg80211_netdev_notifier_call) it will call the notifier again with UNREGISTER. This would then lock the wiphy mutex because we're marked as registered, which causes a deadlock.  Fix this by separately keeping track of whether or not we're in the middle of registering to also skip the notifier call on this unregister.  ",40c575d1ec71f7a61c73ba1603a69650c130559c,0
ipv4: fix NULL dereference in free_fib_info_rcu(),"If fi->fib_metrics could not be allocated in fib_create_info() we attempt to dereference a NULL pointer in free_fib_info_rcu() :      m = fi->fib_metrics;     if (m != &dst_default_metrics && atomic_dec_and_test(&m->refcnt))             kfree(m);  Before my recent patch, we used to call kfree(NULL) and nothing wrong happened.  Instead of using RCU to defer freeing while we are under memory stress, it seems better to take immediate action.  This was reported by syzkaller team.  ",187e5b3ac84d3421d2de3aca949b2791fbcad554,1
sctp: clear the transport of some out_chunk_list chunks in sctp_assoc_rm_peer,"If a transport is removed by asconf but there still are some chunks with this transport queuing on out_chunk_list, later an use-after-free issue will be caused when accessing this transport from these chunks in sctp_outq_flush().  This is an old bug, we fix it by clearing the transport of these chunks in out_chunk_list when removing a transport in sctp_assoc_rm_peer().  ",df132eff463873e14e019a07f387b4d577d6d1f9,1
nbd: do del_gendisk() asynchronously for NBD_DESTROY_ON_DISCONNECT,"Now open_mutex is used to synchronize partition operations (e.g, blk_drop_partitions() and blkdev_reread_part()), however it makes nbd driver broken, because nbd may call del_gendisk() in nbd_release() or nbd_genl_disconnect() if NBD_CFLAG_DESTROY_ON_DISCONNECT is enabled, and deadlock occurs, as shown below:  // AB-BA dead-lock nbd_genl_disconnect            blkdev_open   nbd_disconnect_and_put                                  lock bd_mutex   // last ref   nbd_put     lock nbd_index_mutex       del_gendisk                                    nbd_open                                      try lock nbd_index_mutex         try lock bd_mutex   or  // AA dead-lock nbd_release   lock bd_mutex     nbd_put       try lock bd_mutex  Instead of fixing block layer (e.g, introduce another lock), fixing the nbd driver to call del_gendisk() in a kworker when NBD_DESTROY_ON_DISCONNECT is enabled. When NBD_DESTROY_ON_DISCONNECT is disabled, nbd device will always be destroy through module removal, and there is no risky of deadlock.  To ensure the reuse of nbd index succeeds, moving the calling of idr_remove() after del_gendisk(), so if the reused index is not found in nbd_index_idr, the old disk must have been deleted. And reusing the existing destroy_complete mechanism to ensure nbd_genl_connect() will wait for the completion of del_gendisk().  Also adding a new workqueue for nbd removal, so nbd_cleanup() can ensure all removals complete before exits.  ",68c9417b193d0d174b0ada013602272177e61303,0
net_sched: initialize timer earlier in red_init(),"When red_init() fails, red_destroy() is called to clean up. If the timer is not initialized yet, del_timer_sync() will complain. So we have to move timer_setup() before any failure.  ",608b4adab17889576c6636311f495b1a52418c69,0
netfilter: bridge: ebt_among: add missing match size checks,"ebt_among is special, it has a dynamic match size and is exempt from the central size checks.  Therefore it must check that the size of the match structure provided from userspace is sane by making sure em->match_size is at least the minimum size of the expected structure.  The module has such a check, but its only done after accessing a structure that might be out of bounds.  tested with: ebtables -A INPUT ... \ --among-dst fe:fe:fe:fe:fe:fe --among-dst fe:fe:fe:fe:fe:fe --among-src fe:fe:fe:fe:ff:f,fe:fe:fe:fe:fe:fb,fe:fe:fe:fe:fc:fd,fe:fe:fe:fe:fe:fd,fe:fe:fe:fe:fe:fe --among-src fe:fe:fe:fe:ff:f,fe:fe:fe:fe:fe:fa,fe:fe:fe:fe:fe:fd,fe:fe:fe:fe:fe:fe,fe:fe:fe:fe:fe:fe  ",c4585a2823edf4d1326da44d1524ecbfda26bb37,1
hsr: use netdev_err() instead of WARN_ONCE(),"When HSR interface is sending a frame, it finds a node with the destination ethernet address from the list. If there is no node, it calls WARN_ONCE(). But, using WARN_ONCE() for this situation is a little bit overdoing. So, in this patch, the netdev_err() is used instead.  ",4b793acdca0050739b99ace6a8b9e7f717f57c6b,0
RDMA/restrack: Protect from reentry to resource return path,Nullify the resource task struct pointer to ensure that subsequent calls won't try to release task_struct again.  ,fe9bc1644918aa1d02a889b4ca788bfb67f90816,0
9p/trans_fd: abort p9_read_work if req status changed,"p9_read_work would try to handle an errored req even if it got put to error state by another thread between the lookup (that worked) and the time it had been fully read. The request itself is safe to use because we hold a ref to it from the lookup (for m->rreq, so it was safe to read into the request data buffer until this point), but the req_list has been deleted at the same time status changed, and client_cb already has been called as well, so we should not do either.  ",e4ca13f7d075e551dc158df6af18fb412a1dba0a,0
"KVM: x86: Swap order of CPUID entry ""index"" vs. ""significant flag"" checks","Check whether a CPUID entry's index is significant before checking for a matching index to hack-a-fix an undefined behavior bug due to consuming uninitialized data.  RESET/INIT emulation uses kvm_cpuid() to retrieve CPUID.0x1, which does _not_ have a significant index, and fails to initialize the dummy variable that doubles as EBX/ECX/EDX output _and_ ECX, a.k.a. index, input.  Practically speaking, it's _extremely_  unlikely any compiler will yield code that causes problems, as the compiler would need to inline the kvm_cpuid() call to detect the uninitialized data, and intentionally hose the kernel, e.g. insert ud2, instead of simply ignoring the result of the index comparison.  Although the sketchy ""dummy"" pattern was introduced in SVM by commit 66f7b72e1171 (""KVM: x86: Make register state after reset conform to specification""), it wasn't actually broken until commit 7ff6c0350315 (""KVM: x86: Remove stateful CPUID handling"") arbitrarily swapped the order of operations such that ""index"" was checked before the significant flag.  Avoid consuming uninitialized data by reverting to checking the flag before the index purely so that the fix can be easily backported; the offending RESET/INIT code has been refactored, moved, and consolidated from vendor code to common x86 since the bug was introduced.  A future patch will directly address the bad RESET/INIT behavior.  The undefined behavior was detected by syzbot + KernelMemorySanitizer.    BUG: KMSAN: uninit-value in cpuid_entry2_find arch/x86/kvm/cpuid.c:68   BUG: KMSAN: uninit-value in kvm_find_cpuid_entry arch/x86/kvm/cpuid.c:1103   BUG: KMSAN: uninit-value in kvm_cpuid+0x456/0x28f0 arch/x86/kvm/cpuid.c:1183    cpuid_entry2_find arch/x86/kvm/cpuid.c:68 [inline]    kvm_find_cpuid_entry arch/x86/kvm/cpuid.c:1103 [inline]    kvm_cpuid+0x456/0x28f0 arch/x86/kvm/cpuid.c:1183    kvm_vcpu_reset+0x13fb/0x1c20 arch/x86/kvm/x86.c:10885    kvm_apic_accept_events+0x58f/0x8c0 arch/x86/kvm/lapic.c:2923    vcpu_enter_guest+0xfd2/0x6d80 arch/x86/kvm/x86.c:9534    vcpu_run+0x7f5/0x18d0 arch/x86/kvm/x86.c:9788    kvm_arch_vcpu_ioctl_run+0x245b/0x2d10 arch/x86/kvm/x86.c:10020    Local variable ",e8a747d0884e554a8c1872da6c8f680a4f893c6d,1
ALSA: timer: Fix master timer notification,"snd_timer_notify1() calls the notification to each slave for a master event, but it passes a wrong event number.  It should be +10 offset, corresponding to SNDRV_TIMER_EVENT_MXXX, but it's incorrectly with +100 offset.  Casually this was spotted by UBSAN check via syzkaller.  ",9c1fe96bded935369f8340c2ac2e9e189f697d5d,1
io_uring: initialize fixed_file_data lock,"syzbot reports below warning: INFO: trying to register non-static key. the code is fine but needs lockdep annotation. turning off the locking correctness validator. CPU: 1 PID: 7099 Comm: syz-executor897 Not tainted 5.6.0-next-20200406-syzkaller #0 Hardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 01/01/2011 Call Trace:  __dump_stack lib/dump_stack.c:77 [inline]  dump_stack+0x188/0x20d lib/dump_stack.c:118  assign_lock_key kernel/locking/lockdep.c:913 [inline]  register_lock_class+0x1664/0x1760 kernel/locking/lockdep.c:1225  __lock_acquire+0x104/0x4e00 kernel/locking/lockdep.c:4223  lock_acquire+0x1f2/0x8f0 kernel/locking/lockdep.c:4923  __raw_spin_lock_irqsave include/linux/spinlock_api_smp.h:110 [inline]  _raw_spin_lock_irqsave+0x8c/0xbf kernel/locking/spinlock.c:159  io_sqe_files_register fs/io_uring.c:6599 [inline]  __io_uring_register+0x1fe8/0x2f00 fs/io_uring.c:8001  __do_sys_io_uring_register fs/io_uring.c:8081 [inline]  __se_sys_io_uring_register fs/io_uring.c:8063 [inline]  __x64_sys_io_uring_register+0x192/0x560 fs/io_uring.c:8063  do_syscall_64+0xf6/0x7d0 arch/x86/entry/common.c:295  entry_SYSCALL_64_after_hwframe+0x49/0xb3 ",f7fe9346869a12efe3af3cc9be2e45a1b6ff8761,1
Merge branch 'bpf-cgroup-local-storage',Roman Gushchin says:  ,82c018d734a7aa24a9ac8f33f610c55923fb6911,0
net: openvswitch: ovs_ct_exit to be done under ovs_lock,syzbot wrote: | ,27de77cec985233bdf6546437b9761853265c505,0
nfsd: fix cleanup of nfsd_reply_cache_init on failure,The failure to unregister the shrinker results will result in corruption when the nfsd_net is freed.  Also clean up the drc_slab while we're here.  ,689d7ba4895b803244f596e56ffa3d9e4f24acdc,1
media: uvcvideo: Fix error path in control parsing failure,"When parsing the UVC control descriptors fails, the error path tries to cleanup a media device that hasn't been initialised, potentially resulting in a crash. Fix this by initialising the media device before the error handling path can be reached.  ",8c279e9394cade640ed86ec6c6645a0e7df5e0b6,1
netfilter: nf_tables: hook list memleak in flowtable deletion,"After looking up for the flowtable hooks that need to be removed, release the hook objects in the deletion list. The error path needs to released these hook objects too.  ",3003055f50663095472144994dac0339076031a8,0
tipc: fix uninit skb->data in tipc_nl_compat_dumpit(),"__tipc_nl_compat_dumpit() has two callers, and it expects them to pass a valid nlmsghdr via arg->data. This header is artificial and crafted just for __tipc_nl_compat_dumpit().  tipc_nl_compat_publ_dump() does so by putting a genlmsghdr as well as some nested attribute, TIPC_NLA_SOCK. But the other caller tipc_nl_compat_dumpit() does not, this leaves arg->data uninitialized on this call path.  Fix this by just adding a similar nlmsghdr without any payload in tipc_nl_compat_dumpit().  This bug exists since day 1, but the recent commit 6ea67769ff33 (""net: tipc: prepare attrs in __tipc_nl_compat_dumpit()"") makes it easier to appear.  ",47733f9daf4fe4f7e0eb9e273f21ad3a19130487,1
media: dvb-frontends: use ida for pll number,"KASAN: global-out-of-bounds Read in dvb_pll_attach  Syzbot reported global-out-of-bounds Read in dvb_pll_attach, while accessing id[dvb_pll_devcount], because dvb_pll_devcount was 65, that is more than size of 'id' which is DVB_PLL_MAX(64).  Rather than increasing dvb_pll_devcount every time, use ida so that numbers are allocated correctly. This does mean that no more than 64 devices can be attached at the same time, but this is more than sufficient.  usb 1-1: dvb_usb_v2: will pass the complete MPEG2 transport stream to the software demuxer dvbdev: DVB: registering new adapter (774 Friio White ISDB-T USB2.0) usb 1-1: media controller created dvbdev: dvb_create_media_entity: media entity 'dvb-demux' registered. tc90522 0-0018: Toshiba TC90522 attached. usb 1-1: DVB: registering adapter 0 frontend 0 (Toshiba TC90522 ISDB-T module)... dvbdev: dvb_create_media_entity: media entity 'Toshiba TC90522 ISDB-T module' registered. ",c268e7adea52be0093de1164c425f3c8d8927770,1
tty: Fix out-of-bound vmalloc access in imageblit,"This issue happens when a userspace program does an ioctl FBIOPUT_VSCREENINFO passing the fb_var_screeninfo struct containing only the fields xres, yres, and bits_per_pixel with values.  If this struct is the same as the previous ioctl, the vc_resize() detects it and doesn't call the resize_screen(), leaving the fb_var_screeninfo incomplete. And this leads to the updatescrollmode() calculates a wrong value to fbcon_display->vrows, which makes the real_y() return a wrong value of y, and that value, eventually, causes the imageblit to access an out-of-bound address value.  To solve this issue I made the resize_screen() be called even if the screen does not need any resizing, so it will ""fix and fill"" the fb_var_screeninfo independently.  ",3b0c406124719b625b1aba431659f5cdc24a982c,1
apparmor: fix bad debug check in apparmor_secid_to_secctx(),apparmor_secid_to_secctx() has a bad debug statement tripping on a condition handle by the code.  When kconfig SECURITY_APPARMOR_DEBUG is enabled the debug WARN_ON will trip when **secdata is NULL resulting in the following trace.  ,edf4e7b7b9104b58fddfcd073bd7dcc1585d5326,1
crypto: xts - Fix atomic sleep when walking skcipher,"When we perform a walk in the completion function, we need to ensure that it is atomic.  ",44427c0fbc09b448b22410978a4ef6ee37599d25,0
net/9p/trans_fd.c: fix race by holding the lock,"It may be possible to run p9_fd_cancel() with a deleted req->req_list and incur in a double del. To fix hold the client->lock while changing the status, so the other threads will be synchronized.  ",9f476d7c540cb57556d3cc7e78704e6cd5100f5f,1
sch_cbq: validate TCA_CBQ_WRROPT to avoid crash,"syzbot reported a crash in cbq_normalize_quanta() caused by an out of range cl->priority.  iproute2 enforces this check, but malicious users do not.  kasan: CONFIG_KASAN_INLINE enabled kasan: GPF could be caused by NULL-ptr deref or user memory access general protection fault: 0000 [#1] SMP KASAN PTI ",e9789c7cc182484fc031fd88097eb14cb26c4596,1
tun: avoid calling xdp_rxq_info_unreg() twice,"Similarly to tx ring, xdp_rxq_info is only registered when !tfile->detached, so we need to avoid calling xdp_rxq_info_unreg() twice too. The helper tun_cleanup_tx_ring() already checks for this properly, so it is correct to put xdp_rxq_info_unreg() just inside there.  ",c13da21cdb8085f1d9a53463c88a4d3967fe90fd,0
net: metrics: add proper netlink validation,"Before using nla_get_u32(), better make sure the attribute is of the proper size.  Code recently was changed, but bug has been there from beginning of git.  BUG: KMSAN: uninit-value in rtnetlink_put_metrics+0x553/0x960 net/core/rtnetlink.c:746 CPU: 1 PID: 14139 Comm: syz-executor6 Not tainted 4.17.0-rc5+ #103 Hardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 01/01/2011 Call Trace:  __dump_stack lib/dump_stack.c:77 [inline]  dump_stack+0x185/0x1d0 lib/dump_stack.c:113  kmsan_report+0x149/0x260 mm/kmsan/kmsan.c:1084  __msan_warning_32+0x6e/0xc0 mm/kmsan/kmsan_instr.c:686  rtnetlink_put_metrics+0x553/0x960 net/core/rtnetlink.c:746  fib_dump_info+0xc42/0x2190 net/ipv4/fib_semantics.c:1361  rtmsg_fib+0x65f/0x8c0 net/ipv4/fib_semantics.c:419  fib_table_insert+0x2314/0x2b50 net/ipv4/fib_trie.c:1287  inet_rtm_newroute+0x210/0x340 net/ipv4/fib_frontend.c:779  rtnetlink_rcv_msg+0xa32/0x1560 net/core/rtnetlink.c:4646  netlink_rcv_skb+0x378/0x600 net/netlink/af_netlink.c:2448  rtnetlink_rcv+0x50/0x60 net/core/rtnetlink.c:4664  netlink_unicast_kernel net/netlink/af_netlink.c:1310 [inline]  netlink_unicast+0x1678/0x1750 net/netlink/af_netlink.c:1336  netlink_sendmsg+0x104f/0x1350 net/netlink/af_netlink.c:1901  sock_sendmsg_nosec net/socket.c:629 [inline]  sock_sendmsg net/socket.c:639 [inline]  ___sys_sendmsg+0xec0/0x1310 net/socket.c:2117  __sys_sendmsg net/socket.c:2155 [inline]  __do_sys_sendmsg net/socket.c:2164 [inline]  __se_sys_sendmsg net/socket.c:2162 [inline]  __x64_sys_sendmsg+0x331/0x460 net/socket.c:2162  do_syscall_64+0x152/0x230 arch/x86/entry/common.c:287  entry_SYSCALL_64_after_hwframe+0x44/0xa9 ",5b5e7a0de2bbf2a1afcd9f49e940010e9fb80d53,1
vt: vt_ioctl: fix VT_DISALLOCATE freeing in-use virtual console,"The VT_DISALLOCATE ioctl can free a virtual console while tty_release() is still running, causing a use-after-free in con_shutdown().  This occurs because VT_DISALLOCATE considers a virtual console's 'struct vc_data' to be unused as soon as the corresponding tty's refcount hits 0.  But actually it may be still being closed.  Fix this by making vc_data be reference-counted via the embedded 'struct tty_port'.  A newly allocated virtual console has refcount 1. Opening it for the first time increments the refcount to 2.  Closing it for the last time decrements the refcount (in tty_operations::cleanup() so that it happens late enough), as does VT_DISALLOCATE.  Reproducer: 	#include <fcntl.h> 	#include <linux/vt.h> 	#include <sys/ioctl.h> 	#include <unistd.h>  	int main() 	{ 		if (fork()) { 			for (;;) 				close(open(""/dev/tty5"", O_RDWR)); 		} else { 			int fd = open(""/dev/tty10"", O_RDWR);  			for (;;) 				ioctl(fd, VT_DISALLOCATE, 5); 		} 	}  KASAN report: 	BUG: KASAN: use-after-free in con_shutdown+0x76/0x80 drivers/tty/vt/vt.c:3278 	Write of size 8 at addr ffff88806a4ec108 by task syz_vt/129  	CPU: 0 PID: 129 Comm: syz_vt Not tainted 5.6.0-rc2 #11 	Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS ?-20191223_100556-anatol 04/01/2014 	Call Trace: 	 [...] 	 con_shutdown+0x76/0x80 drivers/tty/vt/vt.c:3278 	 release_tty+0xa8/0x410 drivers/tty/tty_io.c:1514 	 tty_release_struct+0x34/0x50 drivers/tty/tty_io.c:1629 	 tty_release+0x984/0xed0 drivers/tty/tty_io.c:1789 	 [...]  	Allocated by task 129: 	 [...] 	 kzalloc include/linux/slab.h:669 [inline] 	 vc_allocate drivers/tty/vt/vt.c:1085 [inline] 	 vc_allocate+0x1ac/0x680 drivers/tty/vt/vt.c:1066 	 con_install+0x4d/0x3f0 drivers/tty/vt/vt.c:3229 	 tty_driver_install_tty drivers/tty/tty_io.c:1228 [inline] 	 tty_init_dev+0x94/0x350 drivers/tty/tty_io.c:1341 	 tty_open_by_driver drivers/tty/tty_io.c:1987 [inline] 	 tty_open+0x3ca/0xb30 drivers/tty/tty_io.c:2035 	 [...]  	Freed by task 130: 	 [...] 	 kfree+0xbf/0x1e0 mm/slab.c:3757 	 vt_disallocate drivers/tty/vt/vt_ioctl.c:300 [inline] 	 vt_ioctl+0x16dc/0x1e30 drivers/tty/vt/vt_ioctl.c:818 	 tty_ioctl+0x9db/0x11b0 drivers/tty/tty_io.c:2660 	 [...]  ",ca4463bf8438b403596edd0ec961ca0d4fbe0220,1
ext4: fix use-after-free race in ext4_remount()'s error path,It's possible for ext4_show_quota_options() to try reading s_qf_names[i] while it is being modified by ext4_remount() ,33458eaba4dfe778a426df6a19b7aad2ff9f7eec,1
kvm: properly check debugfs dentry before using it,"debugfs can now report an error code if something went wrong instead of just NULL.  So if the return value is to be used as a ""real"" dentry, it needs to be checked if it is an error before dereferencing it.  This is now happening because of ff9fb72bc077 (""debugfs: return error values, not NULL"").  syzbot has found a way to trigger multiple debugfs files attempting to be created, which fails, and then the error code gets passed to dentry_path_raw() which obviously does not like it.  ",8ed0579c12b2fe56a1fac2f712f58fc26c1dc49b,0
ipv6: flowlabel: do not leave opt->tot_len with garbage,"When syzkaller team brought us a C repro for the crash [1] that had been reported many times in the past, I finally could find the root cause.  If FlowLabel info is merged by fl6_merge_options(), we leave part of the opt_space storage provided by udp/raw/l2tp with random value in opt_space.tot_len, unless a control message was provided at sendmsg() time.  Then ip6_setup_cork() would use this random value to perform a kzalloc() call. Undefined behavior and crashes.  Fix is to properly set tot_len in fl6_merge_options()  At the same time, we can also avoid consuming memory and cpu cycles to clear it, if every option is copied via a kmemdup(). This is the change in ip6_setup_cork().  [1] kasan: CONFIG_KASAN_INLINE enabled kasan: GPF could be caused by NULL-ptr deref or user memory access general protection fault: 0000 [#1] SMP KASAN Dumping ftrace buffer:    (ftrace buffer empty) ",864e2a1f8aac05effac6063ce316b480facb46ff,1
net/smc: fix TCP fallback socket release,"clcsock can be released while kernel_accept() references it in TCP listen worker. Also, clcsock needs to wake up before released if TCP fallback is used and the clcsock is blocked by accept. Add a lock to safely release clcsock and call kernel_sock_shutdown() to wake up clcsock from accept in smc_release().  ",78abe3d0dfad196959b1246003366e2610775ea6,0
pipe: Fix missing mask update after pipe_wait(),"Fix pipe_write() to not cache the ring index mask and max_usage as their values are invalidated by calling pipe_wait() because the latter function drops the pipe lock, thereby allowing F_SETPIPE_SZ change them. Without this, pipe_write() may subsequently miscalculate the array indices and pipe fullness, leading to an oops like the following:    BUG: KASAN: slab-out-of-bounds in pipe_write+0xc25/0xe10 fs/pipe.c:481   Write of size 8 at addr ffff8880771167a8 by task syz-executor.3/7987   ...   CPU: 1 PID: 7987 Comm: syz-executor.3 Not tainted 5.4.0-rc2-syzkaller #0   ...   Call Trace:     pipe_write+0xc25/0xe10 fs/pipe.c:481     call_write_iter include/linux/fs.h:1895 [inline]     new_sync_write+0x3fd/0x7e0 fs/read_write.c:483     __vfs_write+0x94/0x110 fs/read_write.c:496     vfs_write+0x18a/0x520 fs/read_write.c:558     ksys_write+0x105/0x220 fs/read_write.c:611     __do_sys_write fs/read_write.c:623 [inline]     __se_sys_write fs/read_write.c:620 [inline]     __x64_sys_write+0x6e/0xb0 fs/read_write.c:620     do_syscall_64+0xca/0x5d0 arch/x86/entry/common.c:290     entry_SYSCALL_64_after_hwframe+0x49/0xbe  This is not a problem for pipe_read() as the mask is recalculated on each pass of the loop, after pipe_wait() has been called.  ",8f868d68d335a17923dffb6858f8e9b656424699,1
rxrpc: Fix local endpoint replacement,"When a local endpoint (struct rxrpc_local) ceases to be in use by any AF_RXRPC sockets, it starts the process of being destroyed, but this doesn't cause it to be removed from the namespace endpoint list immediately as tearing it down isn't trivial and can't be done in softirq context, so it gets deferred.  If a new socket comes along that wants to bind to the same endpoint, a new rxrpc_local object will be allocated and rxrpc_lookup_local() will use list_replace() to substitute the new one for the old.  Then, when the dying object gets to rxrpc_local_destroyer(), it is removed unconditionally from whatever list it is on by calling list_del_init().  However, list_replace() doesn't reset the pointers in the replaced list_head and so the list_del_init() will likely corrupt the local endpoints list.  Fix this by using list_replace_init() instead.  ",b00df840fb4004b7087940ac5f68801562d0d2de,0
n_tty: Access echo_* variables carefully.,"syzbot is reporting stalls at __process_echoes() [1]. This is because since ldata->echo_commit < ldata->echo_tail becomes true for some reason, the discard loop is serving as almost infinite loop. This patch tries to avoid falling into ldata->echo_commit < ldata->echo_tail situation by making access to echo_* variables more carefully.  Since reset_buffer_flags() is called without output_lock held, it should not touch echo_* variables. And omit a call to reset_buffer_flags() from n_tty_open() by using vzalloc().  Since add_echo_byte() is called without output_lock held, it needs memory barrier between storing into echo_buf[] and incrementing echo_head counter. echo_buf() needs corresponding memory barrier before reading echo_buf[]. Lack of handling the possibility of not-yet-stored multi-byte operation might be the reason of falling into ldata->echo_commit < ldata->echo_tail situation, for if I do WARN_ON(ldata->echo_commit == tail + 1) prior to echo_buf(ldata, tail + 1), the WARN_ON() fires.  Also, explicitly masking with buffer for the former ""while"" loop, and use ldata->echo_commit > tail for the latter ""while"" loop.  [1] https://syzkaller.appspot.com/bug?id=17f23b094cd80df750e5b0f8982c521ee6bcbf40  ",ebec3f8f5271139df618ebdf8427e24ba102ba94,1
tipc: better validate user input in tipc_nl_retrieve_key(),"Before calling tipc_aead_key_size(ptr), we need to ensure we have enough data to dereference ptr->keylen.  We probably also want to make sure tipc_aead_key_size() wont overflow with malicious ptr->keylen values.  Syzbot reported:  BUG: KMSAN: uninit-value in __tipc_nl_node_set_key net/tipc/node.c:2971 [inline] BUG: KMSAN: uninit-value in tipc_nl_node_set_key+0x9bf/0x13b0 net/tipc/node.c:3023 CPU: 0 PID: 21060 Comm: syz-executor.5 Not tainted 5.11.0-rc7-syzkaller #0 Hardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 01/01/2011 Call Trace:  __dump_stack lib/dump_stack.c:79 [inline]  dump_stack+0x21c/0x280 lib/dump_stack.c:120  kmsan_report+0xfb/0x1e0 mm/kmsan/kmsan_report.c:118  __msan_warning+0x5f/0xa0 mm/kmsan/kmsan_instr.c:197  __tipc_nl_node_set_key net/tipc/node.c:2971 [inline]  tipc_nl_node_set_key+0x9bf/0x13b0 net/tipc/node.c:3023  genl_family_rcv_msg_doit net/netlink/genetlink.c:739 [inline]  genl_family_rcv_msg net/netlink/genetlink.c:783 [inline]  genl_rcv_msg+0x1319/0x1610 net/netlink/genetlink.c:800  netlink_rcv_skb+0x6fa/0x810 net/netlink/af_netlink.c:2494  genl_rcv+0x63/0x80 net/netlink/genetlink.c:811  netlink_unicast_kernel net/netlink/af_netlink.c:1304 [inline]  netlink_unicast+0x11d6/0x14a0 net/netlink/af_netlink.c:1330  netlink_sendmsg+0x1740/0x1840 net/netlink/af_netlink.c:1919  sock_sendmsg_nosec net/socket.c:652 [inline]  sock_sendmsg net/socket.c:672 [inline]  ____sys_sendmsg+0xcfc/0x12f0 net/socket.c:2345  ___sys_sendmsg net/socket.c:2399 [inline]  __sys_sendmsg+0x714/0x830 net/socket.c:2432  __compat_sys_sendmsg net/compat.c:347 [inline]  __do_compat_sys_sendmsg net/compat.c:354 [inline]  __se_compat_sys_sendmsg+0xa7/0xc0 net/compat.c:351  __ia32_compat_sys_sendmsg+0x4a/0x70 net/compat.c:351  do_syscall_32_irqs_on arch/x86/entry/common.c:79 [inline]  __do_fast_syscall_32+0x102/0x160 arch/x86/entry/common.c:141  do_fast_syscall_32+0x6a/0xc0 arch/x86/entry/common.c:166  do_SYSENTER_32+0x73/0x90 arch/x86/entry/common.c:209  entry_SYSENTER_compat_after_hwframe+0x4d/0x5c ",0217ed2848e8538bcf9172d97ed2eeb4a26041bb,1
ath9k: Fix use-after-free Write in ath9k_htc_rx_msg,Write out of slab bounds. We should check epid.  The case reported by syzbot: https://lore.kernel.org/linux-usb/0000000000006ac55b05a1c05d72@google.com BUG: KASAN: use-after-free in htc_process_conn_rsp drivers/net/wireless/ath/ath9k/htc_hst.c:131 [inline] BUG: KASAN: use-after-free in ath9k_htc_rx_msg+0xa25/0xaf0 drivers/net/wireless/ath/ath9k/htc_hst.c:443 Write of size 2 at addr ffff8881cea291f0 by task swapper/1/0  Call Trace:  htc_process_conn_rsp drivers/net/wireless/ath/ath9k/htc_hst.c:131 [inline] ath9k_htc_rx_msg+0xa25/0xaf0 drivers/net/wireless/ath/ath9k/htc_hst.c:443 ath9k_hif_usb_reg_in_cb+0x1ba/0x630 drivers/net/wireless/ath/ath9k/hif_usb.c:718 __usb_hcd_giveback_urb+0x29a/0x550 drivers/usb/core/hcd.c:1650 usb_hcd_giveback_urb+0x368/0x420 drivers/usb/core/hcd.c:1716 dummy_timer+0x1258/0x32ae drivers/usb/gadget/udc/dummy_hcd.c:1966 call_timer_fn+0x195/0x6f0 kernel/time/timer.c:1404 expire_timers kernel/time/timer.c:1449 [inline] __run_timers kernel/time/timer.c:1773 [inline] __run_timers kernel/time/timer.c:1740 [inline] run_timer_softirq+0x5f9/0x1500 kernel/time/timer.c:1786  ,e4ff08a4d727146bb6717a39a8d399d834654345,1
net: caif: fix memory leak in ldisc_open,"Syzbot reported memory leak in tty_init_dev(). The problem was in unputted tty in ldisc_open()  static int ldisc_open(struct tty_struct *tty) { ... 	ser->tty = tty_kref_get(tty); ... 	result = register_netdevice(dev); 	if (result) { 		rtnl_unlock(); 		free_netdev(dev); 		return -ENODEV; 	} ... }  Ser pointer is netdev private_data, so after free_netdev() this pointer goes away with unputted tty reference. So, fix it by adding tty_kref_put() before freeing netdev.  ",58af3d3d54e87bfc1f936e16c04ade3369d34011,1
xfrm: skip policies marked as dead while rehashing,"syzkaller triggered following KASAN splat:  BUG: KASAN: slab-out-of-bounds in xfrm_hash_rebuild+0xdbe/0xf00 net/xfrm/xfrm_policy.c:618 read of size 2 at addr ffff8801c8e92fe4 by task kworker/1:1/23 [..] Workqueue: events xfrm_hash_rebuild [..]  __asan_report_load2_noabort+0x14/0x20 mm/kasan/report.c:428  xfrm_hash_rebuild+0xdbe/0xf00 net/xfrm/xfrm_policy.c:618  process_one_work+0xbbf/0x1b10 kernel/workqueue.c:2112  worker_thread+0x223/0x1990 kernel/workqueue.c:2246 [..]  The reproducer triggers: 1016                 if (error) { 1017                         list_move_tail(&walk->walk.all, &x->all); 1018                         goto out; 1019                 }  in xfrm_policy_walk() via pfkey (it sets tiny rcv space, dump callback returns -ENOBUFS).  In this case, *walk is located the pfkey socket struct, so this socket becomes visible in the global policy list.  It looks like this is intentional -- phony walker has walk.dead set to 1 and all other places skip such ""policies"".  Ccing original authors of the two commits that seem to expose this issue (first patch missed ->dead check, second patch adds pfkey sockets to policies dumper list).  ",862591bf4f519d1b8d859af720fafeaebdd0162a,1
ieee802154: atusb: fix use-after-free at disconnect,The disconnect callback was accessing the hardware-descriptor private data after having having freed it.  ,7fd25e6fc035f4b04b75bca6d7e8daa069603a76,1
rcu: Add *_ONCE() and data_race() to rcu_node ->exp_tasks plus locking,"There are lockless loads from the rcu_node structure's ->exp_tasks field, so this commit causes all stores to use WRITE_ONCE() and all lockless loads to use READ_ONCE() or data_race(), with the latter for debug prints.  This code also did a unprotected traversal of the linked list pointed into by ->exp_tasks, so this commit also acquires the rcu_node structure's ->lock to properly protect this traversal.  This list was traversed unprotected only when printing an RCU CPU stall warning for an expedited grace period, so the odds of seeing this in production are not all that high.  This data race was reported by KCSAN.  ",314eeb43e5f22856b281c91c966e51e5782a3498,1
ALSA: seq: Fix nested rwsem annotation for lockdep splat,"syzkaller reported the lockdep splat due to the possible deadlock of grp->list_mutex of each sequencer client object.  Actually this is rather a false-positive report due to the missing nested lock annotations.  The sequencer client may deliver the event directly to another client which takes another own lock.  For addressing this issue, this patch replaces the simple down_read() with down_read_nested().  As a lock subclass, the already existing ""hop"" can be re-used, which indicates the depth of the call.  Reference: http://lkml.kernel.org/r/089e082686ac9b482e055c832617@google.com ",1f20f9ff57ca23b9f5502fca85ce3977e8496cb1,1
netfilter: x_tables: fix int overflow in xt_alloc_table_info(),syzkaller triggered OOM kills by passing ipt_replace.size = -1 to IPT_SO_SET_REPLACE. The root cause is that SMP_ALIGN() in xt_alloc_table_info() causes int overflow and the size check passes when it should not. SMP_ALIGN() is no longer needed leftover.  Remove SMP_ALIGN() call in xt_alloc_table_info().  ,889c604fd0b5f6d3b8694ade229ee44124de1127,1
fbcon: prevent user font height or width change from causing potential out-of-bounds access,Add a check to fbcon_resize() to ensure that a possible change to user font height or user font width will not allow a font data out-of-bounds access. NOTE: must use original charcount in calculation as font charcount can change and cannot be used to determine the font data allocated size.  ,39b3cffb8cf3111738ea993e2757ab382253d86a,1
loop: access lo_backing_file only when the loop device is Lo_bound,"Commit 758a58d0bc67 (""loop: set GENHD_FL_NO_PART_SCAN after blkdev_reread_part()"") separates ""lo->lo_backing_file = NULL"" and ""lo->lo_state = Lo_unbound"" into different critical regions protected by loop_ctl_mutex.  However, there is below race that the NULL lo->lo_backing_file would be accessed when the backend of a loop is another loop device, e.g., loop0's backend is a file, while loop1's backend is loop0.  loop0's backend is file            loop1's backend is loop0  __loop_clr_fd()   mutex_lock(&loop_ctl_mutex);   lo->lo_backing_file = NULL; --> set to NULL   mutex_unlock(&loop_ctl_mutex);                                    loop_set_fd()                                      mutex_lock_killable(&loop_ctl_mutex);                                      loop_validate_file()                                        f = l->lo_backing_file; --> NULL                                          access if loop0 is not Lo_unbound   mutex_lock(&loop_ctl_mutex);   lo->lo_state = Lo_unbound;   mutex_unlock(&loop_ctl_mutex);  lo->lo_backing_file should be accessed only when the loop device is Lo_bound.  In fact, the problem has been introduced already in commit 7ccd0791d985 (""loop: Push loop_ctl_mutex down into loop_clr_fd()"") after which loop_validate_file() could see devices in Lo_rundown state with which it did not count. It was harmless at that point but still.  ",f7c8a4120eedf24c36090b7542b179ff7a649219,1
hugetlbfs: prevent filesystem stacking of hugetlbfs,"syzbot found issues with having hugetlbfs on a union/overlay as reported in [1].  Due to the limitations (no write) and special functionality of hugetlbfs, it does not work well in filesystem stacking.  There are no know use cases for hugetlbfs stacking.  Rather than making modifications to get hugetlbfs working in such environments, simply prevent stacking.  [1] https://lore.kernel.org/linux-mm/000000000000b4684e05a2968ca6@google.com/  ",15568299b7d9988063afce60731df605ab236e2a,0
mm: Fix MREMAP_DONTUNMAP accounting on VMA merge,"When remapping a mapping where a portion of a VMA is remapped into another portion of the VMA it can cause the VMA to become split. During the copy_vma operation the VMA can actually be remerged if it's an anonymous VMA whose pages have not yet been faulted. This isn't normally a problem because at the end of the remap the original portion is unmapped causing it to become split again.  However, MREMAP_DONTUNMAP leaves that original portion in place which means that the VMA which was split and then remerged is not actually split at the end of the mremap. This patch fixes a bug where we don't detect that the VMAs got remerged and we end up putting back VM_ACCOUNT on the next mapping which is completely unreleated. When that next mapping is unmapped it results in incorrectly unaccounting for the memory which was never accounted, and eventually we will underflow on the memory comittment.  There is also another issue which is similar, we're currently accouting for the number of pages in the new_vma but that's wrong. We need to account for the length of the remap operation as that's all that is being added. If there was a mapping already at that location its comittment would have been adjusted as part of the munmap at the start of the mremap.  A really simple repro can be seen in: https://gist.github.com/bgaff/e101ce99da7d9a8c60acc641d07f312c  ",dadbd85f2afc8ccd1dd1f0131781c740c91edd96,1
sched/core: Fix PI boosting between RT and DEADLINE tasks,syzbot reported the following warning:   ,740797ce3a124b7dd22b7fb832d87bc8fba1cf6f,0
ipv4: Check attribute length for RTA_GATEWAY in multipath route,syzbot reported uninit-value: ,7a3429bace0e08d94c39245631ea6bc109dafa49,0
Bluetooth: hci_sock: purge socket queues in the destruct() callback,"The receive path may take the socket right before hci_sock_release(), but it may enqueue the packets to the socket queues after the call to skb_queue_purge(), therefore the socket can be destroyed without clear its queues completely.  Moving these skb_queue_purge() to the hci_sock_destruct() will fix this issue, because nothing is referencing the socket at this point.  ",709fca500067524381e28a5f481882930eebac88,0
"fou, fou6: avoid uninit-value in gue_err() and gue6_err()","My prior commit missed the fact that these functions were using udp_hdr() (aka skb_transport_header()) to get access to GUE header.  Since pskb_transport_may_pull() does not exist yet, we have to add transport_offset to our pskb_may_pull() calls.  BUG: KMSAN: uninit-value in gue_err+0x514/0xfa0 net/ipv4/fou.c:1032 CPU: 1 PID: 10648 Comm: syz-executor.1 Not tainted 5.0.0+ #11 Hardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 01/01/2011 Call Trace:  <IRQ>  __dump_stack lib/dump_stack.c:77 [inline]  dump_stack+0x173/0x1d0 lib/dump_stack.c:113  kmsan_report+0x12e/0x2a0 mm/kmsan/kmsan.c:600  __msan_warning+0x82/0xf0 mm/kmsan/kmsan_instr.c:313  gue_err+0x514/0xfa0 net/ipv4/fou.c:1032  __udp4_lib_err_encap_no_sk net/ipv4/udp.c:571 [inline]  __udp4_lib_err_encap net/ipv4/udp.c:626 [inline]  __udp4_lib_err+0x12e6/0x1d40 net/ipv4/udp.c:665  udp_err+0x74/0x90 net/ipv4/udp.c:737  icmp_socket_deliver net/ipv4/icmp.c:767 [inline]  icmp_unreach+0xb65/0x1070 net/ipv4/icmp.c:884  icmp_rcv+0x11a1/0x1950 net/ipv4/icmp.c:1066  ip_protocol_deliver_rcu+0x584/0xbb0 net/ipv4/ip_input.c:208  ip_local_deliver_finish net/ipv4/ip_input.c:234 [inline]  NF_HOOK include/linux/netfilter.h:289 [inline]  ip_local_deliver+0x624/0x7b0 net/ipv4/ip_input.c:255  dst_input include/net/dst.h:450 [inline]  ip_rcv_finish net/ipv4/ip_input.c:414 [inline]  NF_HOOK include/linux/netfilter.h:289 [inline]  ip_rcv+0x6bd/0x740 net/ipv4/ip_input.c:524  __netif_receive_skb_one_core net/core/dev.c:4973 [inline]  __netif_receive_skb net/core/dev.c:5083 [inline]  process_backlog+0x756/0x10e0 net/core/dev.c:5923  napi_poll net/core/dev.c:6346 [inline]  net_rx_action+0x78b/0x1a60 net/core/dev.c:6412  __do_softirq+0x53f/0x93a kernel/softirq.c:293  invoke_softirq kernel/softirq.c:375 [inline]  irq_exit+0x214/0x250 kernel/softirq.c:416  exiting_irq+0xe/0x10 arch/x86/include/asm/apic.h:536  smp_apic_timer_interrupt+0x48/0x70 arch/x86/kernel/apic/apic.c:1064  apic_timer_interrupt+0x2e/0x40 arch/x86/entry/entry_64.S:814  </IRQ> ",5355ed6388e23b69a00d48398a68d022135e6486,1
USB: core: Avoid WARNings for 0-length descriptor requests,"The USB core has utility routines to retrieve various types of descriptors.  These routines will now provoke a WARN if they are asked to retrieve 0 bytes (USB ""receive"" requests must not have zero length), so avert this by checking the size argument at the start.  CC: Johan Hovold <johan@kernel.org> ",60dfe484cef45293e631b3a6e8995f1689818172,0
vlan: Fix vlan insertion for packets without ethernet header,"In some situation vlan packets do not have ethernet headers. One example is packets from tun devices. Users can specify vlan protocol in tun_pi field instead of IP protocol. When we have a vlan device with reorder_hdr disabled on top of the tun device, such packets from tun devices are untagged in skb_vlan_untag() and vlan headers will be inserted back in vlan_insert_inner_tag().  vlan_insert_inner_tag() however did not expect packets without ethernet headers, so in such a case size argument for memmove() underflowed.  We don't need to copy headers for packets which do not have preceding headers of vlan headers, so skip memmove() in that case. Also don't write vlan protocol in skb->data when it does not have enough room for it.  ",c769accdf3d8a103940bea2979b65556718567e9,1
RDMA/ucma: Introduce safer rdma_addr_size() variants,"There are several places in the ucma ABI where userspace can pass in a sockaddr but set the address family to AF_IB.  When that happens, rdma_addr_size() will return a size bigger than sizeof struct sockaddr_in6, and the ucma kernel code might end up copying past the end of a buffer not sized for a struct sockaddr_ib.  Fix this by introducing new variants      int rdma_addr_size_in6(struct sockaddr_in6 *addr);     int rdma_addr_size_kss(struct __kernel_sockaddr_storage *addr);  that are type-safe for the types used in the ucma ABI and return 0 if the size computed is bigger than the size of the type passed in.  We can use these new variants to check what size userspace has passed in before copying any addresses.  ",84652aefb347297aa08e91e283adf7b18f77c2d5,0
af_key: do not use GFP_KERNEL in atomic contexts,"pfkey_broadcast() might be called from non process contexts, we can not use GFP_KERNEL in these cases [1].  This patch partially reverts commit ba51b6be38c1 (""net: Fix RCU splat in af_key""), only keeping the GFP_ATOMIC forcing under rcu_read_lock() section.  [1] : syzkaller reported :  in_atomic(): 1, irqs_disabled(): 0, pid: 2932, name: syzkaller183439 3 locks held by syzkaller183439/2932:  #0:  (&net->xfrm.xfrm_cfg_mutex){+.+.+.}, at: [<ffffffff83b43888>] pfkey_sendmsg+0x4c8/0x9f0 net/key/af_key.c:3649  #1:  (&pfk->dump_lock){+.+.+.}, at: [<ffffffff83b467f6>] pfkey_do_dump+0x76/0x3f0 net/key/af_key.c:293  #2:  (&(&net->xfrm.xfrm_policy_lock)->rlock){+...+.}, at: [<ffffffff83957632>] spin_lock_bh include/linux/spinlock.h:304 [inline]  #2:  (&(&net->xfrm.xfrm_policy_lock)->rlock){+...+.}, at: [<ffffffff83957632>] xfrm_policy_walk+0x192/0xa30 net/xfrm/xfrm_policy.c:1028 CPU: 0 PID: 2932 Comm: syzkaller183439 Not tainted 4.13.0-rc4+ #24 Hardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 01/01/2011 Call Trace:  __dump_stack lib/dump_stack.c:16 [inline]  dump_stack+0x194/0x257 lib/dump_stack.c:52  ___might_sleep+0x2b2/0x470 kernel/sched/core.c:5994  __might_sleep+0x95/0x190 kernel/sched/core.c:5947  slab_pre_alloc_hook mm/slab.h:416 [inline]  slab_alloc mm/slab.c:3383 [inline]  kmem_cache_alloc+0x24b/0x6e0 mm/slab.c:3559  skb_clone+0x1a0/0x400 net/core/skbuff.c:1037  pfkey_broadcast_one+0x4b2/0x6f0 net/key/af_key.c:207  pfkey_broadcast+0x4ba/0x770 net/key/af_key.c:281  dump_sp+0x3d6/0x500 net/key/af_key.c:2685  xfrm_policy_walk+0x2f1/0xa30 net/xfrm/xfrm_policy.c:1042  pfkey_dump_sp+0x42/0x50 net/key/af_key.c:2695  pfkey_do_dump+0xaa/0x3f0 net/key/af_key.c:299  pfkey_spddump+0x1a0/0x210 net/key/af_key.c:2722  pfkey_process+0x606/0x710 net/key/af_key.c:2814  pfkey_sendmsg+0x4d6/0x9f0 net/key/af_key.c:3650 sock_sendmsg_nosec net/socket.c:633 [inline]  sock_sendmsg+0xca/0x110 net/socket.c:643  ___sys_sendmsg+0x755/0x890 net/socket.c:2035  __sys_sendmsg+0xe5/0x210 net/socket.c:2069  SYSC_sendmsg net/socket.c:2080 [inline]  SyS_sendmsg+0x2d/0x50 net/socket.c:2076  entry_SYSCALL_64_fastpath+0x1f/0xbe ",36f41f8fc6d8aa9f8c9072d66ff7cf9055f5e69b,1
ipmr: Add lockdep expression to ipmr_for_each_table macro,"During the initialization process, ipmr_new_table() is called to create new tables which in turn calls ipmr_get_table() which traverses net->ipv4.mr_tables without holding the writer lock. However, this is safe to do so as no tables exist at this time. Hence add a suitable lockdep expression to silence the following false-positive warning:  ",7013908c2db285cd6b48fcd427a56354beac2233,0
debugfs: Return -EPERM when locked down,"When lockdown is enabled, debugfs_is_locked_down returns 1. It will then trigger the following:  ",a37f4958f7b63d2b3cd17a76151fdfc29ce1da5f,0
ALSA: rawmidi: Fix missing input substream checks in compat ioctls,Some rawmidi compat ioctls lack of the input substream checks (although they do check only for rfile->output).  This many eventually lead to an Oops as NULL substream is passed to the rawmidi core functions.  Fix it by adding the proper checks before each function call.  The bug was spotted by syzkaller.  ,8a56ef4f3ffba9ebf4967b61ef600b0a7ba10f11,1
crypto: af_alg - Use bh_lock_sock in sk_destruct,"As af_alg_release_parent may be called from BH context (most notably due to an async request that only completes after socket closure, or as reported here because of an RCU-delayed sk_destruct call), we must use bh_lock_sock instead of lock_sock.  ",37f96694cf73ba116993a9d2d99ad6a75fa7fdb0,0
x86/fsgsbase/64: Fix NULL deref in 86_fsgsbase_read_task,syzbot found its way in 86_fsgsbase_read_task() and triggered this oops:     KASAN: null-ptr-deref in range [0x0000000000000008-0x000000000000000f]    CPU: 0 PID: 6866 Comm: syz-executor262 Not tainted 5.8.0-syzkaller #0    ,8ab49526b53d3172d1d8dd03a75c7d1f5bd21239,1
khugepaged: fix null-pointer dereference due to race,"khugepaged has to drop mmap lock several times while collapsing a page. The situation can change while the lock is dropped and we need to re-validate that the VMA is still in place and the PMD is still subject for collapse.  But we miss one corner case: while collapsing an anonymous pages the VMA could be replaced with file VMA.  If the file VMA doesn't have any private pages we get NULL pointer dereference:  	general protection fault, probably for non-canonical address 0xdffffc0000000000: 0000 [#1] PREEMPT SMP KASAN 	KASAN: null-ptr-deref in range [0x0000000000000000-0x0000000000000007] 	anon_vma_lock_write include/linux/rmap.h:120 [inline] 	collapse_huge_page mm/khugepaged.c:1110 [inline] 	khugepaged_scan_pmd mm/khugepaged.c:1349 [inline] 	khugepaged_scan_mm_slot mm/khugepaged.c:2110 [inline] 	khugepaged_do_scan mm/khugepaged.c:2193 [inline] 	khugepaged+0x3bba/0x5a10 mm/khugepaged.c:2238  The fix is to make sure that the VMA is anonymous in hugepage_vma_revalidate().  The helper is only used for collapsing anonymous pages.  ",594cced14ad3903166c8b091ff96adac7552f0b3,1
"Revert ""KVM: x86: mmu: Add guest physical address check in translate_gpa()""","Revert a misguided illegal GPA check when ""translating"" a non-nested GPA. The check is woefully incomplete as it does not fill in @exception as expected by all callers, which leads to KVM attempting to inject a bogus exception, potentially exposing kernel stack information in the process.   ",e7177339d7b5f9594b316842122b5fda9513d5e2,0
ipv6: add ip6_null_entry check in rt6_select(),"In rt6_select(), fn->leaf could be pointing to net->ipv6.ip6_null_entry. In this case, we should directly return instead of trying to carry on with the rest of the process. If not, we could crash at:   spin_lock_bh(&leaf->rt6i_table->rt6_lock); because net->ipv6.ip6_null_entry does not have rt6i_table set.  Syzkaller recently reported following issue on net-next: Use struct sctp_sack_info instead kasan: CONFIG_KASAN_INLINE enabled kasan: GPF could be caused by NULL-ptr deref or user memory access general protection fault: 0000 [#1] SMP KASAN Dumping ftrace buffer:    (ftrace buffer empty) ",87b1af8dcc084d3d509d55067185ca74aed70ce2,1
netfilter: nf_tables: fix flowtable list del corruption,"syzbot reported following crash:    list_del corruption, ffff88808c9bb000->prev is LIST_POISON2 (dead000000000122)   [..]   Call Trace:    __list_del_entry include/linux/list.h:131 [inline]    list_del_rcu include/linux/rculist.h:148 [inline]    nf_tables_commit+0x1068/0x3b30 net/netfilter/nf_tables_api.c:7183    [..]  The commit transaction list has:  NFT_MSG_NEWTABLE NFT_MSG_NEWFLOWTABLE NFT_MSG_DELFLOWTABLE NFT_MSG_DELTABLE  A missing generation check during DELTABLE processing causes it to queue the DELFLOWTABLE operation a second time, so we corrupt the list here:    case NFT_MSG_DELFLOWTABLE:      list_del_rcu(&nft_trans_flowtable(trans)->list);      nf_tables_flowtable_notify(&trans->ctx,  because we have two different DELFLOWTABLE transactions for the same flowtable.  We then call list_del_rcu() twice for the same flowtable->list.  The object handling seems to suffer from the same bug so add a generation check too and only queue delete transactions for flowtables/objects that are still active in the next generation.  ",335178d5429c4cee61b58f4ac80688f556630818,1
fs/binfmt_elf.c: free PT_INTERP filename ASAP,There is no reason for PT_INTERP filename to linger till the end of the whole loading process.  ,cc338010a233c0817276b1348692376db4b4b093,0
netlink: annotate data races around nlk->bound,"While existing code is correct, KCSAN is reporting a data-race in netlink_insert / netlink_sendmsg [1]  It is correct to read nlk->bound without a lock, as netlink_autobind() will acquire all needed locks.  [1] BUG: KCSAN: data-race in netlink_insert / netlink_sendmsg  write to 0xffff8881031c8b30 of 1 bytes by task 18752 on cpu 0:  netlink_insert+0x5cc/0x7f0 net/netlink/af_netlink.c:597  netlink_autobind+0xa9/0x150 net/netlink/af_netlink.c:842  netlink_sendmsg+0x479/0x7c0 net/netlink/af_netlink.c:1892  sock_sendmsg_nosec net/socket.c:703 [inline]  sock_sendmsg net/socket.c:723 [inline]  ____sys_sendmsg+0x360/0x4d0 net/socket.c:2392  ___sys_sendmsg net/socket.c:2446 [inline]  __sys_sendmsg+0x1ed/0x270 net/socket.c:2475  __do_sys_sendmsg net/socket.c:2484 [inline]  __se_sys_sendmsg net/socket.c:2482 [inline]  __x64_sys_sendmsg+0x42/0x50 net/socket.c:2482  do_syscall_x64 arch/x86/entry/common.c:50 [inline]  do_syscall_64+0x3d/0x90 arch/x86/entry/common.c:80  entry_SYSCALL_64_after_hwframe+0x44/0xae  read to 0xffff8881031c8b30 of 1 bytes by task 18751 on cpu 1:  netlink_sendmsg+0x270/0x7c0 net/netlink/af_netlink.c:1891  sock_sendmsg_nosec net/socket.c:703 [inline]  sock_sendmsg net/socket.c:723 [inline]  __sys_sendto+0x2a8/0x370 net/socket.c:2019  __do_sys_sendto net/socket.c:2031 [inline]  __se_sys_sendto net/socket.c:2027 [inline]  __x64_sys_sendto+0x74/0x90 net/socket.c:2027  do_syscall_x64 arch/x86/entry/common.c:50 [inline]  do_syscall_64+0x3d/0x90 arch/x86/entry/common.c:80  entry_SYSCALL_64_after_hwframe+0x44/0xae  value changed: 0x00 -> 0x01  Reported by Kernel Concurrency Sanitizer on: CPU: 1 PID: 18751 Comm: syz-executor.0 Not tainted 5.14.0-rc1-syzkaller #0 Hardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 01/01/2011  ",7707a4d01a648e4c655101a469c956cb11273655,1
net/smc: check for missing nlattrs in SMC_PNETID messages,It's possible to crash the kernel in several different ways by sending messages to the SMC_PNETID generic netlink family that are missing the expected attributes:  - Missing SMC_PNETID_NAME => null pointer dereference when comparing   names. - Missing SMC_PNETID_ETHNAME => null pointer dereference accessing   smc_pnetentry::ndev. - Missing SMC_PNETID_IBNAME => null pointer dereference accessing   smc_pnetentry::smcibdev. - Missing SMC_PNETID_IBPORT => out of bounds array access to   smc_ib_device::pattr[-1].  Fix it by validating that all expected attributes are present and that SMC_PNETID_IBPORT is nonzero.  ,d49baa7e12ee70c0a7b821d088a770c94c02e494,1
"KVM: x86: Revert ""KVM: X86: Fix fpu state crash in kvm guest""","Reload the current thread's FPU state, which contains the guest's FPU state, to the CPU registers if necessary during vcpu_enter_guest(). TIF_NEED_FPU_LOAD can be set any time control is transferred out of KVM, e.g. if I/O is triggered during a KVM call to get_user_pages() or if a softirq occurs while KVM is scheduled in.  Moving the handling of TIF_NEED_FPU_LOAD from vcpu_enter_guest() to kvm_arch_vcpu_load(), effectively kvm_sched_in(), papered over a bug where kvm_put_guest_fpu() failed to account for TIF_NEED_FPU_LOAD.  The easiest way to the kvm_put_guest_fpu() bug was to run with involuntary preemption enable, thus handling TIF_NEED_FPU_LOAD during kvm_sched_in() made the bug go away.  But, removing the handling in vcpu_enter_guest() exposed KVM to the rare case of a softirq triggering kernel_fpu_begin() between vcpu_load() and vcpu_enter_guest().  Now that kvm_{load,put}_guest_fpu() correctly handle TIF_NEED_FPU_LOAD, revert the commit to both restore the vcpu_enter_guest() behavior and eliminate the superfluous switch_fpu_return() in kvm_arch_vcpu_load().  Note, leaving the handling in kvm_arch_vcpu_load() isn't wrong per se, but it is unnecessary, and most critically, makes it extremely difficult to find bugs such as the kvm_put_guest_fpu() issue due to shrinking the window where a softirq can corrupt state.  A sample trace triggered by warning if TIF_NEED_FPU_LOAD is set while vcpu state is loaded:   <IRQ>   gcmaes_crypt_by_sg.constprop.12+0x26e/0x660   ? 0xffffffffc024547d   ? __qdisc_run+0x83/0x510   ? __dev_queue_xmit+0x45e/0x990   ? ip_finish_output2+0x1a8/0x570   ? fib4_rule_action+0x61/0x70   ? fib4_rule_action+0x70/0x70   ? fib_rules_lookup+0x13f/0x1c0   ? helper_rfc4106_decrypt+0x82/0xa0   ? crypto_aead_decrypt+0x40/0x70   ? crypto_aead_decrypt+0x40/0x70   ? crypto_aead_decrypt+0x40/0x70   ? esp_output_tail+0x8f4/0xa5a [esp4]   ? skb_ext_add+0xd3/0x170   ? xfrm_input+0x7a6/0x12c0   ? xfrm4_rcv_encap+0xae/0xd0   ? xfrm4_transport_finish+0x200/0x200   ? udp_queue_rcv_one_skb+0x1ba/0x460   ? udp_unicast_rcv_skb.isra.63+0x72/0x90   ? __udp4_lib_rcv+0x51b/0xb00   ? ip_protocol_deliver_rcu+0xd2/0x1c0   ? ip_local_deliver_finish+0x44/0x50   ? ip_local_deliver+0xe0/0xf0   ? ip_protocol_deliver_rcu+0x1c0/0x1c0   ? ip_rcv+0xbc/0xd0   ? ip_rcv_finish_core.isra.19+0x380/0x380   ? __netif_receive_skb_one_core+0x7e/0x90   ? netif_receive_skb_internal+0x3d/0xb0   ? napi_gro_receive+0xed/0x150   ? 0xffffffffc0243c77   ? net_rx_action+0x149/0x3b0   ? __do_softirq+0xe4/0x2f8   ? handle_irq_event_percpu+0x6a/0x80   ? irq_exit+0xe6/0xf0   ? do_IRQ+0x7f/0xd0   ? common_interrupt+0xf/0xf   </IRQ>   ? irq_entries_start+0x20/0x660   ? vmx_get_interrupt_shadow+0x2f0/0x710 [kvm_intel]   ? kvm_set_msr_common+0xfc7/0x2380 [kvm]   ? recalibrate_cpu_khz+0x10/0x10   ? ktime_get+0x3a/0xa0   ? kvm_arch_vcpu_ioctl_run+0x107/0x560 [kvm]   ? kvm_init+0x6bf/0xd00 [kvm]   ? __seccomp_filter+0x7a/0x680   ? do_vfs_ioctl+0xa4/0x630   ? security_file_ioctl+0x32/0x50   ? ksys_ioctl+0x60/0x90   ? __x64_sys_ioctl+0x16/0x20   ? do_syscall_64+0x5f/0x1a0   ? entry_SYSCALL_64_after_hwframe+0x44/0xa9 ",2620fe268e80d667a94553cd37a94ccaa2cb8c83,1
netfilter: conntrack: serialize hash resizes and cleanups,"Syzbot was able to trigger the following warning [1]  No repro found by syzbot yet but I was able to trigger similar issue by having 2 scripts running in parallel, changing conntrack hash sizes, and:  for j in `seq 1 1000` ; do unshare -n /bin/true >/dev/null ; done  It would take more than 5 minutes for net_namespace structures to be cleaned up.  This is because nf_ct_iterate_cleanup() has to restart everytime a resize happened.  By adding a mutex, we can serialize hash resizes and cleanups and also make get_next_corpse() faster by skipping over empty buckets.  Even without resizes in the picture, this patch considerably speeds up network namespace dismantles.  [1] INFO: task syz-executor.0:8312 can't die for more than 144 seconds. ",e9edc188fc76499b0b9bd60364084037f6d03773,0
f2fs: fix invalid memory access,"syzbot found the following crash on:  HEAD commit:    d9bd94c0bcaa Add linux-next specific files for 20180801 git tree:       linux-next console output: https://syzkaller.appspot.com/x/log.txt?x=1001189c400000 kernel config:  https://syzkaller.appspot.com/x/.config?x=cc8964ea4d04518c dashboard link: https://syzkaller.appspot.com/bug?extid=c966a82db0b14aa37e81 compiler:       gcc (GCC) 8.0.1 20180413 (experimental)  Unfortunately, I don't have any reproducer for this crash yet.  IMPORTANT: if you fix the bug, please add the following tag to the commit: ",d3f07c049dab1a3f1740f476afd3d5e5b738c21c,1
ALSA: seq: Remove spurious WARN_ON() at timer check,"The use of snd_BUG_ON() in ALSA sequencer timer may lead to a spurious WARN_ON() when a slave timer is deployed as its backend and a corresponding master timer stops meanwhile.  The symptom was triggered by syzkaller spontaneously.  Since the NULL timer is valid there, rip off snd_BUG_ON().  ",43a3542870328601be02fcc9d27b09db467336ef,1
xsk: Fix memory leak for failed bind,"Fix a possible memory leak when a bind of an AF_XDP socket fails. When the fill and completion rings are created, they are tied to the socket. But when the buffer pool is later created at bind time, the ownership of these two rings are transferred to the buffer pool as they might be shared between sockets (and the buffer pool cannot be created until we know what we are binding to). So, before the buffer pool is created, these two rings are cleaned up with the socket, and after they have been transferred they are cleaned up together with the buffer pool.  The problem is that ownership was transferred before it was absolutely certain that the buffer pool could be created and initialized correctly and when one of these errors occurred, the fill and completion rings did neither belong to the socket nor the pool and where therefore leaked. Solve this by moving the ownership transfer to the point where the buffer pool has been completely set up and there is no way it can fail.  ",8bee683384087a6275c9183a483435225f7bb209,1
close_range: unshare all fds for CLOSE_RANGE_UNSHARE | CLOSE_RANGE_CLOEXEC,"After introducing CLOSE_RANGE_CLOEXEC syzbot reported a crash when CLOSE_RANGE_CLOEXEC is specified in conjunction with CLOSE_RANGE_UNSHARE. When CLOSE_RANGE_UNSHARE is specified the caller will receive a private file descriptor table in case their file descriptor table is currently shared.  For the case where the caller has requested all file descriptors to be actually closed via e.g. close_range(3, ~0U, 0) the kernel knows that the caller does not need any of the file descriptors anymore and will optimize the close operation by only copying all files in the range from 0 to 3 and no others.  However, if the caller requested CLOSE_RANGE_CLOEXEC together with CLOSE_RANGE_UNSHARE the caller wants to still make use of the file descriptors so the kernel needs to copy all of them and can't optimize.  The original patch didn't account for this and thus could cause oopses as evidenced by the syzbot report because it assumed that all fds had been copied. Fix this by handling the CLOSE_RANGE_CLOEXEC case.  syzbot reported ",fec8a6a691033f2538cd46848f17f337f0739923,1
"net: Revert ""net: optimize the sockptr_t for unified kernel/user address spaces""","This reverts commits 6d04fe15f78acdf8e32329e208552e226f7a8ae6 and a31edb2059ed4e498f9aa8230c734b59d0ad797a.  It turns out the idea to share a single pointer for both kernel and user space address causes various kinds of problems.  So use the slightly less optimal version that uses an extra bit, but which is guaranteed to be safe everywhere.  ",519a8a6cf91dda095be2d36216fc4ebc525270a1,0
fbcon: Fix user font detection test at fbcon_resize().,"syzbot is reporting OOB read at fbcon_resize() [1], for commit 39b3cffb8cf31117 (""fbcon: prevent user font height or width change  from causing potential out-of-bounds access"") is by error using registered_fb[con2fb_map[vc->vc_num]]->fbcon_par->p->userfont (which was set to non-zero) instead of fb_display[vc->vc_num].userfont (which remains zero for that display).  We could remove tricky userfont flag [2], for we can determine it by comparing address of the font data and addresses of built-in font data. But since that commit is failing to fix the original OOB read [3], this patch keeps the change minimal in case we decide to revert altogether.  [1] https://syzkaller.appspot.com/bug?id=ebcbbb6576958a496500fee9cf7aa83ea00b5920 [2] https://syzkaller.appspot.com/text?tag=Patch&x=14030853900000 [3] https://syzkaller.appspot.com/bug?id=6fba8c186d97cf1011ab17660e633b1cc4e080c9  ",ec0972adecb391a8d8650832263a4790f3bfb4df,1
locking/rwsem: Add a new RWSEM_ANONYMOUSLY_OWNED flag,"There are use cases where a rwsem can be acquired by one task, but released by another task. In thess cases, optimistic spinning may need to be disabled.  One example will be the filesystem freeze/thaw code where the task that freezes the filesystem will acquire a write lock on a rwsem and then un-owns it before returning to userspace. Later on, another task will come along, acquire the ownership, thaw the filesystem and release the rwsem.  Bit 0 of the owner field was used to designate that it is a reader owned rwsem. It is now repurposed to mean that the owner of the rwsem is not known. If only bit 0 is set, the rwsem is reader owned. If bit 0 and other bits are set, it is writer owned with an unknown owner. One such value for the latter case is (-1L). So we can set owner to 1 for reader-owned, -1 for writer-owned. The owner is unknown in both cases.  To handle transfer of rwsem ownership, the higher level code should set the owner field to -1 to indicate a write-locked rwsem with unknown owner.  Optimistic spinning will be disabled in this case.  Once the higher level code figures who the new owner is, it can then set the owner field accordingly.  ",d7d760efad70c7a030725499bf9f342f04af24dd,0
media: mceusb: Fix potential out-of-bounds shift,"When processing a MCE_RSP_GETPORTSTATUS command, the bit index to set in ir->txports_cabled comes from response data, and isn't validated.  As ir->txports_cabled is a u8, nothing should be done if the bit index is greater than 7.  ",1b43bad31fb0e00f45baf5b05bd21eb8d8ce7f58,1
Bluetooth: hci_sync: Push sync command cancellation to workqueue,"syzbot reported that hci_cmd_sync_cancel may sleep from the wrong context. To avoid this, create a new work item that pushes the relevant parts into a different context.  Note that we keep the old implementation with the name __hci_cmd_sync_cancel as the sleeping behaviour is desired in some cases.  ",744451c162a514044a912cbbd64b7a386035cc5b,0
media: media-request: Fix crash if memory allocation fails,"Syzbot reports a NULL-ptr deref in the kref_put() call:  BUG: KASAN: null-ptr-deref in media_request_put drivers/media/mc/mc-request.c:81 [inline]  kref_put include/linux/kref.h:64 [inline]  media_request_put drivers/media/mc/mc-request.c:81 [inline]  media_request_close+0x4d/0x170 drivers/media/mc/mc-request.c:89  __fput+0x2ed/0x750 fs/file_table.c:281  task_work_run+0x147/0x1d0 kernel/task_work.c:123  tracehook_notify_resume include/linux/tracehook.h:188 [inline]  exit_to_usermode_loop arch/x86/entry/common.c:165 [inline]  prepare_exit_to_usermode+0x48e/0x600 arch/x86/entry/common.c:196  What led to this crash was an injected memory allocation failure in media_request_alloc():  FAULT_INJECTION: forcing a failure. name failslab, interval 1, probability 0, space 0, times 0  should_failslab+0x5/0x20  kmem_cache_alloc_trace+0x57/0x300  ? anon_inode_getfile+0xe5/0x170  media_request_alloc+0x339/0x440  media_device_request_alloc+0x94/0xc0  media_device_ioctl+0x1fb/0x330  ? do_vfs_ioctl+0x6ea/0x1a00  ? media_ioctl+0x101/0x120  ? __media_device_usb_init+0x430/0x430  ? media_poll+0x110/0x110  __se_sys_ioctl+0xf9/0x160  do_syscall_64+0xf3/0x1b0  When that allocation fails, filp->private_data is left uninitialized which media_request_close() does not expect and crashes.  To avoid this, reorder media_request_alloc() such that allocating the struct file happens as the last step thus media_request_close() will no longer get called for a partially created media request.  ",e30cc79cc80fd919b697a15c5000d9f57487de8e,1
cfg80211: further limit wiphy names to 64 bytes,"wiphy names were recently limited to 128 bytes by commit a7cfebcb7594 (""cfg80211: limit wiphy names to 128 bytes"").  As it turns out though, this isn't sufficient because dev_vprintk_emit() needs the syslog header string ""SUBSYSTEM=ieee80211\0DEVICE=+ieee80211:$devname"" to fit into 128 bytes.  This triggered the ""device/subsystem name too long"" WARN when the device name was >= 90 bytes.  As before, this was reproduced by syzbot by sending an HWSIM_CMD_NEW_RADIO command to the MAC80211_HWSIM generic netlink family.  Fix it by further limiting wiphy names to 64 bytes.  ",814596495dd2b9d4aab92d8f89cf19060d25d2ea,0
vhost_net: stop device during reset owner,"We don't stop device before reset owner, this means we could try to serve any virtqueue kick before reset dev->worker. This will result a warn since the work was pending at llist during owner resetting. Fix this by stopping device during owner reset.  ",4cd879515d686849eec5f718aeac62a70b067d82,0
net/x25: fix nonblocking connect,"This patch fixes 2 issues in x25_connect():  1. It makes absolutely no sense to reset the neighbour and the connection state after a (successful) nonblocking call of x25_connect. This prevents any connection from being established, since the response (call accept) cannot be processed.  2. Any further calls to x25_connect() while a call is pending should simply return, instead of creating new Call Request (on different logical channels).  This patch should also fix the ""KASAN: null-ptr-deref Write in x25_connect"" and ""BUG: unable to handle kernel NULL pointer dereference in x25_connect"" bugs reported by syzbot.  ",e21dba7a4df4d93da237da65a096084b4f2e87b4,1
net: devlink: fix reporter dump dumpit,"In order for attrs to be prepared for reporter dump dumpit callback, set GENL_DONT_VALIDATE_DUMP_STRICT instead of GENL_DONT_VALIDATE_DUMP.  ",82a843de41d42681c1bbf9194b28736d06050b08,0
media: usb: siano: Fix general protection fault in smsusb,"The syzkaller USB fuzzer found a general-protection-fault bug in the smsusb part of the Siano DVB driver.  The fault occurs during probe because the driver assumes without checking that the device has both IN and OUT endpoints and the IN endpoint is ep1.  By slightly rearranging the driver's initialization code, we can make the appropriate checks early on and thus avoid the problem.  If the expected endpoints aren't present, the new code safely returns -ENODEV from the probe routine.  ",31e0456de5be379b10fea0fa94a681057114a96e,1
inetpeer: fix uninit-value in inet_getpeer,"syzbot/KMSAN reported that p->dtime was read while it was not yet initialized in :  	delta = (__u32)jiffies - p->dtime; 	if (delta < ttl || !refcount_dec_if_one(&p->refcnt)) 		gc_stack[i] = NULL;  This is a false positive, because the inetpeer wont be erased from rb-tree if the refcount_dec_if_one(&p->refcnt) does not succeed. And this wont happen before first inet_putpeer() call for this inetpeer has been done, and ->dtime field is written exactly before the refcount_dec_and_test(&p->refcnt).  The KMSAN report was :  BUG: KMSAN: uninit-value in inet_peer_gc net/ipv4/inetpeer.c:163 [inline] BUG: KMSAN: uninit-value in inet_getpeer+0x1567/0x1e70 net/ipv4/inetpeer.c:228 CPU: 0 PID: 9494 Comm: syz-executor5 Not tainted 4.16.0+ #82 Hardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 01/01/2011 Call Trace:  __dump_stack lib/dump_stack.c:17 [inline]  dump_stack+0x185/0x1d0 lib/dump_stack.c:53  kmsan_report+0x142/0x240 mm/kmsan/kmsan.c:1067  __msan_warning_32+0x6c/0xb0 mm/kmsan/kmsan_instr.c:676  inet_peer_gc net/ipv4/inetpeer.c:163 [inline]  inet_getpeer+0x1567/0x1e70 net/ipv4/inetpeer.c:228  inet_getpeer_v4 include/net/inetpeer.h:110 [inline]  icmpv4_xrlim_allow net/ipv4/icmp.c:330 [inline]  icmp_send+0x2b44/0x3050 net/ipv4/icmp.c:725  ip_options_compile+0x237c/0x29f0 net/ipv4/ip_options.c:472  ip_rcv_options net/ipv4/ip_input.c:284 [inline]  ip_rcv_finish+0xda8/0x16d0 net/ipv4/ip_input.c:365  NF_HOOK include/linux/netfilter.h:288 [inline]  ip_rcv+0x119d/0x16f0 net/ipv4/ip_input.c:493  __netif_receive_skb_core+0x47cf/0x4a80 net/core/dev.c:4562  __netif_receive_skb net/core/dev.c:4627 [inline]  netif_receive_skb_internal+0x49d/0x630 net/core/dev.c:4701  netif_receive_skb+0x230/0x240 net/core/dev.c:4725  tun_rx_batched drivers/net/tun.c:1555 [inline]  tun_get_user+0x6d88/0x7580 drivers/net/tun.c:1962  tun_chr_write_iter+0x1d4/0x330 drivers/net/tun.c:1990  do_iter_readv_writev+0x7bb/0x970 include/linux/fs.h:1776  do_iter_write+0x30d/0xd40 fs/read_write.c:932  vfs_writev fs/read_write.c:977 [inline]  do_writev+0x3c9/0x830 fs/read_write.c:1012  SYSC_writev+0x9b/0xb0 fs/read_write.c:1085  SyS_writev+0x56/0x80 fs/read_write.c:1082  do_syscall_64+0x309/0x430 arch/x86/entry/common.c:287  entry_SYSCALL_64_after_hwframe+0x3d/0xa2 ",b6a37e5e25414df4b8e9140a5c6f5ee0ec6f3b90,1
USB: cdc-wdm: Fix use after free in service_outstanding_interrupt().,"syzbot is reporting UAF at usb_submit_urb() [1], for service_outstanding_interrupt() is not checking WDM_DISCONNECTING before calling usb_submit_urb(). Close the race by doing same checks wdm_read() does upon retry.  Also, while wdm_read() checks WDM_DISCONNECTING with desc->rlock held, service_interrupt_work() does not hold desc->rlock. Thus, it is possible that usb_submit_urb() is called from service_outstanding_interrupt() from service_interrupt_work() after WDM_DISCONNECTING was set and kill_urbs()  from wdm_disconnect() completed. Thus, move kill_urbs() in wdm_disconnect() to after cancel_work_sync() (which makes sure that service_interrupt_work() is no longer running) completed.  Although it seems to be safe to dereference desc->intf->dev in service_outstanding_interrupt() even if WDM_DISCONNECTING was already set because desc->rlock or cancel_work_sync() prevents wdm_disconnect() from reaching list_del() before service_outstanding_interrupt() completes, let's not emit error message if WDM_DISCONNECTING is set by wdm_disconnect() while usb_submit_urb() is in progress.  [1] https://syzkaller.appspot.com/bug?extid=9e04e2df4a32fb661daf  ",5e5ff0b4b6bcb4d17b7a26ec8bcfc7dd4651684f,1
"net, sk_msg: Don't check if sock is locked when tearing down psock","As John Fastabend reports [0], psock state tear-down can happen on receive path *after* unlocking the socket, if the only other psock user, that is sockmap or sockhash, releases its psock reference before tcp_bpf_recvmsg does so:   tcp_bpf_recvmsg()   psock = sk_psock_get(sk)                         <- refcnt 2   lock_sock(sk);   ...                                   sock_map_free()  <- refcnt 1   release_sock(sk)   sk_psock_put()                                   <- refcnt 0  Remove the lockdep check for socket lock in psock tear-down that got introduced in 7e81a3530206 (""bpf: Sockmap, ensure sock lock held during tear down"").  [0] https://lore.kernel.org/netdev/5e25dc995d7d_74082aaee6e465b441@john-XPS-13-9370.notmuch/  ",58c8db929db1c1d785a6f5d8f8692e5dbcc35e84,0
net: xfrm: fix shift-out-of-bounce,"We need to check up->dirmask to avoid shift-out-of-bounce bug, since up->dirmask comes from userspace.  Also, added XFRM_USERPOLICY_DIRMASK_MAX constant to uapi to inform user-space that up->dirmask has maximum possible value  ",5d8dbb7fb82b8661c16d496644b931c0e2e3a12e,0
fanotify: Allow copying of file handle to userspace,"When file handle is embedded inside fanotify_event and usercopy checks are enabled, we get a warning like:  Bad or missing usercopy whitelist? Kernel memory exposure attempt detected from SLAB object 'fanotify_event' (offset 40, size 8)! ",b2d22b6bb33aac10c415e4ba13c8eade201c6f09,0
libata: don't try to pass through NCQ commands to non-NCQ devices,"syzkaller hit a WARN() in ata_bmdma_qc_issue() when writing to /dev/sg0. This happened because it issued an ATA pass-through command (ATA_16) where the protocol field indicated that NCQ should be used -- but the device did not support NCQ.  We could just remove the WARN() from libata-sff.c, but the real problem seems to be that the SCSI -> ATA translation code passes through NCQ commands without verifying that the device actually supports NCQ.  Fix this by adding the appropriate check to ata_scsi_pass_thru().  Here's reproducer that works in QEMU when /dev/sg0 refers to a disk of the default type (""82371SB PIIX3 IDE""):      #include <fcntl.h>     #include <unistd.h>      int main()     {             char buf[53] = { 0 };  	    buf[36] = 0x85;		",2c1ec6fda2d07044cda922ee25337cf5d4b429b3,1
qrtr: orphan socket in qrtr_release(),"We have to detach sock from socket in qrtr_release(), otherwise skb->sk may still reference to this socket when the skb is released in tun->queue, particularly sk->sk_wq still points to &sock->wq, which leads to a UAF.  ",af9f691f0f5bdd1ade65a7b84927639882d7c3e5,0
ALSA: pcm: Fix tight loop of OSS capture stream,"When the trigger=off is passed for a PCM OSS stream, it sets the start_threshold of the given substream to the boundary size, so that it won't be automatically started.  This can be problematic for a capture stream, unfortunately, as detected by syzkaller.  The scenario is like the following:  - In __snd_pcm_lib_xfer() that is invoked from snd_pcm_oss_read()   loop, we have a check whether the stream was already started or the   stream can be auto-started. - The function at this check returns 0 with trigger=off since we   explicitly disable the auto-start. - The loop continues and repeats calling __snd_pcm_lib_xfer() tightly,   which may lead to an RCU stall.  This patch fixes the bug by simply allowing the wait for non-started stream in the case of OSS capture.  For native usages, it's supposed to be done by the caller side (which is user-space), hence it returns zero like before.  (In theory, __snd_pcm_lib_xfer() could wait even for the native API  usage cases, too; but I'd like to stay in a safer side for not  breaking the existing stuff for now.)  ",e190161f96b88ffae870405fd6c3fdd1d2e7f98d,1
block: fix error in handling dead task for ioprio setting,"Don't combine the task exiting and ""already have io_context"" case, we need to just abort if the task is marked as dead. Return -ESRCH, which is the documented value for ioprio_set() if the specified task could not be found.  ",a957b61254a7d59a6c14ee2ac2db20a62eb299a1,1
RDMA/ucma: ucma_context reference leak in error path,Validating input parameters should be done before getting the cm_id otherwise it can leak a cm_id reference.  ,ef95a90ae6f4f21990e1f7ced6719784a409e811,0
net: rtnetlink: address is mandatory for rtnl_fdb_get,We must have an address to lookup otherwise we'll derefence a null pointer in the ndo_fdb_get callbacks.  CC: Roopa Prabhu <roopa@cumulusnetworks.com> CC: David Ahern <dsa@cumulusnetworks.com> ,f989d03ef25df3fc26d3ea0fe7c19c9830577166,0
x86/mm: fix use-after-free of vma during userfaultfd fault,"Syzkaller with KASAN has reported a use-after-free of vma->vm_flags in __do_page_fault() with the following reproducer:    mmap(&(0x7f0000000000/0xfff000)=nil, 0xfff000, 0x3, 0x32, 0xffffffffffffffff, 0x0)   mmap(&(0x7f0000011000/0x3000)=nil, 0x3000, 0x1, 0x32, 0xffffffffffffffff, 0x0)   r0 = userfaultfd(0x0)   ioctl$UFFDIO_API(r0, 0xc018aa3f, &(0x7f0000002000-0x18)={0xaa, 0x0, 0x0})   ioctl$UFFDIO_REGISTER(r0, 0xc020aa00, &(0x7f0000019000)={{&(0x7f0000012000/0x2000)=nil, 0x2000}, 0x1, 0x0})   r1 = gettid()   syz_open_dev$evdev(&(0x7f0000013000-0x12)=""2f6465762f696e7075742f6576656e742300"", 0x0, 0x0)   tkill(r1, 0x7)  The vma should be pinned by mmap_sem, but handle_userfault() might (in a return to userspace scenario) release it and then acquire again, so when we return to __do_page_fault() (with other result than VM_FAULT_RETRY), the vma might be gone.  Specifically, per Andrea the scenario is  ""A return to userland to repeat the page fault later with a   VM_FAULT_NOPAGE retval (potentially after handling any pending signal   during the return to userland). The return to userland is identified   whenever FAULT_FLAG_USER|FAULT_FLAG_KILLABLE are both set in   vmf->flags""  However, since commit a3c4fb7c9c2e (""x86/mm: Fix fault error path using unsafe vma pointer"") there is a vma_pkey() read of vma->vm_flags after that point, which can thus become use-after-free.  Fix this by moving the read before calling handle_mm_fault().  ",cb0631fd3cf9e989cd48293fe631cbc402aec9a9,1
crypto: algif_aead - skip SGL entries with NULL page,"The TX SGL may contain SGL entries that are assigned a NULL page. This may happen if a multi-stage AIO operation is performed where the data for each stage is pointed to by one SGL entry. Upon completion of that stage, af_alg_pull_tsgl will assign NULL to the SGL entry.  The NULL cipher used to copy the AAD from TX SGL to the destination buffer, however, cannot handle the case where the SGL starts with an SGL entry having a NULL page. Thus, the code needs to advance the start pointer into the SGL to the first non-NULL entry.  This fixes a crash visible on Intel x86 32 bit using the libkcapi test suite.  ",8e1fa89aa8bc2870009b4486644e4a58f2e2a4f5,1
blk-mq-sched: Don't reference queue tagset in blk_mq_sched_tags_teardown(),"We should not reference the queue tagset in blk_mq_sched_tags_teardown() (see function comment) for the blk-mq flags, so use the passed flags instead.  This solves a use-after-free, similarly fixed earlier (and since broken again) in commit f0c1c4d2864e (""blk-mq: fix use-after-free in blk_mq_exit_sched"").  ",8bdf7b3fe1f48a2c1c212d4685903bba01409c0e,1
sch_netem: fix rcu splat in netem_enqueue(),qdisc_root() use from netem_enqueue() triggers a lockdep warning.  __dev_queue_xmit() uses rcu_read_lock_bh() which is not equivalent to rcu_read_lock() + local_bh_disable_bh as far as lockdep is concerned.  ,159d2c7d8106177bd9a986fd005a311fe0d11285,0
percpu_ref: don't refer to ref->data if it isn't allocated,"We can't check ref->data->confirm_switch directly in __percpu_ref_exit(), since ref->data may not be allocated in one not-initialized refcount.  ",7ea6bf2e6c409e245a31b9ac6a4ba24949ad442f,0
i2c: dev: zero out array used for i2c reads from userspace,"If an i2c driver happens to not provide the full amount of data that a user asks for, it is possible that some uninitialized data could be sent to userspace.  While all in-kernel drivers look to be safe, just be sure by initializing the buffer to zero before it is passed to the i2c driver so that any future drivers will not have this issue.  Also properly copy the amount of data recvieved to the userspace buffer, as pointed out by Dan Carpenter.  ",86ff25ed6cd8240d18df58930bd8848b19fce308,1
nbd: don't allow invalid blocksize settings,"syzbot reports a divide-by-zero off the NBD_SET_BLKSIZE ioctl. We need proper validation of the input here. Not just if it's zero, but also if the value is a power-of-2 and in a valid range. Add that.  ",bc811f05d77f47059c197a98b6ad242eb03999cb,0
x86/setup: Explicitly include acpi.h,"After commit 342f43af70db (""iscsi_ibft: fix crash due to KASLR physical memory remapping"") x86_64_defconfig shows the following errors:    arch/x86/kernel/setup.c: In function â€˜setup_archâ€™:   arch/x86/kernel/setup.c:916:13: error: implicit declaration of function â€˜acpi_mps_checkâ€™ [-Werror=implicit-function-declaration]     916 |         if (acpi_mps_check()) {         |             ^~~~~~~~~~~~~~   arch/x86/kernel/setup.c:1110:9: error: implicit declaration of function â€˜acpi_table_upgradeâ€™ [-Werror=implicit-function-declaration]    1110 |         acpi_table_upgrade();         |         ^~~~~~~~~~~~~~~~~~   [... more acpi noise ...]  acpi.h was being implicitly included from iscsi_ibft.h in this configuration so the removal of that header means these functions have no definition or declaration.  In most other configurations, <linux/acpi.h> continued to be included through at least <linux/tboot.h> if CONFIG_INTEL_TXT was enabled, and there were probably other implicit include paths too.  Add acpi.h explicitly so there is no more error, and so that we don't continue to depend on these unreliable implicit include paths.  ",ea7b4244b3656ca33b19a950f092b5bbc718b40c,1
"fcntl: Fix potential deadlock in send_sig{io, urg}()",Syzbot reports a potential deadlock found by the newly added recursive read deadlock detection in lockdep:  [...] ,8d1ddb5e79374fb277985a6b3faa2ed8631c5b4c,0
tipc: fix info leak from kernel tipc_event,We initialize a struct tipc_event allocated on the kernel stack to zero to avert info leak to user space.  ,b06f9d9f1a907dd03f203e2ce9e27e318c22ba01,0
efi/x86: Disable instrumentation in the EFI runtime handling code,"We already disable KASAN instrumentation specifically for the EFI routines that are known to dereference memory addresses that KASAN does not know about, avoiding false positive KASAN splats.  However, as it turns out, having GCOV or KASAN instrumentation enabled interferes with the compiler's ability to optimize away function calls that are guarded by IS_ENABLED() checks that should have resulted in those references to have been const-propagated out of existence. But with instrumenation enabled, we may get build errors like:     ld: arch/x86/platform/efi/efi_64.o: in function `efi_thunk_set_virtual_address_map':    ld: arch/x86/platform/efi/efi_64.o: in function `efi_set_virtual_address_map':  in builds where CONFIG_EFI=y but CONFIG_EFI_MIXED or CONFIG_X86_UV are not defined, even though the invocations are conditional on IS_ENABLED() checks against the respective Kconfig symbols.  So let's disable instrumentation entirely for this subdirectory, which isn't that useful here to begin with.  ",ac6119e7f25b842fc061e8aec88c4f32d3bc28ef,1
netfilter: fix a use-after-free in mtype_destroy(),map->members is freed by ip_set_free() right before using it in mtype_ext_cleanup() again. So we just have to move it down.  ,c120959387efa51479056fd01dc90adfba7a590c,1
ieee802154: hwsim: avoid possible crash in hwsim_del_edge_nl(),Both MAC802154_HWSIM_ATTR_RADIO_ID and MAC802154_HWSIM_ATTR_RADIO_EDGE must be present to avoid a crash.  ,0303b30375dff5351a79cc2c3c87dfa4fda29bed,1
sctp: fix the issue that pathmtu may be set lower than MINSEGMENT,"After commit b6c5734db070 (""sctp: fix the handling of ICMP Frag Needed for too small MTUs""), sctp_transport_update_pmtu would refetch pathmtu from the dst and set it to transport's pathmtu without any check.  The new pathmtu may be lower than MINSEGMENT if the dst is obsolete and updated by .get_dst() in sctp_transport_update_pmtu. In this case, it could have a smaller MTU as well, and thus we should validate it against MINSEGMENT instead.  Syzbot reported a warning in sctp_mtu_payload caused by this.  This patch refetches the pathmtu by calling sctp_dst_mtu where it does the check against MINSEGMENT.  v1->v2:   - refetch the pathmtu by calling sctp_dst_mtu instead as Marcelo's     suggestion.  ",a65925475571953da12a9bc2082aec29d4e2c0e7,1
ovl: fix deadlock in splice write,"There's possibility of an ABBA deadlock in case of a splice write to an overlayfs file and a concurrent splice write to a corresponding real file.  The call chain for splice to an overlay file:   -> do_splice                     [takes sb_writers on overlay file]    -> do_splice_from      -> iter_file_splice_write    [takes pipe->mutex]        -> vfs_iter_write          ...          -> ovl_write_iter        [takes sb_writers on real file]  And the call chain for splice to a real file:   -> do_splice                     [takes sb_writers on real file]    -> do_splice_from      -> iter_file_splice_write    [takes pipe->mutex]  Syzbot successfully bisected this to commit 82a763e61e2b (""ovl: simplify file splice"").  Fix by reverting the write part of the above commit and by adding missing bits from ovl_write_iter() into ovl_splice_write().  ",9b91b6b019fda817eb52f728eb9c79b3579760bc,0
ip6_gre: add validation for csum_start,Validate csum_start in gre_handle_offloads before we call _gre_xmit so that we do not crash later when the csum_start value is used in the lco_csum function call.  This patch deals with ipv6 code.  ,9cf448c200ba9935baa94e7a0964598ce947db9d,1
crypto: x86/aes-ni - add missing error checks in XTS code,"The updated XTS code fails to check the return code of skcipher_walk_virt, which may lead to skcipher_walk_abort() or skcipher_walk_done() being called while the walk argument is in an inconsistent state.  So check the return value after each such call, and bail on errors.  ",821720b9f34ec54106ebf012a712ba73bbcf47c2,0
RDMA/siw: Fix failure handling during device creation,A failing call to ib_device_set_netdev() during device creation caused system crash due to xa_destroy of uninitialized xarray hit by device deallocation. Fixed by moving xarray initialization before potential device deallocation.  ,12e5eef0f4d8087ea7b559f6630be08ffea2d851,1
ethtool: limit bitset size,"Syzbot reported that ethnl_compact_sanity_checks() can be tricked into reading past the end of ETHTOOL_A_BITSET_VALUE and ETHTOOL_A_BITSET_MASK attributes and even the message by passing a value between (u32)(-31) and (u32)(-1) as ETHTOOL_A_BITSET_SIZE.  The problem is that DIV_ROUND_UP(attr_nbits, 32) is 0 for such values so that zero length ETHTOOL_A_BITSET_VALUE will pass the length check but ethnl_bitmap32_not_zero() check would try to access up to 512 MB of attribute ""payload"".  Prevent this overflow byt limiting the bitset size. Technically, compact bitset format would allow bitset sizes up to almost 2^18 (so that the nest size does not exceed U16_MAX) but bitsets used by ethtool are much shorter. S16_MAX, the largest value which can be directly used as an upper limit in policy, should be a reasonable compromise.  ",e34f1753eebc428c312527662eb1b529cf260240,1
KVM: Fix NULL-ptr deref after kvm_create_vm fails,Reported by syzkaller:      kasan: CONFIG_KASAN_INLINE enabled     kasan: GPF could be caused by NULL-ptr deref or user memory access     general protection fault: 0000 [#1] PREEMPT SMP KASAN     CPU: 0 PID: 14727 Comm: syz-executor.3 Not tainted 5.4.0-rc4+ #0     ,8a44119a98bee4381d28f3ed1e41dfacf5c3aa6d,1
netfilter: conntrack: dccp: treat SYNC/SYNCACK as invalid if no prior state,"When first DCCP packet is SYNC or SYNCACK, we insert a new conntrack that has an un-initialized timeout value, i.e. such entry could be reaped at any time.  Mark them as INVALID and only ignore SYNC/SYNCACK when connection had an old state.  ",6613b6173dee098997229caf1f3b961c49da75e6,0
tcp/dccp: fix lockdep issue when SYN is backlogged,"In normal SYN processing, packets are handled without listener lock and in RCU protected ingress path.  But syzkaller is known to be able to trick us and SYN packets might be processed in process context, after being queued into socket backlog.  In commit 06f877d613be (""tcp/dccp: fix other lockdep splats accessing ireq_opt"") I made a very stupid fix, that happened to work mostly because of the regular path being RCU protected.  Really the thing protecting ireq->ireq_opt is RCU read lock, and the pseudo request refcnt is not relevant.  This patch extends what I did in commit 449809a66c1d (""tcp/dccp: block BH for SYN processing"") by adding an extra rcu_read_{lock|unlock} pair in the paths that might be taken when processing SYN from socket backlog (thus possibly in process context)  ",1ad98e9d1bdf4724c0a8532fabd84bf3c457c2bc,1
net: annotate data race in sock_error(),"sock_error() is known to be racy. The code avoids an atomic operation is sk_err is zero, and this field could be changed under us, this is fine.  Sysbot reported:  BUG: KCSAN: data-race in sock_alloc_send_pskb / unix_release_sock  write to 0xffff888131855630 of 4 bytes by task 9365 on cpu 1:  unix_release_sock+0x2e9/0x6e0 net/unix/af_unix.c:550  unix_release+0x2f/0x50 net/unix/af_unix.c:859  __sock_release net/socket.c:599 [inline]  sock_close+0x6c/0x150 net/socket.c:1258  __fput+0x25b/0x4e0 fs/file_table.c:280  ____fput+0x11/0x20 fs/file_table.c:313  task_work_run+0xae/0x130 kernel/task_work.c:164  tracehook_notify_resume include/linux/tracehook.h:189 [inline]  exit_to_user_mode_loop kernel/entry/common.c:174 [inline]  exit_to_user_mode_prepare+0x156/0x190 kernel/entry/common.c:208  __syscall_exit_to_user_mode_work kernel/entry/common.c:290 [inline]  syscall_exit_to_user_mode+0x20/0x40 kernel/entry/common.c:301  do_syscall_64+0x56/0x90 arch/x86/entry/common.c:57  entry_SYSCALL_64_after_hwframe+0x44/0xae  read to 0xffff888131855630 of 4 bytes by task 9385 on cpu 0:  sock_error include/net/sock.h:2269 [inline]  sock_alloc_send_pskb+0xe4/0x4e0 net/core/sock.c:2336  unix_dgram_sendmsg+0x478/0x1610 net/unix/af_unix.c:1671  unix_seqpacket_sendmsg+0xc2/0x100 net/unix/af_unix.c:2055  sock_sendmsg_nosec net/socket.c:654 [inline]  sock_sendmsg net/socket.c:674 [inline]  ____sys_sendmsg+0x360/0x4d0 net/socket.c:2350  __sys_sendmsg_sock+0x25/0x30 net/socket.c:2416  io_sendmsg fs/io_uring.c:4367 [inline]  io_issue_sqe+0x231a/0x6750 fs/io_uring.c:6135  __io_queue_sqe+0xe9/0x360 fs/io_uring.c:6414  __io_req_task_submit fs/io_uring.c:2039 [inline]  io_async_task_func+0x312/0x590 fs/io_uring.c:5074  __tctx_task_work fs/io_uring.c:1910 [inline]  tctx_task_work+0x1d4/0x3d0 fs/io_uring.c:1924  task_work_run+0xae/0x130 kernel/task_work.c:164  tracehook_notify_signal include/linux/tracehook.h:212 [inline]  handle_signal_work kernel/entry/common.c:145 [inline]  exit_to_user_mode_loop kernel/entry/common.c:171 [inline]  exit_to_user_mode_prepare+0xf8/0x190 kernel/entry/common.c:208  __syscall_exit_to_user_mode_work kernel/entry/common.c:290 [inline]  syscall_exit_to_user_mode+0x20/0x40 kernel/entry/common.c:301  do_syscall_64+0x56/0x90 arch/x86/entry/common.c:57  entry_SYSCALL_64_after_hwframe+0x44/0xae  value changed: 0x00000000 -> 0x00000068  Reported by Kernel Concurrency Sanitizer on: CPU: 0 PID: 9385 Comm: syz-executor.3 Not tainted 5.13.0-rc4-syzkaller #0 Hardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 01/01/2011  ",f13ef10059ccf5f4ed201cd050176df62ec25bb8,1
ALSA: core: Fix card races between register and disconnect,"There is a small race window in the card disconnection code that allows the registration of another card with the very same card id. This leads to a warning in procfs creation as caught by syzkaller.  The problem is that we delete snd_cards and snd_cards_lock entries at the very beginning of the disconnection procedure.  This makes the slot available to be assigned for another card object while the disconnection procedure is being processed.  Then it becomes possible to issue a procfs registration with the existing file name although we check the conflict beforehand.  The fix is simply to move the snd_cards and snd_cards_lock clearances at the end of the disconnection procedure.  The references to these entries are merely either from the global proc files like /proc/asound/cards or from the card registration / disconnection, so it should be fine to shift at the very end.  ",2a3f7221acddfe1caa9ff09b3a8158c39b2fdeac,1
USB: serial: quatech2: fix control-request directions,The direction of the pipe argument must match the request-type direction bit or control requests may fail depending on the host-controller-driver implementation.  Fix the three requests which erroneously used usb_rcvctrlpipe().  ,eb8dbe80326c3d44c1e38ee4f40e0d8d3e06f2d0,0
bpf: Do not WARN in bpf_warn_invalid_xdp_action(),"The WARN_ONCE() in bpf_warn_invalid_xdp_action() can be triggered by any bugged program, and even attaching a correct program to a NIC not supporting the given action.  The resulting splat, beyond polluting the logs, fouls automated tools: e.g. a syzkaller reproducers using an XDP program returning an unsupported action will never pass validation.  Replace the WARN_ONCE with a less intrusive pr_warn_once().  ",2cbad989033bff0256675c38f96f5faab852af4b,1
"bpf, sockmap: Fix incorrect fwd_alloc accounting","Incorrect accounting fwd_alloc can result in a warning when the socket is torn down,   [18455.319240] ",144748eb0c445091466c9b741ebd0bfcc5914f3d,0
io_uring: fix ltout double free on completion race,"Always remove linked timeout on io_link_timeout_fn() from the master request link list, otherwise we may get use-after-free when first io_link_timeout_fn() puts linked timeout in the fail path, and then will be found and put on master's free.  ",447c19f3b5074409c794b350b10306e1da1ef4ba,1
usbnet: sanity checking of packet sizes and device mtu,After a reset packet sizes and device mtu can change and need to be reevaluated to calculate queue sizes. Malicious devices can set this to zero and we divide by it. Introduce sanity checking.  ,280ceaed79f18db930c0cc8bb21f6493490bf29c,1
ipv6: addrconf: increment ifp refcount before ipv6_del_addr(),"In the (unlikely) event fixup_permanent_addr() returns a failure, addrconf_permanent_addr() calls ipv6_del_addr() without the mandatory call to in6_ifa_hold(), leading to a refcount error, spotted by syzkaller :  ",e669b86945478b3d90d2d87e3793a6eed06d332f,1
bpf: Fix an unitialized value in bpf_iter,"Commit 15d83c4d7cef (""bpf: Allow loading of a bpf_iter program"") cached btf_id in struct bpf_iter_target_info so later on if it can be checked cheaply compared to checking registered names.  syzbot found a bug that uninitialized value may occur to bpf_iter_target_info->btf_id. This is because we allocated bpf_iter_target_info structure with kmalloc and never initialized field btf_id afterwards. This uninitialized btf_id is typically compared to a u32 bpf program func proto btf_id, and the chance of being equal is extremely slim.  This patch fixed the issue by using kzalloc which will also prevent future likely instances due to adding new fields.  ",17d8beda277a36203585943e70c7909b60775fd5,1
net/smc: fix shutdown in state SMC_LISTEN,"Calling shutdown with SHUT_RD and SHUT_RDWR for a listening SMC socket crashes, because    commit 127f49705823 (""net/smc: release clcsock from tcp_listen_worker"") releases the internal clcsock in smc_close_active() and sets smc->clcsock to NULL. For SHUT_RD the smc_close_active() call is removed. For SHUT_RDWR the kernel_sock_shutdown() call is omitted, since the clcsock is already released.  ",1255fcb2a655f05e02f3a74675a6d6525f187afd,1
mac80211_hwsim: fix use-after-free bug in hwsim_exit_net,"When destroying a net namespace, all hwsim interfaces, which are not created in default namespace are deleted. But the async deletion of the interfaces could last longer than the actual destruction of the namespace, which results to an use after free bug. Therefore use synchronous deletion in this case.  ",8cfd36a0b53aeb4ec21d81eb79706697b84dfc3d,1
netfilter: bridge: ebt_among: add more missing match size checks,"ebt_among is special, it has a dynamic match size and is exempt from the central size checks.  commit c4585a2823edf (""bridge: ebt_among: add missing match size checks"") added validation for pool size, but missed fact that the macros ebt_among_wh_src/dst can already return out-of-bound result because they do not check value of wh_src/dst_ofs (an offset) vs. the size of the match that userspace gave to us.  v2: check that offset has correct alignment. Paolo Abeni points out that we should also check that src/dst wormhash arrays do not overlap, and src + length lines up with start of dst (or vice versa). v3: compact wormhash_sizes_valid() part  NB: Fixes tag is intentionally wrong, this bug exists from day one when match was added for 2.6 kernel. Tag is there so stable maintainers will notice this one too.  Tested with same rules from the earlier patch.  ",c8d70a700a5b486bfa8e5a7d33d805389f6e59f9,1
bpf: devmap: fix use-after-free Read in __dev_map_entry_free,"synchronize_rcu() is fine when the rcu callbacks only need to free memory (kfree_rcu() or direct kfree() call rcu call backs)  __dev_map_entry_free() is a bit more complex, so we need to make sure that call queued __dev_map_entry_free() callbacks have completed.  sysbot report:  BUG: KASAN: use-after-free in dev_map_flush_old kernel/bpf/devmap.c:365 [inline] BUG: KASAN: use-after-free in __dev_map_entry_free+0x2a8/0x300 kernel/bpf/devmap.c:379 Read of size 8 at addr ffff8801b8da38c8 by task ksoftirqd/1/18  CPU: 1 PID: 18 Comm: ksoftirqd/1 Not tainted 4.17.0+ #39 Hardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 01/01/2011 Call Trace:   __dump_stack lib/dump_stack.c:77 [inline]   dump_stack+0x1b9/0x294 lib/dump_stack.c:113   print_address_description+0x6c/0x20b mm/kasan/report.c:256   kasan_report_error mm/kasan/report.c:354 [inline]   kasan_report.cold.7+0x242/0x2fe mm/kasan/report.c:412   __asan_report_load8_noabort+0x14/0x20 mm/kasan/report.c:433   dev_map_flush_old kernel/bpf/devmap.c:365 [inline]   __dev_map_entry_free+0x2a8/0x300 kernel/bpf/devmap.c:379   __rcu_reclaim kernel/rcu/rcu.h:178 [inline]   rcu_do_batch kernel/rcu/tree.c:2558 [inline]   invoke_rcu_callbacks kernel/rcu/tree.c:2818 [inline]   __rcu_process_callbacks kernel/rcu/tree.c:2785 [inline]   rcu_process_callbacks+0xe9d/0x1760 kernel/rcu/tree.c:2802   __do_softirq+0x2e0/0xaf5 kernel/softirq.c:284   run_ksoftirqd+0x86/0x100 kernel/softirq.c:645   smpboot_thread_fn+0x417/0x870 kernel/smpboot.c:164   kthread+0x345/0x410 kernel/kthread.c:240   ret_from_fork+0x3a/0x50 arch/x86/entry/entry_64.S:412  Allocated by task 6675:   save_stack+0x43/0xd0 mm/kasan/kasan.c:448   set_track mm/kasan/kasan.c:460 [inline]   kasan_kmalloc+0xc4/0xe0 mm/kasan/kasan.c:553   kmem_cache_alloc_trace+0x152/0x780 mm/slab.c:3620   kmalloc include/linux/slab.h:513 [inline]   kzalloc include/linux/slab.h:706 [inline]   dev_map_alloc+0x208/0x7f0 kernel/bpf/devmap.c:102   find_and_alloc_map kernel/bpf/syscall.c:129 [inline]   map_create+0x393/0x1010 kernel/bpf/syscall.c:453   __do_sys_bpf kernel/bpf/syscall.c:2351 [inline]   __se_sys_bpf kernel/bpf/syscall.c:2328 [inline]   __x64_sys_bpf+0x303/0x510 kernel/bpf/syscall.c:2328   do_syscall_64+0x1b1/0x800 arch/x86/entry/common.c:290   entry_SYSCALL_64_after_hwframe+0x49/0xbe  Freed by task 26:   save_stack+0x43/0xd0 mm/kasan/kasan.c:448   set_track mm/kasan/kasan.c:460 [inline]   __kasan_slab_free+0x11a/0x170 mm/kasan/kasan.c:521   kasan_slab_free+0xe/0x10 mm/kasan/kasan.c:528   __cache_free mm/slab.c:3498 [inline]   kfree+0xd9/0x260 mm/slab.c:3813   dev_map_free+0x4fa/0x670 kernel/bpf/devmap.c:191   bpf_map_free_deferred+0xba/0xf0 kernel/bpf/syscall.c:262   process_one_work+0xc64/0x1b70 kernel/workqueue.c:2153   worker_thread+0x181/0x13a0 kernel/workqueue.c:2296   kthread+0x345/0x410 kernel/kthread.c:240   ret_from_fork+0x3a/0x50 arch/x86/entry/entry_64.S:412  The buggy address belongs to the object at ffff8801b8da37c0   which belongs to the cache kmalloc-512 of size 512 The buggy address is located 264 bytes inside of   512-byte region [ffff8801b8da37c0, ffff8801b8da39c0) The buggy address belongs to the page: page:ffffea0006e368c0 count:1 mapcount:0 mapping:ffff8801da800940 index:0xffff8801b8da3540 flags: 0x2fffc0000000100(slab) raw: 02fffc0000000100 ffffea0007217b88 ffffea0006e30cc8 ffff8801da800940 raw: ffff8801b8da3540 ffff8801b8da3040 0000000100000004 0000000000000000 page dumped because: kasan: bad access detected  Memory state around the buggy ",2baae3545327632167c0180e9ca1d467416f1919,1
net_sched: fix RTNL deadlock again caused by request_module(),"tcf_action_init_1() loads tc action modules automatically with request_module() after parsing the tc action names, and it drops RTNL lock and re-holds it before and after request_module(). This causes a lot of troubles, as discovered by syzbot, because we can be in the middle of batch initializations when we create an array of tc actions.  One of the problem is deadlock:  CPU 0					CPU 1 rtnl_lock(); for (...) {   tcf_action_init_1();     -> rtnl_unlock();     -> request_module(); 				rtnl_lock(); 				for (...) { 				  tcf_action_init_1(); 				    -> tcf_idr_check_alloc(); 				   // Insert one action into idr, 				   // but it is not committed until 				   // tcf_idr_insert_many(), then drop 				   // the RTNL lock in the _next_ 				   // iteration 				   -> rtnl_unlock();     -> rtnl_lock();     -> a_o->init();       -> tcf_idr_check_alloc();       // Now waiting for the same index       // to be committed 				    -> request_module(); 				    -> rtnl_lock() 				    // Now waiting for RTNL lock 				} 				rtnl_unlock(); } rtnl_unlock();  This is not easy to solve, we can move the request_module() before this loop and pre-load all the modules we need for this netlink message and then do the rest initializations. So the loop breaks down to two now:          for (i = 1; i <= TCA_ACT_MAX_PRIO && tb[i]; i++) {                 struct tc_action_ops *a_o;                  a_o = tc_action_load_ops(name, tb[i]...);                 ops[i - 1] = a_o;         }          for (i = 1; i <= TCA_ACT_MAX_PRIO && tb[i]; i++) {                 act = tcf_action_init_1(ops[i - 1]...);         }  Although this looks serious, it only has been reported by syzbot, so it seems hard to trigger this by humans. And given the size of this patch, I'd suggest to make it to net-next and not to backport to stable.  This patch has been tested by syzbot and tested with tdc.py by me.  ",d349f997686887906b1183b5be96933c5452362a,0
USB: core: Fix incorrect pipe calculation in do_proc_control(),"When the user submits a control URB via usbfs, the user supplies the bRequestType value and the kernel uses it to compute the pipe value. However, do_proc_control() performs this computation incorrectly in the case where the bRequestType direction bit is set to USB_DIR_IN and the URB's transfer length is 0: The pipe's direction is also set to IN but it should be OUT, which is the direction the actual transfer will use regardless of bRequestType.  Commit 5cc59c418fde (""USB: core: WARN if pipe direction != setup packet direction"") added a check to compare the direction bit in the pipe value to a control URB's actual direction and to WARN if they are different.  This can be triggered by the incorrect computation mentioned above, as found by syzbot.  This patch fixes the computation, thus avoiding the WARNing.  ",b0863f1927323110e3d0d69f6adb6a91018a9a3c,0
"batman-adv: initialize ""struct batadv_tvlv_tt_vlan_data""->reserved field","KMSAN found uninitialized value at batadv_tt_prepare_tvlv_local_data() [1], for commit ced72933a5e8ab52 (""batman-adv: use CRC32C instead of CRC16 in TT code"") inserted 'reserved' field into ""struct batadv_tvlv_tt_data"" and commit 7ea7b4a142758dea (""batman-adv: make the TT CRC logic VLAN specific"") moved that field to ""struct batadv_tvlv_tt_vlan_data"" but left that field uninitialized.  [1] https://syzkaller.appspot.com/bug?id=07f3e6dba96f0eb3cabab986adcd8a58b9bdbe9d  ",08c27f3322fec11950b8f1384aa0f3b11d028528,1
blktrace: fix unlocked registration of tracepoints,"We need to ensure that tracepoints are registered and unregistered with the users of them. The existing atomic count isn't enough for that. Add a lock around the tracepoints, so we serialize access to them.  This fixes cases where we have multiple users setting up and tearing down tracepoints, like this:  CPU: 0 PID: 2995 Comm: syzkaller857118 Not tainted 4.14.0-rc5-next-20171018+ #36 Hardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 01/01/2011 Call Trace:   __dump_stack lib/dump_stack.c:16 [inline]   dump_stack+0x194/0x257 lib/dump_stack.c:52   panic+0x1e4/0x41c kernel/panic.c:183   __warn+0x1c4/0x1e0 kernel/panic.c:546   report_bug+0x211/0x2d0 lib/bug.c:183   fixup_bug+0x40/0x90 arch/x86/kernel/traps.c:177   do_trap_no_signal arch/x86/kernel/traps.c:211 [inline]   do_trap+0x260/0x390 arch/x86/kernel/traps.c:260   do_error_trap+0x120/0x390 arch/x86/kernel/traps.c:297   do_invalid_op+0x1b/0x20 arch/x86/kernel/traps.c:310   invalid_op+0x18/0x20 arch/x86/entry/entry_64.S:905 ",a6da0024ffc19e0d47712bb5ca4fd083f76b07df,1
binder: check for binder_thread allocation failure in binder_poll(),"If the kzalloc() in binder_get_thread() fails, binder_poll() dereferences the resulting NULL pointer.  Fix it by returning POLLERR if the memory allocation failed.  This bug was found by syzkaller using fault injection.  ",f88982679f54f75daa5b8eff3da72508f1e7422f,1
ALSA: seq: Set upper limit of processed events,"Currently ALSA sequencer core tries to process the queued events as much as possible when they become dispatchable.  If applications try to queue too massive events to be processed at the very same timing, the sequencer core would still try to process such all events, either in the interrupt context or via some notifier; in either away, it might be a cause of RCU stall or such problems.  As a potential workaround for those problems, this patch adds the upper limit of the amount of events to be processed.  The remaining events are processed in the next batch, so they won't be lost.  For the time being, it's limited up to 1000 events per queue, which should be high enough for any normal usages.  ",6fadb494a638d8b8a55864ecc6ac58194f03f327,0
net: qrtr: Fix memory leak in qrtr_tun_open,"If qrtr_endpoint_register() failed, tun is leaked. Fix this, by freeing tun in error path.  syzbot report: BUG: memory leak unreferenced object 0xffff88811848d680 (size 64):   comm ""syz-executor684"", pid 10171, jiffies 4294951561 (age 26.070s)   ",fc0494ead6398609c49afa37bc949b61c5c16b91,1
inet: fully convert sk->sk_rx_dst to RCU rules,"syzbot reported various issues around early demux, one being included in this changelog [1]  sk->sk_rx_dst is using RCU protection without clearly documenting it.  And following sequences in tcp_v4_do_rcv()/tcp_v6_do_rcv() are not following standard RCU rules.  [a]    dst_release(dst); [b]    sk->sk_rx_dst = NULL;  They look wrong because a delete operation of RCU protected pointer is supposed to clear the pointer before the call_rcu()/synchronize_rcu() guarding actual memory freeing.  In some cases indeed, dst could be freed before [b] is done.  We could cheat by clearing sk_rx_dst before calling dst_release(), but this seems the right time to stick to standard RCU annotations and debugging facilities.  [1] BUG: KASAN: use-after-free in dst_check include/net/dst.h:470 [inline] BUG: KASAN: use-after-free in tcp_v4_early_demux+0x95b/0x960 net/ipv4/tcp_ipv4.c:1792 Read of size 2 at addr ffff88807f1cb73a by task syz-executor.5/9204  CPU: 0 PID: 9204 Comm: syz-executor.5 Not tainted 5.16.0-rc5-syzkaller #0 Hardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 01/01/2011 Call Trace:  <TASK>  __dump_stack lib/dump_stack.c:88 [inline]  dump_stack_lvl+0xcd/0x134 lib/dump_stack.c:106  print_address_description.constprop.0.cold+0x8d/0x320 mm/kasan/report.c:247  __kasan_report mm/kasan/report.c:433 [inline]  kasan_report.cold+0x83/0xdf mm/kasan/report.c:450  dst_check include/net/dst.h:470 [inline]  tcp_v4_early_demux+0x95b/0x960 net/ipv4/tcp_ipv4.c:1792  ip_rcv_finish_core.constprop.0+0x15de/0x1e80 net/ipv4/ip_input.c:340  ip_list_rcv_finish.constprop.0+0x1b2/0x6e0 net/ipv4/ip_input.c:583  ip_sublist_rcv net/ipv4/ip_input.c:609 [inline]  ip_list_rcv+0x34e/0x490 net/ipv4/ip_input.c:644  __netif_receive_skb_list_ptype net/core/dev.c:5508 [inline]  __netif_receive_skb_list_core+0x549/0x8e0 net/core/dev.c:5556  __netif_receive_skb_list net/core/dev.c:5608 [inline]  netif_receive_skb_list_internal+0x75e/0xd80 net/core/dev.c:5699  gro_normal_list net/core/dev.c:5853 [inline]  gro_normal_list net/core/dev.c:5849 [inline]  napi_complete_done+0x1f1/0x880 net/core/dev.c:6590  virtqueue_napi_complete drivers/net/virtio_net.c:339 [inline]  virtnet_poll+0xca2/0x11b0 drivers/net/virtio_net.c:1557  __napi_poll+0xaf/0x440 net/core/dev.c:7023  napi_poll net/core/dev.c:7090 [inline]  net_rx_action+0x801/0xb40 net/core/dev.c:7177  __do_softirq+0x29b/0x9c2 kernel/softirq.c:558  invoke_softirq kernel/softirq.c:432 [inline]  __irq_exit_rcu+0x123/0x180 kernel/softirq.c:637  irq_exit_rcu+0x5/0x20 kernel/softirq.c:649  common_interrupt+0x52/0xc0 arch/x86/kernel/irq.c:240  asm_common_interrupt+0x1e/0x40 arch/x86/include/asm/idtentry.h:629 ",8f905c0e7354ef261360fb7535ea079b1082c105,1
media: vb2: vb2_mmap: move lock up,"If a filehandle is dup()ped, then it is possible to close it from one fd and call mmap from the other. This creates a race condition in vb2_mmap where it is using queue data that __vb2_queue_free (called from close()) is in the process of releasing.  By moving up the mutex_lock(mmap_lock) in vb2_mmap this race is avoided since __vb2_queue_free is called with the same mutex locked. So vb2_mmap now reads consistent buffer data.  ",cd26d1c4d1bc947b56ae404998ae2276df7b39b7,1
KVM: VMX: Always clear vmx->fail on emulation_required,"Revert a relatively recent change that set vmx->fail if the vCPU is in L2 and emulation_required is true, as that behavior is completely bogus. Setting vmx->fail and synthesizing a VM-Exit is contradictory and wrong:    (a) it's impossible to have both a VM-Fail and VM-Exit   (b) vmcs.EXIT_REASON is not modified on VM-Fail   (c) emulation_required refers to guest state and guest state checks are       always VM-Exits, not VM-Fails.  For KVM specifically, emulation_required is handled before nested exits in __vmx_handle_exit(), thus setting vmx->fail has no immediate effect, i.e. KVM calls into handle_invalid_guest_state() and vmx->fail is ignored. Setting vmx->fail can ultimately result in a WARN in nested_vmx_vmexit() firing when tearing down the VM as KVM never expects vmx->fail to be set when L2 is active, KVM always reflects those errors into L1.    ",a80dfc025924024d2c61a4c1b8ef62b2fce76a04,0
ALSA: rawmidi - fix the uninitalized user_pversion,"The user_pversion was uninitialized for the user space file structure in the open function, because the file private structure use kmalloc for the allocation.  The kernel ALSA sequencer code clears the file structure, so no additional fixes are required.  ",39a8fc4971a00d22536aeb7d446ee4a97810611b,1
KEYS: fix NULL pointer dereference during ASN.1 parsing [ver #2],"syzkaller reported a NULL pointer dereference in asn1_ber_decoder().  It can be reproduced by the following command, assuming CONFIG_PKCS7_TEST_KEY=y:          keyctl add pkcs7_test desc '' @s  The bug is that if the data buffer is empty, an integer underflow occurs in the following check:          if (unlikely(dp >= datalen - 1))                 goto data_overrun_error;  This results in the NULL data pointer being dereferenced.  Fix it by checking for 'datalen - dp < 2' instead.  Also fix the similar check for 'dp >= datalen - n' later in the same function.  That one possibly could result in a buffer overread.  The NULL pointer dereference was reproducible using the ""pkcs7_test"" key type but not the ""asymmetric"" key type because the ""asymmetric"" key type checks for a 0-length payload before calling into the ASN.1 decoder but the ""pkcs7_test"" key type does not.  The bug report was:      BUG: unable to handle kernel NULL pointer dereference at           (null)     IP: asn1_ber_decoder+0x17f/0xe60 lib/asn1_decoder.c:233     PGD 7b708067 P4D 7b708067 PUD 7b6ee067 PMD 0     Oops: 0000 [#1] SMP     ",624f5ab8720b3371367327a822c267699c1823b8,1
net: genetlink: always allocate separate attrs for dumpit ops,"Individual dumpit ops (start, dumpit, done) are locked by genl_lock if !family->parallel_ops. However, multiple genl_family_rcv_msg_dumpit() calls may in in flight in parallel. Each has a separate struct genl_dumpit_info allocated but they share the same family->attrbuf. Fix this by allocating separate memory for attrs for dumpit ops, for non-parallel_ops (for parallel_ops it is done already).  ",ab5b526da0485ac4af3d395e5ce1c04b1bfbb89c,0
net_sched: ematch: reject invalid TCF_EM_SIMPLE,"It is possible for malicious userspace to set TCF_EM_SIMPLE bit even for matches that should not have this bit set.  This can fool two places using tcf_em_is_simple()  1) tcf_em_tree_destroy() -> memory leak of em->data    if ops->destroy() is NULL  2) tcf_em_tree_dump() wrongly report/leak 4 low-order bytes    of a kernel pointer.  BUG: memory leak unreferenced object 0xffff888121850a40 (size 32):   comm ""syz-executor927"", pid 7193, jiffies 4294941655 (age 19.840s)   ",55cd9f67f1e45de8517cdaab985fb8e56c0bc1d8,1
pkt_sched: fq: do not accept silly TCA_FQ_QUANTUM,"As diagnosed by Florian :  If TCA_FQ_QUANTUM is set to 0x80000000, fq_deueue() can loop forever in :  if (f->credit <= 0) {   f->credit += q->quantum;   goto begin; }  ... because f->credit is either 0 or -2147483648.  Let's limit TCA_FQ_QUANTUM to no more than 1 << 20 : This max value should limit risks of breaking user setups while fixing this bug.  ",d9e15a2733067c9328fb56d98fe8e574fa19ec31,0
net/tls: swap sk_write_space on close,"Now that we swap the original proto and clear the ULP pointer on close we have to make sure no callback will try to access the freed state. sk_write_space is not part of sk_prot, remember to swap it.  ",57c722e932cfb82e9820bbaae1b1f7222ea97b52,0
xfrm: Fix infinite loop in xfrm_get_dst_nexthop with transport mode.,"On transport mode we forget to fetch the child dst_entry before we continue the while loop, this leads to an infinite loop. Fix this by fetching the child dst_entry before we continue the while loop.  ",013cb81e89f8a70deef086ca29a923faf5585ab0,1
sch_hhf: ensure quantum and hhf_non_hh_weight are non-zero,"In case of TCA_HHF_NON_HH_WEIGHT or TCA_HHF_QUANTUM is zero, it would make no progress inside the loop in hhf_dequeue() thus kernel would get stuck.  Fix this by checking this corner case in hhf_change().  ",d4d6ec6dac07f263f06d847d6f732d6855522845,0
xsk: do not call synchronize_net() under RCU read lock,"The XSKMAP update and delete functions called synchronize_net(), which can sleep. It is not allowed to sleep during an RCU read section.  Instead we need to make sure that the sock sk_destruct (xsk_destruct) function is asynchronously called after an RCU grace period. Setting the SOCK_RCU_FREE flag for XDP sockets takes care of this.  ",cee271678d0e3177a25d0fcb2fa5e051d48e4262,0
make sock_alloc_file() do sock_release() on failures,"This changes calling conventions (and simplifies the hell out the callers).  New rules: once struct socket had been passed to sock_alloc_file(), it's been consumed either by struct file or by sock_release() done by sock_alloc_file().  Either way the caller should not do sock_release() after that point.  ",8e1611e2357927b22892ecc062d65c99d0d89066,0
x86/entry: Increase entry_stack size to a full page,"Marco crashed in bad_iret with a Clang11/KCSAN build due to overflowing the stack. Now that we run C code on it, expand it to a full page.  Suggested-by: Andy Lutomirski <luto@amacapital.net> ",c7aadc09321d8f9a1d3bd1e6d8a47222ecddf6c5,1
x86/fpu: Don't let userspace set bogus xcomp_bv,"On x86, userspace can use the ptrace() or rt_sigreturn() system calls to set a task's extended state (xstate) or ""FPU"" registers.  ptrace() can set them for another task using the PTRACE_SETREGSET request with NT_X86_XSTATE, while rt_sigreturn() can set them for the current task. In either case, registers can be set to any value, but the kernel assumes that the XSAVE area itself remains valid in the sense that the CPU can restore it.  However, in the case where the kernel is using the uncompacted xstate format (which it does whenever the XSAVES instruction is unavailable), it was possible for userspace to set the xcomp_bv field in the xstate_header to an arbitrary value.  However, all bits in that field are reserved in the uncompacted case, so when switching to a task with nonzero xcomp_bv, the XRSTOR instruction failed with a #GP fault.  This caused the WARN_ON_FPU(err) in copy_kernel_to_xregs() to be hit.  In addition, since the error is otherwise ignored, the FPU registers from the task previously executing on the CPU were leaked.  Fix the bug by checking that the user-supplied value of xcomp_bv is 0 in the uncompacted case, and returning an error otherwise.  The reason for validating xcomp_bv rather than simply overwriting it with 0 is that we want userspace to see an error if it (incorrectly) provides an XSAVE area in compacted format rather than in uncompacted format.  Note that as before, in case of error we clear the task's FPU state. This is perhaps non-ideal, especially for PTRACE_SETREGSET; it might be better to return an error before changing anything.  But it seems the ""clear on error"" behavior is fine for now, and it's a little tricky to do otherwise because it would mean we couldn't simply copy the full userspace state into kernel memory in one __copy_from_user().  This bug was found by syzkaller, which hit the above-mentioned WARN_ON_FPU():      ",814fb7bb7db5433757d76f4c4502c96fc53b0b5e,1
tty: Avoid possible error pointer dereference at tty_ldisc_restore().,"syzbot is reporting crashes [1] triggered by memory allocation failure at tty_ldisc_get() from tty_ldisc_restore(). While syzbot stops at WARN_ON() due to panic_on_warn == true, panic_on_warn == false will after all trigger an OOPS by dereferencing old->ops->num if IS_ERR(old) == true.  We can simplify tty_ldisc_restore() as three calls (old->ops->num, N_TTY, N_NULL) to tty_ldisc_failto() in addition to avoiding possible error pointer dereference.  If someone reports kernel panic triggered by forcing all memory allocations for tty_ldisc_restore() to fail, we can consider adding __GFP_NOFAIL for tty_ldisc_restore() case.  [1] https://syzkaller.appspot.com/bug?id=6ac359c61e71d22e06db7f8f88243feb11d927e7  ",598c2d41ff44889dd8eced4f117403e472158d85,1
kobject_uevent: remove warning in init_uevent_argv(),syzbot can trigger the WARN() in init_uevent_argv() which isn't the nicest as the code does properly recover and handle the error.  So change the WARN() call to pr_warn() and provide some more information on what the buffer size that was needed.  ,b4104180a2efb85f55e1ba1407885c9421970338,0
KVM: MMU: check guest CR3 reserved bits based on its physical address width.,"Currently, KVM uses CR3_L_MODE_RESERVED_BITS to check the reserved bits in CR3. Yet the length of reserved bits in guest CR3 should be based on the physical address width exposed to the VM. This patch changes CR3 check logic to calculate the reserved bits at runtime.  ",d1cd3ce9004412949163bfaa062a4df98fe75a98,0
RDMA: Fix use-after-free in rxe_queue_cleanup,On error handling path in rxe_qp_from_init() qp->sq.queue is freed and then rxe_create_qp() will drop last reference to this object. qp clean up function will try to free this queue one time and it causes UAF bug.  Fix it by zeroing queue pointer after freeing queue in rxe_qp_from_init().  ,84b01721e8042cdd1e8ffeb648844a09cd4213e0,1
tcp: tcp_v4_err() icmp skb is named icmp_skb,"I missed the fact that tcp_v4_err() differs from tcp_v6_err().  After commit 4d1a2d9ec1c1 (""Rename skb to icmp_skb in tcp_v4_err()"") the skb argument has been renamed to icmp_skb only in one function.  I will in a future patch reconciliate these functions to avoid this kind of confusion.  ",239174945dac8cb9613db7755103d5fb6c32241d,0
crypto: pcrypt - Delay write to padata->info,"These three events can race when pcrypt is used multiple times in a template (""pcrypt(pcrypt(...))""):    1.  [taskA] The caller makes the crypto request via crypto_aead_encrypt()   2.  [kworkerB] padata serializes the inner pcrypt request   3.  [kworkerC] padata serializes the outer pcrypt request  3 might finish before the call to crypto_aead_encrypt() returns in 1, resulting in two possible issues.  First, a use-after-free of the crypto request's memory when, for example, taskA writes to the outer pcrypt request's padata->info in pcrypt_aead_enc() after kworkerC completes the request.  Second, the outer pcrypt request overwrites the inner pcrypt request's return code with -EINPROGRESS, making a successful request appear to fail.  For instance, kworkerB writes the outer pcrypt request's padata->info in pcrypt_aead_done() and then taskA overwrites it in pcrypt_aead_enc().  Avoid both situations by delaying the write of padata->info until after the inner crypto request's return code is checked.  This prevents the use-after-free by not touching the crypto request's memory after the next-inner crypto request is made, and stops padata->info from being overwritten.  ",68b6dea802cea0dbdd8bd7ccc60716b5a32a5d8a,1
vhost: validate log when IOTLB is enabled,Vq log_base is the userspace address of bitmap which has nothing to do with IOTLB. So it needs to be validated unconditionally otherwise we may try use 0 as log_base which may lead to pin pages that will lead unexpected result (e.g trigger BUG_ON() in set_bit_to_user()).  ,d65026c6c62e7d9616c8ceb5a53b68bcdc050525,1
KVM: let kvm_destroy_vm_debugfs clean up vCPU debugfs directories,"After commit 63d0434 (""KVM: x86: move kvm_create_vcpu_debugfs after last failure point"") we are creating the pre-vCPU debugfs files after the creation of the vCPU file descriptor.  This makes it possible for userspace to reach kvm_vcpu_release before kvm_create_vcpu_debugfs has finished.  The vcpu->debugfs_dentry then does not have any associated inode anymore, and this causes a NULL-pointer dereference in debugfs_create_file.  The solution is simply to avoid removing the files; they are cleaned up when the VM file descriptor is closed (and that must be after KVM_CREATE_VCPU returns).  We can stop storing the dentry in struct kvm_vcpu too, because it is not needed anywhere after kvm_create_vcpu_debugfs returns.  ",d56f5136b01020155b6b0a29f69d924687529bee,1
netfilter: xt_hashlimit: fix lock imbalance,syszkaller found that rcu was not held in hashlimit_mt_common()  We only need to enable BH at this point.  ,de526f401284e1638d4c97cb5a4c292ac3f37655,0
net: ip_gre: Accept IFLA_INFO_DATA-less configuration,The fix referenced below causes a crash when an ERSPAN tunnel is created without passing IFLA_INFO_DATA. Fix by validating passed-in data in the same way as ipgre does.  ,32ca98feab8c9076c89c0697c5a85e46fece809d,1
io_uring: fix error clear of ->file_table in io_sqe_files_register(),"syzbot reports that when using failslab and friends, we can get a double free in io_sqe_files_unregister():  BUG: KASAN: double-free or invalid-free in io_sqe_files_unregister+0x20b/0x300 fs/io_uring.c:3185  CPU: 1 PID: 8819 Comm: syz-executor452 Not tainted 5.4.0-rc6-next-20191108 Hardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 01/01/2011 Call Trace:   __dump_stack lib/dump_stack.c:77 [inline]   dump_stack+0x197/0x210 lib/dump_stack.c:118   print_address_description.constprop.0.cold+0xd4/0x30b mm/kasan/report.c:374   kasan_report_invalid_free+0x65/0xa0 mm/kasan/report.c:468   __kasan_slab_free+0x13a/0x150 mm/kasan/common.c:450   kasan_slab_free+0xe/0x10 mm/kasan/common.c:480   __cache_free mm/slab.c:3426 [inline]   kfree+0x10a/0x2c0 mm/slab.c:3757   io_sqe_files_unregister+0x20b/0x300 fs/io_uring.c:3185   io_ring_ctx_free fs/io_uring.c:3998 [inline]   io_ring_ctx_wait_and_kill+0x348/0x700 fs/io_uring.c:4060   io_uring_release+0x42/0x50 fs/io_uring.c:4068   __fput+0x2ff/0x890 fs/file_table.c:280   ____fput+0x16/0x20 fs/file_table.c:313   task_work_run+0x145/0x1c0 kernel/task_work.c:113   exit_task_work include/linux/task_work.h:22 [inline]   do_exit+0x904/0x2e60 kernel/exit.c:817   do_group_exit+0x135/0x360 kernel/exit.c:921   __do_sys_exit_group kernel/exit.c:932 [inline]   __se_sys_exit_group kernel/exit.c:930 [inline]   __x64_sys_exit_group+0x44/0x50 kernel/exit.c:930   do_syscall_64+0xfa/0x760 arch/x86/entry/common.c:290   entry_SYSCALL_64_after_hwframe+0x49/0xbe ",46568e9be70ff8211d986685f08d919376c32998,1
ALSA: oss: Use kvzalloc() for local buffer allocations,"PCM OSS layer may allocate a few temporary buffers, one for the core read/write and another for the conversions via plugins.  Currently both are allocated via vmalloc().  But as the allocation size is equivalent with the PCM period size, the required size might be quite small, depending on the application.  This patch replaces these vmalloc() calls with kvzalloc() for covering small period sizes better.  Also, we use ""z""-alloc variant here for addressing the possible uninitialized access reported by syzkaller.  ",65766ee0bf7fe8b3be80e2e1c3ef54ad59b29476,1
ext4: mballoc: Use this_cpu_read instead of this_cpu_ptr,"Simplify reading a seq variable by directly using this_cpu_read API instead of doing this_cpu_ptr and then dereferencing it.  This also avoid the below kernel BUG: which happens when CONFIG_DEBUG_PREEMPT is enabled  BUG: using smp_processor_id() in preemptible [00000000] code: syz-fuzzer/6927 caller is ext4_mb_new_blocks+0xa4d/0x3b70 fs/ext4/mballoc.c:4711 CPU: 1 PID: 6927 Comm: syz-fuzzer Not tainted 5.7.0-next-20200602-syzkaller #0 Hardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 01/01/2011 Call Trace:  __dump_stack lib/dump_stack.c:77 [inline]  dump_stack+0x18f/0x20d lib/dump_stack.c:118  check_preemption_disabled+0x20d/0x220 lib/smp_processor_id.c:48  ext4_mb_new_blocks+0xa4d/0x3b70 fs/ext4/mballoc.c:4711  ext4_ext_map_blocks+0x201b/0x33e0 fs/ext4/extents.c:4244  ext4_map_blocks+0x4cb/0x1640 fs/ext4/inode.c:626  ext4_getblk+0xad/0x520 fs/ext4/inode.c:833  ext4_bread+0x7c/0x380 fs/ext4/inode.c:883  ext4_append+0x153/0x360 fs/ext4/namei.c:67  ext4_init_new_dir fs/ext4/namei.c:2757 [inline]  ext4_mkdir+0x5e0/0xdf0 fs/ext4/namei.c:2802  vfs_mkdir+0x419/0x690 fs/namei.c:3632  do_mkdirat+0x21e/0x280 fs/namei.c:3655  do_syscall_64+0x60/0xe0 arch/x86/entry/common.c:359  entry_SYSCALL_64_after_hwframe+0x44/0xa9  ",811985365378df01386c3cfb7ff716e74ca376d5,1
net_sched: sch_skbprio: add message validation to skbprio_change(),Do not assume the attribute has the right size.  ,2761121af87de45951989a0adada917837d8fa82,0
netfilter: drop outermost socket lock in getsockopt(),"The Syzbot reported a possible deadlock in the netfilter area caused by rtnl lock, xt lock and socket lock being acquired with a different order on different code paths, leading to the following backtrace: ",01ea306f2ac2baff98d472da719193e738759d93,0
KVM: x86: Exit to user-mode on #UD intercept when emulator requires,"Instruction emulation after trapping a #UD exception can result in an MMIO access, for example when emulating a MOVBE on a processor that doesn't support the instruction.  In this case, the #UD vmexit handler must exit to user mode, but there wasn't any code to do so.  Add it for both VMX and SVM.  ",61cb57c9ed631c95b54f8e9090c89d18b3695b3c,0
netfilter: ctnetlink: must check mark attributes vs NULL,else we will oops (null deref) when the attributes aren't present.  Also add back the EOPNOTSUPP in case MARK filtering is requested but kernel doesn't support it.  ,9306425b70bf1284a037b7461222887aff48cf8d,1
ipv6: tcp: fix potential NULL deref in tcp_v6_send_reset(),"syzbot found a crash in tcp_v6_send_reset() caused by my latest change.  Problem is that if an skb has been queued to socket prequeue, skb_dst(skb)->dev can not anymore point to the device.  Fortunately in this case the socket pointer is not NULL.  A similar issue has been fixed in commit 0f85feae6b71 (""tcp: fix more NULL deref after prequeue changes""), I should have known better.  ",392096736a06bc9d8f2b42fd4bb1a44b245b9fed,1
fuse: fix leaked notify reply,"fuse_request_send_notify_reply() may fail if the connection was reset for some reason (e.g. fs was unmounted).  Don't leak request reference in this case.  Besides leaking memory, this resulted in fc->num_waiting not being decremented and hence fuse_wait_aborted() left in a hanging and unkillable state.  ",7fabaf303458fcabb694999d6fa772cc13d4e217,0
net_sched: properly check for empty skb array on error path,"First, the check of &q->ring.queue against NULL is wrong, it is always false. We should check the value rather than the address.  Secondly, we need the same check in pfifo_fast_reset() too, as both ->reset() and ->destroy() are called in qdisc_destroy().  ",1df94c3c5dadbce3df6cc0e989d8c85d43a903d6,0
ALSA: seq: Fix racy access for queue timer in proc read,"snd_seq_info_timer_read() reads the information of the timer assigned for each queue, but it's done in a racy way which may lead to UAF as spotted by syzkaller.  This patch applies the missing q->timer_mutex lock while accessing the timer object as well as a slight code change to adapt the standard coding style.  ",60adcfde92fa40fcb2dbf7cc52f9b096e0cd109a,1
RDMA/core: Fix bogus WARN_ON during ib_unregister_device_queued(),"ib_unregister_device_queued() can only be used by drivers using the new dealloc_device callback flow, and it has a safety WARN_ON to ensure drivers are using it properly.  However, if unregister and register are raced there is a special destruction path that maintains the uniform error handling semantic of 'caller does ib_dealloc_device() on failure'. This requires disabling the dealloc_device callback which triggers the WARN_ON.  Instead of using NULL to disable the callback use a special function pointer so the WARN_ON does not trigger.  ",0cb42c0265837fafa2b4f302c8a7fed2631d7869,1
io_uring: allow disabling rings during the creation,"This patch adds a new IORING_SETUP_R_DISABLED flag to start the rings disabled, allowing the user to register restrictions, buffers, files, before to start processing SQEs.  When IORING_SETUP_R_DISABLED is set, SQE are not processed and SQPOLL kthread is not started.  The restrictions registration are allowed only when the rings are disable to prevent concurrency issue while processing SQEs.  The rings can be enabled using IORING_REGISTER_ENABLE_RINGS opcode with io_uring_register(2).  Suggested-by: Jens Axboe <axboe@kernel.dk> ",7e84e1c7566a1df470a9e1f49d3db2ce311261a4,0
KVM: nVMX: Fix kernel info-leak when enabling KVM_CAP_HYPERV_ENLIGHTENED_VMCS more than once,Consider the case that userspace enables KVM_CAP_HYPERV_ENLIGHTENED_VMCS twice: 1) kvm_vcpu_ioctl_enable_cap() is called to enable KVM_CAP_HYPERV_ENLIGHTENED_VMCS which calls nested_enable_evmcs(). 2) nested_enable_evmcs() sets enlightened_vmcs_enabled to true and fills vmcs_version which is then copied to userspace. 3) kvm_vcpu_ioctl_enable_cap() is called again to enable KVM_CAP_HYPERV_ENLIGHTENED_VMCS which calls nested_enable_evmcs(). 4) This time nested_enable_evmcs() just returns 0 as enlightened_vmcs_enabled is already true. *Without filling vmcs_version*. 5) kvm_vcpu_ioctl_enable_cap() continues as usual and copies *uninitialized* vmcs_version to userspace which leads to kernel info-leak.  Fix this issue by simply changing nested_enable_evmcs() to always fill vmcs_version output argument. Even when enlightened_vmcs_enabled is already set to true.  Note that SVM's nested_enable_evmcs() should not be modified because it always returns a non-zero value (-ENODEV) which results in kvm_vcpu_ioctl_enable_cap() skipping the copy of vmcs_version to userspace (as it should).  ,7f9ad1dfa3c768d1116c2dbacd7a09f9a871534e,1
net: wireless: nl80211: fix out-of-bounds access in nl80211_del_key(),"In nl80211_parse_key(), key.idx is first initialized as -1. If this value of key.idx remains unmodified and gets returned, and nl80211_key_allowed() also returns 0, then rdev_del_key() gets called with key.idx = -1. This causes an out-of-bounds array access.  Handle this issue by checking if the value of key.idx after nl80211_parse_key() is called and return -EINVAL if key.idx < 0.  ",3dc289f8f139997f4e9d3cfccf8738f20d23e47b,1
"Revert ""devlink: Remove not-executed trap policer notifications""",This reverts commit 22849b5ea5952d853547cc5e0651f34a246b2a4f as it revealed that mlxsw and netdevsim (copy/paste from mlxsw) reregisters devlink objects during another devlink user triggered command.  ,c5e0321e43deed0512b34d8d8d40a16c0e22b541,0
slab: alien caches must not be initialized if the allocation of the alien cache failed,Callers of __alloc_alien() check for NULL.  We must do the same check in __alloc_alien_cache to avoid NULL pointer dereferences on allocation failures.  ,09c2e76ed734a1d36470d257a778aaba28e86531,1
net/sched: act_ife: initalize ife->metalist earlier,"It seems better to init ife->metalist earlier in tcf_ife_init() to avoid the following crash :  kasan: CONFIG_KASAN_INLINE enabled kasan: GPF could be caused by NULL-ptr deref or user memory access general protection fault: 0000 [#1] PREEMPT SMP KASAN CPU: 0 PID: 10483 Comm: syz-executor216 Not tainted 5.5.0-rc5-syzkaller #0 Hardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 01/01/2011 ",44c23d71599f81a1c7fe8389e0319822dd50c37c,1
netfilter: ebtables: reject bogus getopt len value,syzkaller reports splat: ,5c04da55c754c44937b3d19c6522f9023fd5c5d5,1
media: vivid: free bitmap_cap when updating std/timings/etc.,When vivid_update_format_cap() is called it should free any overlay bitmap since the compose size will change.  ,560ccb75c2caa6b1039dec1a53cd2ef526f5bf03,0
autofs: fix slab out of bounds read in getname_kernel(),"The autofs subsystem does not check that the ""path"" parameter is present for all cases where it is required when it is passed in via the ""param"" struct.  In particular it isn't checked for the AUTOFS_DEV_IOCTL_OPENMOUNT_CMD ioctl command.  To solve it, modify validate_dev_ioctl(function to check that a path has been provided for ioctl commands that require it.  ",02f51d45937f7bc7f4dee21e9f85b2d5eac37104,1
ila: Fix rhashtable walker list corruption,ila_xlat_nl_cmd_flush uses rhashtable walkers allocated from the stack but it never frees them.  This corrupts the walker list of the hash table.  This patch fixes it.  ,b5f9bd15b88563b55a99ed588416881367a0ce5f,1
net/smc: fix possible NULL deref in smc_pnet_add_eth(),"I missed that @ndev value can be NULL.  I prefer not factorizing this NULL check, and instead clearly document where a NULL might be expected.  general protection fault, probably for non-canonical address 0xdffffc00000000ba: 0000 [#1] PREEMPT SMP KASAN KASAN: null-ptr-deref in range [0x00000000000005d0-0x00000000000005d7] CPU: 0 PID: 19875 Comm: syz-executor.2 Not tainted 5.16.0-syzkaller #0 Hardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 01/01/2011 ",7b9b1d449a7cef675d6926c4538edee8e601d823,1
can: can_dropped_invalid_skb(): ensure an initialized headroom in outgoing CAN sk_buffs,KMSAN sysbot detected a read access to an untinitialized value in the headroom of an outgoing CAN related sk_buff. When using CAN sockets this area is filled appropriately - but when using a packet socket this initialization is missing.  The problematic read access occurs in the CAN receive path which can only be triggered when the sk_buff is sent through a (virtual) CAN interface. So we check in the sending path whether we need to perform the missing initializations.  ,e7153bf70c3496bac00e7e4f395bb8d8394ac0ea,0
can: af_can: can_rcv(): replace WARN_ONCE by pr_warn_once,"If an invalid CAN frame is received, from a driver or from a tun interface, a Kernel warning is generated.  This patch replaces the WARN_ONCE by a simple pr_warn_once, so that a kernel, bootet with panic_on_warn, does not panic. A printk seems to be more appropriate here.  ",8cb68751c115d176ec851ca56ecfbb411568c9e8,0
io_uring: poll rework,"It's not possible to go forward with the current state of io_uring polling, we need a more straightforward and easier synchronisation. There are a lot of problems with how it is at the moment, including missing events on rewait.  The main idea here is to introduce a notion of request ownership while polling, no one but the owner can modify any part but ->poll_refs of struct io_kiocb, that grants us protection against all sorts of races.  Main users of such exclusivity are poll task_work handler, so before queueing a tw one should have/acquire ownership, which will be handed off to the tw handler. The other user is __io_arm_poll_handler() do initial poll arming. It starts taking the ownership, so tw handlers won't be run until it's released later in the function after vfs_poll. note: also prevents races in __io_queue_proc(). Poll wake/etc. may not be able to get ownership, then they need to increase the poll refcount and the task_work should notice it and retry if necessary, see io_poll_check_events(). There is also IO_POLL_CANCEL_FLAG flag to notify that we want to kill request.  It makes cancellations more reliable, enables double multishot polling, fixes double poll rewait, fixes missing poll events and fixes another bunch of races.  Even though it adds some overhead for new refcounting, and there are a couple of nice performance wins: - no req->refs refcounting for poll requests anymore - if the data is already there (once measured for some test to be 1-2%   of all apoll requests), it removes it doesn't add atomics and removes   spin_lock/unlock pair. - works well with multishots, we don't do remove from queue / add to   queue for each new poll event.  ",aa43477b040251f451db0d844073ac00a8ab66ee,1
vfs: set fs_context::user_ns for reconfigure,"fs_context::user_ns is used by fuse_parse_param(), even during remount, so it needs to be set to the existing value for reconfigure.  Reproducer:  	#include <fcntl.h> 	#include <sys/mount.h>  	int main() 	{ 		char opts[128]; 		int fd = open(""/dev/fuse"", O_RDWR);  		sprintf(opts, ""fd=%d,rootmode=040000,user_id=0,group_id=0"", fd); 		mkdir(""mnt"", 0777); 		mount(""foo"",  ""mnt"", ""fuse.foo"", 0, opts); 		mount(""foo"", ""mnt"", ""fuse.foo"", MS_REMOUNT, opts); 	}  Crash: 	BUG: kernel NULL pointer dereference, ",1dd9bc08cf1420d466dd8dcfcc233777e61ca5d2,1
netlink: extack needs to be reset each time through loop,syzbot triggered the WARN_ON in netlink_ack testing the bad_attr value. The problem is that netlink_rcv_skb loops over the skb repeatedly invoking the callback and without resetting the extack leaving potentially stale data. Initializing each time through avoids the WARN_ON.  ,cbbdf8433a5f117b1a2119ea30fc651b61ef7570,1
tcp: ignore Fast Open on repair mode,"The TCP repair sequence of operation is to first set the socket in repair mode, then inject the TCP stats into the socket with repair socket options, then call connect() to re-activate the socket. The connect syscall simply returns and set state to ESTABLISHED mode. As a result Fast Open is meaningless for TCP repair.  However allowing sendto() system call with MSG_FASTOPEN flag half-way during the repair operation could unexpectedly cause data to be sent, before the operation finishes changing the internal TCP stats (e.g. MSS).  This in turn triggers TCP warnings on inconsistent packet accounting.  The fix is to simply disallow Fast Open operation once the socket is in the repair mode.  ",16ae6aa1705299789f71fdea59bfb119c1fbd9c0,0
Bluetooth: Fix decrementing reference count twice in releasing socket,"When releasing socket, it is possible to enter hci_sock_release() and hci_sock_dev_event(HCI_DEV_UNREG) at the same time in different thread. The reference count of hdev should be decremented only once from one of them but if storing hdev to local variable in hci_sock_release() before detached from socket and setting to NULL in hci_sock_dev_event(), hci_dev_put(hdev) is unexpectedly called twice. This is resolved by referencing hdev from socket after bt_sock_unlink() in hci_sock_release().  ",e20a2e9c42c9e4002d9e338d74e7819e88d77162,0
ntfs: add check for mft record size in superblock,"Number of bytes allocated for mft record should be equal to the mft record size stored in ntfs superblock as reported by syzbot, userspace might trigger out-of-bounds read by dereferencing ctx->attr in ntfs_attr_find()  ",4f8c94022f0bc3babd0a124c0a7dcdd7547bd94e,1
loop: remember whether sysfs_create_group() was done,syzbot is hitting WARN() triggered by memory allocation fault injection [1] because loop module is calling sysfs_remove_group() when sysfs_create_group() failed. Fix this by remembering whether sysfs_create_group() succeeded.  [1] https://syzkaller.appspot.com/bug?id=3f86c0edf75c86d2633aeb9dd69eccc70bc7e90b  ,d3349b6b3c373ac1fbfb040b810fcee5e2adc7e0,1
net: geneve: check skb is large enough for IPv4/IPv6 header,"Check within geneve_xmit_skb/geneve6_xmit_skb that sk_buff structure is large enough to include IPv4 or IPv6 header, and reject if not. The geneve_xmit_skb portion and overall idea was contributed by Eric Dumazet. Fixes a KMSAN-found uninit-value bug reported by syzbot at: https://syzkaller.appspot.com/bug?id=abe95dc3e3e9667fc23b8d81f29ecad95c6f106f  Suggested-by: Eric Dumazet <edumazet@google.com> ",6628ddfec7580882f11fdc5c194a8ea781fdadfa,1
bpf: Fix up register-based shifts in interpreter to silence KUBSAN,"syzbot reported a shift-out-of-bounds that KUBSAN observed in the interpreter:    [...]   UBSAN: shift-out-of-bounds in kernel/bpf/core.c:1420:2   shift exponent 255 is too large for 64-bit type 'long long unsigned int'   CPU: 1 PID: 11097 Comm: syz-executor.4 Not tainted 5.12.0-rc2-syzkaller #0   Hardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 01/01/2011   Call Trace:    __dump_stack lib/dump_stack.c:79 [inline]    dump_stack+0x141/0x1d7 lib/dump_stack.c:120    ubsan_epilogue+0xb/0x5a lib/ubsan.c:148    __ubsan_handle_shift_out_of_bounds.cold+0xb1/0x181 lib/ubsan.c:327    ___bpf_prog_run.cold+0x19/0x56c kernel/bpf/core.c:1420    __bpf_prog_run32+0x8f/0xd0 kernel/bpf/core.c:1735    bpf_dispatcher_nop_func include/linux/bpf.h:644 [inline]    bpf_prog_run_pin_on_cpu include/linux/filter.h:624 [inline]    bpf_prog_run_clear_cb include/linux/filter.h:755 [inline]    run_filter+0x1a1/0x470 net/packet/af_packet.c:2031    packet_rcv+0x313/0x13e0 net/packet/af_packet.c:2104    dev_queue_xmit_nit+0x7c2/0xa90 net/core/dev.c:2387    xmit_one net/core/dev.c:3588 [inline]    dev_hard_start_xmit+0xad/0x920 net/core/dev.c:3609    __dev_queue_xmit+0x2121/0x2e00 net/core/dev.c:4182    __bpf_tx_skb net/core/filter.c:2116 [inline]    __bpf_redirect_no_mac net/core/filter.c:2141 [inline]    __bpf_redirect+0x548/0xc80 net/core/filter.c:2164    ____bpf_clone_redirect net/core/filter.c:2448 [inline]    bpf_clone_redirect+0x2ae/0x420 net/core/filter.c:2420    ___bpf_prog_run+0x34e1/0x77d0 kernel/bpf/core.c:1523    __bpf_prog_run512+0x99/0xe0 kernel/bpf/core.c:1737    bpf_dispatcher_nop_func include/linux/bpf.h:644 [inline]    bpf_test_run+0x3ed/0xc50 net/bpf/test_run.c:50    bpf_prog_test_run_skb+0xabc/0x1c50 net/bpf/test_run.c:582    bpf_prog_test_run kernel/bpf/syscall.c:3127 [inline]    __do_sys_bpf+0x1ea9/0x4f00 kernel/bpf/syscall.c:4406    do_syscall_64+0x2d/0x70 arch/x86/entry/common.c:46    entry_SYSCALL_64_after_hwframe+0x44/0xae   [...]  Generally speaking, KUBSAN reports from the kernel should be fixed. However, in case of BPF, this particular report caused concerns since the large shift is not wrong from BPF point of view, just undefined. In the verifier, K-based shifts that are >= {64,32} (depending on the bitwidth of the instruction) are already rejected. The register-based cases were not given their content might not be known at verification time. Ideas such as verifier instruction rewrite with an additional AND instruction for the source register were brought up, but regularly rejected due to the additional runtime overhead they incur.  As Edward Cree rightly put it:    Shifts by more than insn bitness are legal in the BPF ISA; they are   implementation-defined behaviour [of the underlying architecture],   rather than UB, and have been made legal for performance reasons.   Each of the JIT backends compiles the BPF shift operations to machine   instructions which produce implementation-defined results in such a   case; the resulting contents of the register may be arbitrary but   program behaviour as a whole remains defined.    Guard checks in the fast path (i.e. affecting JITted code) will thus   not be accepted.    The case of division by zero is not truly analogous here, as division   instructions on many of the JIT-targeted architectures will raise a   machine exception / fault on division by zero, whereas (to the best   of my knowledge) none will do so on an out-of-bounds shift.  Given the KUBSAN report only affects the BPF interpreter, but not JITs, one solution is to add the ANDs with 63 or 31 into ___bpf_prog_run(). That would make the shifts defined, and thus shuts up KUBSAN, and the compiler would optimize out the AND on any CPU that interprets the shift amounts modulo the width anyway (e.g., confirmed from disassembly that on x86-64 and arm64 the generated interpreter code is the same before and after this fix).  The BPF interpreter is slow path, and most likely compiled out anyway as distros select BPF_JIT_ALWAYS_ON to avoid speculative execution of BPF instructions by the interpreter. Given the main argument was to avoid sacrificing performance, the fact that the AND is optimized away from compiler for mainstream archs helps as well as a solution moving forward. Also add a comment on LSH/RSH/ARSH translation for JIT authors to provide guidance when they see the ___bpf_prog_run() interpreter code and use it as a model for a new JIT backend.  ",28131e9d933339a92f78e7ab6429f4aaaa07061c,1
ALSA: seq: Fix potential concurrent access to the deleted pool,"The input pool of a client might be deleted via the resize ioctl, the the access to it should be covered by the proper locks.  Currently the only missing place is the call in snd_seq_ioctl_get_client_pool(), and this patch papers over it.  ",75545304eba6a3d282f923b96a466dc25a81e359,0
bpf: fix null pointer deref in bpf_prog_test_run_xdp,"syzkaller was able to generate the following XDP program ...    (18) r0 = 0x0   (61) r5 = *(u32 *)(r1 +12)   (04) (u32) r0 += (u32) 0   (95) exit  ... and trigger a NULL pointer dereference in ___bpf_prog_run() via bpf_prog_test_run_xdp() where this was attempted to run.  Reason is that recent xdp_rxq_info addition to XDP programs updated all drivers, but not bpf_prog_test_run_xdp(), where xdp_buff is set up. Thus when context rewriter does the deref on the netdev it's NULL at runtime. Fix it by using xdp_rxq from loopback dev. __netif_get_rx_queue() helper can also be reused in various other locations later on.  ",65073a67331de3d2cce35607807ddec284e75e81,1
blk-mq: don't grab ->q_usage_counter in blk_mq_sched_bio_merge,"blk_mq_sched_bio_merge is only called from blk-mq.c:blk_attempt_bio_merge(), which is called when queue usage counter is grabbed already:  1) blk_mq_get_new_requests()  2) blk_mq_get_request() - cached request in current plug owns one queue usage counter  So don't grab ->q_usage_counter in blk_mq_sched_bio_merge(), and more importantly this nest way causes hang in blk_mq_freeze_queue_wait().  ",10f7335e3627b4efa341ef8ac457f2c0770c5c19,0
drivers: video: fbcon: fix NULL dereference in fbcon_cursor(),add null-check on function pointer before dereference on ops->cursor  ,01faae5193d6190b7b3aa93dae43f514e866d652,1
io_uring: Fix NULL pointer dereference in loop_rw_iter(),loop_rw_iter() does not check whether the file has a read or write function. This can lead to NULL pointer dereference when the user passes in a file descriptor that does not have read or write function.  The crash log looks like this:  ,2dd2111d0d383df104b144e0d1f6b5a00cb7cd88,1
rds: tcp: use rds_destroy_pending() to synchronize netns/module teardown and rds connection/workq management,An rds_connection can get added during netns deletion between lines 528 and 529 of    506 static void rds_tcp_kill_sock(struct net *net)   :   ,ebeeb1ad9b8adcc37c2ec21a96f39e9d35199b46,0
net/tls: partially revert fix transition through disconnect with close,"Looks like we were slightly overzealous with the shutdown() cleanup. Even though the sock->sk_state can reach CLOSED again, socket->state will not got back to SS_UNCONNECTED once connections is ESTABLISHED. Meaning we will see EISCONN if we try to reconnect, and EINVAL if we try to listen.  Only listen sockets can be shutdown() and reused, but since ESTABLISHED sockets can never be re-connected() or used for listen() we don't need to try to clean up the ULP state early.  ",5d92e631b8be8965a90c144320f06e096081a551,0
smc: convert to ->poll_mask,"smc->clcsock is an internal TCP socket, after TCP socket converts to ->poll_mask, ->poll doesn't exist any more. So just convert smc socket to ->poll_mask too.  ",c0129a0614428e5e4350fa963eecd1fbe19e57e9,0
"bpf, array: fix overflow in max_entries and undefined behavior in index_mask","syzkaller tried to alloc a map with 0xfffffffd entries out of a userns, and thus unprivileged. With the recently added logic in b2157399cc98 (""bpf: prevent out-of-bounds speculation"") we round this up to the next power of two value for max_entries for unprivileged such that we can apply proper masking into potentially zeroed out map slots.  However, this will generate an index_mask of 0xffffffff, and therefore a + 1 will let this overflow into new max_entries of 0. This will pass allocation, etc, and later on map access we still enforce on the original attr->max_entries value which was 0xfffffffd, therefore triggering GPF all over the place. Thus bail out on overflow in such case.  Moreover, on 32 bit archs roundup_pow_of_two() can also not be used, since fls_long(max_entries - 1) can result in 32 and 1UL << 32 in 32 bit space is undefined. Therefore, do this by hand in a 64 bit variable.  This fixes all the issues triggered by syzkaller's reproducers.  ",bbeb6e4323dad9b5e0ee9f60c223dd532e2403b1,1
ALSA: rawmidi: Initialize allocated buffers,"syzbot reported the uninitialized value exposure in certain situations using virmidi loop.  It's likely a very small race at writing and reading, and the influence is almost negligible.  But it's safer to paper over this just by replacing the existing kvmalloc() with kvzalloc().  ",5a7b44a8df822e0667fc76ed7130252523993bda,1
xsk: Fix possible segfault in xsk umem diagnostics,"Fix possible segfault in the xsk diagnostics code when dumping information about the umem. This can happen when a umem has been created, but the socket has not been bound yet. In this case, the xsk buffer pool does not exist yet and we cannot dump the information that was moved from the umem to the buffer pool. Fix this by testing for the existence of the buffer pool and if not there, do not dump any of that information.  ",53ea2076d851ee37e4f3954c5ae569439b138248,0
crypto: af_alg - fix possible uninit-value in alg_bind(),syzbot reported :  BUG: KMSAN: uninit-value in alg_bind+0xe3/0xd90 crypto/af_alg.c:162  We need to check addr_len before dereferencing sa (or uaddr)  ,a466856e0b7ab269cdf9461886d007e88ff575b0,1
fs/namespace.c: fix use-after-free of mount in mnt_warn_timestamp_expiry(),"After do_add_mount() returns success, the caller doesn't hold a reference to the 'struct mount' anymore.  So it's invalid to access it in mnt_warn_timestamp_expiry().  Fix it by calling mnt_warn_timestamp_expiry() before do_add_mount() rather than after, and adjusting the warning message accordingly.  ",0ecee66990644c3482209ff7c12faa7bc40449b1,1
can: j1939: main: j1939_ndev_to_priv(): avoid crash if can_ml_priv is NULL,This patch avoids a NULL pointer deref crash if ndev->ml_priv is NULL.  ,c48c8c1e2e81e71a0f13b83cc5124333f3750064,1
"kernfs, sysfs, cgroup, intel_rdt: Support fs_context","Make kernfs support superblock creation/mount/remount with fs_context.  This requires that sysfs, cgroup and intel_rdt, which are built on kernfs, be made to support fs_context also.  Notes:   (1) A kernfs_fs_context struct is created to wrap fs_context and the      kernfs mount parameters are moved in here (or are in fs_context).   (2) kernfs_mount{,_ns}() are made into kernfs_get_tree().  The extra      namespace tag parameter is passed in the context if desired   (3) kernfs_free_fs_context() is provided as a destructor for the      kernfs_fs_context struct, but for the moment it does nothing except      get called in the right places.   (4) sysfs doesn't wrap kernfs_fs_context since it has no parameters to      pass, but possibly this should be done anyway in case someone wants to      add a parameter in future.   (5) A cgroup_fs_context struct is created to wrap kernfs_fs_context and      the cgroup v1 and v2 mount parameters are all moved there.   (6) cgroup1 parameter parsing error messages are now handled by invalf(),      which allows userspace to collect them directly.   (7) cgroup1 parameter cleanup is now done in the context destructor rather      than in the mount/get_tree and remount functions.  Weirdies:   (*) cgroup_do_get_tree() calls cset_cgroup_from_root() with locks held,      but then uses the resulting pointer after dropping the locks.  I'm      told this is okay and needs commenting.   (*) The cgroup refcount web.  This really needs documenting.   (*) cgroup2 only has one root?  Add a suggestion from Thomas Gleixner in which the RDT enablement code is placed into its own function.  [folded a leak fix from Andrey Vagin]  ",23bf1b6be9c291a7130118dcc7384f72ac04d813,0
net: rtnetlink: validate IFLA_MTU attribute in rtnl_create_link(),"rtnl_create_link() needs to apply dev->min_mtu and dev->max_mtu checks that we apply in do_setlink()  Otherwise malicious users can crash the kernel, for example after an integer overflow :  BUG: KASAN: use-after-free in memset include/linux/string.h:365 [inline] BUG: KASAN: use-after-free in __alloc_skb+0x37b/0x5e0 net/core/skbuff.c:238 Write of size 32 at addr ffff88819f20b9c0 by task swapper/0/0  CPU: 0 PID: 0 Comm: swapper/0 Not tainted 5.5.0-rc1-syzkaller #0 Hardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 01/01/2011 Call Trace:  <IRQ>  __dump_stack lib/dump_stack.c:77 [inline]  dump_stack+0x197/0x210 lib/dump_stack.c:118  print_address_description.constprop.0.cold+0xd4/0x30b mm/kasan/report.c:374  __kasan_report.cold+0x1b/0x41 mm/kasan/report.c:506  kasan_report+0x12/0x20 mm/kasan/common.c:639  check_memory_region_inline mm/kasan/generic.c:185 [inline]  check_memory_region+0x134/0x1a0 mm/kasan/generic.c:192  memset+0x24/0x40 mm/kasan/common.c:108  memset include/linux/string.h:365 [inline]  __alloc_skb+0x37b/0x5e0 net/core/skbuff.c:238  alloc_skb include/linux/skbuff.h:1049 [inline]  alloc_skb_with_frags+0x93/0x590 net/core/skbuff.c:5664  sock_alloc_send_pskb+0x7ad/0x920 net/core/sock.c:2242  sock_alloc_send_skb+0x32/0x40 net/core/sock.c:2259  mld_newpack+0x1d7/0x7f0 net/ipv6/mcast.c:1609  add_grhead.isra.0+0x299/0x370 net/ipv6/mcast.c:1713  add_grec+0x7db/0x10b0 net/ipv6/mcast.c:1844  mld_send_cr net/ipv6/mcast.c:1970 [inline]  mld_ifc_timer_expire+0x3d3/0x950 net/ipv6/mcast.c:2477  call_timer_fn+0x1ac/0x780 kernel/time/timer.c:1404  expire_timers kernel/time/timer.c:1449 [inline]  __run_timers kernel/time/timer.c:1773 [inline]  __run_timers kernel/time/timer.c:1740 [inline]  run_timer_softirq+0x6c3/0x1790 kernel/time/timer.c:1786  __do_softirq+0x262/0x98c kernel/softirq.c:292  invoke_softirq kernel/softirq.c:373 [inline]  irq_exit+0x19b/0x1e0 kernel/softirq.c:413  exiting_irq arch/x86/include/asm/apic.h:536 [inline]  smp_apic_timer_interrupt+0x1a3/0x610 arch/x86/kernel/apic/apic.c:1137  apic_timer_interrupt+0xf/0x20 arch/x86/entry/entry_64.S:829  </IRQ> ",d836f5c69d87473ff65c06a6123e5b2cf5e56f5b,1
net/xfrm/compat: Copy xfrm_spdattr_type_t atributes,"The attribute-translator has to take in mind maxtype, that is xfrm_link::nla_max. When it is set, attributes are not of xfrm_attr_type_t. Currently, they can be only XFRMA_SPD_MAX (message XFRM_MSG_NEWSPDINFO), their UABI is the same for 64/32-bit, so just copy them.  ",4e9505064f58d1252805952f8547a5b7dbc5c111,0
mac80211: fix skb length check in ieee80211_scan_rx(),"Replace hard-coded compile-time constants for header length check with dynamic determination based on the frame type. Otherwise, we hit a validation WARN_ON in cfg80211 later.  ",e298aa358f0ca658406d524b6639fe389cb6e11e,0
zd1211rw: remove false assertion from zd_mac_clear(),The function is called before the lock which is asserted was ever used. Just remove it.  ,7a2eb7367fdea72e448d1a847aa857f6caf8ea2f,0
mm/mempolicy: do not allow illegal MPOL_F_NUMA_BALANCING | MPOL_LOCAL in mbind(),"syzbot reported access to unitialized memory in mbind() [1]  Issue came with commit bda420b98505 (""numa balancing: migrate on fault among multiple bound nodes"")  This commit added a new bit in MPOL_MODE_FLAGS, but only checked valid combination (MPOL_F_NUMA_BALANCING can only be used with MPOL_BIND) in do_set_mempolicy()  This patch moves the check in sanitize_mpol_flags() so that it is also used by mbind()    [1]   BUG: KMSAN: uninit-value in __mpol_equal+0x567/0x590 mm/mempolicy.c:2260    __mpol_equal+0x567/0x590 mm/mempolicy.c:2260    mpol_equal include/linux/mempolicy.h:105 [inline]    vma_merge+0x4a1/0x1e60 mm/mmap.c:1190    mbind_range+0xcc8/0x1e80 mm/mempolicy.c:811    do_mbind+0xf42/0x15f0 mm/mempolicy.c:1333    kernel_mbind mm/mempolicy.c:1483 [inline]    __do_sys_mbind mm/mempolicy.c:1490 [inline]    __se_sys_mbind+0x437/0xb80 mm/mempolicy.c:1486    __x64_sys_mbind+0x19d/0x200 mm/mempolicy.c:1486    do_syscall_x64 arch/x86/entry/common.c:51 [inline]    do_syscall_64+0x54/0xd0 arch/x86/entry/common.c:82    entry_SYSCALL_64_after_hwframe+0x44/0xae    ",6d2aec9e123bb9c49cb5c7fc654f25f81e688e8c,1
ath9k: Fix use-after-free Read in htc_connect_service,"The skb is consumed by htc_send_epid, so it needn't release again.  The case reported by syzbot:  https://lore.kernel.org/linux-usb/000000000000590f6b05a1c05d15@google.com usb 1-1: ath9k_htc: Firmware ath9k_htc/htc_9271-1.4.0.fw requested usb 1-1: ath9k_htc: Transferred FW: ath9k_htc/htc_9271-1.4.0.fw, size: 51008 usb 1-1: Service connection timeout for: 256 ",ced21a4c726bdc60b1680c050a284b08803bc64c,1
scsi: virtio_scsi: Do not overwrite SCSI status,When a sense code is present we should not override the SAM status; the driver already sets it based on the response from the hypervisor.  In addition we should only copy the sense buffer if one is actually provided by the hypervisor.  ,c43ddbf97f46b93727718408d60a47ce8c08f30c,0
netfilter: nfnetlink: add a missing rcu_read_unlock(),"Reported by syzbot : BUG: sleeping function called from invalid context at include/linux/sched/mm.h:201 in_atomic(): 0, irqs_disabled(): 0, non_block: 0, pid: 26899, name: syz-executor.5 1 lock held by syz-executor.5/26899:  #0: ffffffff8bf797a0 (rcu_read_lock){....}-{1:2}, at: nfnetlink_get_subsys net/netfilter/nfnetlink.c:148 [inline]  #0: ffffffff8bf797a0 (rcu_read_lock){....}-{1:2}, at: nfnetlink_rcv_msg+0x1da/0x1300 net/netfilter/nfnetlink.c:226 Preemption disabled at: [<ffffffff8917799e>] preempt_schedule_irq+0x3e/0x90 kernel/sched/core.c:5533 CPU: 1 PID: 26899 Comm: syz-executor.5 Not tainted 5.12.0-next-20210504-syzkaller #0 Hardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 01/01/2011 Call Trace:  __dump_stack lib/dump_stack.c:79 [inline]  dump_stack+0x141/0x1d7 lib/dump_stack.c:120  ___might_sleep.cold+0x1f1/0x237 kernel/sched/core.c:8338  might_alloc include/linux/sched/mm.h:201 [inline]  slab_pre_alloc_hook mm/slab.h:500 [inline]  slab_alloc_node mm/slub.c:2845 [inline]  kmem_cache_alloc_node+0x33d/0x3e0 mm/slub.c:2960  __alloc_skb+0x20b/0x340 net/core/skbuff.c:413  alloc_skb include/linux/skbuff.h:1107 [inline]  nlmsg_new include/net/netlink.h:953 [inline]  netlink_ack+0x1ed/0xaa0 net/netlink/af_netlink.c:2437  netlink_rcv_skb+0x33d/0x420 net/netlink/af_netlink.c:2508  nfnetlink_rcv+0x1ac/0x420 net/netfilter/nfnetlink.c:650  netlink_unicast_kernel net/netlink/af_netlink.c:1312 [inline]  netlink_unicast+0x533/0x7d0 net/netlink/af_netlink.c:1338  netlink_sendmsg+0x856/0xd90 net/netlink/af_netlink.c:1927  sock_sendmsg_nosec net/socket.c:654 [inline]  sock_sendmsg+0xcf/0x120 net/socket.c:674  ____sys_sendmsg+0x6e8/0x810 net/socket.c:2350  ___sys_sendmsg+0xf3/0x170 net/socket.c:2404  __sys_sendmsg+0xe5/0x1b0 net/socket.c:2433  do_syscall_64+0x3a/0xb0 arch/x86/entry/common.c:47  entry_SYSCALL_64_after_hwframe+0x44/0xae ",7072a355ba191c08b0579f0f66e3eba0e28bf818,1
macsec: restrict to ethernet devices,Only attach macsec to ethernet devices.  Syzbot was able to trigger a KMSAN warning in macsec_handle_frame by attaching to a phonet device.  Macvlan has a similar check in macvlan_port_create.  v1->v2   - fix commit message typo  ,b06d072ccc4b1acd0147b17914b7ad1caa1818bb,0
ALSA: timer: Revert active callback sync check at close,"This is essentially a revert of the commit a7588c896b05 (""ALSA: timer: Check ack_list emptiness instead of bit flag"").  The intended change by the commit turns out to be insufficient, as snd_timer_close*() always calls snd_timer_stop() that deletes the ack_list beforehand.  In theory, we can change the behavior of snd_timer_stop() to sync the pending ack_list, but this will become a deadlock for the callback like sequencer that calls again snd_timer_stop() from itself.  So, reverting the change is a more straightforward solution.  ",df55531b8b0eea9d2473f5697ae4f38d0df6bec7,0
llc: fix skb leak in llc_build_and_send_ui_pkt(),"If llc_mac_hdr_init() returns an error, we must drop the skb since no llc_build_and_send_ui_pkt() caller will take care of this.  BUG: memory leak unreferenced object 0xffff8881202b6800 (size 2048):   comm ""syz-executor907"", pid 7074, jiffies 4294943781 (age 8.590s)   ",8fb44d60d4142cd2a440620cd291d346e23c131e,1
net: annotate lockless accesses to sk->sk_napi_id,"We already annotated most accesses to sk->sk_napi_id  We missed sk_mark_napi_id() and sk_mark_napi_id_once() which might be called without socket lock held in UDP stack.  KCSAN reported : BUG: KCSAN: data-race in udpv6_queue_rcv_one_skb / udpv6_queue_rcv_one_skb  write to 0xffff888121c6d108 of 4 bytes by interrupt on cpu 0:  sk_mark_napi_id include/net/busy_poll.h:125 [inline]  __udpv6_queue_rcv_skb net/ipv6/udp.c:571 [inline]  udpv6_queue_rcv_one_skb+0x70c/0xb40 net/ipv6/udp.c:672  udpv6_queue_rcv_skb+0xb5/0x400 net/ipv6/udp.c:689  udp6_unicast_rcv_skb.isra.0+0xd7/0x180 net/ipv6/udp.c:832  __udp6_lib_rcv+0x69c/0x1770 net/ipv6/udp.c:913  udpv6_rcv+0x2b/0x40 net/ipv6/udp.c:1015  ip6_protocol_deliver_rcu+0x22a/0xbe0 net/ipv6/ip6_input.c:409  ip6_input_finish+0x30/0x50 net/ipv6/ip6_input.c:450  NF_HOOK include/linux/netfilter.h:305 [inline]  NF_HOOK include/linux/netfilter.h:299 [inline]  ip6_input+0x177/0x190 net/ipv6/ip6_input.c:459  dst_input include/net/dst.h:442 [inline]  ip6_rcv_finish+0x110/0x140 net/ipv6/ip6_input.c:76  NF_HOOK include/linux/netfilter.h:305 [inline]  NF_HOOK include/linux/netfilter.h:299 [inline]  ipv6_rcv+0x1a1/0x1b0 net/ipv6/ip6_input.c:284  __netif_receive_skb_one_core+0xa7/0xe0 net/core/dev.c:5010  __netif_receive_skb+0x37/0xf0 net/core/dev.c:5124  process_backlog+0x1d3/0x420 net/core/dev.c:5955  napi_poll net/core/dev.c:6392 [inline]  net_rx_action+0x3ae/0xa90 net/core/dev.c:6460  write to 0xffff888121c6d108 of 4 bytes by interrupt on cpu 1:  sk_mark_napi_id include/net/busy_poll.h:125 [inline]  __udpv6_queue_rcv_skb net/ipv6/udp.c:571 [inline]  udpv6_queue_rcv_one_skb+0x70c/0xb40 net/ipv6/udp.c:672  udpv6_queue_rcv_skb+0xb5/0x400 net/ipv6/udp.c:689  udp6_unicast_rcv_skb.isra.0+0xd7/0x180 net/ipv6/udp.c:832  __udp6_lib_rcv+0x69c/0x1770 net/ipv6/udp.c:913  udpv6_rcv+0x2b/0x40 net/ipv6/udp.c:1015  ip6_protocol_deliver_rcu+0x22a/0xbe0 net/ipv6/ip6_input.c:409  ip6_input_finish+0x30/0x50 net/ipv6/ip6_input.c:450  NF_HOOK include/linux/netfilter.h:305 [inline]  NF_HOOK include/linux/netfilter.h:299 [inline]  ip6_input+0x177/0x190 net/ipv6/ip6_input.c:459  dst_input include/net/dst.h:442 [inline]  ip6_rcv_finish+0x110/0x140 net/ipv6/ip6_input.c:76  NF_HOOK include/linux/netfilter.h:305 [inline]  NF_HOOK include/linux/netfilter.h:299 [inline]  ipv6_rcv+0x1a1/0x1b0 net/ipv6/ip6_input.c:284  __netif_receive_skb_one_core+0xa7/0xe0 net/core/dev.c:5010  __netif_receive_skb+0x37/0xf0 net/core/dev.c:5124  process_backlog+0x1d3/0x420 net/core/dev.c:5955  Reported by Kernel Concurrency Sanitizer on: CPU: 1 PID: 10890 Comm: syz-executor.0 Not tainted 5.4.0-rc3+ #0 Hardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 01/01/2011  ",ee8d153d46a3b98c064ee15c0c0a3bbf1450e5a1,1
userfaultfd: remove uffd flags from vma->vm_flags if UFFD_EVENT_FORK fails,"The fix in commit 0cbb4b4f4c44 (""userfaultfd: clear the vma->vm_userfaultfd_ctx if UFFD_EVENT_FORK fails"") cleared the vma->vm_userfaultfd_ctx but kept userfaultfd flags in vma->vm_flags that were copied from the parent process VMA.  As the result, there is an inconsistency between the values of vma->vm_userfaultfd_ctx.ctx and vma->vm_flags which triggers BUG_ON in userfaultfd_release().  Clearing the uffd flags from vma->vm_flags in case of UFFD_EVENT_FORK failure resolves the issue.  ",31e810aa1033a7db50a2746cd34a2432237f6420,1
9p/trans_fd: Fix concurrency del of req_list in p9_fd_cancelled/p9_read_work,"p9_read_work and p9_fd_cancelled may be called concurrently. In some cases, req->req_list may be deleted by both p9_read_work and p9_fd_cancelled.  We can fix it by ignoring replies associated with a cancelled request and ignoring cancelled request if message has been received before lock.  ",74d6a5d5662975aed7f25952f62efbb6f6dadd29,0
net_sched: fix datalen for ematch,"syzbot reported an out-of-bound access in em_nbyte. As initially analyzed by Eric, this is because em_nbyte sets its own em->datalen in em_nbyte_change() other than the one specified by user, but this value gets overwritten later by its caller tcf_em_validate(). We should leave em->datalen untouched to respect their choices.  I audit all the in-tree ematch users, all of those implement ->change() set em->datalen, so we can just avoid setting it twice in this case.  ",61678d28d4a45ef376f5d02a839cc37509ae9281,1
x86/ioperm: Fix use of deprecated config option,"The commit    111e7b15cf10 (""x86/ioperm: Extend IOPL config to control ioperm() as well"")  replaced X86_IOPL_EMULATION with X86_IOPL_IOPERM. However it appears that there was at least one spot missed as tss_update_io_bitmap() still had a reference to it contained in the code.  The result of this is that it exposed a NULL pointer dereference as seen below with a linux-next next-20191120 kernel:    BUG: kernel NULL pointer dereference, ",e3cb0c7102f04c83bf1a7cb1d052e92749310b46,1
net_sched: walk through all child classes in tc_bind_tclass(),"In a complex TC class hierarchy like this:  tc qdisc add dev eth0 root handle 1:0 cbq bandwidth 100Mbit         \   avpkt 1000 cell 8 tc class add dev eth0 parent 1:0 classid 1:1 cbq bandwidth 100Mbit  \   rate 6Mbit weight 0.6Mbit prio 8 allot 1514 cell 8 maxburst 20      \   avpkt 1000 bounded  tc filter add dev eth0 parent 1:0 protocol ip prio 1 u32 match ip \   sport 80 0xffff flowid 1:3 tc filter add dev eth0 parent 1:0 protocol ip prio 1 u32 match ip \   sport 25 0xffff flowid 1:4  tc class add dev eth0 parent 1:1 classid 1:3 cbq bandwidth 100Mbit  \   rate 5Mbit weight 0.5Mbit prio 5 allot 1514 cell 8 maxburst 20      \   avpkt 1000 tc class add dev eth0 parent 1:1 classid 1:4 cbq bandwidth 100Mbit  \   rate 3Mbit weight 0.3Mbit prio 5 allot 1514 cell 8 maxburst 20      \   avpkt 1000  where filters are installed on qdisc 1:0, so we can't merely search from class 1:1 when creating class 1:3 and class 1:4. We have to walk through all the child classes of the direct parent qdisc. Otherwise we would miss filters those need reverse binding.  ",760d228e322e99cdf6d81b4b60a268b8f13cf67a,0
x86/fpu: Prevent state corruption in __fpu__restore_sig(),"The non-compacted slowpath uses __copy_from_user() and copies the entire user buffer into the kernel buffer, verbatim.  This means that the kernel buffer may now contain entirely invalid state on which XRSTOR will #GP. validate_user_xstate_header() can detect some of that corruption, but that leaves the onus on callers to clear the buffer.  Prior to XSAVES support, it was possible just to reinitialize the buffer, completely, but with supervisor states that is not longer possible as the buffer clearing code split got it backwards. Fixing that is possible but not corrupting the state in the first place is more robust.  Avoid corruption of the kernel XSAVE buffer by using copy_user_to_xstate() which validates the XSAVE header contents before copying the actual states to the kernel. copy_user_to_xstate() was previously only called for compacted-format kernel buffers, but it works for both compacted and non-compacted forms.  Using it for the non-compacted form is slower because of multiple __copy_from_user() operations, but that cost is less important than robust code in an already slow path.  ",484cea4f362e1eeb5c869abbfb5f90eae6421b38,1
io_uring: COW io_identity on mismatch,"If the io_identity doesn't completely match the task, then create a copy of it and use that. The existing copy remains valid until the last user of it has gone away.  This also changes the personality lookup to be indexed by io_identity, instead of creds directly.  ",1e6fa5216a0e59ef02e8b6b40d553238a3b81d49,0
netlink: fix uninit-value in netlink_sendmsg,syzbot reported :  BUG: KMSAN: uninit-value in ffs arch/x86/include/asm/bitops.h:432 [inline] BUG: KMSAN: uninit-value in netlink_sendmsg+0xb26/0x1310 net/netlink/af_netlink.c:1851  ,6091f09c2f79730d895149bcfe3d66140288cd0e,1
fuse: fix bad inode,"Jan Kara's analysis of the syzbot report (edited):    The reproducer opens a directory on FUSE filesystem, it then attaches   dnotify mark to the open directory.  After that a fuse_do_getattr() call   finds that attributes returned by the server are inconsistent, and calls   make_bad_inode() which, among other things does:            inode->i_mode = S_IFREG;    This then confuses dnotify which doesn't tear down its structures   properly and eventually crashes.  Avoid calling make_bad_inode() on a live inode: switch to a private flag on the fuse inode.  Also add the test to ops which the bad_inode_ops would have caught.  This bug goes back to the initial merge of fuse in 2.6.14...  ",5d069dbe8aaf2a197142558b6fb2978189ba3454,1
ext4: get rid of super block and sbi from handle_mount_ops(),"At the parsing phase of mount in the new mount api sb will not be available. We've already removed some uses of sb and sbi, but now we need to get rid of the rest of it.  Use ext4_fs_context to store all of the configuration specification so that it can be later applied to the super block and sbi.  ",6e47a3cc68fc525428297a00524833361ebbb0e9,0
netfilter: ipset: avoid null deref when IPSET_ATTR_LINENO is present,"The set uadt functions assume lineno is never NULL, but it is in case of ip_set_utest().  syzkaller managed to generate a netlink message that calls this with LINENO attr present:  general protection fault: 0000 [#1] PREEMPT SMP KASAN ",22dad713b8a5ff488e07b821195270672f486eb2,1
ipv6: add RTA_TABLE and RTA_PREFSRC to rtm_ipv6_policy,KMSAN reported use of uninit-value that I tracked to lack of proper size check on RTA_TABLE attribute.  I also believe RTA_PREFSRC lacks a similar check.  ,aa8f8778493c85fff480cdf8b349b1e1dcb5f243,0
strparser: Use delayed work instead of timer for msg timeout,Sock lock may be taken in the message timer function which is a problem since timers run in BH. Instead of timers use delayed_work.  ,829385f08ae99740276cbd46c9db29764c519211,0
RDMA/cma: Set proper port number as index,"Conversion from IDR to XArray missed the fact that idr_alloc() returned index as a return value, this index was saved in port variable and used as query index later on. This caused to the following error.   BUG: KASAN: use-after-free in cma_check_port+0x86a/0xa20 [rdma_cm]  Read of size 8 at addr ffff888069fde998 by task ucmatose/387  CPU: 3 PID: 387 Comm: ucmatose Not tainted 5.1.0-rc2+ #253  Hardware name: QEMU Standard PC (Q35 + ICH9, 2009), BIOS rel-1.11.0-0-g63451fca13-prebuilt.qemu-project.org 04/01/2014  Call Trace:   dump_stack+0x7c/0xc0   print_address_description+0x6c/0x23c   ? cma_check_port+0x86a/0xa20 [rdma_cm]   kasan_report.cold.3+0x1c/0x35   ? cma_check_port+0x86a/0xa20 [rdma_cm]   ? cma_check_port+0x86a/0xa20 [rdma_cm]   cma_check_port+0x86a/0xa20 [rdma_cm]   rdma_bind_addr+0x11bc/0x1b00 [rdma_cm]   ? find_held_lock+0x33/0x1c0   ? cma_ndev_work_handler+0x180/0x180 [rdma_cm]   ? wait_for_completion+0x3d0/0x3d0   ucma_bind+0x120/0x160 [rdma_ucm]   ? ucma_resolve_addr+0x1a0/0x1a0 [rdma_ucm]   ucma_write+0x1f8/0x2b0 [rdma_ucm]   ? ucma_open+0x260/0x260 [rdma_ucm]   vfs_write+0x157/0x460   ksys_write+0xb8/0x170   ? __ia32_sys_read+0xb0/0xb0   ? trace_hardirqs_off_caller+0x5b/0x160   ? do_syscall_64+0x18/0x3c0   do_syscall_64+0x95/0x3c0   entry_SYSCALL_64_after_hwframe+0x49/0xbe    Allocated by task 381:    __kasan_kmalloc.constprop.5+0xc1/0xd0    cma_alloc_port+0x4d/0x160 [rdma_cm]    rdma_bind_addr+0x14e7/0x1b00 [rdma_cm]    ucma_bind+0x120/0x160 [rdma_ucm]    ucma_write+0x1f8/0x2b0 [rdma_ucm]    vfs_write+0x157/0x460    ksys_write+0xb8/0x170    do_syscall_64+0x95/0x3c0    entry_SYSCALL_64_after_hwframe+0x49/0xbe    Freed by task 381:    __kasan_slab_free+0x12e/0x180    kfree+0xed/0x290    rdma_destroy_id+0x6b6/0x9e0 [rdma_cm]    ucma_close+0x110/0x300 [rdma_ucm]    __fput+0x25a/0x740    task_work_run+0x10e/0x190    do_exit+0x85e/0x29e0    do_group_exit+0xf0/0x2e0    get_signal+0x2e0/0x17e0    do_signal+0x94/0x1570    exit_to_usermode_loop+0xfa/0x130    do_syscall_64+0x327/0x3c0    entry_SYSCALL_64_after_hwframe+0x49/0xbe  ",061ccb52d23cfa2cf3195546a21c3a87194db5b7,1
"Revert ""USB: rio500: simplify locking""",This reverts commit d710734b06770814de2bfa2819420fb5df7f3a81. This simplification causes a deadlock.  ,2ca359f4f8b954b3a9d15a89f22a8b7283e7669f,0
bpf: do not disable/enable BH in bpf_map_free_id(),"syzkaller reported following splat [1]  Since hard irq are disabled by the caller, bpf_map_free_id() should not try to enable/disable BH.  Another solution would be to change htab_map_delete_elem() to defer the free_htab_elem() call after raw_spin_unlock_irqrestore(&b->lock, flags), but this might be not enough to cover other code paths.  [1] ",930651a75bf1ba6893a8b8475270664ebdb6cf4a,1
mac80211: mesh: embedd mesh_paths and mpp_paths into ieee80211_if_mesh,"Syzbot hit NULL deref in rhashtable_free_and_destroy(). The problem was in mesh_paths and mpp_paths being NULL.  mesh_pathtbl_init() could fail in case of memory allocation failure, but nobody cared, since ieee80211_mesh_init_sdata() returns void. It led to leaving 2 pointers as NULL. Syzbot has found null deref on exit path, but it could happen anywhere else, because code assumes these pointers are valid.  Since all ieee80211_*_setup_sdata functions are void and do not fail, let's embedd mesh_paths and mpp_paths into parent struct to avoid adding error handling on higher levels and follow the pattern of others setup_sdata functions  ",8b5cb7e41d9d77ffca036b0239177de123394a55,1
reiserfs: Fix memory leak in reiserfs_parse_options(),"When a usrjquota or grpjquota mount option is used multiple times, we will leak memory allocated for the file name. Make sure the last setting is used and all the previous ones are properly freed.  ",e9d4709fcc26353df12070566970f080e651f0c9,1
ext4: avoid race conditions when remounting with options that change dax,"Trying to change dax mount options when remounting could allow mount options to be enabled for a small amount of time, and then the mount option change would be reverted.  In the case of ""mount -o remount,dax"", this can cause a race where files would temporarily treated as DAX ",829b37b8cddb1db75c1b7905505b90e593b15db1,1
"mm, oom: fix use-after-free in oom_kill_process","Syzbot instance running on upstream kernel found a use-after-free bug in oom_kill_process.  On further inspection it seems like the process selected to be oom-killed has exited even before reaching read_lock(&tasklist_lock) in oom_kill_process().  More specifically the tsk->usage is 1 which is due to get_task_struct() in oom_evaluate_task() and the put_task_struct within for_each_thread() frees the tsk and for_each_thread() tries to access the tsk.  The easiest fix is to do get/put across the for_each_thread() on the selected task.  Now the next question is should we continue with the oom-kill as the previously selected task has exited? However before adding more complexity and heuristics, let's answer why we even look at the children of oom-kill selected task? The select_bad_process() has already selected the worst process in the system/memcg.  Due to race, the selected process might not be the worst at the kill time but does that matter? The userspace can use the oom_score_adj interface to prefer children to be killed before the parent.  I looked at the history but it seems like this is there before git history.  ",cefc7ef3c87d02fc9307835868ff721ea12cc597,1
ax88172a: fix information leak on short answers,If a malicious device gives a short MAC it can elicit up to 5 bytes of leaked memory out of the driver. We need to check for ETH_ALEN instead.  ,a9a51bd727d141a67b589f375fe69d0e54c4fe22,1
xfrm: fix rcu usage in xfrm_get_type_offload,"request_module can sleep, thus we cannot hold rcu_read_lock() while calling it. The function also jumps back and takes rcu_read_lock() again (in xfrm_state_get_afinfo()), resulting in an imbalance.  This codepath is triggered whenever a new offloaded state is created.  ",2f10a61cee8fdb9f8da90f5db687e1862b22cf06,0
net_sched: check cops->tcf_block in tc_bind_tclass(),"At least sch_red and sch_tbf don't implement ->tcf_block() while still have a non-zero tc ""class"".  Instead of adding nop implementations to each of such qdisc's, we can just relax the check of cops->tcf_block() in tc_bind_tclass(). They don't support TC filter anyway.  ",8b142a00edcf8422ca48b8de88d286efb500cb53,0
sctp: change sctp_prot .no_autobind with true,"syzbot reported a memory leak:    BUG: memory leak, unreferenced object 0xffff888120b3d380 (size 64):   backtrace:      [...] slab_alloc mm/slab.c:3319 [inline]     [...] kmem_cache_alloc+0x13f/0x2c0 mm/slab.c:3483     [...] sctp_bucket_create net/sctp/socket.c:8523 [inline]     [...] sctp_get_port_local+0x189/0x5a0 net/sctp/socket.c:8270     [...] sctp_do_bind+0xcc/0x200 net/sctp/socket.c:402     [...] sctp_bindx_add+0x4b/0xd0 net/sctp/socket.c:497     [...] sctp_setsockopt_bindx+0x156/0x1b0 net/sctp/socket.c:1022     [...] sctp_setsockopt net/sctp/socket.c:4641 [inline]     [...] sctp_setsockopt+0xaea/0x2dc0 net/sctp/socket.c:4611     [...] sock_common_setsockopt+0x38/0x50 net/core/sock.c:3147     [...] __sys_setsockopt+0x10f/0x220 net/socket.c:2084     [...] __do_sys_setsockopt net/socket.c:2100 [inline]  It was caused by when sending msgs without binding a port, in the path: inet_sendmsg() -> inet_send_prepare() -> inet_autobind() -> .get_port/sctp_get_port(), sp->bind_hash will be set while bp->port is not. Later when binding another port by sctp_setsockopt_bindx(), a new bucket will be created as bp->port is not set.  sctp's autobind is supposed to call sctp_autobind() where it does all things including setting bp->port. Since sctp_autobind() is called in sctp_sendmsg() if the sk is not yet bound, it should have skipped the auto bind.  THis patch is to avoid calling inet_autobind() in inet_send_prepare() by changing sctp_prot .no_autobind with true, also remove the unused .get_port.  ",63dfb7938b13fa2c2fbcb45f34d065769eb09414,1
exec: Transform exec_update_mutex into a rw_semaphore,Recently syzbot reported[0] that there is a deadlock amongst the users of exec_update_mutex.  The problematic lock ordering found by lockdep was:     perf_event_open  (exec_update_mutex -> ovl_i_mutex)    chown            (ovl_i_mutex       -> sb_writes)    sendfile         (sb_writes         -> p->lock)      by reading from a proc file and writing to overlayfs    proc_pid_syscall (p->lock           -> exec_update_mutex)  While looking at possible solutions it occured to me that all of the users and possible users involved only wanted to state of the given process to remain the same.  They are all readers.  The only writer is exec.  There is no reason for readers to block on each other.  So fix this deadlock by transforming exec_update_mutex into a rw_semaphore named exec_update_lock that only exec takes for writing.  ,f7cfd871ae0c5008d94b6f66834e7845caa93c15,0
io_uring: dont kill fasync under completion_lock,CPU0                    CPU1        ,4aa84f2ffa81f71e15e5cffc2cc6090dbee78f8e,0
net: dev_addr_list: handle first address in __hw_addr_add_ex,"struct dev_addr_list is used for device addresses, unicast addresses and multicast addresses. The first of those needs special handling of the main address - netdev->dev_addr points directly the data of the entry and drivers write to it freely, so we can't maintain it in the rbtree (for now, at least, to be fixed in net-next).  Current work around sprinkles special handling of the first address on the list throughout the code but it missed the case where address is being added. First address will not be visible during subsequent adds.  Syzbot found a warning where unicast addresses are modified without holding the rtnl lock, tl;dr is that team generates the same modification multiple times, not necessarily when right locks are held.  In the repro we have:    macvlan -> team -> veth  macvlan adds a unicast address to the team. Team then pushes that address down to its memebers (veths). Next something unrelated makes team sync member addrs again, and because of the bug the addr entries get duplicated in the veths. macvlan gets removed, removes its addr from team which removes only one of the duplicated addresses from veths. This removal is done under rtnl. Next syzbot uses iptables to add a multicast addr to team (which does not hold rtnl lock). Team syncs veth addrs, but because veths' unicast list still has the duplicate it will also get sync, even though this update is intended for mc addresses. Again, uc address updates need rtnl lock, boom.  ",a5b8fd657881003ea11c193d147c8f4ba143725d,1
ANDROID: binder: fix transaction leak.,"If a call to put_user() fails, we failed to properly free a transaction and send a failed reply (if necessary).  ",fb2c445277e7b0b4ffe10de8114bad4eccaca948,0
flow_dissector: lookup netns by skb->sk if skb->dev is NULL,"BPF flow dissectors are configured per network namespace. __skb_flow_dissect looks up the netns through dev_net(skb->dev).  In some dissector paths skb->dev is NULL, such as for Unix sockets. In these cases fall back to looking up the netns by socket.  Analyzing the codepaths leading to __skb_flow_dissect I did not find a case where both skb->dev and skb->sk are NULL. Warn and fall back to standard flow dissector if one is found.  ",d0e13a1488ad30dc3c2c9347b931cb10f892e3a4,0
fanotify: update connector fsid cache on add mark,"When implementing connector fsid cache, we only initialized the cache when the first mark added to object was added by FAN_REPORT_FID group. We forgot to update conn->fsid when the second mark is added by FAN_REPORT_FID group to an already attached connector without fsid cache.  ",c285a2f01d692ef48d7243cf1072897bbd237407,0
ipv6: Error when route does not have any valid nexthops,"When user space sends invalid information in RTA_MULTIPATH, the nexthop list in ip6_route_multipath_add() is empty and 'rt_notif' is set to NULL.  The code that emits the in-kernel notifications does not check for this condition, which results in a NULL pointer dereference [1].  Fix this by bailing earlier in the function if the parsed nexthop list is empty. This is consistent with the corresponding IPv4 code.  v2: * Check if parsed nexthop list is empty and bail with extack set  [1] kasan: CONFIG_KASAN_INLINE enabled kasan: GPF could be caused by NULL-ptr deref or user memory access general protection fault: 0000 [#1] PREEMPT SMP KASAN CPU: 0 PID: 9190 Comm: syz-executor149 Not tainted 5.2.0-rc5+ #38 Hardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 01/01/2011 ",9eee3b4913d734b2c2496ddeea625d5b56583757,1
seccomp: don't leak memory when filter install races,"In seccomp_set_mode_filter() with TSYNC | NEW_LISTENER, we first initialize the listener fd, then check to see if we can actually use it later in seccomp_may_assign_mode(), which can fail if anyone else in our thread group has installed a filter and caused some divergence. If we can't, we partially clean up the newly allocated file: we put the fd, put the file, but don't actually clean up the *memory* that was allocated at filter->notif. Let's clean that up too.  To accomplish this, let's hoist the actual ""detach a notifier from a filter"" code to its own helper out of seccomp_notify_release(), so that in case anyone adds stuff to init_listener(), they only have to add the cleanup code in one spot. This does a bit of extra locking and such on the failure path when the filter is not attached, but it's a slow failure path anyway.  ",a566a9012acd7c9a4be7e30dc7acb7a811ec2260,1
mm: memcontrol: fix warning when allocating the root cgroup,"Commit 3e38e0aaca9e (""mm: memcg: charge memcg percpu memory to the parent cgroup"") adds memory tracking to the memcg kernel structures themselves to make cgroups liable for the memory they are consuming through the allocation of child groups (which can be significant).  This code is a bit awkward as it's spread out through several functions: The outermost function does memalloc_use_memcg(parent) to set up current->active_memcg, which designates which cgroup to charge, and the inner functions pass GFP_ACCOUNT to request charging for specific allocations.  To make sure this dependency is satisfied at all times - to make sure we don't randomly charge whoever is calling the functions - the inner functions warn on !current->active_memcg.  However, this triggers a false warning when the root memcg itself is allocated.  No parent exists in this case, and so current->active_memcg is rightfully NULL.  It's a false positive, not indicative of a bug.  Delete the warnings for now, we can revisit this later.  ",9f457179244a1c0316546b1760f8993d0d718861,0
KVM: x86: fix escape of guest dr6 to the host,syzkaller reported:     ,efdab992813fb2ed825745625b83c05032e9cda2,1
net: usb: ax88179_178a: initialize local variables before use,"Use memset to initialize local array in drivers/net/usb/ax88179_178a.c, and also set a local u16 and u32 variable to 0. Fixes a KMSAN found uninit-value bug reported by syzbot at: https://syzkaller.appspot.com/bug?id=00371c73c72f72487c1d0bfe0cc9d00de339d5aa  ",bd78980be1a68d14524c51c4b4170782fada622b,1
udlfb: Fix memory leak in dlfb_usb_probe,"The dlfb_alloc_urb_list function is called in dlfb_usb_probe function, after that if an error occurs, the dlfb_free_urb_list function need to be called.  BUG: memory leak unreferenced object 0xffff88810adde100 (size 32):   comm ""kworker/1:0"", pid 17, jiffies 4294947788 (age 19.520s)   ",5c0e4110f751934e748a66887c61f8e73805f0f9,1
tipc: compare remote and local protocols in tipc_udp_enable(),"When TIPC_NLA_UDP_REMOTE is an IPv6 mcast address but TIPC_NLA_UDP_LOCAL is an IPv4 address, a NULL-ptr deref is triggered as the UDP tunnel sock is initialized to IPv4 or IPv6 sock merely based on the protocol in local address.  We should just error out when the remote address and local address have different protocols.  ",fb83ed496b9a654f60cd1d58a0e1e79ec5694808,0
ovl: fix access beyond unterminated strings,"KASAN detected slab-out-of-bounds access in printk from overlayfs, because string format used %*s instead of %.*s.  > BUG: KASAN: slab-out-of-bounds in string+0x298/0x2d0 lib/vsprintf.c:604 > Read of size 1 at addr ffff8801c36c66ba by task syz-executor2/27811 > > CPU: 0 PID: 27811 Comm: syz-executor2 Not tainted 4.19.0-rc5+ #36 ... >  printk+0xa7/0xcf kernel/printk/printk.c:1996 >  ovl_lookup_index.cold.15+0xe8/0x1f8 fs/overlayfs/namei.c:689  ",601350ff58d5415a001769532f6b8333820e5786,1
tipc: fix a double free in tipc_enable_bearer(),"bearer_disable() already calls kfree_rcu() to free struct tipc_bearer, we don't need to call kfree() again.  ",dc4501ff287547dea7ca10f1c580c741291a8760,1
f2fs: sanity check on sit entry,"syzbot hit the following crash on upstream commit 87ef12027b9b1dd0e0b12cf311fbcb19f9d92539 (Wed Apr 18 19:48:17 2018 +0000) Merge tag 'ceph-for-4.17-rc2' of git://github.com/ceph/ceph-client syzbot dashboard link: https://syzkaller.appspot.com/bug?extid=83699adeb2d13579c31e  C reproducer: https://syzkaller.appspot.com/x/repro.c?id=5805208181407744 syzkaller reproducer: https://syzkaller.appspot.com/x/repro.syz?id=6005073343676416 Raw console output: https://syzkaller.appspot.com/x/log.txt?id=6555047731134464 Kernel config: https://syzkaller.appspot.com/x/.config?id=1808800213120130118 compiler: gcc (GCC) 8.0.1 20180413 (experimental)  IMPORTANT: if you fix the bug, please add the following tag to the commit: ",b2ca374f33bd33fd822eb871876e4888cf79dc97,1
wireguard: allowedips: fix use-after-free in root_remove_peer_lists,"In the unlikely case a new node could not be allocated, we need to remove @newnode from @peer->allowedips_list before freeing it.  ",9981159fc3b677b357f84e069a11de5a5ec8a2a8,1
pptp: remove a buggy dst release in pptp_connect(),"Once dst has been cached in socket via sk_setup_caps(), it is illegal to call ip_rt_put() (or dst_release()), since sk_setup_caps() did not change dst refcount.  We can still dereference it since we hold socket lock.  Caugth by syzbot :  BUG: KASAN: use-after-free in atomic_dec_return include/asm-generic/atomic-instrumented.h:198 [inline] BUG: KASAN: use-after-free in dst_release+0x27/0xa0 net/core/dst.c:185 Write of size 4 at addr ffff8801c54dc040 by task syz-executor4/20088  CPU: 1 PID: 20088 Comm: syz-executor4 Not tainted 4.16.0+ #376 Hardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 01/01/2011 Call Trace:  __dump_stack lib/dump_stack.c:17 [inline]  dump_stack+0x1a7/0x27d lib/dump_stack.c:53  print_address_description+0x73/0x250 mm/kasan/report.c:256  kasan_report_error mm/kasan/report.c:354 [inline]  kasan_report+0x23c/0x360 mm/kasan/report.c:412  check_memory_region_inline mm/kasan/kasan.c:260 [inline]  check_memory_region+0x137/0x190 mm/kasan/kasan.c:267  kasan_check_write+0x14/0x20 mm/kasan/kasan.c:278  atomic_dec_return include/asm-generic/atomic-instrumented.h:198 [inline]  dst_release+0x27/0xa0 net/core/dst.c:185  sk_dst_set include/net/sock.h:1812 [inline]  sk_dst_reset include/net/sock.h:1824 [inline]  sock_setbindtodevice net/core/sock.c:610 [inline]  sock_setsockopt+0x431/0x1b20 net/core/sock.c:707  SYSC_setsockopt net/socket.c:1845 [inline]  SyS_setsockopt+0x2ff/0x360 net/socket.c:1828  do_syscall_64+0x281/0x940 arch/x86/entry/common.c:287  entry_SYSCALL_64_after_hwframe+0x42/0xb7 ",bfacfb457b36911a10140b8cb3ce76a74883ac5a,1
io_uring: free fixed_file_data after RCU grace period,"The percpu refcount protects this structure, and we can have an atomic switch in progress when exiting. This makes it unsafe to just free the struct normally, and can trigger the following KASAN warning:  BUG: KASAN: use-after-free in percpu_ref_switch_to_atomic_rcu+0xfa/0x1b0 Read of size 1 at addr ffff888181a19a30 by task swapper/0/0  CPU: 0 PID: 0 Comm: swapper/0 Not tainted 5.6.0-rc4+ #5747 Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS 1.10.2-1ubuntu1 04/01/2014 Call Trace:  <IRQ>  dump_stack+0x76/0xa0  print_address_description.constprop.0+0x3b/0x60  ? percpu_ref_switch_to_atomic_rcu+0xfa/0x1b0  ? percpu_ref_switch_to_atomic_rcu+0xfa/0x1b0  __kasan_report.cold+0x1a/0x3d  ? percpu_ref_switch_to_atomic_rcu+0xfa/0x1b0  percpu_ref_switch_to_atomic_rcu+0xfa/0x1b0  rcu_core+0x370/0x830  ? percpu_ref_exit+0x50/0x50  ? rcu_note_context_switch+0x7b0/0x7b0  ? run_rebalance_domains+0x11d/0x140  __do_softirq+0x10a/0x3e9  irq_exit+0xd5/0xe0  smp_apic_timer_interrupt+0x86/0x200  apic_timer_interrupt+0xf/0x20  </IRQ> ",c1e2148f8ecb26863b899d402a823dab8e26efd1,1
netfilter: ipset: Fix oversized kvmalloc() calls,The commit  commit 7661809d493b426e979f39ab512e3adf41fbcc69 Author: Linus Torvalds <torvalds@linux-foundation.org> Date:   Wed Jul 14 09:45:49 2021 -0700      mm: don't allow oversized kvmalloc() calls  limits the max allocatable memory via kvmalloc() to MAX_INT. Apply the same limit in ipset.  ,7bbc3d385bd813077acaf0e6fdb2a86a901f5382,0
seccomp: Make NEW_LISTENER and TSYNC flags exclusive,"As the comment notes, the return codes for TSYNC and NEW_LISTENER conflict, because they both return positive values, one in the case of success and one in the case of error. So, let's disallow both of these flags together.  While this is technically a userspace break, all the users I know of are still waiting on me to land this feature in libseccomp, so I think it'll be safe. Also, at present my use case doesn't require TSYNC at all, so this isn't a big deal to disallow. If someone wanted to support this, a path forward would be to add a new flag like TSYNC_AND_LISTENER_YES_I_UNDERSTAND_THAT_TSYNC_WILL_JUST_RETURN_EAGAIN, but the use cases are so different I don't see it really happening.  Finally, it's worth noting that this does actually fix a UAF issue: at the end of seccomp_set_mode_filter(), we have:          if (flags & SECCOMP_FILTER_FLAG_NEW_LISTENER) {                 if (ret < 0) {                         listener_f->private_data = NULL;                         fput(listener_f);                         put_unused_fd(listener);                 } else {                         fd_install(listener, listener_f);                         ret = listener;                 }         } out_free:         seccomp_filter_free(prepared);  But if ret > 0 because TSYNC raced, we'll install the listener fd and then free the filter out from underneath it, causing a UAF when the task closes it or dies. This patch also switches the condition to be simply if (ret), so that if someone does add the flag mentioned above, they won't have to remember to fix this too.  ",7a0df7fbc14505e2e2be19ed08654a09e1ed5bf6,1
selinux: Add __GFP_NOWARN to allocation at str_read(),syzbot is hitting warning at str_read() [1] because len parameter can become larger than KMALLOC_MAX_SIZE. We don't need to emit warning for this case.  [1] https://syzkaller.appspot.com/bug?id=7f2f5aad79ea8663c296a2eedb81978401a908f0  ,4458bba09788e70e8fb39ad003f087cd9dfbd6ac,1
io_uring: drop ctx->uring_lock before acquiring sqd->lock,"The SQPOLL thread dictates the lock order, and we hold the ctx->uring_lock for all the registration opcodes. We also hold a ref to the ctx, and we do drop the lock for other reasons to quiesce, so it's fine to drop the ctx lock temporarily to grab the sqd->lock. This fixes the following lockdep splat:  ",009ad9f0c6eed0caa7943bc46aa1ae2cb8c382fb,0
can: j1935: j1939_tp_tx_dat_new(): fix missing initialization of skbcnt,This fixes an uninit-value warning: BUG: KMSAN: uninit-value in can_receive+0x26b/0x630 net/can/af_can.c:650  ,e009f95b1543e26606dca2f7e6e9f0f9174538e5,1
tipc: block BH before using dst_cache,"dst_cache_get() documents it must be used with BH disabled.  sysbot reported :  BUG: using smp_processor_id() in preemptible [00000000] code: /21697 caller is dst_cache_get+0x3a/0xb0 net/core/dst_cache.c:68 CPU: 0 PID: 21697 Comm:  Not tainted 5.7.0-rc6-syzkaller #0 Hardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 01/01/2011 Call Trace:  __dump_stack lib/dump_stack.c:77 [inline]  dump_stack+0x188/0x20d lib/dump_stack.c:118  check_preemption_disabled lib/smp_processor_id.c:47 [inline]  debug_smp_processor_id.cold+0x88/0x9b lib/smp_processor_id.c:57  dst_cache_get+0x3a/0xb0 net/core/dst_cache.c:68  tipc_udp_xmit.isra.0+0xb9/0xad0 net/tipc/udp_media.c:164  tipc_udp_send_msg+0x3e6/0x490 net/tipc/udp_media.c:244  tipc_bearer_xmit_skb+0x1de/0x3f0 net/tipc/bearer.c:526  tipc_enable_bearer+0xb2f/0xd60 net/tipc/bearer.c:331  __tipc_nl_bearer_enable+0x2bf/0x390 net/tipc/bearer.c:995  tipc_nl_bearer_enable+0x1e/0x30 net/tipc/bearer.c:1003  genl_family_rcv_msg_doit net/netlink/genetlink.c:673 [inline]  genl_family_rcv_msg net/netlink/genetlink.c:718 [inline]  genl_rcv_msg+0x627/0xdf0 net/netlink/genetlink.c:735  netlink_rcv_skb+0x15a/0x410 net/netlink/af_netlink.c:2469  genl_rcv+0x24/0x40 net/netlink/genetlink.c:746  netlink_unicast_kernel net/netlink/af_netlink.c:1303 [inline]  netlink_unicast+0x537/0x740 net/netlink/af_netlink.c:1329  netlink_sendmsg+0x882/0xe10 net/netlink/af_netlink.c:1918  sock_sendmsg_nosec net/socket.c:652 [inline]  sock_sendmsg+0xcf/0x120 net/socket.c:672  ____sys_sendmsg+0x6bf/0x7e0 net/socket.c:2362  ___sys_sendmsg+0x100/0x170 net/socket.c:2416  __sys_sendmsg+0xec/0x1b0 net/socket.c:2449  do_syscall_64+0xf6/0x7d0 arch/x86/entry/common.c:295  entry_SYSCALL_64_after_hwframe+0x49/0xb3 ",1378817486d6860f6a927f573491afe65287abf1,1
drm: Fix use-after-free read in drm_getunique(),"There is a time-of-check-to-time-of-use error in drm_getunique() due to retrieving file_priv->master prior to locking the device's master mutex.  An example can be seen in the crash report of the use-after-free error found by Syzbot: https://syzkaller.appspot.com/bug?id=148d2f1dfac64af52ffd27b661981a540724f803  In the report, the master pointer was used after being freed. This is because another process had acquired the device's master mutex in drm_setmaster_ioctl(), then overwrote fpriv->master in drm_new_set_master(). The old value of fpriv->master was subsequently freed before the mutex was unlocked.  To fix this, we lock the device's master mutex before retrieving the pointer from from fpriv->master. This patch passes the Syzbot reproducer test.  ",b436acd1cf7fac0ba987abd22955d98025c80c2b,1
cfg80211: call cfg80211_leave_ocb when switching away from OCB,"If the userland switches back-and-forth between NL80211_IFTYPE_OCB and NL80211_IFTYPE_ADHOC via send_msg(NL80211_CMD_SET_INTERFACE), there is a chance where the cleanup cfg80211_leave_ocb() is not called. This leads to initialization of in-use memory (e.g. init u.ibss while in-use by u.ocb) due to a shared struct/union within ieee80211_sub_if_data:  struct ieee80211_sub_if_data {     ...     union {         struct ieee80211_if_ap ap;         struct ieee80211_if_vlan vlan;         struct ieee80211_if_managed mgd;         struct ieee80211_if_ibss ibss; // <- shares address         struct ieee80211_if_mesh mesh;         struct ieee80211_if_ocb ocb; // <- shares address         struct ieee80211_if_mntr mntr;         struct ieee80211_if_nan nan;     } u;     ... }  Therefore add handling of otype == NL80211_IFTYPE_OCB, during cfg80211_change_iface() to perform cleanup when leaving OCB mode.  link to syzkaller bug: https://syzkaller.appspot.com/bug?id=0612dbfa595bf4b9b680ff7b4948257b8e3732d5  ",a64b6a25dd9f984ed05fade603a00e2eae787d2f,1
USB: usblp: fix use-after-free on disconnect,"A recent commit addressing a runtime PM use-count regression, introduced a use-after-free by not making sure we held a reference to the struct usb_interface for the lifetime of the driver data.  ",7a759197974894213621aa65f0571b51904733d6,1
ALSA: line6: Perform sanity check for each URB creation,"LINE6 drivers create stream URBs with a fixed pipe without checking its validity, and this may lead to a kernel ",6e8a914ad619042c5f25a4feb663357c4170fd8d,1
bpf: don't accept cgroup local storage with zero value size,"Explicitly forbid creating cgroup local storage maps with zero value size, as it makes no sense and might even cause a panic.  ",b0584ea66d73919cbf5878a3420a837f06ab8396,0
ubi: fastmap: Don't produce the initial next anchor PEB when fastmap is disabled,"Following process triggers a memleak caused by forgetting to release the initial next anchor PEB (CONFIG_MTD_UBI_FASTMAP is disabled): 1. attach -> __erase_worker -> produce the initial next anchor PEB 2. detach -> ubi_fastmap_close (Do nothing, it should have released the    initial next anchor PEB)  Don't produce the initial next anchor PEB in __erase_worker() when fastmap is disabled.  ",3b185255bb2f34fa6927619b9ef27f192a3d9f5a,0
RDMA/ucma: Fix use-after-free access in ucma_close,The error in ucma_create_id() left ctx in the list of contexts belong to ucma file descriptor. The attempt to close this file descriptor causes to use-after-free accesses while iterating over such list.  ,ed65a4dc22083e73bac599ded6a262318cad7baf,1
fuse: truncate pagecache on atomic_o_trunc,"fuse_finish_open() will be called with FUSE_NOWRITE in case of atomic O_TRUNC.  This can deadlock with fuse_wait_on_page_writeback() in fuse_launder_page() triggered by invalidate_inode_pages2().  Fix by replacing invalidate_inode_pages2() in fuse_finish_open() with a truncate_pagecache() call.  This makes sense regardless of FOPEN_KEEP_CACHE or fc->writeback cache, so do it unconditionally.  ",76224355db7570cbe6b6f75c8929a1558828dd55,0
netfilter: nft_limit: avoid possible divide error in nft_limit_init,"div_u64() divides u64 by u32.  nft_limit_init() wants to divide u64 by u64, use the appropriate math function (div64_u64)  divide error: 0000 [#1] PREEMPT SMP KASAN CPU: 1 PID: 8390 Comm: syz-executor188 Not tainted 5.12.0-rc4-syzkaller #0 Hardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 01/01/2011 ",b895bdf5d643b6feb7c60856326dd4feb6981560,1
net/sched: annotate lockless accesses to qdisc->empty,"KCSAN reported the following race [1]  BUG: KCSAN: data-race in __dev_queue_xmit / net_tx_action  read to 0xffff8880ba403508 of 1 bytes by task 21814 on cpu 1:  __dev_xmit_skb net/core/dev.c:3389 [inline]  __dev_queue_xmit+0x9db/0x1b40 net/core/dev.c:3761  dev_queue_xmit+0x21/0x30 net/core/dev.c:3825  neigh_hh_output include/net/neighbour.h:500 [inline]  neigh_output include/net/neighbour.h:509 [inline]  ip6_finish_output2+0x873/0xec0 net/ipv6/ip6_output.c:116  __ip6_finish_output net/ipv6/ip6_output.c:142 [inline]  __ip6_finish_output+0x2d7/0x330 net/ipv6/ip6_output.c:127  ip6_finish_output+0x41/0x160 net/ipv6/ip6_output.c:152  NF_HOOK_COND include/linux/netfilter.h:294 [inline]  ip6_output+0xf2/0x280 net/ipv6/ip6_output.c:175  dst_output include/net/dst.h:436 [inline]  ip6_local_out+0x74/0x90 net/ipv6/output_core.c:179  ip6_send_skb+0x53/0x110 net/ipv6/ip6_output.c:1795  udp_v6_send_skb.isra.0+0x3ec/0xa70 net/ipv6/udp.c:1173  udpv6_sendmsg+0x1906/0x1c20 net/ipv6/udp.c:1471  inet6_sendmsg+0x6d/0x90 net/ipv6/af_inet6.c:576  sock_sendmsg_nosec net/socket.c:637 [inline]  sock_sendmsg+0x9f/0xc0 net/socket.c:657  ___sys_sendmsg+0x2b7/0x5d0 net/socket.c:2311  __sys_sendmmsg+0x123/0x350 net/socket.c:2413  __do_sys_sendmmsg net/socket.c:2442 [inline]  __se_sys_sendmmsg net/socket.c:2439 [inline]  __x64_sys_sendmmsg+0x64/0x80 net/socket.c:2439  do_syscall_64+0xcc/0x370 arch/x86/entry/common.c:290  entry_SYSCALL_64_after_hwframe+0x44/0xa9  write to 0xffff8880ba403508 of 1 bytes by interrupt on cpu 0:  qdisc_run_begin include/net/sch_generic.h:160 [inline]  qdisc_run include/net/pkt_sched.h:120 [inline]  net_tx_action+0x2b1/0x6c0 net/core/dev.c:4551  __do_softirq+0x115/0x33f kernel/softirq.c:292  do_softirq_own_stack+0x2a/0x40 arch/x86/entry/entry_64.S:1082  do_softirq.part.0+0x6b/0x80 kernel/softirq.c:337  do_softirq kernel/softirq.c:329 [inline]  __local_bh_enable_ip+0x76/0x80 kernel/softirq.c:189  local_bh_enable include/linux/bottom_half.h:32 [inline]  rcu_read_unlock_bh include/linux/rcupdate.h:688 [inline]  ip6_finish_output2+0x7bb/0xec0 net/ipv6/ip6_output.c:117  __ip6_finish_output net/ipv6/ip6_output.c:142 [inline]  __ip6_finish_output+0x2d7/0x330 net/ipv6/ip6_output.c:127  ip6_finish_output+0x41/0x160 net/ipv6/ip6_output.c:152  NF_HOOK_COND include/linux/netfilter.h:294 [inline]  ip6_output+0xf2/0x280 net/ipv6/ip6_output.c:175  dst_output include/net/dst.h:436 [inline]  ip6_local_out+0x74/0x90 net/ipv6/output_core.c:179  ip6_send_skb+0x53/0x110 net/ipv6/ip6_output.c:1795  udp_v6_send_skb.isra.0+0x3ec/0xa70 net/ipv6/udp.c:1173  udpv6_sendmsg+0x1906/0x1c20 net/ipv6/udp.c:1471  inet6_sendmsg+0x6d/0x90 net/ipv6/af_inet6.c:576  sock_sendmsg_nosec net/socket.c:637 [inline]  sock_sendmsg+0x9f/0xc0 net/socket.c:657  ___sys_sendmsg+0x2b7/0x5d0 net/socket.c:2311  __sys_sendmmsg+0x123/0x350 net/socket.c:2413  __do_sys_sendmmsg net/socket.c:2442 [inline]  __se_sys_sendmmsg net/socket.c:2439 [inline]  __x64_sys_sendmmsg+0x64/0x80 net/socket.c:2439  do_syscall_64+0xcc/0x370 arch/x86/entry/common.c:290  entry_SYSCALL_64_after_hwframe+0x44/0xa9  Reported by Kernel Concurrency Sanitizer on: CPU: 0 PID: 21817 Comm: syz-executor.2 Not tainted 5.4.0-rc6+ #0 Hardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 01/01/2011  ",90b2be27bb0e56483f335cc10fb59ec66882b949,1
bonding: fix using uninitialized mode_lock,"When a bonding interface is being created, it setups its mode and options. At that moment, it uses mode_lock so mode_lock should be initialized before that moment.  rtnl_newlink() 	rtnl_create_link() 		alloc_netdev_mqs() 			->setup() //bond_setup() 	->newlink //bond_newlink 		bond_changelink() 		register_netdevice() 			->ndo_init() //bond_init()  After commit 089bca2caed0 (""bonding: use dynamic lockdep key instead of subclass""), mode_lock is initialized in bond_init(). So in the bond_changelink(), un-initialized mode_lock can be used. mode_lock should be initialized in bond_setup(). This patch partially reverts commit 089bca2caed0 (""bonding: use dynamic lockdep key instead of subclass"")  Test command:     ip link add bond0 type bond mode 802.3ad lacp_rate 0  Splat looks like: ",ad9bd8daf2f9938572b0604e1280fefa8f338581,1
nfc: port100: handle command failure cleanly,"If starting the transfer of a command suceeds but the transfer for the reply fails, it is not enough to initiate killing the transfer for the command may still be running. You need to wait for the killing to finish before you can reuse URB and buffer.  ",5f9f0b11f0816b35867f2cf71e54d95f53f03902,0
drm/lease: fix WARNING in idr_destroy,drm_lease_create takes ownership of leases. And leases will be released by drm_master_put.  drm_master_put     ->drm_master_destroy             ->idr_destroy  So we needn't call idr_destroy again.  ,b216a8e7908cd750550c0480cf7d2b3a37f06954,0
ipv6: fix NULL dereference in ip6_route_dev_notify(),"Based on a syzkaller report [1], I found that a per cpu allocation failure in snmp6_alloc_dev() would then lead to NULL dereference in ip6_route_dev_notify().  It seems this is a very old bug, thus no Fixes tag in this submission.  Let's add in6_dev_put_clear() helper, as we will probably use it elsewhere (once available/present in net-next)  [1] kasan: CONFIG_KASAN_INLINE enabled kasan: GPF could be caused by NULL-ptr deref or user memory access general protection fault: 0000 [#1] SMP KASAN Dumping ftrace buffer:    (ftrace buffer empty) ",12d94a804946af291e24b80fc53ec86264765781,1
nilfs2: fix memory leak in nilfs_sysfs_delete_device_group,"My local syzbot instance hit memory leak in nilfs2.  The problem was in missing kobject_put() in nilfs_sysfs_delete_device_group().  kobject_del() does not call kobject_cleanup() for passed kobject and it leads to leaking duped kobject name if kobject_put() was not called.  Fail log:    BUG: memory leak   unreferenced object 0xffff8880596171e0 (size 8):   comm ""syz-executor379"", pid 8381, jiffies 4294980258 (age 21.100s)   ",8fd0c1b0647a6bda4067ee0cd61e8395954b6f28,1
crypto: api - Fix use-after-free and race in crypto_spawn_alg,"There are two problems in crypto_spawn_alg.  First of all it may return spawn->alg even if spawn->dead is set.  This results in a double-free as detected by syzbot.  Secondly the setting of the DYING flag is racy because we hold the read-lock instead of the write-lock.  We should instead call crypto_shoot_alg in a safe manner by gaining a refcount, dropping the lock, and then releasing the refcount.  This patch fixes both problems.  ",6603523bf5e432c7c8490fb500793bb15d4e5f61,1
can: af_can: prevent potential access of uninitialized member in can_rcv(),"In can_rcv(), cfd->len is uninitialized when skb->len = 0, and this uninitialized cfd->len is accessed nonetheless by pr_warn_once().  Fix this uninitialized variable access by checking cfd->len's validity condition (cfd->len > CAN_MAX_DLEN) separately after the skb->len's condition is checked, and appropriately modify the log messages that are generated as well. In case either of the required conditions fail, the skb is freed and NET_RX_DROP is returned, same as before.  ",c8c958a58fc67f353289986850a0edf553435702,1
net/smc: do not schedule tx_work in SMC_CLOSED state,The setsockopts options TCP_NODELAY and TCP_CORK may schedule the tx worker. Make sure the socket is not yet moved into SMC_CLOSED state (for instance by a shutdown SHUT_RDWR call).  ,f9cedf1a9b1cdcfb0c52edb391d01771e43994a4,0
ext4: always initialize the crc32c checksum driver,"The extended attribute code now uses the crc32c checksum for hashing purposes, so we should just always always initialize it.  We also want to prevent NULL pointer dereferences if one of the metadata checksum features is enabled after the file sytsem is originally mounted.  This issue has been assigned CVE-2018-1094.  https://bugzilla.kernel.org/show_bug.cgi?id=199183 https://bugzilla.redhat.com/show_bug.cgi?id=1560788  ",a45403b51582a87872927a3e0fc0a389c26867f1,1
net/packet: annotate accesses to po->bind,"tpacket_snd(), packet_snd(), packet_getname() and packet_seq_show() can read po->num without holding a lock. This means other threads can change po->num at the same time.  KCSAN complained about this known fact [1] Add READ_ONCE()/WRITE_ONCE() to address the issue.  [1] BUG: KCSAN: data-race in packet_do_bind / packet_sendmsg  write to 0xffff888131a0dcc0 of 2 bytes by task 24714 on cpu 0:  packet_do_bind+0x3ab/0x7e0 net/packet/af_packet.c:3181  packet_bind+0xc3/0xd0 net/packet/af_packet.c:3255  __sys_bind+0x200/0x290 net/socket.c:1637  __do_sys_bind net/socket.c:1648 [inline]  __se_sys_bind net/socket.c:1646 [inline]  __x64_sys_bind+0x3d/0x50 net/socket.c:1646  do_syscall_64+0x4a/0x90 arch/x86/entry/common.c:47  entry_SYSCALL_64_after_hwframe+0x44/0xae  read to 0xffff888131a0dcc0 of 2 bytes by task 24719 on cpu 1:  packet_snd net/packet/af_packet.c:2899 [inline]  packet_sendmsg+0x317/0x3570 net/packet/af_packet.c:3040  sock_sendmsg_nosec net/socket.c:654 [inline]  sock_sendmsg net/socket.c:674 [inline]  ____sys_sendmsg+0x360/0x4d0 net/socket.c:2350  ___sys_sendmsg net/socket.c:2404 [inline]  __sys_sendmsg+0x1ed/0x270 net/socket.c:2433  __do_sys_sendmsg net/socket.c:2442 [inline]  __se_sys_sendmsg net/socket.c:2440 [inline]  __x64_sys_sendmsg+0x42/0x50 net/socket.c:2440  do_syscall_64+0x4a/0x90 arch/x86/entry/common.c:47  entry_SYSCALL_64_after_hwframe+0x44/0xae  value changed: 0x0000 -> 0x1200  Reported by Kernel Concurrency Sanitizer on: CPU: 1 PID: 24719 Comm: syz-executor.5 Not tainted 5.13.0-rc4-syzkaller #0 Hardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 01/01/2011  ",c7d2ef5dd4b03ed0ee1d13bc0c55f9cf62d49bd6,1
af_key: fix leaks in key_pol_get_resp and dump_sp.,"In both functions, if pfkey_xfrm_policy2msg failed we leaked the newly allocated sk_buff.  Free it on error.  ",7c80eb1c7e2b8420477fbc998971d62a648035d9,0
"Revert ""KVM: x86: Open code necessary bits of kvm_lapic_set_base() at vCPU RESET""","Revert a change to open code bits of kvm_lapic_set_base() when emulating APIC RESET to fix an apic_hw_disabled underflow bug due to arch.apic_base and apic_hw_disabled being unsyncrhonized when the APIC is created.  If kvm_arch_vcpu_create() fails after creating the APIC, kvm_free_lapic() will see the initialized-to-zero vcpu->arch.apic_base and decrement apic_hw_disabled without KVM ever having incremented apic_hw_disabled.  Using kvm_lapic_set_base() in kvm_lapic_reset() is also desirable for a potential future where KVM supports RESET outside of vCPU creation, in which case all the side effects of kvm_lapic_set_base() are needed, e.g. to handle the transition from x2APIC => xAPIC.  Alternatively, KVM could temporarily increment apic_hw_disabled (and call kvm_lapic_set_base() at RESET), but that's a waste of cycles and would impact the performance of other vCPUs and VMs.  The other subtle side effect is that updating the xAPIC ID needs to be done at RESET regardless of whether the APIC was previously enabled, i.e. kvm_lapic_reset() needs an explicit call to kvm_apic_set_xapic_id() regardless of whether or not kvm_lapic_set_base() also performs the update.  That makes stuffing the enable bit at vCPU creation slightly more palatable, as doing so affects only the apic_hw_disabled key.  Opportunistically tweak the comment to explicitly call out the connection between vcpu->arch.apic_base and apic_hw_disabled, and add a comment to call out the need to always do kvm_apic_set_xapic_id() at RESET.  Underflow scenario:    kvm_vm_ioctl() {     kvm_vm_ioctl_create_vcpu() {       kvm_arch_vcpu_create() {         if (something_went_wrong)           goto fail_free_lapic;         ",f7d8a19f9a056a05c5c509fa65af472a322abfee,1
net/x25: fix use-after-free in x25_device_event(),"In case of failure x25_connect() does a x25_neigh_put(x25->neighbour) but forgets to clear x25->neighbour pointer, thus triggering use-after-free.  Since the socket is visible in x25_list, we need to hold x25_list_lock to protect the operation.  syzbot report :  BUG: KASAN: use-after-free in x25_kill_by_device net/x25/af_x25.c:217 [inline] BUG: KASAN: use-after-free in x25_device_event+0x296/0x2b0 net/x25/af_x25.c:252 Read of size 8 at addr ffff8880a030edd0 by task syz-executor003/7854  CPU: 0 PID: 7854 Comm: syz-executor003 Not tainted 5.0.0+ #97 Hardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 01/01/2011 Call Trace:  __dump_stack lib/dump_stack.c:77 [inline]  dump_stack+0x172/0x1f0 lib/dump_stack.c:113  print_address_description.cold+0x7c/0x20d mm/kasan/report.c:187  kasan_report.cold+0x1b/0x40 mm/kasan/report.c:317  __asan_report_load8_noabort+0x14/0x20 mm/kasan/generic_report.c:135  x25_kill_by_device net/x25/af_x25.c:217 [inline]  x25_device_event+0x296/0x2b0 net/x25/af_x25.c:252  notifier_call_chain+0xc7/0x240 kernel/notifier.c:93  __raw_notifier_call_chain kernel/notifier.c:394 [inline]  raw_notifier_call_chain+0x2e/0x40 kernel/notifier.c:401  call_netdevice_notifiers_info+0x3f/0x90 net/core/dev.c:1739  call_netdevice_notifiers_extack net/core/dev.c:1751 [inline]  call_netdevice_notifiers net/core/dev.c:1765 [inline]  __dev_notify_flags+0x1e9/0x2c0 net/core/dev.c:7607  dev_change_flags+0x10d/0x170 net/core/dev.c:7643  dev_ifsioc+0x2b0/0x940 net/core/dev_ioctl.c:237  dev_ioctl+0x1b8/0xc70 net/core/dev_ioctl.c:488  sock_do_ioctl+0x1bd/0x300 net/socket.c:995  sock_ioctl+0x32b/0x610 net/socket.c:1096  vfs_ioctl fs/ioctl.c:46 [inline]  file_ioctl fs/ioctl.c:509 [inline]  do_vfs_ioctl+0xd6e/0x1390 fs/ioctl.c:696  ksys_ioctl+0xab/0xd0 fs/ioctl.c:713  __do_sys_ioctl fs/ioctl.c:720 [inline]  __se_sys_ioctl fs/ioctl.c:718 [inline]  __x64_sys_ioctl+0x73/0xb0 fs/ioctl.c:718  do_syscall_64+0x103/0x610 arch/x86/entry/common.c:290  entry_SYSCALL_64_after_hwframe+0x49/0xbe ",95d6ebd53c79522bf9502dbc7e89e0d63f94dae4,1
mm: drop hotplug lock from lru_add_drain_all(),"Pulling cpu hotplug locks inside the mm core function like lru_add_drain_all just asks for problems and the recent lockdep splat [1] just proves this.  While the usage in that particular case might be wrong we should avoid the locking as lru_add_drain_all() is used in many places.  It seems that this is not all that hard to achieve actually.  We have done the same thing for drain_all_pages which is analogous by commit a459eeb7b852 (""mm, page_alloc: do not depend on cpu hotplug locks inside the allocator"").  All we have to care about is to handle        - the work item might be executed on a different cpu in worker from         unbound pool so it doesn't run on pinned on the cpu        - we have to make sure that we do not race with page_alloc_cpu_dead         calling lru_add_drain_cpu  the first part is already handled because the worker calls lru_add_drain which disables preemption when calling lru_add_drain_cpu on the local cpu it is draining.  The later is true because page_alloc_cpu_dead is called on the controlling CPU after the hotplugged CPU vanished completely.  [1] http://lkml.kernel.org/r/089e0825eec8955c1f055c83d476@google.com  [add a cpu hotplug locking interaction as per tglx] ",9852a7212324fd25f896932f4f4607ce47b0a22f,1
jffs2: Fix NULL pointer dereference in rp_size fs option parsing,"syzkaller found the following JFFS2 splat:    Unable to handle kernel paging request at virtual address dfffa00000000001   Mem abort info:     ESR = 0x96000004     EC = 0x25: DABT (current EL), IL = 32 bits     SET = 0, FnV = 0     EA = 0, S1PTW = 0   Data abort info:     ISV = 0, ISS = 0x00000004     CM = 0, WnR = 0   [dfffa00000000001] address between user and kernel address ranges   Internal error: Oops: 96000004 [#1] SMP   Dumping ftrace buffer:      (ftrace buffer empty)   ",a61df3c413e49b0042f9caf774c58512d1cc71b7,1
HID: uhid: forbid UHID_CREATE under KERNEL_DS or elevated privileges,"When a UHID_CREATE command is written to the uhid char device, a copy_from_user() is done from a user pointer embedded in the command. When the address limit is KERNEL_DS, e.g. as is the case during sys_sendfile(), this can read from kernel memory.  Alternatively, information can be leaked from a setuid binary that is tricked to write to the file descriptor.  Therefore, forbid UHID_CREATE in these cases.  No other commands in uhid_char_write() are affected by this bug and UHID_CREATE is marked as ""obsolete"", so apply the restriction to UHID_CREATE only rather than to uhid_char_write() entirely.  ",8c01db7619f07c85c5cd81ec5eb83608b56c88f5,0
sctp: fix refcount bug in sctp_wfree,"We should iterate over the datamsgs to move all chunks(skbs) to newsk.  The following case cause the bug: for the trouble SKB, it was in outq->transmitted list  sctp_outq_sack         sctp_check_transmitted                 SKB was moved to outq->sacked list         then throw away the sack queue                 SKB was deleted from outq->sacked (but it was held by datamsg at sctp_datamsg_to_asoc So, sctp_wfree was not called here)  then migrate happened          sctp_for_each_tx_datachunk(         sctp_clear_owner_w);         sctp_assoc_migrate();         sctp_for_each_tx_datachunk(         sctp_set_owner_w); SKB was not in the outq, and was not changed to newsk  finally  __sctp_outq_teardown         sctp_chunk_put (for another skb)                 sctp_datamsg_put                         __kfree_skb(msg->frag_list)                                 sctp_wfree (for SKB) 	SKB->sk was still oldsk (skb->sk != asoc->base.sk).  ",5c3e82fe159622e46e91458c1a6509c321a62820,0
Bluetooth: hci_ldisc: Initialize hci_dev before open(),"The hci_dev struct hdev is referenced in work queues and timers started by open() in some protocols. This creates a race between the initialization function and the work or timer which can result hdev being dereferenced while it is still null.  The syzbot report contains a reliable reproducer which causes a null pointer dereference of hdev in hci_uart_write_work() by making the memory allocation for hdev fail.  To fix this, ensure hdev is valid from before calling a protocol's open() until after calling a protocol's close().  ",32a7b4cbe93b0a0ef7e63d31ca69ce54736c4412,1
Input: synaptics - avoid using uninitialized variable when probing,synaptics_detect() does not check whether sending commands to the device succeeds and instead relies on getting unique data from the device. Let's make sure we seed entire buffer with zeroes to make sure we will not use garbage on stack that just happen to be 0x47.  ,f39f8688888ae74fa8deae2d01289b69b4727394,1
tipc: fix bug on error path in tipc_topsrv_kern_subscr(),"In commit cc1ea9ffadf7 (""tipc: eliminate struct tipc_subscriber"") we re-introduced an old bug on the error path in the function tipc_topsrv_kern_subscr(). We now re-introduce the correction too.  ",96c252bf1c5c6d7e2dac3dea42f3f0a9c939d20e,0
afs: Fix rapid cell addition/removal by not using RCU on cells tree,"There are a number of problems that are being seen by the rapidly mounting and unmounting an afs dynamic root with an explicit cell and volume specified (which should probably be rejected, but that's a separate issue):  What the tests are doing is to look up/create a cell record for the name given and then tear it down again without actually using it to try to talk to a server.  This is repeated endlessly, very fast, and the new cell collides with the old one if it's not quick enough to reuse it.  It appears (as suggested by Hillf Danton) that the search through the RB tree under a read_seqbegin_or_lock() under RCU conditions isn't safe and that it's not blocking the write_seqlock(), despite taking two passes at it.  He suggested that the code should take a ref on the cell it's attempting to look at - but this shouldn't be necessary until we've compared the cell names.  It's possible that I'm missing a barrier somewhere.  However, using an RCU search for this is overkill, really - we only need to access the cell name in a few places, and they're places where we're may end up sleeping anyway.  Fix this by switching to an R/W semaphore instead.  Additionally, draw the down_read() call inside the function (renamed to afs_find_cell()) since all the callers were taking the RCU read lock (or should've been[*]).  [*] afs_probe_cell_name() should have been, but that doesn't appear to be involved in the bug reports.  The symptoms of this look like:  	general protection fault, probably for non-canonical address 0xf27d208691691fdb: 0000 [#1] PREEMPT SMP KASAN 	KASAN: maybe wild-memory-access in range [0x93e924348b48fed8-0x93e924348b48fedf] 	... 	",92e3cc91d8f51ce64a8b7c696377180953dd316e,1
netfilter: xt_RATEEST: acquire xt_rateest_mutex for hash insert,"rateest_hash is supposed to be protected by xt_rateest_mutex, and, as suggested by Eric, lookup and insert should be atomic, so we should acquire the xt_rateest_mutex once for both.  So introduce a non-locking helper for internal use and keep the locking one for external.  ",7dc68e98757a8eccf8ca7a53a29b896f1eef1f76,0
mac80211_hwsim: check that n_limits makes sense,"Under certain circumstances, radios created via netlink could have n_limits be zero and no possible interface types, which makes no sense. Reject this early to prevent a WARN_ON() in cfg80211.  ",9c5d3afac436beef91b7a6312068e9360c7d8446,0
ipv6: do not leave garbage in rt->fib6_metrics,"In case ip_fib_metrics_init() returns an error, we better rewrite rt->fib6_metrics with &dst_default_metrics so that we do not crash later in ip_fib_metrics_put()  ",fda21d46cce2879dbce981978f8cb07b36035369,1
net: qrtr: Fix memory leak on qrtr_tx_wait failure,"qrtr_tx_wait does not check for radix_tree_insert failure, causing the 'flow' object to be unreferenced after qrtr_tx_wait return. Fix that by releasing flow on radix_tree_insert failure.  ",8a03dd925786bdc3834d56ccc980bb70668efa35,1
RDMA/ucma: Correct option size check using optlen,"The option size check is using optval instead of optlen causing the set option call to fail. Use the correct field, optlen, for size check.  ",5f3e3b85cc0a5eae1c46d72e47d3de7bf208d9e2,0
scsi: bsg: Fix device unregistration,"device_initialize() is used to take a refcount on the device. However, put_device() is not called during device teardown. This leads to a leak of private data of the driver core, dev_name(), etc. This is reported by kmemleak at boot time if we compile kernel with DEBUG_TEST_DRIVER_REMOVE.  Fix memory leaks during unregistration and implement a release function.  ",1a0db7744e453844aa2db3f2959aea4a378025ea,1
Bluetooth: Set CONF_NOT_COMPLETE as l2cap_chan default,"Currently l2cap_chan_set_defaults() reset chan->conf_state to zero. However, there is a flag CONF_NOT_COMPLETE which is set when creating the l2cap_chan. It is suggested that the flag should be cleared when l2cap_chan is ready, but when l2cap_chan_set_defaults() is called, l2cap_chan is not yet ready. Therefore, we must set this flag as the default.  Example crash call trace: __dump_stack lib/dump_stack.c:15 [inline] dump_stack+0xc4/0x118 lib/dump_stack.c:56 panic+0x1c6/0x38b kernel/panic.c:117 __warn+0x170/0x1b9 kernel/panic.c:471 warn_slowpath_fmt+0xc7/0xf8 kernel/panic.c:494 debug_print_object+0x175/0x193 lib/debugobjects.c:260 debug_object_assert_init+0x171/0x1bf lib/debugobjects.c:614 debug_timer_assert_init kernel/time/timer.c:629 [inline] debug_assert_init kernel/time/timer.c:677 [inline] del_timer+0x7c/0x179 kernel/time/timer.c:1034 try_to_grab_pending+0x81/0x2e5 kernel/workqueue.c:1230 cancel_delayed_work+0x7c/0x1c4 kernel/workqueue.c:2929 l2cap_clear_timer+0x1e/0x41 include/net/bluetooth/l2cap.h:834 l2cap_chan_del+0x2d8/0x37e net/bluetooth/l2cap_core.c:640 l2cap_chan_close+0x532/0x5d8 net/bluetooth/l2cap_core.c:756 l2cap_sock_shutdown+0x806/0x969 net/bluetooth/l2cap_sock.c:1174 l2cap_sock_release+0x64/0x14d net/bluetooth/l2cap_sock.c:1217 __sock_release+0xda/0x217 net/socket.c:580 sock_close+0x1b/0x1f net/socket.c:1039 __fput+0x322/0x55c fs/file_table.c:208 ____fput+0x17/0x19 fs/file_table.c:244 task_work_run+0x19b/0x1d3 kernel/task_work.c:115 exit_task_work include/linux/task_work.h:21 [inline] do_exit+0xe4c/0x204a kernel/exit.c:766 do_group_exit+0x291/0x291 kernel/exit.c:891 get_signal+0x749/0x1093 kernel/signal.c:2396 do_signal+0xa5/0xcdb arch/x86/kernel/signal.c:737 exit_to_usermode_loop arch/x86/entry/common.c:243 [inline] prepare_exit_to_usermode+0xed/0x235 arch/x86/entry/common.c:277 syscall_return_slowpath+0x3a7/0x3b3 arch/x86/entry/common.c:348 int_ret_from_sys_call+0x25/0xa3  ",3a9d54b1947ecea8eea9a902c0b7eb58a98add8a,1
"perf/core: Fix another perf,trace,cpuhp lock inversion",Lockdep noticed the following 3-way lockup race:          perf_trace_init()  #0       mutex_lock(&event_mutex)           perf_trace_event_init()             perf_trace_event_reg()               tp_event->class->reg() := tracepoint_probe_register  #1              mutex_lock(&tracepoints_mutex)                   trace_point_add_func()  #2                  static_key_enable()   #2	do_cpu_up() 	  perf_event_init_cpu()  #3	    mutex_lock(&pmus_lock)  #4	    mutex_lock(&ctx->mutex)  	perf_ioctl()  #4	  ctx = perf_event_ctx_lock() 	  _perf_iotcl() 	    ftrace_profile_set_filter()  #0	      mutex_lock(&event_mutex)  Fudge it for now by noting that the tracepoint state does not depend on the event <-> context relation. Ugly though :/  ,43fa87f7deed52e8c8420182e0c133bc4cf395f6,1
io_uring: Fix memory leak in io_sqe_buffers_register(),"unreferenced object 0xffff8881123bf0a0 (size 32): comm ""syz-executor557"", pid 8384, jiffies 4294946143 (age 12.360s) backtrace: [<ffffffff81469b71>] kmalloc_node include/linux/slab.h:579 [inline] [<ffffffff81469b71>] kvmalloc_node+0x61/0xf0 mm/util.c:587 [<ffffffff815f0b3f>] kvmalloc include/linux/mm.h:795 [inline] [<ffffffff815f0b3f>] kvmalloc_array include/linux/mm.h:813 [inline] [<ffffffff815f0b3f>] kvcalloc include/linux/mm.h:818 [inline] [<ffffffff815f0b3f>] io_rsrc_data_alloc+0x4f/0xc0 fs/io_uring.c:7164 [<ffffffff815f26d8>] io_sqe_buffers_register+0x98/0x3d0 fs/io_uring.c:8383 [<ffffffff815f84a7>] __io_uring_register+0xf67/0x18c0 fs/io_uring.c:9986 [<ffffffff81609222>] __do_sys_io_uring_register fs/io_uring.c:10091 [inline] [<ffffffff81609222>] __se_sys_io_uring_register fs/io_uring.c:10071 [inline] [<ffffffff81609222>] __x64_sys_io_uring_register+0x112/0x230 fs/io_uring.c:10071 [<ffffffff842f616a>] do_syscall_64+0x3a/0xb0 arch/x86/entry/common.c:47 [<ffffffff84400068>] entry_SYSCALL_64_after_hwframe+0x44/0xae  Fix data->tags memory leak, through io_rsrc_data_free() to release data memory space.  ",bb6659cc0ad3c2afc3801b708b19c4c67e55ddf2,1
blk-cgroup: blk_cgroup_bio_start() should use irq-safe operations on blkg->iostat_cpu,"c3df5fb57fe8 (""cgroup: rstat: fix A-A deadlock on 32bit around u64_stats_sync"") made u64_stats updates irq-safe to avoid A-A deadlocks. Unfortunately, the conversion missed one in blk_cgroup_bio_start(). Fix it.  ",3c08b0931eedd04c530040499fadeccab50ed646,0
block: remove REQ_NOWAIT_INLINE,"We had a few issues with this code, and there's still a problem around how we deal with error handling for chained/split bios. For now, just revert the code and we'll try again with a thoroug solution. This reverts commits:  e15c2ffa1091 (""block: fix O_DIRECT error handling for bio fragments"") 0eb6ddfb865c (""block: Fix __blkdev_direct_IO() for bio fragments"") 6a43074e2f46 (""block: properly handle IOCB_NOWAIT for async O_DIRECT IO"") 893a1c97205a (""blk-mq: allow REQ_NOWAIT to return an error inline"")  ",7b6620d7db566a46f49b4b9deab9fa061fd4b59b,1
wireguard: noise: reject peers with low order public keys,"Our static-static calculation returns a failure if the public key is of low order. We check for this when peers are added, and don't allow them to be added if they're low order, except in the case where we haven't yet been given a private key. In that case, we would defer the removal of the peer until we're given a private key, since at that point we're doing new static-static calculations which incur failures we can act on. This meant, however, that we wound up removing peers rather late in the configuration flow.  Syzkaller points out that peer_remove calls flush_workqueue, which in turn might then wait for sending a handshake initiation to complete. Since handshake initiation needs the static identity lock, holding the static identity lock while calling peer_remove can result in a rare deadlock. We have precisely this case in this situation of late-stage peer removal based on an invalid public key. We can't drop the lock when removing, because then incoming handshakes might interact with a bogus static-static calculation.  While the band-aid patch for this would involve breaking up the peer removal into two steps like wg_peer_remove_all does, in order to solve the locking issue, there's actually a much more elegant way of fixing this:  If the static-static calculation succeeds with one private key, it *must* succeed with all others, because all 32-byte strings map to valid private keys, thanks to clamping. That means we can get rid of this silly dance and locking headaches of removing peers late in the configuration flow, and instead just reject them early on, regardless of whether the device has yet been assigned a private key. For the case where the device doesn't yet have a private key, we safely use zeros just for the purposes of checking for low order points by way of checking the output of the calculation.  The following PoC will trigger the deadlock:  ip link add wg0 type wireguard ip addr add 10.0.0.1/24 dev wg0 ip link set wg0 up ping -f 10.0.0.2 & while true; do         wg set wg0 private-key /dev/null peer AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA= allowed-ips 10.0.0.0/24 endpoint 10.0.0.3:1234         wg set wg0 private-key <(echo AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA=) done  ",ec31c2676a10e064878927b243fada8c2fb0c03c,0
"vt: selection, close sel_buffer race","syzkaller reported this UAF: BUG: KASAN: use-after-free in n_tty_receive_buf_common+0x2481/0x2940 drivers/tty/n_tty.c:1741 Read of size 1 at addr ffff8880089e40e9 by task syz-executor.1/13184  CPU: 0 PID: 13184 Comm: syz-executor.1 Not tainted 5.4.7 #1 Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS 1.12.0-1 04/01/2014 Call Trace: ...  kasan_report+0xe/0x20 mm/kasan/common.c:634  n_tty_receive_buf_common+0x2481/0x2940 drivers/tty/n_tty.c:1741  tty_ldisc_receive_buf+0xac/0x190 drivers/tty/tty_buffer.c:461  paste_selection+0x297/0x400 drivers/tty/vt/selection.c:372  tioclinux+0x20d/0x4e0 drivers/tty/vt/vt.c:3044  vt_ioctl+0x1bcf/0x28d0 drivers/tty/vt/vt_ioctl.c:364  tty_ioctl+0x525/0x15a0 drivers/tty/tty_io.c:2657  vfs_ioctl fs/ioctl.c:47 [inline]  It is due to a race between parallel paste_selection (TIOCL_PASTESEL) and set_selection_user (TIOCL_SETSEL) invocations. One uses sel_buffer, while the other frees it and reallocates a new one for another selection. Add a mutex to close this race.  The mutex takes care properly of sel_buffer and sel_buffer_lth only. The other selection global variables (like sel_start, sel_end, and sel_cons) are protected only in set_selection_user. The other functions need quite some more work to close the races of the variables there. This is going to happen later.  This likely fixes (I am unsure as there is no reproducer provided) bug 206361 too. It was marked as CVE-2020-8648.  ",07e6124a1a46b4b5a9b3cacc0c306b50da87abf5,1
HID: sony: Fix memory corruption issue on cleanup.,"The sony driver is not properly cleaning up from potential failures in sony_input_configured. Currently it calls hid_hw_stop, while hid_connect is still running. This is not a good idea, instead hid_hw_stop should be moved to sony_probe. Similar changes were recently made to Logitech drivers, which were also doing improper cleanup.  ",2bcdacb70327013ca2066bfcf2af1009eff01f1d,1
padata: fix possible padata_works_lock deadlock,"syzbot reports,    ",1b0df11fde0f14a269a181b3b7f5122415bc5ed7,0
tipc: fix use-after-free in tipc_sk_filter_rcv,"skb free-ed in:   1/ condition 1: tipc_sk_filter_rcv -> tipc_sk_proto_rcv   2/ condition 2: tipc_sk_filter_rcv -> tipc_group_filter_msg This leads to a ""use-after-free"" access in the next condition.  We fix this by intializing the variable at declaration, then it is safe to check this variable to continue processing if condition matches.  syzbot report:  ",77d5ad4048fba5bd6e16f78498d4b41e5534b8f5,1
net: core: don't call SIOCBRADD/DELIF for non-bridge devices,"Commit ad2f99aedf8f (""net: bridge: move bridge ioctls out of .ndo_do_ioctl"") changed SIOCBRADD/DELIF to use bridge's ioctl hook (br_ioctl_hook) without checking if the target netdevice is actually a bridge which can cause crashes and generally interpreting other devices' private pointers as net_bridge pointers.  Crash example (lo - loopback): $ brctl addif lo ens16  BUG: kernel NULL pointer dereference, ",9384eacd80f3da8d05fd17073eafd1f7fef80b26,1
locking/lockdep: Fix possible NULL deref,We can't invalidate xhlocks when we've not yet allocated any.  ,5e351ad106997e06b2dc3da9c6b939b95f67fb88,0
rcu-tasks: Simplify trc_read_check_handler() atomic operations,"Currently, trc_wait_for_one_reader() atomically increments the trc_n_readers_need_end counter before sending the IPI invoking trc_read_check_handler().  All failure paths out of trc_read_check_handler() and also from the smp_call_function_single() within trc_wait_for_one_reader() must carefully atomically decrement this counter.  This is more complex than it needs to be.  This commit therefore simplifies things and saves a few lines of code by dispensing with the atomic decrements in favor of having trc_read_check_handler() do the atomic increment only in the success case. In theory, this represents no change in functionality.  ",96017bf9039763a2e02dcc6adaa18592cd73a39d,0
netlink: Fix nlmsg_parse as a wrapper for strict message parsing,"Eric reported a syzbot warning:  BUG: KMSAN: uninit-value in nh_valid_get_del_req+0x6f1/0x8c0 net/ipv4/nexthop.c:1510 CPU: 0 PID: 11812 Comm: syz-executor444 Not tainted 5.3.0-rc3+ #17 Hardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 01/01/2011 Call Trace:  __dump_stack lib/dump_stack.c:77 [inline]  dump_stack+0x191/0x1f0 lib/dump_stack.c:113  kmsan_report+0x162/0x2d0 mm/kmsan/kmsan_report.c:109  __msan_warning+0x75/0xe0 mm/kmsan/kmsan_instr.c:294  nh_valid_get_del_req+0x6f1/0x8c0 net/ipv4/nexthop.c:1510  rtm_del_nexthop+0x1b1/0x610 net/ipv4/nexthop.c:1543  rtnetlink_rcv_msg+0x115a/0x1580 net/core/rtnetlink.c:5223  netlink_rcv_skb+0x431/0x620 net/netlink/af_netlink.c:2477  rtnetlink_rcv+0x50/0x60 net/core/rtnetlink.c:5241  netlink_unicast_kernel net/netlink/af_netlink.c:1302 [inline]  netlink_unicast+0xf6c/0x1050 net/netlink/af_netlink.c:1328  netlink_sendmsg+0x110f/0x1330 net/netlink/af_netlink.c:1917  sock_sendmsg_nosec net/socket.c:637 [inline]  sock_sendmsg net/socket.c:657 [inline]  ___sys_sendmsg+0x14ff/0x1590 net/socket.c:2311  __sys_sendmmsg+0x53a/0xae0 net/socket.c:2413  __do_sys_sendmmsg net/socket.c:2442 [inline]  __se_sys_sendmmsg+0xbd/0xe0 net/socket.c:2439  __x64_sys_sendmmsg+0x56/0x70 net/socket.c:2439  do_syscall_64+0xbc/0xf0 arch/x86/entry/common.c:297  entry_SYSCALL_64_after_hwframe+0x63/0xe7  The root cause is nlmsg_parse calling __nla_parse which means the header struct size is not checked.  nlmsg_parse should be a wrapper around __nlmsg_parse with NL_VALIDATE_STRICT for the validate argument very much like nlmsg_parse_deprecated is for NL_VALIDATE_LIBERAL.  ",d00ee64e1dcf09b3afefd1340f3e9eb637272714,1
ipv6: the entire IPv6 header chain must fit the first fragment,"While building ipv6 datagram we currently allow arbitrary large extheaders, even beyond pmtu size. The syzbot has found a way to exploit the above to trigger the following splat:  kernel BUG at ./include/linux/skbuff.h:2073! invalid opcode: 0000 [#1] SMP KASAN Dumping ftrace buffer:     (ftrace buffer empty) ",10b8a3de603df7b96004179b1b33b1708c76d144,1
Uprobes: Fix kernel oops with delayed_uprobe_remove(),There could be a race between task exit and probe unregister:    exit_mm()   mmput()   __mmput()                     uprobe_unregister()   uprobe_clear_state()          put_uprobe()   delayed_uprobe_remove()       delayed_uprobe_remove()  put_uprobe() is calling delayed_uprobe_remove() without taking delayed_uprobe_lock and thus the race sometimes results in a kernel crash. Fix this by taking delayed_uprobe_lock before calling delayed_uprobe_remove() from put_uprobe().  Detailed crash log can be found at:     ,1aed58e67a6ec1e7a18bfabe8ba6ec2d27c15636,1
HID: usbhid: Fix race between usbhid_close() and usbhid_stop(),"The syzbot fuzzer discovered a bad race between in the usbhid driver between usbhid_stop() and usbhid_close().  In particular, usbhid_stop() does:  	usb_free_urb(usbhid->urbin); 	... 	usbhid->urbin = NULL; ",0ed08faded1da03eb3def61502b27f81aef2e615,1
net/ipv6: fix LOCKDEP issue in rt6_remove_exception_rt(),"rt6_remove_exception_rt() is called under rcu_read_lock() only.  We lock rt6_exception_lock a bit later, so we do not hold rt6_exception_lock yet.  ",091311debcf02ff80a76d70b524eba4b2ffe66f1,0
net: qrtr: ns: Protect radix_tree_deref_slot() using rcu read locks,The rcu read locks are needed to avoid potential race condition while dereferencing radix tree from multiple threads. The issue was identified by syzbot. Below is the crash report:  ,a7809ff90ce6c48598d3c4ab54eb599bec1e9c42,1
netfilter: bridge: stp fix reference to uninitialized data,The destination mac (destmac) is only valid if EBT_DESTMAC flag is set. Fix by changing the order of the comparison to look for the flag first.  ,a4995684a949cc1d28fbf09900c47c34b9427ecf,1
net/tls: free the record on encryption error,"When tls_do_encryption() fails the SG lists are left with the SG_END and SG_CHAIN marks in place. One could hope that once encryption fails we will never see the record again, but that is in fact not true. Commit d3b18ad31f93 (""tls: add bpf support to sk_msg handling"") added special handling to ENOMEM and ENOSPC errors which mean we may see the same record re-submitted.  As suggested by John free the record, the BPF code is already doing just that.  ",d10523d0b3d78153ee58d19853ced26c9004c8c4,1
USB: core: Fix races in character device registration and deregistraion,"The syzbot fuzzer has found two (!) races in the USB character device registration and deregistration routines.  This patch fixes the races.  The first race results from the fact that usb_deregister_dev() sets usb_minors[intf->minor] to NULL before calling device_destroy() on the class device.  This leaves a window during which another thread can allocate the same minor number but will encounter a duplicate name error when it tries to register its own class device.  A typical error message in the system log would look like:      sysfs: cannot create duplicate filename '/class/usbmisc/ldusb0'  The patch fixes this race by destroying the class device first.  The second race is in usb_register_dev().  When that routine runs, it first allocates a minor number, then drops minor_rwsem, and then creates the class device.  If the device creation fails, the minor number is deallocated and the whole routine returns an error.  But during the time while minor_rwsem was dropped, there is a window in which the minor number is allocated and so another thread can successfully open the device file.  Typically this results in use-after-free errors or invalid accesses when the other thread closes its open file reference, because the kernel then tries to release resources that were already deallocated when usb_register_dev() failed.  The patch fixes this race by keeping minor_rwsem locked throughout the entire routine.  ",303911cfc5b95d33687d9046133ff184cf5043ff,1
io_uring: hold 'ctx' reference around task_work queue + execute,"We're holding the request reference, but we need to go one higher to ensure that the ctx remains valid after the request has finished. If the ring is closed with pending task_work inflight, and the given io_kiocb finishes sync during issue, then we need a reference to the ring itself around the task_work execution cycle.  ",6d816e088c359866f9867057e04f244c608c42fe,0
net: fix uninit-value in caif_seqpkt_sendmsg,"When nr_segs equal to zero in iovec_from_user, the object msg->msg_iter.iov is uninit stack memory in caif_seqpkt_sendmsg which is defined in ___sys_sendmsg. So we cann't just judge msg->msg_iter.iov->base directlly. We can use nr_segs to judge msg in caif_seqpkt_sendmsg whether has data buffers.  ",991e634360f2622a683b48dfe44fe6d9cb765a09,0
drm/vgem: Close use-after-free race in vgem_gem_create,"There's two references floating around here (for the object reference, not the handle_count reference, that's a different thing):  - The temporary reference held by vgem_gem_create, acquired by   creating the object and released by calling   drm_gem_object_put_unlocked.  - The reference held by the object handle, created by   drm_gem_handle_create. This one generally outlives the function,   except if a 2nd thread races with a GEM_CLOSE ioctl call.  So usually everything is correct, except in that race case, where the access to gem_object->size could be looking at freed data already. Which again isn't a real problem (userspace shot its feet off already with the race, we could return garbage), but maybe someone can exploit this as an information leak.  ",4b848f20eda5974020f043ca14bacf7a7e634fc8,1
scsi: core: fix the dma_max_mapping_size call,"We should only call dma_max_mapping_size for devices that have a DMA mask set, otherwise we can run into a NULL pointer dereference that will crash the system.  Also we need to do right shift to get the sectors from the size in bytes, not a left shift.  ",1b5d9a6e98350e0713b4faa1b04e8f239f63b581,1
bonding/alb: make sure arp header is pulled before accessing it,"Similar to commit 38f88c454042 (""bonding/alb: properly access headers in bond_alb_xmit()""), we need to make sure arp header was pulled in skb->head before blindly accessing it in rlb_arp_xmit().  Remove arp_pkt() private helper, since it is more readable/obvious to have the following construct back to back :  	if (!pskb_network_may_pull(skb, sizeof(*arp))) 		return NULL; 	arp = (struct arp_pkt *)skb_network_header(skb);  syzbot reported :  BUG: KMSAN: uninit-value in bond_slave_has_mac_rx include/net/bonding.h:704 [inline] BUG: KMSAN: uninit-value in rlb_arp_xmit drivers/net/bonding/bond_alb.c:662 [inline] BUG: KMSAN: uninit-value in bond_alb_xmit+0x575/0x25e0 drivers/net/bonding/bond_alb.c:1477 CPU: 0 PID: 12743 Comm: syz-executor.4 Not tainted 5.6.0-rc2-syzkaller #0 Hardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 01/01/2011 Call Trace:  __dump_stack lib/dump_stack.c:77 [inline]  dump_stack+0x1c9/0x220 lib/dump_stack.c:118  kmsan_report+0xf7/0x1e0 mm/kmsan/kmsan_report.c:118  __msan_warning+0x58/0xa0 mm/kmsan/kmsan_instr.c:215  bond_slave_has_mac_rx include/net/bonding.h:704 [inline]  rlb_arp_xmit drivers/net/bonding/bond_alb.c:662 [inline]  bond_alb_xmit+0x575/0x25e0 drivers/net/bonding/bond_alb.c:1477  __bond_start_xmit drivers/net/bonding/bond_main.c:4257 [inline]  bond_start_xmit+0x85d/0x2f70 drivers/net/bonding/bond_main.c:4282  __netdev_start_xmit include/linux/netdevice.h:4524 [inline]  netdev_start_xmit include/linux/netdevice.h:4538 [inline]  xmit_one net/core/dev.c:3470 [inline]  dev_hard_start_xmit+0x531/0xab0 net/core/dev.c:3486  __dev_queue_xmit+0x37de/0x4220 net/core/dev.c:4063  dev_queue_xmit+0x4b/0x60 net/core/dev.c:4096  packet_snd net/packet/af_packet.c:2967 [inline]  packet_sendmsg+0x8347/0x93b0 net/packet/af_packet.c:2992  sock_sendmsg_nosec net/socket.c:652 [inline]  sock_sendmsg net/socket.c:672 [inline]  __sys_sendto+0xc1b/0xc50 net/socket.c:1998  __do_sys_sendto net/socket.c:2010 [inline]  __se_sys_sendto+0x107/0x130 net/socket.c:2006  __x64_sys_sendto+0x6e/0x90 net/socket.c:2006  do_syscall_64+0xb8/0x160 arch/x86/entry/common.c:296  entry_SYSCALL_64_after_hwframe+0x44/0xa9 ",b7469e83d2add567e4e0b063963db185f3167cea,1
l2tp: add sk_family checks to l2tp_validate_socket,"syzbot was able to trigger a crash after using an ISDN socket and fool l2tp.  Fix this by making sure the UDP socket is of the proper family.  BUG: KASAN: slab-out-of-bounds in setup_udp_tunnel_sock+0x465/0x540 net/ipv4/udp_tunnel.c:78 Write of size 1 at addr ffff88808ed0c590 by task syz-executor.5/3018  CPU: 0 PID: 3018 Comm: syz-executor.5 Not tainted 5.7.0-rc6-syzkaller #0 Hardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 01/01/2011 Call Trace:  __dump_stack lib/dump_stack.c:77 [inline]  dump_stack+0x188/0x20d lib/dump_stack.c:118  print_address_description.constprop.0.cold+0xd3/0x413 mm/kasan/report.c:382  __kasan_report.cold+0x20/0x38 mm/kasan/report.c:511  kasan_report+0x33/0x50 mm/kasan/common.c:625  setup_udp_tunnel_sock+0x465/0x540 net/ipv4/udp_tunnel.c:78  l2tp_tunnel_register+0xb15/0xdd0 net/l2tp/l2tp_core.c:1523  l2tp_nl_cmd_tunnel_create+0x4b2/0xa60 net/l2tp/l2tp_netlink.c:249  genl_family_rcv_msg_doit net/netlink/genetlink.c:673 [inline]  genl_family_rcv_msg net/netlink/genetlink.c:718 [inline]  genl_rcv_msg+0x627/0xdf0 net/netlink/genetlink.c:735  netlink_rcv_skb+0x15a/0x410 net/netlink/af_netlink.c:2469  genl_rcv+0x24/0x40 net/netlink/genetlink.c:746  netlink_unicast_kernel net/netlink/af_netlink.c:1303 [inline]  netlink_unicast+0x537/0x740 net/netlink/af_netlink.c:1329  netlink_sendmsg+0x882/0xe10 net/netlink/af_netlink.c:1918  sock_sendmsg_nosec net/socket.c:652 [inline]  sock_sendmsg+0xcf/0x120 net/socket.c:672  ____sys_sendmsg+0x6e6/0x810 net/socket.c:2352  ___sys_sendmsg+0x100/0x170 net/socket.c:2406  __sys_sendmsg+0xe5/0x1b0 net/socket.c:2439  do_syscall_64+0xf6/0x7d0 arch/x86/entry/common.c:295  entry_SYSCALL_64_after_hwframe+0x49/0xb3 ",d9a81a225277686eb629938986d97629ea102633,1
fs: quota: fix array-index-out-of-bounds bug by passing correct argument to vfs_cleanup_quota_inode(),"When dquot_resume() was last updated, the argument that got passed to vfs_cleanup_quota_inode was incorrectly set.  If type = -1 and dquot_load_quota_sb() returns a negative value, then vfs_cleanup_quota_inode() gets called with -1 passed as an argument, and this leads to an array-index-out-of-bounds bug.  Fix this issue by correctly passing the arguments.  ",e51d68e76d604c6d5d1eb13ae1d6da7f6c8c0dfc,1
tipc: fix one byte leak in tipc_sk_set_orig_addr(),"sysbot/KMSAN reported an uninit-value in recvmsg() that I tracked down to tipc_sk_set_orig_addr(), missing srcaddr->member.scope initialization.  This patches moves srcaddr->sock.scope init to follow fields order and ease future verifications.  BUG: KMSAN: uninit-value in copy_to_user include/linux/uaccess.h:184 [inline] BUG: KMSAN: uninit-value in move_addr_to_user+0x32e/0x530 net/socket.c:226 CPU: 0 PID: 4549 Comm: syz-executor287 Not tainted 4.17.0-rc3+ #88 Hardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 01/01/2011 Call Trace:  __dump_stack lib/dump_stack.c:77 [inline]  dump_stack+0x185/0x1d0 lib/dump_stack.c:113  kmsan_report+0x142/0x240 mm/kmsan/kmsan.c:1067  kmsan_internal_check_memory+0x135/0x1e0 mm/kmsan/kmsan.c:1157  kmsan_copy_to_user+0x69/0x160 mm/kmsan/kmsan.c:1199  copy_to_user include/linux/uaccess.h:184 [inline]  move_addr_to_user+0x32e/0x530 net/socket.c:226  ___sys_recvmsg+0x4e2/0x810 net/socket.c:2285  __sys_recvmsg net/socket.c:2328 [inline]  __do_sys_recvmsg net/socket.c:2338 [inline]  __se_sys_recvmsg net/socket.c:2335 [inline]  __x64_sys_recvmsg+0x325/0x460 net/socket.c:2335  do_syscall_64+0x154/0x220 arch/x86/entry/common.c:287  entry_SYSCALL_64_after_hwframe+0x44/0xa9 ",09c8b9718a7af674036643fa2e0dbb2f09aba75e,1
hfsplus: stop workqueue when fill_super() failed,"syzbot is reporting ODEBUG messages at hfsplus_fill_super() [1].  This is because hfsplus_fill_super() forgot to call cancel_delayed_work_sync().  As far as I can see, it is hfsplus_mark_mdb_dirty() from hfsplus_new_inode() in hfsplus_fill_super() that calls queue_delayed_work().  Therefore, I assume that hfsplus_new_inode() does not fail if queue_delayed_work() was called, and the out_put_hidden_dir label is the appropriate location to call cancel_delayed_work_sync().  [1] https://syzkaller.appspot.com/bug?id=a66f45e96fdbeb76b796bf46eb25ea878c42a6c9  ",66072c29328717072fd84aaff3e070e3f008ba77,1
net: hsr: check skb can contain struct hsr_ethhdr in fill_frame_info,"Check at start of fill_frame_info that the MAC header in the supplied skb is large enough to fit a struct hsr_ethhdr, as otherwise this is not a valid HSR frame. If it is too small, return an error which will then cause the callers to clean up the skb. Fixes a KMSAN-found uninit-value bug reported by syzbot at: https://syzkaller.appspot.com/bug?id=f7e9b601f1414f814f7602a82b6619a8d80bce3f  ",2e9f60932a2c19e8a11b4a69d419f107024b05a0,1
xfrm: Refuse to insert 32 bit userspace socket policies on 64 bit systems,"We don't have a compat layer for xfrm, so userspace and kernel structures have different sizes in this case. This results in a broken configuration, so refuse to configure socket policies when trying to insert from 32 bit userspace as we do it already with policies inserted via netlink.  ",19d7df69fdb2636856dc8919de72fc1bf8f79598,0
media: dvd_usb: memory leak in cinergyt2_fe_attach,"When the driver fails to talk with the hardware with dvb_usb_generic_rw, it will return an error to dvb_usb_adapter_frontend_init. However, the driver forgets to free the resource (e.g., struct cinergyt2_fe_state), which leads to a memory leak.  Fix this by freeing struct cinergyt2_fe_state when dvb_usb_generic_rw fails in cinergyt2_frontend_attach.  backtrace:   [<0000000056e17b1a>] kmalloc include/linux/slab.h:552 [inline]   [<0000000056e17b1a>] kzalloc include/linux/slab.h:682 [inline]   [<0000000056e17b1a>] cinergyt2_fe_attach+0x21/0x80 drivers/media/usb/dvb-usb/cinergyT2-fe.c:271   [<00000000ae0b1711>] cinergyt2_frontend_attach+0x21/0x70 drivers/media/usb/dvb-usb/cinergyT2-core.c:74   [<00000000d0254861>] dvb_usb_adapter_frontend_init+0x11b/0x1b0 drivers/media/usb/dvb-usb/dvb-usb-dvb.c:290   [<0000000002e08ac6>] dvb_usb_adapter_init drivers/media/usb/dvb-usb/dvb-usb-init.c:84 [inline]   [<0000000002e08ac6>] dvb_usb_init drivers/media/usb/dvb-usb/dvb-usb-init.c:173 [inline]   [<0000000002e08ac6>] dvb_usb_device_init.cold+0x4d0/0x6ae drivers/media/usb/dvb-usb/dvb-usb-init.c:287  ",9ad1efee086e0e913914fa2b2173efb830bad68c,1
block: fix too broad elevator check in blk_mq_free_request(),"We added RQF_ELV to tell whether there's an IO scheduler attached, and RQF_ELVPRIV tells us whether there's an IO scheduler with private data attached. Don't check RQF_ELV in blk_mq_free_request(), what we care about here is just if we have scheduler private data attached.  This fixes a boot crash  ",e0d78afeb8d190164a823d5ef5821b0b3802af33,1
tracing: Check for no filter when processing event filters,"The syzkaller detected a out-of-bounds issue with the events filter code, specifically here:  	prog[N].pred = NULL;					",70303420b5721c38998cf987e6b7d30cc62d4ff1,1
fs/seq_file.c: simplify seq_file iteration code and interface,"The documentation for seq_file suggests that it is necessary to be able to move the iterator to a given offset, however that is not the case. If the iterator is stored in the private data and is stable from one read() syscall to the next, it is only necessary to support first/next interactions.  Implementing this in a client is a little clumsy.   - if ->start() is given a pos of zero, it should go to start of    sequence.   - if ->start() is given the name pos that was given to the most recent    next() or start(), it should restore the iterator to state just    before that last call   - if ->start is given another number, it should set the iterator one    beyond the start just before the last ->start or ->next call.  Also, the documentation says that the implementation can interpret the pos however it likes (other than zero meaning start), but seq_file increments the pos sometimes which does impose on the implementation.  This patch simplifies the interface for first/next iteration and simplifies the code, while maintaining complete backward compatability. Now:   - if ->start() is given a pos of zero, it should return an iterator    placed at the start of the sequence   - if ->start() is given a non-zero pos, it should return the iterator    in the same state it was after the last ->start or ->next.  This is particularly useful for interators which walk the multiple chains in a hash table, e.g.  using rhashtable_walk*.  See fs/gfs2/glock.c and drivers/staging/lustre/lustre/llite/vvp_dev.c  A large part of achieving this is to *always* call ->next after ->show has successfully stored all of an entry in the buffer.  Never just increment the index instead.  Also:   - always pass &m->index to ->start() and ->next(), never a temp    variable   - don't clear ->from when ->count is zero, as ->from is dead when    ->count is zero.  Some ->next functions do not increment *pos when they return NULL.  To maintain compatability with this, we still need to increment m->index in one place, if ->next didn't increment it.  Note that such ->next functions are buggy and should be fixed.  A simple demonstration is     dd if=/proc/swaps bs=1000 skip=1  Choose any block size larger than the size of /proc/swaps.  This will always show the whole last line of /proc/swaps.  This patch doesn't work around buggy next() functions for this case.  [neilb@suse.com: ensure ->from is valid]   ",1f4aace60b0edc2d885aaa263abf4df42c8c65a8,0
net: usb: Fix uninit-was-stored issue in asix_read_phy_addr(),The buffer size is 2 Bytes and we expect to receive the same amount of data. But sometimes we receive less data and run into uninit-was-stored issue upon read. Hence modify the error check on the return value to match with the buffer size as a prevention.  Reported-and-tested by: syzbot+a7e220df5a81d1ab400e@syzkaller.appspotmail.com ,a092b7233f0e000cc6f2c71a49e2ecc6f917a5fc,1
crypto: aesni - xts_crypt() return if walk.nbytes is 0,xts_crypt() code doesn't call kernel_fpu_end() after calling kernel_fpu_begin() if walk.nbytes is 0. The correct behavior should be not calling kernel_fpu_begin() if walk.nbytes is 0.  ,72ff2bf04db2a48840df93a461b7115900f46c05,0
x86/traps: Disable interrupts in exc_aligment_check(),exc_alignment_check() fails to disable interrupts before returning to the entry code.  ,bce9b042ec73e8662b8119d4ca47e7c78b20d0bf,0
crypto: x86/salsa20 - remove x86 salsa20 implementations,"The x86 assembly implementations of Salsa20 use the frame base pointer register (%ebp or %rbp), which breaks frame pointer convention and breaks stack traces when unwinding from an interrupt in the crypto code. Recent (v4.10+) kernels will warn about this, e.g.  ",b7b73cd5d74694ed59abcdb4974dacb4ff8b2a2a,0
cfg80211: always free wiphy specific regdomain,"In the (somewhat unlikely) event that we allocate a wiphy, then add a regdomain to it, and then fail registration, we leak the regdomain. Fix this by just always freeing it at the end, in the normal cases we'll free (and NULL) it during wiphy_unregister(). This happened when the wiphy settings were bad, and since they can be controlled by userspace with hwsim, syzbot was able to find this issue.  ",e53e9828a8d2c6545e01ff9711f1221f2fd199ce,0
fs/reiserfs/journal.c: add missing resierfs_warning() arg,"One use of the reiserfs_warning() macro in journal_init_dev() is missing a parameter, causing the following warning:    REISERFS warning (device loop0): journal_init_dev: Cannot open '%s': %i journal_init_dev:  This also causes a WARN_ONCE() warning in the vsprintf code, and then a panic if panic_on_warn is set.    Please remove unsupported %/ in format string   ",9ad553abe66f8be3f4755e9fa0a6ba137ce76341,0
tracing/kprobe: Fix NULL pointer access in trace_porbe_unlink(),"Fix NULL pointer access in trace_probe_unlink() by initializing trace_probe.list correctly in trace_probe_init().  In the error case of trace_probe_init(), it can call trace_probe_unlink() before initializing trace_probe.list member. This causes NULL pointer dereference at list_del_init() in trace_probe_unlink().  Syzbot reported :  kasan: CONFIG_KASAN_INLINE enabled kasan: GPF could be caused by NULL-ptr deref or user memory access general protection fault: 0000 [#1] PREEMPT SMP KASAN CPU: 1 PID: 8633 Comm: syz-executor797 Not tainted 5.3.0-rc8-next-20190915 #0 Hardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 01/01/2011 ",d59fae6fea39efe65bb3d3310aaa2a54b5f55c0d,1
rsi: fix a double free bug in rsi_91x_deinit(),"`dev` (struct rsi_91x_usbdev *) field of adapter (struct rsi_91x_usbdev *) is allocated  and initialized in `rsi_init_usb_interface`. If any error is detected in information read from the device side,  `rsi_init_usb_interface` will be freed. However, in the higher level error handling code in `rsi_probe`, if error is detected, `rsi_91x_deinit` is called again, in which `dev` will be freed again, resulting double free.  This patch fixes the double free by removing the free operation on `dev` in `rsi_init_usb_interface`, because `rsi_91x_deinit` is also used in `rsi_disconnect`, in that code path, the `dev` field is not  (and thus needs to be) freed.  This bug was found in v4.19, but is also present in the latest version of kernel. Fixes CVE-2019-15504.  ",8b51dc7291473093c821195c4b6af85fadedbc2f,1
tcp: fix a lockdep issue in tcp_fastopen_reset_cipher(),"icsk_accept_queue.fastopenq.lock is only fully initialized at listen() time.  LOCKDEP is not happy if we attempt a spin_lock_bh() on it, because of missing annotation. (Although kernel runs just fine)  Lets use net->ipv4.tcp_fastopen_ctx_lock to protect ctx access.  ",9eba9353388da7bfac9694dfe94c15365d49ebd6,0
devlink: Add missed notifications iterators,"The commit mentioned in Fixes line missed a couple of notifications that were registered before devlink_register() and should be delayed too.  As such, the too early placed WARN_ON() check spotted it.  ",ef91abfb20c743c0cbe98e4351cd0ce05c81340a,0
media: hdpvr: add terminating 0 at end of string,"dev->usbc_buf was passed as argument for %s, but it was not safeguarded by a terminating 0.  This caused this syzbot issue:  https://syzkaller.appspot.com/bug?extid=79d18aac4bf1770dd050  ",8b8900b729e4f31f12ac1127bde137c775c327e6,1
ip: fix ip_mc_may_pull() return value,"ip_mc_may_pull() must return 0 if there is a problem, not an errno.  syzbot reported :  BUG: KASAN: use-after-free in br_ip4_multicast_igmp3_report net/bridge/br_multicast.c:947 [inline] BUG: KASAN: use-after-free in br_multicast_ipv4_rcv net/bridge/br_multicast.c:1631 [inline] BUG: KASAN: use-after-free in br_multicast_rcv+0x3cd8/0x4440 net/bridge/br_multicast.c:1741 Read of size 4 at addr ffff88820a4084ee by task syz-executor.2/11183  CPU: 1 PID: 11183 Comm: syz-executor.2 Not tainted 5.0.0+ #14 Hardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 01/01/2011 Call Trace:  __dump_stack lib/dump_stack.c:77 [inline]  dump_stack+0x172/0x1f0 lib/dump_stack.c:113  print_address_description.cold+0x7c/0x20d mm/kasan/report.c:187  kasan_report.cold+0x1b/0x40 mm/kasan/report.c:317  __asan_report_load4_noabort+0x14/0x20 mm/kasan/generic_report.c:131  br_ip4_multicast_igmp3_report net/bridge/br_multicast.c:947 [inline]  br_multicast_ipv4_rcv net/bridge/br_multicast.c:1631 [inline]  br_multicast_rcv+0x3cd8/0x4440 net/bridge/br_multicast.c:1741  br_handle_frame_finish+0xa3a/0x14c0 net/bridge/br_input.c:108  br_nf_hook_thresh+0x2ec/0x380 net/bridge/br_netfilter_hooks.c:1005  br_nf_pre_routing_finish+0x8e2/0x1750 net/bridge/br_netfilter_hooks.c:410  NF_HOOK include/linux/netfilter.h:289 [inline]  NF_HOOK include/linux/netfilter.h:283 [inline]  br_nf_pre_routing+0x7e7/0x13a0 net/bridge/br_netfilter_hooks.c:506  nf_hook_entry_hookfn include/linux/netfilter.h:119 [inline]  nf_hook_slow+0xbf/0x1f0 net/netfilter/core.c:511  nf_hook include/linux/netfilter.h:244 [inline]  NF_HOOK include/linux/netfilter.h:287 [inline]  br_handle_frame+0x95b/0x1450 net/bridge/br_input.c:305  __netif_receive_skb_core+0xa96/0x3040 net/core/dev.c:4902  __netif_receive_skb_one_core+0xa8/0x1a0 net/core/dev.c:4971  __netif_receive_skb+0x2c/0x1c0 net/core/dev.c:5083  netif_receive_skb_internal+0x117/0x660 net/core/dev.c:5186  netif_receive_skb+0x6e/0x5a0 net/core/dev.c:5261  ",083b78a9ed64bc71957dd7da866c128a307ea062,1
net: correct zerocopy refcnt with udp MSG_MORE,"TCP zerocopy takes a uarg reference for every skb, plus one for the tcp_sendmsg_locked datapath temporarily, to avoid reaching refcnt zero as it builds, sends and frees skbs inside its inner loop.  UDP and RAW zerocopy do not send inside the inner loop so do not need the extra sock_zerocopy_get + sock_zerocopy_put pair. Commit 52900d22288ed (""udp: elide zerocopy operation in hot path"") introduced extra_uref to pass the initial reference taken in sock_zerocopy_alloc to the first generated skb.  But, sock_zerocopy_realloc takes this extra reference at the start of every call. With MSG_MORE, no new skb may be generated to attach the extra_uref to, so refcnt is incorrectly 2 with only one skb.  Do not take the extra ref if uarg && !tcp, which implies MSG_MORE. Update extra_uref accordingly.  This conditional assignment triggers a false positive may be used uninitialized warning, so have to initialize extra_uref at define.  Changes v1->v2: fix typo in Fixes SHA1  ",100f6d8e09905c59be45b6316f8f369c0be1b2d8,1
floppy: Add max size check for user space request,"We need to check the max request size that is from user space before allocating pages. If the request size exceeds the limit, return -EINVAL. This check can avoid the warning below from page allocator.  ",545a32498c536ee152331cd2e7d2416aa0f20e01,0
reiserfs: check directory items on read from disk,"While verifying the leaf item that we read from the disk, reiserfs doesn't check the directory items, this could cause a crash when we read a directory item from the disk that has an invalid deh_location.  This patch adds a check to the directory items read from the disk that does a bounds check on deh_location for the directory entries. Any directory entry header with a directory entry offset greater than the item length is considered invalid.  ",13d257503c0930010ef9eed78b689cec417ab741,1
net/tls: fix async operation,"Mallesham reports the TLS with async accelerator was broken by commit d10523d0b3d7 (""net/tls: free the record on encryption error"") because encryption can return -EINPROGRESS in such setups, which should not be treated as an error.  The error is also present in the BPF path (likely copied from there).  ",db885e66d268884dc72967279b7e84f522556abc,0
netfilter: conntrack: fix error path in nf_conntrack_pernet_init(),"When nf_ct_netns_get() fails, it should clean up itself, its caller doesn't need to call nf_conntrack_fini_net().  nf_conntrack_init_net() is called after registering sysctl and proc, so its cleanup function should be called before unregistering sysctl and proc.  ",ac088a88b5d544b7b82f00214b1588b3c88a7fc6,0
xfs: fix mount failure crash on invalid iclog memory access,"syzbot (via KASAN) reports a use-after-free in the error path of xlog_alloc_log(). Specifically, the iclog freeing loop doesn't handle the case of a fully initialized ->l_iclog linked list. Instead, it assumes that the list is partially constructed and NULL terminated.  This bug manifested because there was no possible error scenario after iclog list setup when the original code was added.  Subsequent code and associated error conditions were added some time later, while the original error handling code was never updated. Fix up the error loop to terminate either on a NULL iclog or reaching the end of the list.  ",798a9cada4694ca8d970259f216cec47e675bfd5,1
KVM: x86: Prevent deadlock against tk_core.seq,"syzbot reported a possible deadlock in pvclock_gtod_notify():  CPU 0  		  	   	    	    CPU 1 write_seqcount_begin(&tk_core.seq);   pvclock_gtod_notify()			    spin_lock(&pool->lock);     queue_work(..., &pvclock_gtod_work)	    ktime_get()      spin_lock(&pool->lock);		      do {      						seq = read_seqcount_begin(tk_core.seq) 						... 				              } while (read_seqcount_retry(&tk_core.seq, seq);  While this is unlikely to happen, it's possible.  Delegate queue_work() to irq_work() which postpones it until the tk_core.seq write held region is left and interrupts are reenabled.  ",3f804f6d201ca93adf4c3df04d1bfd152c1129d6,0
tcp: purge write queue in tcp_connect_init(),"syzkaller found a reliable way to crash the host, hitting a BUG() in __tcp_retransmit_skb()  Malicous MSG_FASTOPEN is the root cause. We need to purge write queue in tcp_connect_init() at the point we init snd_una/write_seq.  This patch also replaces the BUG() by a less intrusive WARN_ON_ONCE()  kernel BUG at net/ipv4/tcp_output.c:2837! invalid opcode: 0000 [#1] SMP KASAN Dumping ftrace buffer:    (ftrace buffer empty) ",7f582b248d0a86bae5788c548d7bb5bca6f7691a,1
mm/madvise.c: fix freeing of locked page with MADV_FREE,"If madvise(..., MADV_FREE) split a transparent hugepage, it called put_page() before unlock_page().  This was wrong because put_page() can free the page, e.g. if a concurrent madvise(..., MADV_DONTNEED) has removed it from the memory mapping. put_page() then rightfully complained about freeing a locked page.  Fix this by moving the unlock_page() before put_page().  This bug was found by syzkaller, which encountered the following splat:      BUG: Bad page state in process syzkaller412798  pfn:1bd800     page:ffffea0006f60000 count:0 mapcount:0 mapping:          (null) index:0x20a00     flags: 0x200000000040019(locked|uptodate|dirty|swapbacked)     raw: 0200000000040019 0000000000000000 0000000000020a00 00000000ffffffff     raw: ffffea0006f60020 ffffea0006f60020 0000000000000000 0000000000000000     page dumped because: PAGE_FLAGS_CHECK_AT_FREE flag(s) set     bad because of flags: 0x1(locked)     ",263630e8d176d87308481ebdcd78ef9426739c6b,1
devlink: Wait longer before warning about unset port type,"The commit cited below causes devlink to emit a warning if a type was not set on a devlink port for longer than 30 seconds to ""prevent misbehavior of drivers"". This proved to be problematic when unregistering the backing netdev. The flow is always:  devlink_port_type_clear()	// schedules the warning unregister_netdev()		// blocking devlink_port_unregister()	// cancels the warning  The call to unregister_netdev() can block for long periods of time for various reasons: RTNL lock is contended, large amounts of configuration to unroll following dismantle of the netdev, etc. This results in devlink emitting a warning despite the driver behaving correctly.  In emulated environments (of future hardware) which are usually very slow, the warning can also be emitted during port creation as more than 30 seconds can pass between the time the devlink port is registered and when its type is set.  In addition, syzbot has hit this warning [1] 1974 times since 07/11/19 without being able to produce a reproducer. Probably because reproduction depends on the load or other bugs (e.g., RTNL not being released).  To prevent bogus warnings, increase the timeout to 1 hour.  [1] https://syzkaller.appspot.com/bug?id=e99b59e9c024a666c9f7450dc162a4b74d09d9cb  ",4c582234ab3948d08a24c82eb1e00436aabacbc6,1
ALSA: line6: toneport: Fix broken usage of timer for delayed execution,"The line6 toneport driver has code for some delayed initialization, and this hits the kernel Oops because mutex and other sleepable functions are used in the timer callback.  Fix the abuse by a delayed work instead so that everything works gracefully.  ",7f84ff68be05ec7a5d2acf8fdc734fe5897af48f,0
ALSA: seq: Cover unsubscribe_port() in list_mutex,"The call of unsubscribe_port() which manages the group count and module refcount from delete_and_unsubscribe_port() looks racy; it's not covered by the group list lock, and it's likely a cause of the reported unbalance at port deletion.  Let's move the call inside the group list_mutex to plug the hole.  ",7c32ae35fbf9cffb7aa3736f44dec10c944ca18e,0
RDMA/ucma: Ensure that CM_ID exists prior to access it,"Prior to access UCMA commands, the context should be initialized and connected to CM_ID with ucma_create_id(). In case user skips this step, he can provide non-valid ctx without CM_ID and cause to multiple NULL dereferences.  Also there are situations where the create_id can be raced with other user access, ensure that the context is only shared to other threads once it is fully initialized to avoid the races.  ",e8980d67d6017c8eee8f9c35f782c4bd68e004c9,1
net/9p: validate fds in p9_fd_open,"p9_fd_open just fgets file descriptors passed in from userspace, but doesn't verify that they are valid for read or writing.  This gets cought down in the VFS when actually attempting a read or write, but a new warning added in linux-next upsets syzcaller.  Fix this by just verifying the fds early on.  ",a39c46067c845a8a2d7144836e9468b7f072343e,0
netfilter: nf_conntrack_bridge: fix CONFIG_IPV6=y,This patch fixes a few problems with CONFIG_IPV6=y and CONFIG_NF_CONNTRACK_BRIDGE=m:  In file included from net/netfilter/utils.c:5: include/linux/netfilter_ipv6.h: In function 'nf_ipv6_br_defrag': include/linux/netfilter_ipv6.h:110:9: error: implicit declaration of function 'nf_ct_frag6_gather'; did you mean 'nf_ct_attach'? [-Werror=implicit-function-declaration]  And these too:  net/ipv6/netfilter.c:242:2: error: unknown field 'br_defrag' specified in initializer net/ipv6/netfilter.c:243:2: error: unknown field 'br_fragment' specified in initializer  This patch includes an original chunk from wenxu.  ,c9bb6165a16e6d5498981a6c777b94a78e74462b,0
cgroup: Fix css_task_iter_advance_css_set() cset skip condition,"While adding handling for dying task group leaders c03cd7738a83 (""cgroup: Include dying leaders with live threads in PROCS iterations"") added an inverted cset skip condition to css_task_iter_advance_css_set().  It should skip cset if it's completely empty but was incorrectly testing for the inverse condition for the dying_tasks list.  Fix it.  ",c596687a008b579c503afb7a64fcacc7270fae9e,1
xsk: Fix possible memory leak at socket close,"Fix a possible memory leak at xsk socket close that is caused by the refcounting of the umem object being wrong. The reference count of the umem was decremented only after the pool had been freed. Note that if the buffer pool is destroyed, it is important that the umem is destroyed after the pool, otherwise the umem would disappear while the driver is still running. And as the buffer pool needs to be destroyed in a work queue, the umem is also (if its refcount reaches zero) destroyed after the buffer pool in that same work queue.  What was missing is that the refcount also needs to be decremented when the pool is not freed and when the pool has not even been created. The first case happens when the refcount of the pool is higher than 1, i.e. it is still being used by some other socket using the same device and queue id. In this case, it is safe to decrement the refcount of the umem outside of the work queue as the umem will never be freed because the refcount of the umem is always greater than or equal to the refcount of the buffer pool. The second case is if the buffer pool has not been created yet, i.e. the socket was closed before it was bound but after the umem was created. In this case, it is safe to destroy the umem outside of the work queue, since there is no pool that can use it by definition.  ",e5e1a4bc916d29958c3b587354293738fcb984d7,1
dccp: fix tasklet usage,"syzbot reported a crash in tasklet_action_common() caused by dccp.  dccp needs to make sure socket wont disappear before tasklet handler has completed.  This patch takes a reference on the socket when arming the tasklet, and moves the sock_put() from dccp_write_xmit_timer() to dccp_write_xmitlet()  kernel BUG at kernel/softirq.c:514! invalid opcode: 0000 [#1] SMP KASAN Dumping ftrace buffer:    (ftrace buffer empty) ",a8d7aa17bbc970971ccdf71988ea19230ab368b1,1
apparmor: Fix uninitialized value in aa_split_fqname,"Syzkaller reported a OOB-read with the stacktrace below. This occurs inside __aa_lookupn_ns as `n` is not initialized. `n` is obtained from aa_splitn_fqname. In cases where `name` is invalid, aa_splitn_fqname returns without initializing `ns_name` and `ns_len`.  Fix this by always initializing `ns_name` and `ns_len`.  	__dump_stack lib/dump_stack.c:77 [inline] 	dump_stack+0x1c4/0x2b4 lib/dump_stack.c:113 	print_address_description.cold.8+0x9/0x1ff mm/kasan/report.c:256 	kasan_report_error mm/kasan/report.c:354 [inline] 	kasan_report.cold.9+0x242/0x309 mm/kasan/report.c:412 	__asan_report_load1_noabort+0x14/0x20 mm/kasan/report.c:430 	memcmp+0xe3/0x160 lib/string.c:861 	strnstr+0x4b/0x70 lib/string.c:934 	__aa_lookupn_ns+0xc1/0x570 security/apparmor/policy_ns.c:209 	aa_lookupn_ns+0x88/0x1e0 security/apparmor/policy_ns.c:240 	aa_fqlookupn_profile+0x1b9/0x1010 security/apparmor/policy.c:468 	fqlookupn_profile+0x80/0xc0 security/apparmor/label.c:1844 	aa_label_strn_parse+0xa3a/0x1230 security/apparmor/label.c:1908 	aa_label_parse+0x42/0x50 security/apparmor/label.c:1943 	aa_change_profile+0x513/0x3510 security/apparmor/domain.c:1362 	apparmor_setprocattr+0xaa4/0x1150 security/apparmor/lsm.c:658 	security_setprocattr+0x66/0xc0 security/security.c:1298 	proc_pid_attr_write+0x301/0x540 fs/proc/base.c:2555 	__vfs_write+0x119/0x9f0 fs/read_write.c:485 	vfs_write+0x1fc/0x560 fs/read_write.c:549 	ksys_write+0x101/0x260 fs/read_write.c:598 	__do_sys_write fs/read_write.c:610 [inline] 	__se_sys_write fs/read_write.c:607 [inline] 	__x64_sys_write+0x73/0xb0 fs/read_write.c:607 	do_syscall_64+0x1b9/0x820 arch/x86/entry/common.c:290 	entry_SYSCALL_64_after_hwframe+0x49/0xbe  ",250f2da49cb8e582215a65c03f50e8ddf5cd119c,1
locking/lockdep: Add debug_locks check in __lock_downgrade(),"Tetsuo Handa had reported he saw an incorrect ""downgrading a read lock"" warning right after a previous lockdep warning. It is likely that the previous warning turned off lock debugging causing the lockdep to have inconsistency states leading to the lock downgrade warning.  Fix that by add a check for debug_locks at the beginning of __lock_downgrade().  ",513e1073d52e55b8024b4f238a48de7587c64ccf,0
audit: fix error handling in audit_data_to_entry(),"Commit 219ca39427bf (""audit: use union for audit_field values since they are mutually exclusive"") combined a number of separate fields in the audit_field struct into a single union.  Generally this worked just fine because they are generally mutually exclusive. Unfortunately in audit_data_to_entry() the overlap can be a problem when a specific error case is triggered that causes the error path code to attempt to cleanup an audit_field struct and the cleanup involves attempting to free a stored LSM string (the lsm_str field). Currently the code always has a non-NULL value in the audit_field.lsm_str field as the top of the for-loop transfers a value into audit_field.val (both .lsm_str and .val are part of the same union); if audit_data_to_entry() fails and the audit_field struct is specified to contain a LSM string, but the audit_field.lsm_str has not yet been properly set, the error handling code will attempt to free the bogus audit_field.lsm_str value that was set with audit_field.val at the top of the for-loop.  This patch corrects this by ensuring that the audit_field.val is only set when needed (it is cleared when the audit_field struct is allocated with kcalloc()).  It also corrects a few other issues to ensure that in case of error the proper error code is returned.  ",2ad3e17ebf94b7b7f3f64c050ff168f9915345eb,1
io_uring: fix null-deref in io_disable_sqo_submit,"general protection fault, probably for non-canonical address 	0xdffffc0000000022: 0000 [#1] KASAN: null-ptr-deref 	in range [0x0000000000000110-0x0000000000000117] ",b4411616c26f26c4017b8fa4d3538b1a02028733,1
kernel/relay.c: limit kmalloc size to KMALLOC_MAX_SIZE,chan->n_subbufs is set by the user and relay_create_buf() does a kmalloc() of chan->n_subbufs * sizeof(size_t *).  kmalloc_slab() will generate a warning when this fails if chan->subbufs * sizeof(size_t *) > KMALLOC_MAX_SIZE.  Limit chan->n_subbufs to the maximum allowed kmalloc() size.  ,88913bd8ea2a75d7e460a4bed5f75e1c32660d7e,0
gfs2: bypass signal_our_withdraw if no journal,"Before this patch, function signal_our_withdraw referenced the journal inode immediately. But corrupt file systems may have some invalid journals, in which case our attempt to read it in will withdraw and the resulting signal_our_withdraw would dereference the NULL value.  This patch adds a check to signal_our_withdraw so that if the journal has not yet been initialized, it simply returns and does the old-style withdraw.  Thanks, Andy Price, for his analysis.  ",d5bf630f355d8c532bef2347cf90e8ae60a5f1bd,1
Smack: slab-out-of-bounds in vsscanf,Add barrier to soob. Return -EOVERFLOW if the buffer is exceeded.  Suggested-by: Hillf Danton <hdanton@sina.com> ,84e99e58e8d1e26f04c097f4266e431a33987f36,1
locks: fix error in locks_move_blocks(),"After moving all requests from    fl->fl_blocked_requests to    new->fl_blocked_requests  it is nonsensical to do anything to all the remaining elements, there aren't any.  This should do something to all the requests that have been moved. For simplicity, it does it to all requests in the target list.  Setting ""f->fl_blocker = new"" to all members of new->fl_blocked_requests is ""obviously correct"" as it preserves the invariant of the linkage among requests.  ",bf77ae4c98d721a9aae3840970d46669a78e034a,0
KVM: hyperv: Fix Direct Synthetic timers assert an interrupt w/o lapic_in_kernel,Reported by syzkaller:  	kasan: GPF could be caused by NULL-ptr deref or user memory access 	general protection fault: 0000 [#1] PREEMPT SMP KASAN 	,a073d7e3ad687a7ef32b65affe80faa7ce89bf92,1
audit: always check the netlink payload length in audit_receive_msg(),This patch ensures that we always check the netlink payload length in audit_receive_msg() before we take any action on the payload itself.  ,756125289285f6e55a03861bf4b6257aa3d19a93,0
RDMA/nldev: Fix crash when set a QP to a new counter but QPN is missing,"This fixes the kernel crash when a RDMA_NLDEV_CMD_STAT_SET command is received, but the QP number parameter is not available.    iwpm_register_pid: Unable to send a nlmsg (client = 2)   infiniband syz1: RDMA CMA: cma_listen_on_dev, error -98   general protection fault, probably for non-canonical address 0xdffffc0000000000: 0000 [#1] PREEMPT SMP KASAN   KASAN: null-ptr-deref in range [0x0000000000000000-0x0000000000000007]   CPU: 0 PID: 9754 Comm: syz-executor069 Not tainted 5.6.0-rc2-syzkaller #0   Hardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 01/01/2011   ",78f34a16c28654cb47791257006f90d0948f2f0c,1
net: sched: fix warning in tcindex_alloc_perfect_hash,"Syzbot reported warning in tcindex_alloc_perfect_hash. The problem was in too big cp->hash, which triggers warning in kmalloc. Since cp->hash comes from userspace, there is no need to warn if value is not correct  ",3f2db250099f46988088800052cdf2332c7aba61,0
idr: remove WARN_ON_ONCE() when trying to replace negative ID,"IDR only supports non-negative IDs.  There used to be a 'WARN_ON_ONCE(id < 0)' in idr_replace(), but it was intentionally removed by commit 2e1c9b286765 (""idr: remove WARN_ON_ONCE() on negative IDs"").  Then it was added back by commit 0a835c4f090a (""Reimplement IDR and IDA using the radix tree"").  However it seems that adding it back was a mistake, given that some users such as drm_gem_handle_delete() (DRM_IOCTL_GEM_CLOSE) pass in a value from userspace to idr_replace(), allowing the WARN_ON_ONCE to be triggered.  drm_gem_handle_delete() actually just wants idr_replace() to return an error code if the ID is not allocated, including in the case where the ID is invalid (negative).  So once again remove the bogus WARN_ON_ONCE().  This bug was found by syzkaller, which encountered the following warning:      ",a47f68d6a944113bdc8097db6f933c2e17c27bf9,1
tcp: fix another uninit-value (sk_rx_queue_mapping),"KMSAN is still not happy [1].  I missed that passive connections do not inherit their sk_rx_queue_mapping values from the request socket, but instead tcp_child_process() is calling sk_mark_napi_id(child, skb)  We have many sk_mark_napi_id() callers, so I am providing a new helper, forcing the setting sk_rx_queue_mapping and sk_napi_id.  Note that we had no KMSAN report for sk_napi_id because passive connections got a copy of this field from the listener. sk_rx_queue_mapping in the other hand is inside the sk_dontcopy_begin/sk_dontcopy_end so sk_clone_lock() leaves this field uninitialized.  We might remove dead code populating req->sk_rx_queue_mapping in the future.  [1]  BUG: KMSAN: uninit-value in __sk_rx_queue_set include/net/sock.h:1924 [inline] BUG: KMSAN: uninit-value in sk_rx_queue_update include/net/sock.h:1938 [inline] BUG: KMSAN: uninit-value in sk_mark_napi_id include/net/busy_poll.h:136 [inline] BUG: KMSAN: uninit-value in tcp_child_process+0xb42/0x1050 net/ipv4/tcp_minisocks.c:833  __sk_rx_queue_set include/net/sock.h:1924 [inline]  sk_rx_queue_update include/net/sock.h:1938 [inline]  sk_mark_napi_id include/net/busy_poll.h:136 [inline]  tcp_child_process+0xb42/0x1050 net/ipv4/tcp_minisocks.c:833  tcp_v4_rcv+0x3d83/0x4ed0 net/ipv4/tcp_ipv4.c:2066  ip_protocol_deliver_rcu+0x760/0x10b0 net/ipv4/ip_input.c:204  ip_local_deliver_finish net/ipv4/ip_input.c:231 [inline]  NF_HOOK include/linux/netfilter.h:307 [inline]  ip_local_deliver+0x584/0x8c0 net/ipv4/ip_input.c:252  dst_input include/net/dst.h:460 [inline]  ip_sublist_rcv_finish net/ipv4/ip_input.c:551 [inline]  ip_list_rcv_finish net/ipv4/ip_input.c:601 [inline]  ip_sublist_rcv+0x11fd/0x1520 net/ipv4/ip_input.c:609  ip_list_rcv+0x95f/0x9a0 net/ipv4/ip_input.c:644  __netif_receive_skb_list_ptype net/core/dev.c:5505 [inline]  __netif_receive_skb_list_core+0xe34/0x1240 net/core/dev.c:5553  __netif_receive_skb_list+0x7fc/0x960 net/core/dev.c:5605  netif_receive_skb_list_internal+0x868/0xde0 net/core/dev.c:5696  gro_normal_list net/core/dev.c:5850 [inline]  napi_complete_done+0x579/0xdd0 net/core/dev.c:6587  virtqueue_napi_complete drivers/net/virtio_net.c:339 [inline]  virtnet_poll+0x17b6/0x2350 drivers/net/virtio_net.c:1557  __napi_poll+0x14e/0xbc0 net/core/dev.c:7020  napi_poll net/core/dev.c:7087 [inline]  net_rx_action+0x824/0x1880 net/core/dev.c:7174  __do_softirq+0x1fe/0x7eb kernel/softirq.c:558  run_ksoftirqd+0x33/0x50 kernel/softirq.c:920  smpboot_thread_fn+0x616/0xbf0 kernel/smpboot.c:164  kthread+0x721/0x850 kernel/kthread.c:327  ret_from_fork+0x1f/0x30  ",03cfda4fa6ea9bea2f30160579a78c2b8c1e616e,1
net: ieee802154: fix nl802154 del llsec key,This patch fixes a nullpointer dereference if NL802154_ATTR_SEC_KEY is not set by the user. If this is the case nl802154 will return -EINVAL.  ,37feaaf5ceb2245e474369312bb7b922ce7bce69,1
net: qrtr: Fix an out of bounds read qrtr_endpoint_post(),"This code assumes that the user passed in enough data for a qrtr_hdr_v1 or qrtr_hdr_v2 struct, but it's not necessarily true.  If the buffer is too small then it will read beyond the end.  ",8ff41cc21714704ef0158a546c3c4d07fae2c952,1
tipc: fix a null pointer deref,"In commit c55c8edafa91 (""tipc: smooth change between replicast and broadcast"") we introduced new method to eliminate the risk of message reordering that happen in between different nodes. Unfortunately, we forgot checking at receiving side to ignore intra node.  We fix this by checking and returning if arrived message from intra node.  syzbot report:  ",08e046c8966a872a4fb047aa940b5c991ee5635d,0
net/nfc: Avoid stalls when nfc_alloc_send_skb() returned NULL.,"syzbot is reporting stalls at nfc_llcp_send_ui_frame() [1]. This is because nfc_llcp_send_ui_frame() is retrying the loop without any delay when nonblocking nfc_alloc_send_skb() returned NULL.  Since there is no need to use MSG_DONTWAIT if we retry until sock_alloc_send_pskb() succeeds, let's use blocking call. Also, in case an unexpected error occurred, let's break the loop if blocking nfc_alloc_send_skb() failed.  [1] https://syzkaller.appspot.com/bug?id=4a131cc571c3733e0eff6bc673f4e36ae48f19c6  ",3bc53be9db21040b5d2de4d455f023c8c494aa68,1
ppp: unlock all_ppp_mutex before registering device,"ppp_dev_uninit(), which is the .ndo_uninit() handler of PPP devices, needs to lock pn->all_ppp_mutex. Therefore we mustn't call register_netdevice() with pn->all_ppp_mutex already locked, or we'd deadlock in case register_netdevice() fails and calls .ndo_uninit().  Fortunately, we can unlock pn->all_ppp_mutex before calling register_netdevice(). This lock protects pn->units_idr, which isn't used in the device registration process.  However, keeping pn->all_ppp_mutex locked during device registration did ensure that no device in transient state would be published in pn->units_idr. In practice, unlocking it before calling register_netdevice() doesn't change this property: ppp_unit_register() is called with 'ppp_mutex' locked and all searches done in pn->units_idr hold this lock too.  ",0171c41835591e9aa2e384b703ef9a6ae367c610,0
crypto: pcrypt - Avoid deadlock by using per-instance padata queues,"If the pcrypt template is used multiple times in an algorithm, then a deadlock occurs because all pcrypt instances share the same padata_instance, which completes requests in the order submitted.  That is, the inner pcrypt request waits for the outer pcrypt request while the outer request is already waiting for the inner.  This patch fixes this by allocating a set of queues for each pcrypt instance instead of using two global queues.  In order to maintain the existing user-space interface, the pinst structure remains global so any sysfs modifications will apply to every pcrypt instance.  Note that when an update occurs we have to allocate memory for every pcrypt instance.  Should one of the allocations fail we will abort the update without rolling back changes already made.  The new per-instance data structure is called padata_shell and is essentially a wrapper around parallel_data.  Reproducer:  	#include <linux/if_alg.h> 	#include <sys/socket.h> 	#include <unistd.h>  	int main() 	{ 		struct sockaddr_alg addr = { 			.salg_type = ""aead"", 			.salg_name = ""pcrypt(pcrypt(rfc4106-gcm-aesni))"" 		}; 		int algfd, reqfd; 		char buf[32] = { 0 };  		algfd = socket(AF_ALG, SOCK_SEQPACKET, 0); 		bind(algfd, (void *)&addr, sizeof(addr)); 		setsockopt(algfd, SOL_ALG, ALG_SET_KEY, buf, 20); 		reqfd = accept(algfd, 0, 0); 		write(reqfd, buf, 32); 		read(reqfd, buf, 16); 	}  ",bbefa1dd6a6d53537c11624752219e39959d04fb,0
tipc: handle the err returned from cmd header function,Syzbot found a crash:    BUG: KMSAN: uninit-value in tipc_nl_compat_name_table_dump+0x54f/0xcd0 net/tipc/netlink_compat.c:872   Call Trace:     tipc_nl_compat_name_table_dump+0x54f/0xcd0 net/tipc/netlink_compat.c:872     __tipc_nl_compat_dumpit+0x59e/0xda0 net/tipc/netlink_compat.c:215     tipc_nl_compat_dumpit+0x63a/0x820 net/tipc/netlink_compat.c:280     tipc_nl_compat_handle net/tipc/netlink_compat.c:1226 [inline]     tipc_nl_compat_recv+0x1b5f/0x2750 net/tipc/netlink_compat.c:1265     genl_family_rcv_msg net/netlink/genetlink.c:601 [inline]     genl_rcv_msg+0x185f/0x1a60 net/netlink/genetlink.c:626     netlink_rcv_skb+0x431/0x620 net/netlink/af_netlink.c:2477     genl_rcv+0x63/0x80 net/netlink/genetlink.c:637     netlink_unicast_kernel net/netlink/af_netlink.c:1310 [inline]     netlink_unicast+0xf3e/0x1020 net/netlink/af_netlink.c:1336     netlink_sendmsg+0x127f/0x1300 net/netlink/af_netlink.c:1917     sock_sendmsg_nosec net/socket.c:622 [inline]     sock_sendmsg net/socket.c:632 [inline]    ,2ac695d1d602ce00b12170242f58c3d3a8e36d04,1
crypto: x86/twofish-3way - Fix %rbp usage,"Using %rbp as a temporary register breaks frame pointer convention and breaks stack traces when unwinding from an interrupt in the crypto code.  In twofish-3way, we can't simply replace %rbp with another register because there are none available.  Instead, we use the stack to hold the values that %rbp, %r11, and %r12 were holding previously.  Each of these values represents the half of the output from the previous Feistel round that is being passed on unchanged to the following round.  They are only used once per round, when they are exchanged with %rax, %rbx, and %rcx.  As a result, we free up 3 registers (one per block) and can reassign them so that %rbp is not used, and additionally %r14 and %r15 are not used so they do not need to be saved/restored.  There may be a small overhead caused by replacing 'xchg REG, REG' with the needed sequence 'mov MEM, REG; mov REG, MEM; mov REG, REG' once per round.  But, counterintuitively, when I tested ""ctr-twofish-3way"" on a Haswell processor, the new version was actually about 2% faster. (Perhaps 'xchg' is not as well optimized as plain moves.)  ",d8c7fe9f2a486a6e5f0d5229ca43807af5ab22c6,0
xfrm/compat: Cleanup WARN()s that can be user-triggered,Replace WARN_ONCE() that can be triggered from userspace with pr_warn_once(). Those still give user a hint what's the issue.  I've left WARN()s that are not possible to trigger with current code-base and that would mean that the code has issues: - relying on current compat_msg_min[type] <= xfrm_msg_min[type] - expected 4-byte padding size difference between   compat_msg_min[type] and xfrm_msg_min[type] - compat_policy[type].len <= xfrma_policy[type].len (for every type)  ,ef19e111337f6c3dca7019a8bad5fbc6fb18d635,0
tun: do not arm flow_gc_timer in tun_flow_init(),"Timer is properly armed on demand from tun_flow_update(), so there is no need to arm it at tun init.  ",ee74d9967b829232723939cb7c9b100b29f6ec98,0
rds: fix two RCU related problems,"When a rds sock is bound, it is inserted into the bind_hash_table which is protected by RCU. But when releasing rds sock, after it is removed from this hash table, it is freed immediately without respecting RCU grace period. This could cause some use-after-free as reported by syzbot.  Mark the rds sock with SOCK_RCU_FREE before inserting it into the bind_hash_table, so that it would be always freed after a RCU grace period.  The other problem is in rds_find_bound(), the rds sock could be freed in between rhashtable_lookup_fast() and rds_sock_addref(), so we need to extend RCU read lock protection in rds_find_bound() to close this race condition.  ",cc4dfb7f70a344f24c1c71e298deea0771dadcb2,1
net: annotate data race around sk_ll_usec,"sk_ll_usec is read locklessly from sk_can_busy_loop() while another thread can change its value in sock_setsockopt()  This is correct but needs annotations.  BUG: KCSAN: data-race in __skb_try_recv_datagram / sock_setsockopt  write to 0xffff88814eb5f904 of 4 bytes by task 14011 on cpu 0:  sock_setsockopt+0x1287/0x2090 net/core/sock.c:1175  __sys_setsockopt+0x14f/0x200 net/socket.c:2100  __do_sys_setsockopt net/socket.c:2115 [inline]  __se_sys_setsockopt net/socket.c:2112 [inline]  __x64_sys_setsockopt+0x62/0x70 net/socket.c:2112  do_syscall_64+0x4a/0x90 arch/x86/entry/common.c:47  entry_SYSCALL_64_after_hwframe+0x44/0xae  read to 0xffff88814eb5f904 of 4 bytes by task 14001 on cpu 1:  sk_can_busy_loop include/net/busy_poll.h:41 [inline]  __skb_try_recv_datagram+0x14f/0x320 net/core/datagram.c:273  unix_dgram_recvmsg+0x14c/0x870 net/unix/af_unix.c:2101  unix_seqpacket_recvmsg+0x5a/0x70 net/unix/af_unix.c:2067  ____sys_recvmsg+0x15d/0x310 include/linux/uio.h:244  ___sys_recvmsg net/socket.c:2598 [inline]  do_recvmmsg+0x35c/0x9f0 net/socket.c:2692  __sys_recvmmsg net/socket.c:2771 [inline]  __do_sys_recvmmsg net/socket.c:2794 [inline]  __se_sys_recvmmsg net/socket.c:2787 [inline]  __x64_sys_recvmmsg+0xcf/0x150 net/socket.c:2787  do_syscall_64+0x4a/0x90 arch/x86/entry/common.c:47  entry_SYSCALL_64_after_hwframe+0x44/0xae  value changed: 0x00000000 -> 0x00000101  Reported by Kernel Concurrency Sanitizer on: CPU: 1 PID: 14001 Comm: syz-executor.3 Not tainted 5.13.0-syzkaller #0 Hardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 01/01/2011  ",0dbffbb5335a1e3aa6855e4ee317e25e669dd302,1
ALSA: pcm: Fix possible OOB access in PCM oss plugins,"The PCM OSS emulation converts and transfers the data on the fly via ""plugins"".  The data is converted over the dynamically allocated buffer for each plugin, and recently syzkaller caught OOB in this flow.  Although the bisection by syzbot pointed out to the commit 65766ee0bf7f (""ALSA: oss: Use kvzalloc() for local buffer allocations""), this is merely a commit to replace vmalloc() with kvmalloc(), hence it can't be the cause.  The further debug action revealed that this happens in the case where a slave PCM doesn't support only the stereo channels while the OSS stream is set up for a mono channel.  Below is a brief explanation:  At each OSS parameter change, the driver sets up the PCM hw_params again in snd_pcm_oss_change_params_lock().  This is also the place where plugins are created and local buffers are allocated.  The problem is that the plugins are created before the final hw_params is determined.  Namely, two snd_pcm_hw_param_near() calls for setting the period size and periods may influence on the final result of channels, rates, etc, too, while the current code has already created plugins beforehand with the premature values.  So, the plugin believes that channels=1, while the actual I/O is with channels=2, which makes the driver reading/writing over the allocated buffer size.  The fix is simply to move the plugin allocation code after the final hw_params call.  ",ca0214ee2802dd47239a4e39fb21c5b00ef61b22,1
virtio-net: fix use-after-free in page_to_skb(),"KASAN/syzbot had 4 reports, one of them being:  BUG: KASAN: slab-out-of-bounds in memcpy include/linux/fortify-string.h:191 [inline] BUG: KASAN: slab-out-of-bounds in page_to_skb+0x5cf/0xb70 drivers/net/virtio_net.c:480 Read of size 12 at addr ffff888014a5f800 by task systemd-udevd/8445  CPU: 0 PID: 8445 Comm: systemd-udevd Not tainted 5.12.0-rc8-next-20210419-syzkaller #0 Hardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 01/01/2011 Call Trace:  <IRQ>  __dump_stack lib/dump_stack.c:79 [inline]  dump_stack+0x141/0x1d7 lib/dump_stack.c:120  print_address_description.constprop.0.cold+0x5b/0x2f8 mm/kasan/report.c:233  __kasan_report mm/kasan/report.c:419 [inline]  kasan_report.cold+0x7c/0xd8 mm/kasan/report.c:436  check_region_inline mm/kasan/generic.c:180 [inline]  kasan_check_range+0x13d/0x180 mm/kasan/generic.c:186  memcpy+0x20/0x60 mm/kasan/shadow.c:65  memcpy include/linux/fortify-string.h:191 [inline]  page_to_skb+0x5cf/0xb70 drivers/net/virtio_net.c:480  receive_mergeable drivers/net/virtio_net.c:1009 [inline]  receive_buf+0x2bc0/0x6250 drivers/net/virtio_net.c:1119  virtnet_receive drivers/net/virtio_net.c:1411 [inline]  virtnet_poll+0x568/0x10b0 drivers/net/virtio_net.c:1516  __napi_poll+0xaf/0x440 net/core/dev.c:6962  napi_poll net/core/dev.c:7029 [inline]  net_rx_action+0x801/0xb40 net/core/dev.c:7116  __do_softirq+0x29b/0x9fe kernel/softirq.c:559  invoke_softirq kernel/softirq.c:433 [inline]  __irq_exit_rcu+0x136/0x200 kernel/softirq.c:637  irq_exit_rcu+0x5/0x20 kernel/softirq.c:649  common_interrupt+0xa4/0xd0 arch/x86/kernel/irq.c:240  ",af39c8f72301b268ad8b04bae646b6025918b82b,1
qmi_wwan: Fix out-of-bounds read,"The syzbot reported   Call Trace:   __dump_stack lib/dump_stack.c:77 [inline]   dump_stack+0xca/0x13e lib/dump_stack.c:113   print_address_description+0x67/0x231 mm/kasan/report.c:188   __kasan_report.cold+0x1a/0x32 mm/kasan/report.c:317   kasan_report+0xe/0x20 mm/kasan/common.c:614   qmi_wwan_probe+0x342/0x360 drivers/net/usb/qmi_wwan.c:1417   usb_probe_interface+0x305/0x7a0 drivers/usb/core/driver.c:361   really_probe+0x281/0x660 drivers/base/dd.c:509   driver_probe_device+0x104/0x210 drivers/base/dd.c:670   __device_attach_driver+0x1c2/0x220 drivers/base/dd.c:777   bus_for_each_drv+0x15c/0x1e0 drivers/base/bus.c:454  Caused by too many confusing indirections and casts. id->driver_info is a pointer stored in a long.  We want the pointer here, not the address of it.  Thanks-to: Hillf Danton <hdanton@sina.com> ",904d88d743b0c94092c5117955eab695df8109e8,1
vt: prevent leaking uninitialized data to userspace via /dev/vcs*,KMSAN reported an infoleak when reading from /dev/vcs*:    BUG: KMSAN: kernel-infoleak in vcs_read+0x18ba/0x1cc0   Call Trace:   ...    kmsan_copy_to_user+0x7a/0x160 mm/kmsan/kmsan.c:1253    copy_to_user ./include/linux/uaccess.h:184    vcs_read+0x18ba/0x1cc0 drivers/tty/vt/vc_screen.c:352    __vfs_read+0x1b2/0x9d0 fs/read_write.c:416    vfs_read+0x36c/0x6b0 fs/read_write.c:452   ...   ,21eff69aaaa0e766ca0ce445b477698dc6a9f55a,1
media: usb:zr364xx:Fix KASAN:null-ptr-deref Read in zr364xx_vidioc_querycap,SyzKaller hit the null pointer deref while reading from uninitialized udev->product in zr364xx_vidioc_querycap().  ,5d2e73a5f80a5b5aff3caf1ec6d39b5b3f54b26e,1
net/9p/trans_fd.c: fix race-condition by flushing workqueue before the kfree(),"The patch adds the flush in p9_mux_poll_stop() as it the function used by p9_conn_destroy(), in turn called by p9_fd_close() to stop the async polling associated with the data regarding the connection.  ",430ac66eb4c5b5c4eb846b78ebf65747510b30f1,1
ovl: fix error handling in ovl_verify_set_fh(),We hit a BUG on kfree of an ERR_PTR()...  ,babf4770be0adc69e6d2de150f4040f175e24beb,1
tuntap: fix possible deadlock when fail to register netdev,Private destructor could be called when register_netdev() fail with rtnl lock held. This will lead deadlock in tun_free_netdev() who tries to hold rtnl_lock. Fixing this by switching to use spinlock to synchronize.  ,124da8f6118bce3d9aeb5c6f5395ed131141aad5,0
"Revert ""tcp: Reset tcp connections in SYN-SENT state""","This reverts commit e880f8b3a24a73704731a7227ed5fee14bd90192.  1) Patch has not been properly tested, and is wrong [1] 2) Patch submission did not include TCP maintainer (this is me)  [1] divide error: 0000 [#1] PREEMPT SMP KASAN CPU: 0 PID: 8426 Comm: syz-executor478 Not tainted 5.12.0-rc4-syzkaller #0 Hardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 01/01/2011 ",a7150e382267d5d2bb3e1a2a07776e97646b0952,1
l2ip: fix possible use-after-free,"Before taking a refcount on a rcu protected structure, we need to make sure the refcount is not zero.  syzbot reported :  refcount_t: increment on 0; use-after-free. ",a622b40035d16196bf19b2b33b854862595245fc,1
tipc: fix the skb_unshare() in tipc_buf_append(),"skb_unshare() drops a reference count on the old skb unconditionally, so in the failure case, we end up freeing the skb twice here. And because the skb is allocated in fclone and cloned by caller tipc_msg_reassemble(), the consequence is actually freeing the original skb too, thus triggered the UAF by syzbot.  Fix this by replacing this skb_unshare() with skb_cloned()+skb_copy().  ",ed42989eab57d619667d7e87dfbd8fe207db54fe,0
ovl: fix lock in ovl_llseek(),"ovl_inode_lock() is interruptible. When inode_lock() in ovl_llseek() was replaced with ovl_inode_lock(), we did not add a check for error.  Fix this by making ovl_inode_lock() uninterruptible and change the existing call sites to use an _interruptible variant.  ",531d3040bc5cf37dea01b118608347cca9325f9d,0
USB: core: Fix misleading driver bug report,"The syzbot fuzzer found a race between URB submission to endpoint 0 and device reset.  Namely, during the reset we call usb_ep0_reinit() because the characteristics of ep0 may have changed (if the reset follows a firmware update, for example).  While usb_ep0_reinit() is running there is a brief period during which the pointers stored in udev->ep_in[0] and udev->ep_out[0] are set to NULL, and if an URB is submitted to ep0 during that period, usb_urb_ep_type_check() will report it as a driver bug.  In the absence of those pointers, the routine thinks that the endpoint doesn't exist.  The log message looks like this:  ",ac854131d9844f79e2fdcef67a7707227538d78a,1
net: fix building errors on powerpc when CONFIG_RETPOLINE is not set,"This commit fixes the errores reported when building for powerpc:   ERROR: modpost: ""ip6_dst_check"" [vmlinux] is a static EXPORT_SYMBOL  ERROR: modpost: ""ipv4_dst_check"" [vmlinux] is a static EXPORT_SYMBOL  ERROR: modpost: ""ipv4_mtu"" [vmlinux] is a static EXPORT_SYMBOL  ERROR: modpost: ""ip6_mtu"" [vmlinux] is a static EXPORT_SYMBOL  ",9c97921a51a013917cfc387998882ecd0795937c,0
net: annotate data-race in neigh_output(),"neigh_output() reads n->nud_state and hh->hh_len locklessly.  This is fine, but we need to add annotations and document this.  We evaluate skip_cache first to avoid reading these fields if the cache has to by bypassed.  syzbot report:  BUG: KCSAN: data-race in __neigh_event_send / ip_finish_output2  write to 0xffff88810798a885 of 1 bytes by interrupt on cpu 1:  __neigh_event_send+0x40d/0xac0 net/core/neighbour.c:1128  neigh_event_send include/net/neighbour.h:444 [inline]  neigh_resolve_output+0x104/0x410 net/core/neighbour.c:1476  neigh_output include/net/neighbour.h:510 [inline]  ip_finish_output2+0x80a/0xaa0 net/ipv4/ip_output.c:221  ip_finish_output+0x3b5/0x510 net/ipv4/ip_output.c:309  NF_HOOK_COND include/linux/netfilter.h:296 [inline]  ip_output+0xf3/0x1a0 net/ipv4/ip_output.c:423  dst_output include/net/dst.h:450 [inline]  ip_local_out+0x164/0x220 net/ipv4/ip_output.c:126  __ip_queue_xmit+0x9d3/0xa20 net/ipv4/ip_output.c:525  ip_queue_xmit+0x34/0x40 net/ipv4/ip_output.c:539  __tcp_transmit_skb+0x142a/0x1a00 net/ipv4/tcp_output.c:1405  tcp_transmit_skb net/ipv4/tcp_output.c:1423 [inline]  tcp_xmit_probe_skb net/ipv4/tcp_output.c:4011 [inline]  tcp_write_wakeup+0x4a9/0x810 net/ipv4/tcp_output.c:4064  tcp_send_probe0+0x2c/0x2b0 net/ipv4/tcp_output.c:4079  tcp_probe_timer net/ipv4/tcp_timer.c:398 [inline]  tcp_write_timer_handler+0x394/0x520 net/ipv4/tcp_timer.c:626  tcp_write_timer+0xb9/0x180 net/ipv4/tcp_timer.c:642  call_timer_fn+0x2e/0x1d0 kernel/time/timer.c:1421  expire_timers+0x135/0x240 kernel/time/timer.c:1466  __run_timers+0x368/0x430 kernel/time/timer.c:1734  run_timer_softirq+0x19/0x30 kernel/time/timer.c:1747  __do_softirq+0x12c/0x26e kernel/softirq.c:558  invoke_softirq kernel/softirq.c:432 [inline]  __irq_exit_rcu kernel/softirq.c:636 [inline]  irq_exit_rcu+0x4e/0xa0 kernel/softirq.c:648  sysvec_apic_timer_interrupt+0x69/0x80 arch/x86/kernel/apic/apic.c:1097  asm_sysvec_apic_timer_interrupt+0x12/0x20  native_safe_halt arch/x86/include/asm/irqflags.h:51 [inline]  arch_safe_halt arch/x86/include/asm/irqflags.h:89 [inline]  acpi_safe_halt drivers/acpi/processor_idle.c:109 [inline]  acpi_idle_do_entry drivers/acpi/processor_idle.c:553 [inline]  acpi_idle_enter+0x258/0x2e0 drivers/acpi/processor_idle.c:688  cpuidle_enter_state+0x2b4/0x760 drivers/cpuidle/cpuidle.c:237  cpuidle_enter+0x3c/0x60 drivers/cpuidle/cpuidle.c:351  call_cpuidle kernel/sched/idle.c:158 [inline]  cpuidle_idle_call kernel/sched/idle.c:239 [inline]  do_idle+0x1a3/0x250 kernel/sched/idle.c:306  cpu_startup_entry+0x15/0x20 kernel/sched/idle.c:403  secondary_startup_64_no_verify+0xb1/0xbb  read to 0xffff88810798a885 of 1 bytes by interrupt on cpu 0:  neigh_output include/net/neighbour.h:507 [inline]  ip_finish_output2+0x79a/0xaa0 net/ipv4/ip_output.c:221  ip_finish_output+0x3b5/0x510 net/ipv4/ip_output.c:309  NF_HOOK_COND include/linux/netfilter.h:296 [inline]  ip_output+0xf3/0x1a0 net/ipv4/ip_output.c:423  dst_output include/net/dst.h:450 [inline]  ip_local_out+0x164/0x220 net/ipv4/ip_output.c:126  __ip_queue_xmit+0x9d3/0xa20 net/ipv4/ip_output.c:525  ip_queue_xmit+0x34/0x40 net/ipv4/ip_output.c:539  __tcp_transmit_skb+0x142a/0x1a00 net/ipv4/tcp_output.c:1405  tcp_transmit_skb net/ipv4/tcp_output.c:1423 [inline]  tcp_xmit_probe_skb net/ipv4/tcp_output.c:4011 [inline]  tcp_write_wakeup+0x4a9/0x810 net/ipv4/tcp_output.c:4064  tcp_send_probe0+0x2c/0x2b0 net/ipv4/tcp_output.c:4079  tcp_probe_timer net/ipv4/tcp_timer.c:398 [inline]  tcp_write_timer_handler+0x394/0x520 net/ipv4/tcp_timer.c:626  tcp_write_timer+0xb9/0x180 net/ipv4/tcp_timer.c:642  call_timer_fn+0x2e/0x1d0 kernel/time/timer.c:1421  expire_timers+0x135/0x240 kernel/time/timer.c:1466  __run_timers+0x368/0x430 kernel/time/timer.c:1734  run_timer_softirq+0x19/0x30 kernel/time/timer.c:1747  __do_softirq+0x12c/0x26e kernel/softirq.c:558  invoke_softirq kernel/softirq.c:432 [inline]  __irq_exit_rcu kernel/softirq.c:636 [inline]  irq_exit_rcu+0x4e/0xa0 kernel/softirq.c:648  sysvec_apic_timer_interrupt+0x69/0x80 arch/x86/kernel/apic/apic.c:1097  asm_sysvec_apic_timer_interrupt+0x12/0x20  native_safe_halt arch/x86/include/asm/irqflags.h:51 [inline]  arch_safe_halt arch/x86/include/asm/irqflags.h:89 [inline]  acpi_safe_halt drivers/acpi/processor_idle.c:109 [inline]  acpi_idle_do_entry drivers/acpi/processor_idle.c:553 [inline]  acpi_idle_enter+0x258/0x2e0 drivers/acpi/processor_idle.c:688  cpuidle_enter_state+0x2b4/0x760 drivers/cpuidle/cpuidle.c:237  cpuidle_enter+0x3c/0x60 drivers/cpuidle/cpuidle.c:351  call_cpuidle kernel/sched/idle.c:158 [inline]  cpuidle_idle_call kernel/sched/idle.c:239 [inline]  do_idle+0x1a3/0x250 kernel/sched/idle.c:306  cpu_startup_entry+0x15/0x20 kernel/sched/idle.c:403  rest_init+0xee/0x100 init/main.c:734  arch_call_rest_init+0xa/0xb  start_kernel+0x5e4/0x669 init/main.c:1142  secondary_startup_64_no_verify+0xb1/0xbb  value changed: 0x20 -> 0x01  Reported by Kernel Concurrency Sanitizer on: CPU: 0 PID: 0 Comm: swapper/0 Not tainted 5.15.0-rc6-syzkaller #0 Hardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 01/01/2011  ",d18785e213866935b4c3dc0c33c3e18801ce0ce8,1
KEYS: DNS: fix parsing multiple options,"My recent fix for dns_resolver_preparse() printing very long strings was incomplete, as shown by syzbot which still managed to hit the WARN_ONCE() in set_precision() by adding a crafted ""dns_resolver"" key:      precision 50001 too large     ",c604cb767049b78b3075497b80ebb8fd530ea2cc,0
rtc: disable uie before setting time and enable after,"When setting the time in the future with the uie timer enabled, rtc_timer_do_work will loop for a while because the expiration of the uie timer was way before the current RTC time and a new timer will be enqueued until the current rtc time is reached.  If the uie timer is enabled, disable it before setting the time and enable it after expiring current timers (which may actually be an alarm).  This is the safest thing to do to ensure the uie timer is still synchronized with the RTC, especially in the UIE emulation case.  ",7e7c005b4b1f1f169bcc4b2c3a40085ecc663df2,0
JFS: more checks for invalid superblock,"syzbot is feeding invalid superblock data to JFS for mount testing. JFS does not check several of the fields -- just assumes that they are good since the JFS_MAGIC and version fields are good.  In this case (syzbot reproducer), we have s_l2bsize == 0xda0c, pad == 0xf045, and s_state == 0x50, all of which are invalid IMO. Having s_l2bsize == 0xda0c causes this UBSAN warning:   UBSAN: shift-out-of-bounds in fs/jfs/jfs_mount.c:373:25   shift exponent -9716 is negative  s_l2bsize can be tested for correctness. pad can be tested for non-0 and punted. s_state can be tested for its valid values and punted.  Do those 3 tests and if any of them fails, report the superblock as invalid/corrupt and let fsck handle it.  With this patch, chkSuper() says this when JFS_DEBUG is enabled:   jfs_mount: Mount Failure: superblock is corrupt!   Mount JFS Failure: -22   jfs_mount failed w/return code = -22  The obvious problem with this method is that next week there could be another syzbot test that uses different fields for invalid values, this making this like a game of whack-a-mole.  syzkaller link: https://syzkaller.appspot.com/bug?extid=36315852ece4132ec193  ",3bef198f1b17d1bb89260bad947ef084c0a2d1a6,1
PM / hibernate: Fix oops at snapshot_write(),syzbot is reporting NULL pointer dereference at snapshot_write() [1]. This is because data->handle is zero-cleared by ioctl(SNAPSHOT_FREE). Fix this by checking data_of(data->handle) != NULL before using it.  [1] https://syzkaller.appspot.com/bug?id=828a3c71bd344a6de8b6a31233d51a72099f27fd  ,fc14eebfc20854a38fd9f1d93a42b1783dad4d17,1
ext4: fix race writing to an inline_data file while its xattrs are changing,"The location of the system.data extended attribute can change whenever xattr_sem is not taken.  So we need to recalculate the i_inline_off field since it mgiht have changed between ext4_write_begin() and ext4_write_end().  This means that caching i_inline_off is probably not helpful, so in the long run we should probably get rid of it and shrink the in-memory ext4 inode slightly, but let's fix the race the simple way for now.  ",a54c4613dac1500b40e4ab55199f7c51f028e848,1
"compiler_types.h: Add __no_sanitize_{address,undefined} to noinstr","Adds the portable definitions for __no_sanitize_address, and __no_sanitize_undefined, and subsequently changes noinstr to use the attributes to disable instrumentation via KASAN or UBSAN.  ",5144f8a8dfd7b3681f0a2b5bf599a210b2315018,1
net: avoid skb_warn_bad_offload on IS_ERR,"skb_warn_bad_offload warns when packets enter the GSO stack that require skb_checksum_help or vice versa. Do not warn on arbitrary bad packets. Packet sockets can craft many. Syzkaller was able to demonstrate another one with eth_type games.  In particular, suppress the warning when segmentation returns an error, which is for reasons other than checksum offload.  See also commit 36c92474498a (""net: WARN if skb_checksum_help() is called on skb requiring segmentation"") for context on this warning.  ",8d74e9f88d65af8bb2e095aff506aa6eac755ada,0
tuntap: fix use after free during release,"After commit b196d88aba8a (""tun: fix use after free for ptr_ring"") we need clean up tx ring during release(). But unfortunately, it tries to do the cleanup blindly after socket were destroyed which will lead another use-after-free. Fix this by doing the cleanup before dropping the last reference of the socket in __tun_detach().  ",7063efd33bb15abc0160347f89eb5aba6b7d000e,1
tipc: fix shutdown() of connectionless socket,"syzbot is reporting hung task at nbd_ioctl() [1], for there are two problems regarding TIPC's connectionless socket's shutdown() operation.  ",2a63866c8b51a3f72cea388dfac259d0e14c4ba6,0
USB: fix error handling in usb_driver_claim_interface(),"The syzbot fuzzing project found a use-after-free bug in the USB core.  The bug was caused by usbfs not unbinding from an interface when the USB device file was closed, which led another process to attempt the unbind later on, after the private data structure had been deallocated.  The reason usbfs did not unbind the interface at the appropriate time was because it thought the interface had never been claimed in the first place.  This was caused by the fact that usb_driver_claim_interface() does not clean up properly when device_bind_driver() returns an error.  Although the error code gets passed back to the caller, the iface->dev.driver pointer remains set and iface->condition remains equal to USB_INTERFACE_BOUND.  This patch adds proper error handling to usb_driver_claim_interface().  ",bd729f9d67aa9a303d8925bb8c4f06af25f407d1,1
gfs2: Fix memory leak when gfs2meta's fs_context is freed,"gfs2 and gfs2meta share an ->init_fs_context function which allocates an args structure stored in fc->fs_private. gfs2 registers a ->free function to free this memory when the fs_context is cleaned up, but there was not one registered for gfs2meta, causing a leak.  Register a ->free function for gfs2meta. The existing gfs2_fc_free function does what we need.  ",30aecae86e914f526a2ca8d552011960ef6a2615,1
sctp: remove sched init from sctp_stream_init,syzbot reported a NULL-ptr deref caused by that sched->init() in sctp_stream_init() set stream->rr_next = NULL.    kasan: GPF could be caused by NULL-ptr deref or user memory access   ,2e990dfd13974d9eae493006f42ffb48707970ef,1
"Revert ""tipc: use consistent GFP flags""","This reverts commit 86c3a3e964d910a62eeb277d60b2a60ebefa9feb.  The tipc_aead_init() function can be calling from an interrupt routine. This allocation might sleep with GFP_KERNEL flag, hence the following BUG is reported.  ",f845fe5819efc4111c456c102f15db6d9ed3406e,1
io_uring: fix data race to avoid potential NULL-deref,"Commit ba5ef6dc8a82 (""io_uring: fortify tctx/io_wq cleanup"") introduced setting tctx->io_wq to NULL a bit earlier. This has caused KCSAN to detect a data race between accesses to tctx->io_wq:    write to 0xffff88811d8df330 of 8 bytes by task 3709 on cpu 1:    io_uring_clean_tctx                  fs/io_uring.c:9042 [inline]    __io_uring_cancel                    fs/io_uring.c:9136    io_uring_files_cancel                include/linux/io_uring.h:16 [inline]    do_exit                              kernel/exit.c:781    do_group_exit                        kernel/exit.c:923    get_signal                           kernel/signal.c:2835    arch_do_signal_or_restart            arch/x86/kernel/signal.c:789    handle_signal_work                   kernel/entry/common.c:147 [inline]    exit_to_user_mode_loop               kernel/entry/common.c:171 [inline]    ...   read to 0xffff88811d8df330 of 8 bytes by task 6412 on cpu 0:    io_uring_try_cancel_iowq             fs/io_uring.c:8911 [inline]    io_uring_try_cancel_requests         fs/io_uring.c:8933    io_ring_exit_work                    fs/io_uring.c:8736    process_one_work                     kernel/workqueue.c:2276    ...  With the config used, KCSAN only reports data races with value changes: this implies that in the case here we also know that tctx->io_wq was non-NULL. Therefore, depending on interleaving, we may end up with:                [CPU 0]                 |        [CPU 1]   io_uring_try_cancel_iowq()          | io_uring_clean_tctx()     if (!tctx->io_wq) // false        |   ...     ...                               |   tctx->io_wq = NULL     io_wq_cancel_cb(tctx->io_wq, ...) |   ...       -> NULL-deref                   |  Note: It is likely that thus far we've gotten lucky and the compiler optimizes the double-read into a single read into a register -- but this is never guaranteed, and can easily change with a different config!  Fix the data race by restoring the previous behaviour, where both setting io_wq to NULL and put of the wq are _serialized_ after concurrent io_uring_try_cancel_iowq() via acquisition of the uring_lock and removal of the node in io_uring_del_task_file().  ",b16ef427adf31fb4f6522458d37b3fe21d6d03b8,1
sctp: Define usercopy region in SCTP proto slab cache,"The SCTP socket event notification subscription information need to be copied to/from userspace. In support of usercopy hardening, this patch defines a region in the struct proto slab cache in which userspace copy operations are allowed. Additionally moves the usercopy fields to be adjacent for the region to cover both.  example ",ab9ee8e38b292f9a6698a4fedbb6ff8d08ce2012,0
media: mceusb: return without resubmitting URB in case of -EPROTO error.,"Syzkaller reported a warning called ""rcu detected stall in dummy_timer"".  The error seems to be an error in mceusb_dev_recv(). In the case of -EPROTO error, the routine immediately resubmits the URB. Instead it should return without resubmitting URB.  ",476db72e521983ecb847e4013b263072bb1110fc,0
xfrm: clean up xfrm protocol checks,"In commit 6a53b7593233 (""xfrm: check id proto in validate_tmpl()"") I introduced a check for xfrm protocol, but according to Herbert IPSEC_PROTO_ANY should only be used as a wildcard for lookup, so it should be removed from validate_tmpl().  And, IPSEC_PROTO_ANY is expected to only match 3 IPSec-specific protocols, this is why xfrm_state_flush() could still miss IPPROTO_ROUTING, which leads that those entries are left in net->xfrm.state_all before exit net. Fix this by replacing IPSEC_PROTO_ANY with zero.  This patch also extracts the check from validate_tmpl() to xfrm_id_proto_valid() and uses it in parse_ipsecrequest(). With this, no other protocols should be added into xfrm.  ",dbb2483b2a46fbaf833cfb5deb5ed9cace9c7399,0
io_uring: fix cancel of deferred reqs with ->files,"While trying to cancel requests with ->files, it also should look for requests in ->defer_list, otherwise it might end up hanging a thread.  Cancel all requests in ->defer_list up to the last request there with matching ->files, that's needed to follow drain ordering semantics.  ",b7ddce3cbf010edbfac6c6d8cc708560a7bcd7a4,0
ext4: annotate data race in start_this_handle(),Access to journal->j_running_transaction is not protected by appropriate lock and thus is racy. We are well aware of that and the code handles the race properly. Just add a comment and data_race() annotation.  ,3b1833e92baba135923af4a07e73fe6e54be5a2f,1
RDMA/nldev: Check stat attribute before accessing it,"The access to non-existent netlink attribute causes to the following kernel panic. Fix it by checking existence before trying to read it.    general protection fault, probably for non-canonical address 0xdffffc0000000000: 0000 [#1] PREEMPT SMP KASAN   KASAN: null-ptr-deref in range [0x0000000000000000-0x0000000000000007]   CPU: 0 PID: 6744 Comm: syz-executor.0 Not tainted 5.15.0-syzkaller #0   Hardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 01/01/2011   ",d821f7c13ca03318ad1bdc64ce64afb43080a07a,1
Input: do not use WARN() in input_alloc_absinfo(),"Some of fuzzers set panic_on_warn=1 so that they can handle WARN()ings the same way they handle full-blown kernel crashes. We used WARN() in input_alloc_absinfo() to get a better idea where memory allocation failed, but since then kmalloc() and friends started dumping call stack on memory allocation failures anyway, so we are not getting anything extra from WARN().  Because of the above, let's replace WARN with dev_err(). We use dev_err() instead of simply removing message and relying on kcalloc() to give us stack dump so that we'd know the instance of hardware device to which we were trying to attach input device.  ",100294cee9a98bfd4d6cb2d1c8a8aef0e959b0c4,1
l2tp: use sk_dst_check() to avoid race on sk->sk_dst_cache,"In l2tp code, if it is a L2TP_UDP_ENCAP tunnel, tunnel->sk points to a UDP socket. User could call sendmsg() on both this tunnel and the UDP socket itself concurrently. As l2tp_xmit_skb() holds socket lock and call __sk_dst_check() to refresh sk->sk_dst_cache, while udpv6_sendmsg() is lockless and call sk_dst_check() to refresh sk->sk_dst_cache, there could be a race and cause the dst cache to be freed multiple times. So we fix l2tp side code to always call sk_dst_check() to garantee xchg() is called when refreshing sk->sk_dst_cache to avoid race conditions.  Syzkaller reported stack trace: BUG: KASAN: use-after-free in atomic_read include/asm-generic/atomic-instrumented.h:21 [inline] BUG: KASAN: use-after-free in atomic_fetch_add_unless include/linux/atomic.h:575 [inline] BUG: KASAN: use-after-free in atomic_add_unless include/linux/atomic.h:597 [inline] BUG: KASAN: use-after-free in dst_hold_safe include/net/dst.h:308 [inline] BUG: KASAN: use-after-free in ip6_hold_safe+0xe6/0x670 net/ipv6/route.c:1029 Read of size 4 at addr ffff8801aea9a880 by task syz-executor129/4829  CPU: 0 PID: 4829 Comm: syz-executor129 Not tainted 4.18.0-rc7-next-20180802+ #30 Hardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 01/01/2011 Call Trace:  __dump_stack lib/dump_stack.c:77 [inline]  dump_stack+0x1c9/0x2b4 lib/dump_stack.c:113  print_address_description+0x6c/0x20b mm/kasan/report.c:256  kasan_report_error mm/kasan/report.c:354 [inline]  kasan_report.cold.7+0x242/0x30d mm/kasan/report.c:412  check_memory_region_inline mm/kasan/kasan.c:260 [inline]  check_memory_region+0x13e/0x1b0 mm/kasan/kasan.c:267  kasan_check_read+0x11/0x20 mm/kasan/kasan.c:272  atomic_read include/asm-generic/atomic-instrumented.h:21 [inline]  atomic_fetch_add_unless include/linux/atomic.h:575 [inline]  atomic_add_unless include/linux/atomic.h:597 [inline]  dst_hold_safe include/net/dst.h:308 [inline]  ip6_hold_safe+0xe6/0x670 net/ipv6/route.c:1029  rt6_get_pcpu_route net/ipv6/route.c:1249 [inline]  ip6_pol_route+0x354/0xd20 net/ipv6/route.c:1922  ip6_pol_route_output+0x54/0x70 net/ipv6/route.c:2098  fib6_rule_lookup+0x283/0x890 net/ipv6/fib6_rules.c:122  ip6_route_output_flags+0x2c5/0x350 net/ipv6/route.c:2126  ip6_dst_lookup_tail+0x1278/0x1da0 net/ipv6/ip6_output.c:978  ip6_dst_lookup_flow+0xc8/0x270 net/ipv6/ip6_output.c:1079  ip6_sk_dst_lookup_flow+0x5ed/0xc50 net/ipv6/ip6_output.c:1117  udpv6_sendmsg+0x2163/0x36b0 net/ipv6/udp.c:1354  inet_sendmsg+0x1a1/0x690 net/ipv4/af_inet.c:798  sock_sendmsg_nosec net/socket.c:622 [inline]  sock_sendmsg+0xd5/0x120 net/socket.c:632  ___sys_sendmsg+0x51d/0x930 net/socket.c:2115  __sys_sendmmsg+0x240/0x6f0 net/socket.c:2210  __do_sys_sendmmsg net/socket.c:2239 [inline]  __se_sys_sendmmsg net/socket.c:2236 [inline]  __x64_sys_sendmmsg+0x9d/0x100 net/socket.c:2236  do_syscall_64+0x1b9/0x820 arch/x86/entry/common.c:290  entry_SYSCALL_64_after_hwframe+0x49/0xbe ",6d37fa49da1e8db8fb1995be22ac837ca41ac8a8,1
ax25: fix a use-after-free in ax25_fillin_cb(),"There are multiple issues here:  1. After freeing dev->ax25_ptr, we need to set it to NULL otherwise    we may use a dangling pointer.  2. There is a race between ax25_setsockopt() and device notifier as    reported by syzbot. Close it by holding RTNL lock.  3. We need to test if dev->ax25_ptr is NULL before using it.  ",c433570458e49bccea5c551df628d058b3526289,1
net_sched: fix ops->bind_class() implementations,"The current implementations of ops->bind_class() are merely searching for classid and updating class in the struct tcf_result, without invoking either of cl_ops->bind_tcf() or cl_ops->unbind_tcf(). This breaks the design of them as qdisc's like cbq use them to count filters too. This is why syzbot triggered the warning in cbq_destroy_class().  In order to fix this, we have to call cl_ops->bind_tcf() and cl_ops->unbind_tcf() like the filter binding path. This patch does so by refactoring out two helper functions __tcf_bind_filter() and __tcf_unbind_filter(), which are lockless and accept a Qdisc pointer, then teaching each implementation to call them correctly.  Note, we merely pass the Qdisc pointer as an opaque pointer to each filter, they only need to pass it down to the helper functions without understanding it at all.  ",2e24cd755552350b94a7617617c6877b8cbcb701,0
mm: fix VM_BUG_ON(PageTail) and BUG_ON(PageWriteback),"Twice now, when exercising ext4 looped on shmem huge pages, I have crashed on the PF_ONLY_HEAD check inside PageWaiters(): ext4_finish_bio() calling end_page_writeback() calling wake_up_page() on tail of a shmem huge page, no longer an ext4 page at all.  The problem is that PageWriteback is not accompanied by a page reference (as the NOTE at the end of test_clear_page_writeback() acknowledges): as soon as TestClearPageWriteback has been done, that page could be removed from page cache, freed, and reused for something else by the time that wake_up_page() is reached.  https://lore.kernel.org/linux-mm/20200827122019.GC14765@casper.infradead.org/ Matthew Wilcox suggested avoiding or weakening the PageWaiters() tail check; but I'm paranoid about even looking at an unreferenced struct page, lest its memory might itself have already been reused or hotremoved (and wake_up_page_bit() may modify that memory with its ClearPageWaiters()).  Then on crashing a second time, realized there's a stronger reason against that approach.  If my testing just occasionally crashes on that check, when the page is reused for part of a compound page, wouldn't it be much more common for the page to get reused as an order-0 page before reaching wake_up_page()?  And on rare occasions, might that reused page already be marked PageWriteback by its new user, and already be waited upon?  What would that look like?  It would look like BUG_ON(PageWriteback) after wait_on_page_writeback() in write_cache_pages() (though I have never seen that crash myself).  Matthew Wilcox explaining this to himself:  ""page is allocated, added to page cache, dirtied, writeback starts,    ",073861ed77b6b957c3c8d54a11dc503f7d986ceb,1
net: correct udp zerocopy refcnt also when zerocopy only on append,"The below patch fixes an incorrect zerocopy refcnt increment when appending with MSG_MORE to an existing zerocopy udp skb.    send(.., MSG_ZEROCOPY | MSG_MORE);	// refcnt 1   send(.., MSG_ZEROCOPY | MSG_MORE);	// refcnt still 1 (bar frags)  But it missed that zerocopy need not be passed at the first send. The right test whether the uarg is newly allocated and thus has extra refcnt 1 is not !skb, but !skb_zcopy.    send(.., MSG_MORE);			// <no uarg>   send(.., MSG_ZEROCOPY);		// refcnt 1  ",522924b583082f51b8a2406624a2f27c22119b20,0
xsk: silence warning on memory allocation failure,syzkaller reported a warning from xdp_umem_pin_pages():    ,a343993c518ce252b62ec00ac06bccfb1d17129d,1
afs: Fix memory leak when mounting with multiple source parameters,"There's a memory leak in afs_parse_source() whereby multiple source= parameters overwrite fc->source in the fs_context struct without freeing the previously recorded source.  Fix this by only permitting a single source parameter and rejecting with an error all subsequent ones.  This was caught by syzbot with the kernel memory leak detector, showing something like the following trace:    unreferenced object 0xffff888114375440 (size 32):     comm ""repro"", pid 5168, jiffies 4294923723 (age 569.948s)     backtrace:       slab_post_alloc_hook+0x42/0x79       __kmalloc_track_caller+0x125/0x16a       kmemdup_nul+0x24/0x3c       vfs_parse_fs_string+0x5a/0xa1       generic_parse_monolithic+0x9d/0xc5       do_new_mount+0x10d/0x15a       do_mount+0x5f/0x8e       __do_sys_mount+0xff/0x127       do_syscall_64+0x2d/0x3a       entry_SYSCALL_64_after_hwframe+0x44/0xa9  ",4cb682964706deffb4861f0a91329ab3a705039f,1
i2c: robotfuzz-osif: fix control-request directions,The direction of the pipe argument must match the request-type direction bit or control requests may fail depending on the host-controller-driver implementation.  Control transfers without a data stage are treated as OUT requests by the USB stack and should be using usb_sndctrlpipe(). Failing to do so will now trigger a warning.  Fix the OSIFI2C_SET_BIT_RATE and OSIFI2C_STOP requests which erroneously used the osif_usb_read() helper and set the IN direction bit.  ,4ca070ef0dd885616ef294d269a9bf8e3b258e1a,0
net: memcg: fix lockdep splat in inet_csk_accept(),"Locking newsk while still holding the listener lock triggered a lockdep splat [1]  We can simply move the memcg code after we release the listener lock, as this can also help if multiple threads are sharing a common listener.  Also fix a typo while reading socket sk_rmem_alloc.  [1] ",06669ea346e476a5339033d77ef175566a40efbb,0
selinux: ensure the context is NUL terminated in security_context_to_sid_core(),The syzbot/syzkaller automated tests found a problem in security_context_to_sid_core() during early boot (before we load the SELinux policy) where we could potentially feed context strings without NUL terminators into the strcmp() function.  We already guard against this during normal operation (after the SELinux policy has been loaded) by making a copy of the context strings and explicitly adding a NUL terminator to the end.  The patch extends this protection to the early boot case (no loaded policy) by moving the context copy earlier in security_context_to_sid_core().  ,ef28df55ac27e1e5cd122e19fa311d886d47a756,1
mm: shmem: disable interrupt when acquiring info->lock in userfaultfd_copy path,Syzbot reported the below lockdep splat:      ,94b7cc01da5a3cc4f3da5e0ff492ef008bb555d6,0
posix-timer: Properly check sigevent->sigev_notify,"timer_create() specifies via sigevent->sigev_notify the signal delivery for the new timer. The valid modes are SIGEV_NONE, SIGEV_SIGNAL, SIGEV_THREAD and (SIGEV_SIGNAL | SIGEV_THREAD_ID).  The sanity check in good_sigevent() is only checking the valid combination for the SIGEV_THREAD_ID bit, i.e. SIGEV_SIGNAL, but if SIGEV_THREAD_ID is not set it accepts any random value.  This has no real effects on the posix timer and signal delivery code, but it affects show_timer() which handles the output of /proc/$PID/timers. That function uses a string array to pretty print sigev_notify. The access to that array has no bound checks, so random sigev_notify cause access beyond the array bounds.  Add proper checks for the valid notify modes and remove the SIGEV_THREAD_ID masking from various code pathes as SIGEV_NONE can never be set in combination with SIGEV_THREAD_ID.  ",cef31d9af908243421258f1df35a4a644604efbe,1
USB: core: Make do_proc_control() and do_proc_bulk() killable,"The USBDEVFS_CONTROL and USBDEVFS_BULK ioctls invoke usb_start_wait_urb(), which contains an uninterruptible wait with a user-specified timeout value.  If timeout value is very large and the device being accessed does not respond in a reasonable amount of time, the kernel will complain about ""Task X blocked for more than N seconds"", as found in testing by syzbot:  INFO: task syz-executor.0:8700 blocked for more than 143 seconds.       Not tainted 5.14.0-rc7-syzkaller #0 ""echo 0 > /proc/sys/kernel/hung_task_timeout_secs"" disables this message. ",ae8709b296d80c7f45aa1f35c0e7659ad69edce1,1
Bluetooth: Fix null pointer dereference in hci_event_packet(),"AMP_MGR is getting derefernced in hci_phy_link_complete_evt(), when called from hci_event_packet() and there is a possibility, that hcon->amp_mgr may not be found when accessing after initialization of hcon.  - net/bluetooth/hci_event.c:4945 The bug seems to get triggered in this line:  bredr_hcon = hcon->amp_mgr->l2cap_conn->hcon;  Fix it by adding a NULL check for the hcon->amp_mgr before checking the ev-status.  ",6dfccd13db2ff2b709ef60a50163925d477549aa,1
reiserfs: add check for an invalid ih_entry_count,when directory item has an invalid value set for ih_entry_count it might trigger use-after-free or out-of-bounds read in bin_search_in_dir_item()  ih_entry_count * IH_SIZE for directory item should not be larger than ih_item_len  ,d24396c5290ba8ab04ba505176874c4e04a2d53c,1
io_uring: defer file table grabbing request cleanup for locked requests,"If we're in the error path failing links and we have a link that has grabbed a reference to the fs_struct, then we cannot safely drop our reference to the table if we already hold the completion lock. This adds a hardirq dependency to the fs_struct->lock, which it currently doesn't have.  Defer the final cleanup and free of such requests to avoid adding this dependency.  ",51a4cc112c7a42b62a91bcccdfac42e7c4561729,0
media: gspca: Fix memory leak in probe,"The gspca driver leaks memory when a probe fails.  gspca_dev_probe2() calls v4l2_device_register(), which takes a reference to the underlying device node (in this case, a USB interface).  But the failure pathway neglects to call v4l2_device_unregister(), the routine responsible for dropping this reference.  Consequently the memory for the USB interface and its device never gets released.  This patch adds the missing function call.  ",e469d0b09a19496e1972a20974bbf55b728151eb,1
can: af_can: can_rx_unregister(): remove WARN() statement from list operation sanity check,To detect potential bugs in CAN protocol implementations (double removal of receiver entries) a WARN() statement has been used if no matching list item was found for removal.  The fault injection issued by syzkaller was able to create a situation where the closing of a socket runs simultaneously to the notifier call chain for removing the CAN network device in use.  This case is very unlikely in real life but it doesn't break anything. Therefore we just replace the WARN() statement with pr_warn() to preserve the notification for the CAN protocol development.  ,d73ff9b7c4eacaba0fd956d14882bcae970f8307,1
net/xfrm: fix out-of-bounds packet access,BUG: KASAN: slab-out-of-bounds in _decode_session6+0x1331/0x14e0 net/ipv6/xfrm6_policy.c:161 Read of size 1 at addr ffff8801d882eec7 by task syz-executor1/6667 Call Trace:   __dump_stack lib/dump_stack.c:77 [inline]   dump_stack+0x1c9/0x2b4 lib/dump_stack.c:113   print_address_description+0x6c/0x20b mm/kasan/report.c:256   kasan_report_error mm/kasan/report.c:354 [inline]   kasan_report.cold.7+0x242/0x30d mm/kasan/report.c:412   __asan_report_load1_noabort+0x14/0x20 mm/kasan/report.c:430   _decode_session6+0x1331/0x14e0 net/ipv6/xfrm6_policy.c:161   __xfrm_decode_session+0x71/0x140 net/xfrm/xfrm_policy.c:2299   xfrm_decode_session include/net/xfrm.h:1232 [inline]   vti6_tnl_xmit+0x3c3/0x1bc1 net/ipv6/ip6_vti.c:542   __netdev_start_xmit include/linux/netdevice.h:4313 [inline]   netdev_start_xmit include/linux/netdevice.h:4322 [inline]   xmit_one net/core/dev.c:3217 [inline]   dev_hard_start_xmit+0x272/0xc10 net/core/dev.c:3233   __dev_queue_xmit+0x2ab2/0x3870 net/core/dev.c:3803   dev_queue_xmit+0x17/0x20 net/core/dev.c:3836  ,9f7e43da6ae4862b48bac233838ba808c1167a0d,1
net: cipso: fix warnings in netlbl_cipsov4_add_std,"Syzbot reported warning in netlbl_cipsov4_add(). The problem was in too big doi_def->map.std->lvl.local_size passed to kcalloc(). Since this value comes from userpace there is no need to warn if value is not correct.  The same problem may occur with other kcalloc() calls in this function, so, I've added __GFP_NOWARN flag to all kcalloc() calls there.  ",8ca34a13f7f9b3fa2c464160ffe8cc1a72088204,0
KVM/Eventfd: Avoid crash when assign and deassign specific eventfd in parallel.,"Syzbot reports crashes in kvm_irqfd_assign(), caused by use-after-free when kvm_irqfd_assign() and kvm_irqfd_deassign() run in parallel for one specific eventfd. When the assign path hasn't finished but irqfd has been added to kvm->irqfds.items list, another thead may deassign the eventfd and free struct kvm_kernel_irqfd(). The assign path then uses the struct kvm_kernel_irqfd that has been freed by deassign path. To avoid such issue, keep irqfd under kvm->irq_srcu protection after the irqfd has been added to kvm->irqfds.items list, and call synchronize_srcu() in irq_shutdown() to make sure that irqfd has been fully initialized in the assign path.  ",b5020a8e6b54d2ece80b1e7dedb33c79a40ebd47,1
ALSA: ctl: Workaround for lockdep warning wrt card->ctl_files_rwlock,"The recent change in lockdep for read lock caused the deadlock warnings in ALSA control code which uses the read_lock() for notification and else while write_lock_irqsave() is used for adding and removing the list entry.  Although a deadlock would practically never hit in a real usage (the addition and the deletion can't happen with the notification), it's better to fix the read_lock() usage in a semantically correct way.  This patch replaces the read_lock() calls with read_lock_irqsave() version for avoiding a reported deadlock.  The notification code path takes the irq disablement in anyway, and other code paths are very short execution, hence there shouldn't be any big performance hit by this change.  ",6564d0ad67efb2d977e130e7448505ee538af016,0
net: netlink: af_netlink: Prevent empty skb by adding a check on len.,Adding a check on len parameter to avoid empty skb. This prevents a division error in netem_enqueue function which is caused when skb->len=0 and skb->data_len=0 in the randomized corruption step as shown below.  skb->data[prandom_u32() % skb_headlen(skb)] ^= 1<<(prandom_u32() % 8);  ,f123cffdd8fe8ea6c7fded4b88516a42798797d0,1
RDS: Check cmsg_len before dereferencing CMSG_DATA,"RDS currently doesn't check if the length of the control message is large enough to hold the required data, before dereferencing the control message data. This results in following crash:  BUG: KASAN: stack-out-of-bounds in rds_rdma_bytes net/rds/send.c:1013 [inline] BUG: KASAN: stack-out-of-bounds in rds_sendmsg+0x1f02/0x1f90 net/rds/send.c:1066 Read of size 8 at addr ffff8801c928fb70 by task syzkaller455006/3157  CPU: 0 PID: 3157 Comm: syzkaller455006 Not tainted 4.15.0-rc3+ #161 Hardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 01/01/2011 Call Trace:  __dump_stack lib/dump_stack.c:17 [inline]  dump_stack+0x194/0x257 lib/dump_stack.c:53  print_address_description+0x73/0x250 mm/kasan/report.c:252  kasan_report_error mm/kasan/report.c:351 [inline]  kasan_report+0x25b/0x340 mm/kasan/report.c:409  __asan_report_load8_noabort+0x14/0x20 mm/kasan/report.c:430  rds_rdma_bytes net/rds/send.c:1013 [inline]  rds_sendmsg+0x1f02/0x1f90 net/rds/send.c:1066  sock_sendmsg_nosec net/socket.c:628 [inline]  sock_sendmsg+0xca/0x110 net/socket.c:638  ___sys_sendmsg+0x320/0x8b0 net/socket.c:2018  __sys_sendmmsg+0x1ee/0x620 net/socket.c:2108  SYSC_sendmmsg net/socket.c:2139 [inline]  SyS_sendmmsg+0x35/0x60 net/socket.c:2134  entry_SYSCALL_64_fastpath+0x1f/0x96 ",14e138a86f6347c6199f610576d2e11c03bec5f0,1
mm: fix vma_is_anonymous() false-positives,vma_is_anonymous() relies on ->vm_ops being NULL to detect anonymous VMA.  This is unreliable as ->mmap may not set ->vm_ops.  False-positive vma_is_anonymous() may lead to crashes:  	next ffff8801ce5e7040 prev ffff8801d20eca50 mm ffff88019c1e13c0 	prot 27 anon_vma ffff88019680cdd8 vm_ops 0000000000000000 	pgoff 0 file ffff8801b2ec2d00 private_data 0000000000000000 	flags: 0xff(read|write|exec|shared|mayread|maywrite|mayexec|mayshare) 	,bfd40eaff5abb9f62c8ef94ca13ed0d94a560f10,1
rds: rds_msg_zcopy should return error of null rm->data.op_mmp_znotifier,"if either or both of MSG_ZEROCOPY and SOCK_ZEROCOPY have not been specified, the rm->data.op_mmp_znotifier allocation will be skipped. In this case, it is invalid ot pass down a cmsghdr with RDS_CMSG_ZCOPY_COOKIE, so return EINVAL from rds_msg_zcopy for this case.  ",79a5b9727a1cceacd49921b78425ebda91836bd6,0
tty/n_hdlc: fix __might_sleep warning,Fix __might_sleep warning[1] in tty/n_hdlc.c read due to copy_to_user call while current is TASK_INTERRUPTIBLE.  This is a false positive since the code path does not depend on current state remaining TASK_INTERRUPTIBLE.  The loop breaks out and sets TASK_RUNNING after calling copy_to_user.  This patch supresses the warning by setting TASK_RUNNING before calling copy_to_user.  [1] https://syzkaller.appspot.com/bug?id=17d5de7f1fcab794cb8c40032f893f52de899324  ,fc01d8c61ce02c034e67378cd3e645734bc18c8c,1
netfilter: use skb_to_full_sk in ip6_route_me_harder,"For some reason, Florian forgot to apply to ip6_route_me_harder the fix that went in commit 29e09229d9f2 (""netfilter: use skb_to_full_sk in ip_route_me_harder"")  ",7d98386d55a5afaa65de77e1e9197edeb8a42079,0
inet: fix various use-after-free in defrags units,"syzbot reported another issue caused by my recent patches. [1]  The issue here is that fqdir_exit() is initiating a work queue and immediately returns. A bit later cleanup_net() was able to free the MIB (percpu data) and the whole struct net was freed, but we had active frag timers that fired and triggered use-after-free.  We need to make sure that timers can catch fqdir->dead being set, to bailout.  Since RCU is used for the reader side, this means we want to respect an RCU grace period between these operations :  1) qfdir->dead = 1;  2) netns dismantle (freeing of various data structure)  This patch uses new new (struct pernet_operations)->pre_exit infrastructure to ensures a full RCU grace period happens between fqdir_pre_exit() and fqdir_exit()  This also means we can use a regular work queue, we no longer need rcu_work.  Tested:  $ time for i in {1..1000}; do unshare -n /bin/false;done  real	0m2.585s user	0m0.160s sys	0m2.214s  [1]  BUG: KASAN: use-after-free in ip_expire+0x73e/0x800 net/ipv4/ip_fragment.c:152 Read of size 8 at addr ffff88808b9fe330 by task syz-executor.4/11860  CPU: 1 PID: 11860 Comm: syz-executor.4 Not tainted 5.2.0-rc2+ #22 Hardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 01/01/2011 Call Trace:  <IRQ>  __dump_stack lib/dump_stack.c:77 [inline]  dump_stack+0x172/0x1f0 lib/dump_stack.c:113  print_address_description.cold+0x7c/0x20d mm/kasan/report.c:188  __kasan_report.cold+0x1b/0x40 mm/kasan/report.c:317  kasan_report+0x12/0x20 mm/kasan/common.c:614  __asan_report_load8_noabort+0x14/0x20 mm/kasan/generic_report.c:132  ip_expire+0x73e/0x800 net/ipv4/ip_fragment.c:152  call_timer_fn+0x193/0x720 kernel/time/timer.c:1322  expire_timers kernel/time/timer.c:1366 [inline]  __run_timers kernel/time/timer.c:1685 [inline]  __run_timers kernel/time/timer.c:1653 [inline]  run_timer_softirq+0x66f/0x1740 kernel/time/timer.c:1698  __do_softirq+0x25c/0x94c kernel/softirq.c:293  invoke_softirq kernel/softirq.c:374 [inline]  irq_exit+0x180/0x1d0 kernel/softirq.c:414  exiting_irq arch/x86/include/asm/apic.h:536 [inline]  smp_apic_timer_interrupt+0x13b/0x550 arch/x86/kernel/apic/apic.c:1068  apic_timer_interrupt+0xf/0x20 arch/x86/entry/entry_64.S:806  </IRQ> ",d5dd88794a13c2f24cce31abad7a0a6c5e0ed2db,1
"init, tracing: Add initcall trace events","Being able to trace the start and stop of initcalls is useful to see where the timings are an issue. There is already an ""initcall_debug"" parameter, but that can cause a large overhead itself, as the printing of the information may take longer than the initcall functions.  Adding in a start and finish trace event around the initcall functions, as well as a trace event that records the level of the initcalls, one can get a much finer measurement of the times and interactions of the initcalls themselves, as trace events are much lighter than printk()s.  Suggested-by: Abderrahmane Benbachir <abderrahmane.benbachir@polymtl.ca> ",4ee7c60de83ac01fa4c33c55937357601631e8ad,0
blk-mq: Keep set->nr_hw_queues and set->map[].nr_queues in sync,blk_mq_map_queues() and multiple .map_queues() implementations expect that set->map[HCTX_TYPE_DEFAULT].nr_queues is set to the number of hardware queues. Hence set .nr_queues before calling these functions. This patch fixes the following kernel warning:  ,6e66b49392419f3fe134e1be583323ef75da1e4b,0
ip: in cmsg IP(V6)_ORIGDSTADDR call pskb_may_pull,"Syzbot reported a read beyond the end of the skb head when returning IPV6_ORIGDSTADDR:    BUG: KMSAN: kernel-infoleak in put_cmsg+0x5ef/0x860 net/core/scm.c:242   CPU: 0 PID: 4501 Comm: syz-executor128 Not tainted 4.17.0+ #9   Hardware name: Google Google Compute Engine/Google Compute Engine, BIOS   Google 01/01/2011   Call Trace:     __dump_stack lib/dump_stack.c:77 [inline]     dump_stack+0x185/0x1d0 lib/dump_stack.c:113     kmsan_report+0x188/0x2a0 mm/kmsan/kmsan.c:1125     kmsan_internal_check_memory+0x138/0x1f0 mm/kmsan/kmsan.c:1219     kmsan_copy_to_user+0x7a/0x160 mm/kmsan/kmsan.c:1261     copy_to_user include/linux/uaccess.h:184 [inline]     put_cmsg+0x5ef/0x860 net/core/scm.c:242     ip6_datagram_recv_specific_ctl+0x1cf3/0x1eb0 net/ipv6/datagram.c:719     ip6_datagram_recv_ctl+0x41c/0x450 net/ipv6/datagram.c:733     rawv6_recvmsg+0x10fb/0x1460 net/ipv6/raw.c:521     [..]  This logic and its ipv4 counterpart read the destination port from the packet at skb_transport_offset(skb) + 4.  With MSG_MORE and a local SOCK_RAW sender, syzbot was able to cook a packet that stores headers exactly up to skb_transport_offset(skb) in the head and the remainder in a frag.  Call pskb_may_pull before accessing the pointer to ensure that it lies in skb head.  ",2efd4fca703a6707cad16ab486eaab8fc7f0fd49,1
tipc: fix a null pointer deref on error path,"In tipc_topsrv_kern_subscr() when s->tipc_conn_new() fails we call tipc_close_conn() to clean up, but in this case calling conn_put() is just enough.  This fixes the folllowing crash:   kasan: GPF could be caused by NULL-ptr deref or user memory access  general protection fault: 0000 [#1] SMP KASAN  Dumping ftrace buffer:     (ftrace buffer empty)  ",672ecbe1c977616aa720c9397589665b33e72610,1
netfilter: nf_tables: free flowtable hooks on hook register error,"If hook registration fails, the hooks allocated via nft_netdev_hook_alloc need to be freed.  We can't change the goto label to 'goto 5' -- while it does fix the memleak it does cause a warning splat from the netfilter core (the hooks were not registered).  ",2d285f26ecd072800a29c5b71e63437f21ef830a,0
KVM: x86: disable interrupts while pvclock_gtod_sync_lock is taken,pvclock_gtod_sync_lock can be taken with interrupts disabled if the preempt notifier calls get_kvmclock_ns to update the Xen ,a83829f56c7ce17d5d05370820e185d9a23d3090,0
KVM: VMX: do not use uninitialized gfn_to_hva_cache,"An uninitialized gfn_to_hva_cache has ghc->len == 0, which causes the accessors to croak very loudly.  While a BUG_ON is definitely _too_ loud and a bug on its own, there is indeed an issue of using the caches in such a way that they could not have been initialized, because ghc->gpa == 0 might match and thus kvm_gfn_to_hva_cache_init would not be called.  For the vmcs12_cache, the solution is simply to invoke kvm_gfn_to_hva_cache_init unconditionally: we already know that the cache does not match the current VMCS pointer. For the shadow_vmcs12_cache, there is no similar condition that checks the VMCS link pointer, so invalidate the cache on VMXON.  ",8503fea6761de32b72585001ac94e5f81ce8ca44,1
ath9k_htc: fix NULL pointer dereference at ath9k_htc_rxep(),"syzbot is reporting lockdep warning followed by kernel panic at ath9k_htc_rxep() [1], for ath9k_htc_rxep() depends on ath9k_rx_init() being already completed.  Since ath9k_htc_rxep() is set by ath9k_htc_connect_svc(WMI_BEACON_SVC)  from ath9k_init_htc_services(), it is possible that ath9k_htc_rxep() is called via timer interrupt before ath9k_rx_init() from ath9k_init_device() is called.  Since we can't call ath9k_init_device() before ath9k_init_htc_services(), let's hold ath9k_htc_rxep() no-op until ath9k_rx_init() completes.  ",b0ec7e55fce65f125bd1d7f02e2dc4de62abee34,1
"bpf: sockmap, consume_skb in close path","Currently, when a sock is closed and the bpf_tcp_close() callback is used we remove memory but do not free the skb. Call consume_skb() if the skb is attached to the buffer.  ",7ebc14d507b4b55105da8d1a1eda323381529cc7,0
mm: memcontrol: fix NULL-ptr deref in percpu stats flush,"__mem_cgroup_free() can be called on the failure path in mem_cgroup_alloc().  However memcg_flush_percpu_vmstats() and memcg_flush_percpu_vmevents() which are called from __mem_cgroup_free() access the fields of memcg which can potentially be null if called from failure path from mem_cgroup_alloc().  Indeed syzbot has reported the following crash:  	kasan: CONFIG_KASAN_INLINE enabled 	kasan: GPF could be caused by NULL-ptr deref or user memory access 	general protection fault: 0000 [#1] PREEMPT SMP KASAN 	CPU: 0 PID: 30393 Comm: syz-executor.1 Not tainted 5.4.0-rc2+ #0 	Hardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 01/01/2011 	",7961eee3978475fd9e8626137f88595b1ca05856,1
net: change addr_list_lock back to static key,"The dynamic key update for addr_list_lock still causes troubles, for example the following race condition still exists:  CPU 0:				CPU 1: (RCU read lock)			(RTNL lock) dev_mc_seq_show()		netdev_update_lockdep_key() 				  -> lockdep_unregister_key()  -> netif_addr_lock_bh()  because lockdep doesn't provide an API to update it atomically. Therefore, we have to move it back to static keys and use subclass for nest locking like before.  In commit 1a33e10e4a95 (""net: partially revert dynamic lockdep key changes""), I already reverted most parts of commit ab92d68fc22f (""net: core: add generic lockdep keys"").  This patch reverts the rest and also part of commit f3b0a18bb6cb (""net: remove unnecessary variables and callback""). After this patch, addr_list_lock changes back to using static keys and subclasses to satisfy lockdep. ",845e0ebb4408d4473cf60d21224a897037e9a77a,1
ip6mr: fix stale iterator,"When we dump the ip6mr mfc entries via proc, we initialize an iterator with the table to dump but we don't clear the cache pointer which might be initialized from a prior read on the same descriptor that ended. This can result in lock imbalance (an unnecessary unlock) leading to other crashes and hangs. Clear the cache pointer like ipmr does to fix the issue. Thanks for the reliable reproducer.  Here's syzbot's trace:  ",4adfa79fc254efb7b0eb3cd58f62c2c3f805f1ba,1
team: avoid complex list operations in team_nl_cmd_options_set(),"The current opt_inst_list operations inside team_nl_cmd_options_set() is too complex to track:      LIST_HEAD(opt_inst_list);     nla_for_each_nested(...) {         list_for_each_entry(opt_inst, &team->option_inst_list, list) {             if (__team_option_inst_tmp_find(&opt_inst_list, opt_inst))                 continue;             list_add(&opt_inst->tmp_list, &opt_inst_list);         }     }     team_nl_send_event_options_get(team, &opt_inst_list);  as while we retrieve 'opt_inst' from team->option_inst_list, it could be added to the local 'opt_inst_list' for multiple times. The __team_option_inst_tmp_find() doesn't work, as the setter team_mode_option_set() still calls team->ops.exit() which uses ->tmp_list too in __team_options_change_check().  Simplify the list operations by moving the 'opt_inst_list' and team_nl_send_event_options_get() into the nla_for_each_nested() loop so that it can be guranteed that we won't insert a same list entry for multiple times. Therefore, __team_option_inst_tmp_find() can be removed too.  ",2fdeee2549231b1f989f011bb18191f5660d3745,0
firmware_loader: fix use-after-free in firmware_fallback_sysfs,"This use-after-free happens when a fw_priv object has been freed but hasn't been removed from the pending list (pending_fw_head). The next time fw_load_sysfs_fallback tries to insert into the list, it ends up accessing the pending_list member of the previously freed fw_priv.  The root cause here is that all code paths that abort the fw load don't delete it from the pending list. For example:          _request_firmware()           -> fw_abort_batch_reqs()               -> fw_state_aborted()  To fix this, delete the fw_priv from the list in __fw_set_state() if the new state is DONE or ABORTED. This way, all aborts will remove the fw_priv from the list. Accordingly, remove calls to list_del_init that were being made before calling fw_state_(aborted|done).  Also, in fw_load_sysfs_fallback, don't add the fw_priv to the pending list if it is already aborted. Instead, just jump out and return early.  ",75d95e2e39b27f733f21e6668af1c9893a97de5e,1
rds: do not call ->conn_alloc with GFP_KERNEL,"Commit ebeeb1ad9b8a (""rds: tcp: use rds_destroy_pending() to synchronize netns/module teardown and rds connection/workq management"") adds an rcu read critical section to __rd_conn_create. The memory allocations in that critcal section need to use GFP_ATOMIC to avoid sleeping.  This patch was verified with syzkaller reproducer.  ",d4014d8cc6dfa964e3e66df525de2384e3583018,1
ALSA: pcm: oss: Remove WARNING from snd_pcm_plug_alloc() checks,The return value checks in snd_pcm_plug_alloc() are covered with snd_BUG_ON() macro that may trigger a kernel ,5461e0530c222129dfc941058be114b5cbc00837,1
net/802/garp: fix memleak in garp_request_join(),"I got kmemleak report when doing fuzz test:  BUG: memory leak unreferenced object 0xffff88810c909b80 (size 64):   comm ""syz"", pid 957, jiffies 4295220394 (age 399.090s)   ",42ca63f980842918560b25f0244307fd83b4777c,1
kvm: fix kvm_ioctl_create_device() reference counting (CVE-2019-6974),"kvm_ioctl_create_device() does the following:  1. creates a device that holds a reference to the VM object (with a borrowed    reference, the VM's refcount has not been bumped yet) 2. initializes the device 3. transfers the reference to the device to the caller's file descriptor table 4. calls kvm_get_kvm() to turn the borrowed reference to the VM into a real    reference  The ownership transfer in step 3 must not happen before the reference to the VM becomes a proper, non-borrowed reference, which only happens in step 4. After step 3, an attacker can close the file descriptor and drop the borrowed reference, which can cause the refcount of the kvm object to drop to zero.  This means that we need to grab a reference for the device before anon_inode_getfd(), otherwise the VM can disappear from under us.  ",cfa39381173d5f969daf43582c95ad679189cbc9,1
Input: usbtouchscreen - fix control-request directions,The direction of the pipe argument must match the request-type direction bit or control requests may fail depending on the host-controller-driver implementation.  Fix the four control requests which erroneously used usb_rcvctrlpipe().  ,41e81022a04a0294c55cfa7e366bc14b9634c66e,0
"bpf, sockmap: fix sock_hash_alloc and reject zero-sized keys","Currently, it is possible to create a sock hash map with key size of 0 and have the kernel return a fd back to user space. This is invalid for hash maps (and kernel also hasn't been tested for zero key size support in general at this point). Thus, reject such configuration.  ",b845c898b2f1ea458d5453f0fa1da6e2dfce3bb4,0
io_uring: fix potential ABBA deadlock in ->show_fdinfo(),syzbot reports a potential lock deadlock between the normal IO path and ->show_fdinfo():  ,fad8e0de4426a776c9bcb060555e7c09e2d08db6,0
USB: serial: io_edgeport: fix memory leak in edge_startup,"sysbot found memory leak in edge_startup(). The problem was that when an error was received from the usb_submit_urb(), nothing was cleaned up.  ",cfdc67acc785e01a8719eeb7012709d245564701,1
can: af_can: canfd_rcv(): replace WARN_ONCE by pr_warn_once,"If an invalid CANFD frame is received, from a driver or from a tun interface, a Kernel warning is generated.  This patch replaces the WARN_ONCE by a simple pr_warn_once, so that a kernel, bootet with panic_on_warn, does not panic. A printk seems to be more appropriate here.  ",d4689846881d160a4d12a514e991a740bcb5d65a,0
net: mdiobus: Fix memory leak in __mdiobus_register,"Once device_register() failed, we should call put_device() to decrement reference count for cleanup. Or it will cause memory leak.  BUG: memory leak unreferenced object 0xffff888114032e00 (size 256):   comm ""kworker/1:3"", pid 2960, jiffies 4294943572 (age 15.920s)   ",ab609f25d19858513919369ff3d9a63c02cd9e2e,1
net/hsr: fix possible crash in add_timer(),"syzbot found another add_timer() issue, this time in net/hsr [1]  Let's use mod_timer() which is safe.  [1] kernel BUG at kernel/time/timer.c:1136! invalid opcode: 0000 [#1] PREEMPT SMP KASAN CPU: 0 PID: 15909 Comm: syz-executor.3 Not tainted 5.0.0+ #97 Hardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 01/01/2011 kobject: 'loop2' (00000000f5629718): kobject_uevent_env ",1e027960edfaa6a43f9ca31081729b716598112b,1
llc: fix NULL pointer deref for SOCK_ZAPPED,"For SOCK_ZAPPED socket, we don't need to care about llc->sap, so we should just skip these refcount functions in this case.  ",3a04ce7130a7e5dad4e78d45d50313747f8c830f,0
net: ieee802154: forbid monitor for set llsec params,This patch forbids to set llsec params for monitor interfaces which we don't support yet.  ,88c17855ac4291fb462e13a86b7516773b6c932e,0
"cipso,calipso: resolve a number of problems with the DOI refcounts","The current CIPSO and CALIPSO refcounting scheme for the DOI definitions is a bit flawed in that we:  1. Don't correctly match gets/puts in netlbl_cipsov4_list(). 2. Decrement the refcount on each attempt to remove the DOI from the    DOI list, only removing it from the list once the refcount drops    to zero.  This patch fixes these problems by adding the missing ""puts"" to netlbl_cipsov4_list() and introduces a more conventional, i.e. not-buggy, refcounting mechanism to the DOI definitions.  Upon the addition of a DOI to the DOI list, it is initialized with a refcount of one, removing a DOI from the list removes it from the list and drops the refcount by one; ""gets"" and ""puts"" behave as expected with respect to refcounts, increasing and decreasing the DOI's refcount by one.  ",ad5d07f4a9cd671233ae20983848874731102c08,0
inet_diag: bc: read cgroup id only for full sockets,"Fix bug introduced by commit b1f3e43dbfac (""inet_diag: add support for cgroup filter"").  ",ee1bd483cc062d5050f9537064651dd2e06baee7,0
io-wq: wait for io_wq_create() to setup necessary workers,"We currently have a race where if setup is really slow, we can be calling io_wq_destroy() before we're done setting up. This will cause the caller to get stuck waiting for the manager to set things up, but the manager already exited.  Fix this by doing a sync setup of the manager. This also fixes the case where if we failed creating workers, we'd also get stuck.  In practice this race window was really small, as we already wait for the manager to start. Hence someone would have to call io_wq_destroy() after the task has started, but before it started the first loop. The reported test case forked tons of these, which is why it became an issue.  ",b60fda6000a99a7ccac36005ab78b14b47c06de3,1
fib: fib_dump_info can no longer use __in_dev_get_rtnl,"syzbot reported yet another regression added with DOIT_UNLOCKED. When nexthop is marked as dead, fib_dump_info uses __in_dev_get_rtnl():  ./include/linux/inetdevice.h:230 suspicious rcu_dereference_protected() usage! rcu_scheduler_active = 2, debug_locks = 1 1 lock held by syz-executor2/23859:  #0:  (rcu_read_lock){....}, at: [<ffffffff840283f0>] inet_rtm_getroute+0xaa0/0x2d70 net/ipv4/route.c:2738 [..]   lockdep_rcu_suspicious+0x123/0x170 kernel/locking/lockdep.c:4665   __in_dev_get_rtnl include/linux/inetdevice.h:230 [inline]   fib_dump_info+0x1136/0x13d0 net/ipv4/fib_semantics.c:1377   inet_rtm_getroute+0xf97/0x2d70 net/ipv4/route.c:2785 ..  This isn't safe anymore, callers either hold RTNL mutex or rcu read lock, so these spots must use rcu_dereference_rtnl() or plain rcu_derefence() (plus unconditional rcu read lock).  This does the latter.  ",25dd169aea6553aea548197a5d4580bbdeda1c85,1
net: usb: asix: init MAC address buffers,This is for fixing bug KMSAN: uninit-value in ax88772_bind  Tested by https://groups.google.com/d/msg/syzkaller-bugs/aFQurGotng4/eB_HlNhhCwAJ  ,78226f6eaac80bf30256a33a4926c194ceefdf36,1
tipc: Fix NULL pointer dereference in __tipc_sendstream(),"tipc_sendstream() may send zero length packet, then tipc_msg_append() do not alloc skb, skb_peek_tail() will get NULL, msg_set_ack_required will trigger NULL pointer dereference.  ",4c21daae3dbc9f8536cc18e6e53627821fa2c90c,1
autofs: simplify parse_options() function call,"The parse_options() function uses a long list of parameters, most of which are present in the super block info structure already.  The mount parameters set in parse_options() options don't require cleanup so using the super block info struct directly is simpler.  ",9bf964c9cee40285808ce973be7a266876404501,0
rtlwifi: rise completion at the last step of firmware callback,"request_firmware_nowait() which schedules another work is used to load firmware when USB is probing. If USB is unplugged before running the firmware work, it goes disconnect ops, and then causes use-after-free. Though we wait for completion of firmware work before freeing the hw, firmware callback rises completion too early. So I move it to the last step.  usb 5-1: Direct firmware load for rtlwifi/rtl8192cufw.bin failed with error -2 rtlwifi: Loading alternative firmware rtlwifi/rtl8192cufw.bin rtlwifi: Selected firmware is not available ",4dfde294b9792dcf8615b55c58f093d544f472f0,1
RDMA/ucma: Check AF family prior resolving address,"Garbage supplied by user will cause to UCMA module provide zero memory size for memcpy(), because it wasn't checked, it will produce unpredictable results in rdma_resolve_addr().  ",2975d5de6428ff6d9317e9948f0968f7d42e5d74,0
ALSA: timer: Make snd_timer_close() really kill pending actions,"snd_timer_close() is supposed to close the timer instance and sync with the deactivation of pending actions.  However, there are still some overlooked cases:  - It calls snd_timer_stop() at the beginning, but some other might   re-trigger the timer right after that.  - snd_timer_stop() calls del_timer_sync() only when all belonging   instances are closed.  If multiple instances were assigned to a   timer object and one is closed, the timer is still running.  Then   the pending action assigned to this timer might be left.  Actually either of the above is the likely cause of the reported syzkaller UAF.  This patch plug these holes by introducing SNDRV_TIMER_IFLG_DEAD flag.  This is set at the beginning of snd_timer_close(), and the flag is checked at snd_timer_start*() and else, so that no longer new action is left after snd_timer_close().  ",fe1b26c93d430400ac37d820425e2468218ae8b2,1
dnotify: Handle errors from fsnotify_add_mark_locked() in fcntl_dirnotify(),"fsnotify_add_mark_locked() can fail but we do not check its return value. This didn't matter before commit 9dd813c15b2c ""fsnotify: Move mark list head from object into dedicated structure"" as none of possible failures could happen for dnotify but after that commit -ENOMEM can be returned. Handle this error properly in fcntl_dirnotify() as otherwise we just hit BUG_ON(dn_mark->dn) in dnotify_free_mark().  ",b3a0066005821acdc0cdb092cb72587182ab583f,1
tty: fix memory leak in vc_deallocate,"syzbot reported memory leak in tty/vt. The problem was in VT_DISALLOCATE ioctl cmd. After allocating unimap with PIO_UNIMAP it wasn't freed via VT_DISALLOCATE, but vc_cons[currcons].d was zeroed.  ",211b4d42b70f1c1660feaa968dac0efc2a96ac4d,1
io_uring: fix error path cleanup in io_sqe_files_register(),"syzbot reports the following crash:  general protection fault, probably for non-canonical address 0xdffffc0000000000: 0000 [#1] PREEMPT SMP KASAN KASAN: null-ptr-deref in range [0x0000000000000000-0x0000000000000007] CPU: 1 PID: 8927 Comm: syz-executor.3 Not tainted 5.9.0-syzkaller #0 Hardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 01/01/2011 ",55cbc2564ab2fd555ec0fc39311a9cfb811d7da5,1
bpf: reject passing modified ctx to helper functions,"As commit 28e33f9d78ee (""bpf: disallow arithmetic operations on context pointer"") already describes, f1174f77b50c (""bpf/verifier: rework value tracking"") removed the specific white-listed cases we had previously where we would allow for pointer arithmetic in order to further generalize it, and allow e.g. context access via modified registers. While the dereferencing of modified context pointers had been forbidden through 28e33f9d78ee, syzkaller did recently manage to trigger several KASAN splats for slab out of bounds access and use after frees by simply passing a modified context pointer to a helper function which would then do the bad access since verifier allowed it in adjust_ptr_min_max_vals().  Rejecting arithmetic on ctx pointer in adjust_ptr_min_max_vals() generally could break existing programs as there's a valid use case in tracing in combination with passing the ctx to helpers as bpf_probe_read(), where the register then becomes unknown at verification time due to adding a non-constant offset to it. An access sequence may look like the following:    offset = args->filename;  ",58990d1ff3f7896ee341030e9a7c2e4002570683,1
sctp: make sure stream nums can match optlen in sctp_setsockopt_reset_streams,"Now in sctp_setsockopt_reset_streams, it only does the check optlen < sizeof(*params) for optlen. But it's not enough, as params->srs_number_streams should also match optlen.  If the streams in params->srs_stream_list are less than stream nums in params->srs_number_streams, later when dereferencing the stream list, it could cause a slab-out-of-bounds crash, as reported by syzbot.  This patch is to fix it by also checking the stream numbers in sctp_setsockopt_reset_streams to make sure at least it's not greater than the streams in the list.  ",2342b8d95bcae5946e1b9b8d58645f37500ef2e7,1
ipv4: better IP_MAX_MTU enforcement,"While working on yet another syzkaller report, I found that our IP_MAX_MTU enforcements were not properly done.  gcc seems to reload dev->mtu for min(dev->mtu, IP_MAX_MTU), and final result can be bigger than IP_MAX_MTU :/  This is a problem because device mtu can be changed on other cpus or threads.  While this patch does not fix the issue I am working on, it is probably worth addressing it.  ",c780a049f9bf442314335372c9abc4548bfe3e44,1
netfilter: nf_tables: do not leave dangling pointer in nf_tables_set_alloc_name,"If nf_tables_set_alloc_name() frees set->name, we better clear set->name to avoid a future use-after-free or invalid-free.  BUG: KASAN: double-free or invalid-free in nf_tables_newset+0x1ed6/0x2560 net/netfilter/nf_tables_api.c:4148  CPU: 0 PID: 28233 Comm: syz-executor.0 Not tainted 5.6.0-syzkaller #0 Hardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 01/01/2011 Call Trace:  __dump_stack lib/dump_stack.c:77 [inline]  dump_stack+0x188/0x20d lib/dump_stack.c:118  print_address_description.constprop.0.cold+0xd3/0x315 mm/kasan/report.c:374  kasan_report_invalid_free+0x61/0xa0 mm/kasan/report.c:468  __kasan_slab_free+0x129/0x140 mm/kasan/common.c:455  __cache_free mm/slab.c:3426 [inline]  kfree+0x109/0x2b0 mm/slab.c:3757  nf_tables_newset+0x1ed6/0x2560 net/netfilter/nf_tables_api.c:4148  nfnetlink_rcv_batch+0x83a/0x1610 net/netfilter/nfnetlink.c:433  nfnetlink_rcv_skb_batch net/netfilter/nfnetlink.c:543 [inline]  nfnetlink_rcv+0x3af/0x420 net/netfilter/nfnetlink.c:561  netlink_unicast_kernel net/netlink/af_netlink.c:1303 [inline]  netlink_unicast+0x537/0x740 net/netlink/af_netlink.c:1329  netlink_sendmsg+0x882/0xe10 net/netlink/af_netlink.c:1918  sock_sendmsg_nosec net/socket.c:652 [inline]  sock_sendmsg+0xcf/0x120 net/socket.c:672  ____sys_sendmsg+0x6b9/0x7d0 net/socket.c:2345  ___sys_sendmsg+0x100/0x170 net/socket.c:2399  __sys_sendmsg+0xec/0x1b0 net/socket.c:2432  do_syscall_64+0xf6/0x7d0 arch/x86/entry/common.c:294  entry_SYSCALL_64_after_hwframe+0x49/0xbe ",7fb6f78df7003234d8df4f90aeecc432d7d0c804,1
rcu: Reject RCU_LOCKDEP_WARN() false positives,"If another lockdep report runs concurrently with an RCU lockdep report from RCU_LOCKDEP_WARN(), the following sequence of events can occur:  1.	debug_lockdep_rcu_enabled() sees that lockdep is enabled 	when called from (say) synchronize_rcu().  2.	Lockdep is disabled by a concurrent lockdep report.  3.	debug_lockdep_rcu_enabled() evaluates its lockdep-expression 	argument, for example, lock_is_held(&rcu_bh_lock_map).  4.	Because lockdep is now disabled, lock_is_held() plays it safe and 	returns the constant 1.  5.	But in this case, the constant 1 is not safe, because invoking 	synchronize_rcu() under rcu_read_lock_bh() is disallowed.  6.	debug_lockdep_rcu_enabled() wrongly invokes lockdep_rcu_suspicious(), 	resulting in a false-positive splat.  This commit therefore changes RCU_LOCKDEP_WARN() to check debug_lockdep_rcu_enabled() after checking the lockdep expression, so that any ""safe"" returns from lock_is_held() are rejected by debug_lockdep_rcu_enabled().  This requires memory ordering, which is supplied by READ_ONCE(debug_locks).  The resulting volatile accesses prevent the compiler from reordering and the fact that only one variable is being accessed prevents the underlying hardware from reordering. The combination works for IA64, which can reorder reads to the same location, but this is defeated by the volatile accesses, which compile to load instructions that provide ordering.  ",3066820034b5dd4e89bd74a7739c51c2d6f5e554,0
Input: kbtab - sanity check for endpoint type,The driver should check whether the endpoint it uses has the correct type.  ,c88090dfc84254fa149174eb3e6a8458de1912c4,1
net: caif: fix memory leak in caif_device_notify,"In case of caif_enroll_dev() fail, allocated link_support won't be assigned to the corresponding structure. So simply free allocated pointer in case of error  ",b53558a950a89824938e9811eddfc8efcd94e1bb,1
xfrm/compat: memset(0) 64-bit padding at right place,"32-bit messages translated by xfrm_compat can have attributes attached. For all, but XFRMA_SA, XFRMA_POLICY the size of payload is the same in 32-bit UABI and 64-bit UABI. For XFRMA_SA (struct xfrm_usersa_info) and XFRMA_POLICY (struct xfrm_userpolicy_info) it's only tail-padding that is present in 64-bit payload, but not in 32-bit. The proper size for destination nlattr is already calculated by xfrm_user_rcv_calculate_len64() and allocated with kvmalloc().  xfrm_attr_cpy32() copies 32-bit copy_len into 64-bit attribute translated payload, zero-filling possible padding for SA/POLICY. Due to a typo, *pos already has 64-bit payload size, in a result next memset(0) is called on the memory after the translated attribute, not on the tail-padding of it.  ",d1949d045fd67eab8a32a579a8c1ab1681330854,0
KVM: nVMX: fix guest CR4 loading when emulating L2 to L1 exit,"When KVM emulates an exit from L2 to L1, it loads L1 CR4 into the guest CR4. Before this CR4 loading, the guest CR4 refers to L2 CR4. Because these two CR4's are in different levels of guest, we should vmx_set_cr4() rather than kvm_set_cr4() here. The latter, which is used to handle guest writes to its CR4, checks the guest change to CR4 and may fail if the change is invalid.  The failure may cause trouble. Consider we start   a L1 guest with non-zero L1 PCID in use,      (i.e. L1 CR4.PCIDE == 1 && L1 CR3.PCID != 0) and   a L2 guest with L2 PCID disabled,      (i.e. L2 CR4.PCIDE == 0) and following events may happen:  1. If kvm_set_cr4() is used in load_vmcs12_host_state() to load L1 CR4    into guest CR4 (in VMCS01) for L2 to L1 exit, it will fail because    of PCID check. As a result, the guest CR4 recorded in L0 KVM (i.e.    vcpu->arch.cr4) is left to the value of L2 CR4.  2. Later, if L1 attempts to change its CR4, e.g., clearing VMXE bit,    kvm_set_cr4() in L0 KVM will think L1 also wants to enable PCID,    because the wrong L2 CR4 is used by L0 KVM as L1 CR4. As L1    CR3.PCID != 0, L0 KVM will inject GP to L1 guest.  ",8eb3f87d903168bdbd1222776a6b1e281f50513e,0
sctp: kfree_rcu asoc,"In sctp_hash_transport/sctp_epaddr_lookup_transport, it dereferences a transport's asoc under rcu_read_lock while asoc is freed not after a grace period, which leads to a use-after-free panic.  This patch fixes it by calling kfree_rcu to make asoc be freed after a grace period.  Note that only the asoc's memory is delayed to free in the patch, it won't cause sk to linger longer.  Thanks Neil and Marcelo to make this clear.  ",fb6df5a6234c38a9c551559506a49a677ac6f07a,1
shmem: Convert shmem_add_to_page_cache to XArray,We can use xas_find_conflict() instead of radix_tree_gang_lookup_slot() to find any conflicting entry and combine the three paths through this function into one.  ,552446a4166189a8c2515571dd6e25fd64a2dc78,0
media: radio-raremono: change devm_k*alloc to k*alloc,"Change devm_k*alloc to k*alloc to manually allocate memory  The manual allocation and freeing of memory is necessary because when the USB radio is disconnected, the memory associated with devm_k*alloc is freed. Meaning if we still have unresolved references to the radio device, then we get use-after-free errors.  This patch fixes this by manually allocating memory, and freeing it in the v4l2.release callback that gets called when the last radio device exits.  ",c666355e60ddb4748ead3bdd983e3f7f2224aaf0,1
sctp: do not allow the v4 socket to bind a v4mapped v6 address,"The check in sctp_sockaddr_af is not robust enough to forbid binding a v4mapped v6 addr on a v4 socket.  The worse thing is that v4 socket's bind_verify would not convert this v4mapped v6 addr to a v4 addr. syzbot even reported a crash as the v4 socket bound a v6 addr.  This patch is to fix it by doing the common sa.sa_family check first, then AF_INET check for v4mapped v6 addrs.  ",c5006b8aa74599ce19104b31d322d2ea9ff887cc,1
net: avoid uninit-value from tcp_conn_request,"A recent change triggers a KMSAN warning, because request sockets do not initialize @sk_rx_queue_mapping field.  Add sk_rx_queue_update() helper to make our intent clear.  BUG: KMSAN: uninit-value in sk_rx_queue_set include/net/sock.h:1922 [inline] BUG: KMSAN: uninit-value in tcp_conn_request+0x3bcc/0x4dc0 net/ipv4/tcp_input.c:6922  sk_rx_queue_set include/net/sock.h:1922 [inline]  tcp_conn_request+0x3bcc/0x4dc0 net/ipv4/tcp_input.c:6922  tcp_v4_conn_request+0x218/0x2a0 net/ipv4/tcp_ipv4.c:1528  tcp_rcv_state_process+0x2c5/0x3290 net/ipv4/tcp_input.c:6406  tcp_v4_do_rcv+0xb4e/0x1330 net/ipv4/tcp_ipv4.c:1738  tcp_v4_rcv+0x468d/0x4ed0 net/ipv4/tcp_ipv4.c:2100  ip_protocol_deliver_rcu+0x760/0x10b0 net/ipv4/ip_input.c:204  ip_local_deliver_finish net/ipv4/ip_input.c:231 [inline]  NF_HOOK include/linux/netfilter.h:307 [inline]  ip_local_deliver+0x584/0x8c0 net/ipv4/ip_input.c:252  dst_input include/net/dst.h:460 [inline]  ip_sublist_rcv_finish net/ipv4/ip_input.c:551 [inline]  ip_list_rcv_finish net/ipv4/ip_input.c:601 [inline]  ip_sublist_rcv+0x11fd/0x1520 net/ipv4/ip_input.c:609  ip_list_rcv+0x95f/0x9a0 net/ipv4/ip_input.c:644  __netif_receive_skb_list_ptype net/core/dev.c:5505 [inline]  __netif_receive_skb_list_core+0xe34/0x1240 net/core/dev.c:5553  __netif_receive_skb_list+0x7fc/0x960 net/core/dev.c:5605  netif_receive_skb_list_internal+0x868/0xde0 net/core/dev.c:5696  gro_normal_list net/core/dev.c:5850 [inline]  napi_complete_done+0x579/0xdd0 net/core/dev.c:6587  virtqueue_napi_complete drivers/net/virtio_net.c:339 [inline]  virtnet_poll+0x17b6/0x2350 drivers/net/virtio_net.c:1557  __napi_poll+0x14e/0xbc0 net/core/dev.c:7020  napi_poll net/core/dev.c:7087 [inline]  net_rx_action+0x824/0x1880 net/core/dev.c:7174  __do_softirq+0x1fe/0x7eb kernel/softirq.c:558  invoke_softirq+0xa4/0x130 kernel/softirq.c:432  __irq_exit_rcu kernel/softirq.c:636 [inline]  irq_exit_rcu+0x76/0x130 kernel/softirq.c:648  common_interrupt+0xb6/0xd0 arch/x86/kernel/irq.c:240  asm_common_interrupt+0x1e/0x40  smap_restore arch/x86/include/asm/smap.h:67 [inline]  get_shadow_origin_ptr mm/kmsan/instrumentation.c:31 [inline]  __msan_metadata_ptr_for_load_1+0x28/0x30 mm/kmsan/instrumentation.c:63  tomoyo_check_acl+0x1b0/0x630 security/tomoyo/domain.c:173  tomoyo_path_permission security/tomoyo/file.c:586 [inline]  tomoyo_check_open_permission+0x61f/0xe10 security/tomoyo/file.c:777  tomoyo_file_open+0x24f/0x2d0 security/tomoyo/tomoyo.c:311  security_file_open+0xb1/0x1f0 security/security.c:1635  do_dentry_open+0x4e4/0x1bf0 fs/open.c:809  vfs_open+0xaf/0xe0 fs/open.c:957  do_open fs/namei.c:3426 [inline]  path_openat+0x52f1/0x5dd0 fs/namei.c:3559  do_filp_open+0x306/0x760 fs/namei.c:3586  do_sys_openat2+0x263/0x8f0 fs/open.c:1212  do_sys_open fs/open.c:1228 [inline]  __do_sys_open fs/open.c:1236 [inline]  __se_sys_open fs/open.c:1232 [inline]  __x64_sys_open+0x314/0x380 fs/open.c:1232  do_syscall_x64 arch/x86/entry/common.c:51 [inline]  do_syscall_64+0x54/0xd0 arch/x86/entry/common.c:82  entry_SYSCALL_64_after_hwframe+0x44/0xae  ",a37a0ee4d25c152a087c5e913b76f207eaebdb54,1
tipc: Fix memory leak in tipc_group_create_member(),"tipc_group_add_to_tree() returns silently if `key` matches `nkey` of an existing node, causing tipc_group_create_member() to leak memory. Let tipc_group_add_to_tree() return an error in such a case, so that tipc_group_create_member() can handle it properly.  ",bb3a420d47ab00d7e1e5083286cab15235a96680,1
io-wq: fix race around pending work on teardown,syzbot reports that it's triggering the warning condition on having pending work on shutdown:  ,f5d2d23bf0d948ce0b9307b7bacae7ff0bc03c71,1
media: media/v4l2-core: Fix kernel-infoleak in video_put_user(),video_put_user() is copying uninitialized stack memory to userspace due to the compiler not initializing holes in the structures declared on the stack. Fix it by initializing `ev32` and `vb32` using memset().  ,4ffb879ea648c2b42da4ca992ed3db87e564af69,1
RDMA/ucma: Check that device is connected prior to access it,Add missing check that device is connected prior to access it.  ,4b658d1bbc16605330694bb3ef2570c465ef383d,0
/dev/mem: Bail out upon SIGKILL.,"syzbot found that a thread can stall for minutes inside read_mem() or write_mem() after that thread was killed by SIGKILL [1]. Reading from iomem areas of /dev/mem can be slow, depending on the hardware. While reading 2GB at one read() is legal, delaying termination of killed thread for minutes is bad. Thus, allow reading/writing /dev/mem and /dev/kmem to be preemptible and killable.    ",8619e5bdeee8b2c685d686281f2d2a6017c4bc15,0
membarrier: Fix RCU locking bug caused by faulty merge,"The following commit:    227a4aadc75b (""sched/membarrier: Fix p->mm->membarrier_state racy load"")  got fat fingered by me when merging it with other patches. It meant to move the RCU section out of the for loop but ended up doing it partially, leaving a superfluous rcu_read_lock() inside, causing havok.  ",73956fc07dd7b25d4a33ab3fdd6247c60d0b237c,0
team: avoid adding twice the same option to the event list,"When parsing the options provided by the user space, team_nl_cmd_options_set() insert them in a temporary list to send multiple events with a single message. While each option's attribute is correctly validated, the code does not check for duplicate entries before inserting into the event list.  Exploiting the above, the syzbot was able to trigger the following splat:  kernel BUG at lib/list_debug.c:31! invalid opcode: 0000 [#1] SMP KASAN Dumping ftrace buffer:     (ftrace buffer empty) ",4fb0534fb7bbc2346ba7d3a072b538007f4135a5,1
net: prevent user from passing illegal stab size,"We observed below report when playing with netlink sock:    UBSAN: shift-out-of-bounds in net/sched/sch_api.c:580:10   shift exponent 249 is too large for 32-bit type   CPU: 0 PID: 685 Comm: a.out Not tainted   Call Trace:    dump_stack_lvl+0x8d/0xcf    ubsan_epilogue+0xa/0x4e    __ubsan_handle_shift_out_of_bounds+0x161/0x182    __qdisc_calculate_pkt_len+0xf0/0x190    __dev_queue_xmit+0x2ed/0x15b0  it seems like kernel won't check the stab log value passing from user, and will use the insane value later to calculate pkt_len.  This patch just add a check on the size/cell_log to avoid insane calculation.  ",b193e15ac69d56f35e1d8e2b5d16cbd47764d053,1
drm: fix oops in drm_atomic_set_crtc_for_connector,"crtc can be NULL. connector, extracted from conn_state, can't.  ",0003b687ee6d55b889f037530582493f353f0567,1
bonding: check return value of register_netdevice() in bond_newlink(),"Very similar to commit 544f287b8495 (""bonding: check error value of register_netdevice() immediately""), we should immediately check the return value of register_netdevice() before doing anything else.  ",c75d1d5248c0c97996051809ad0e9f154ba5d76e,0
usb: yurex: Fix use-after-free in yurex_delete,"syzbot reported the following crash [0]:  BUG: KASAN: use-after-free in usb_free_coherent+0x79/0x80 drivers/usb/core/usb.c:928 Read of size 8 at addr ffff8881b18599c8 by task syz-executor.4/16007  CPU: 0 PID: 16007 Comm: syz-executor.4 Not tainted 5.3.0-rc2+ #23 Hardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 01/01/2011 Call Trace:   __dump_stack lib/dump_stack.c:77 [inline]   dump_stack+0xca/0x13e lib/dump_stack.c:113   print_address_description+0x6a/0x32c mm/kasan/report.c:351   __kasan_report.cold+0x1a/0x33 mm/kasan/report.c:482   kasan_report+0xe/0x12 mm/kasan/common.c:612   usb_free_coherent+0x79/0x80 drivers/usb/core/usb.c:928   yurex_delete+0x138/0x330 drivers/usb/misc/yurex.c:100   kref_put include/linux/kref.h:65 [inline]   yurex_release+0x66/0x90 drivers/usb/misc/yurex.c:392   __fput+0x2d7/0x840 fs/file_table.c:280   task_work_run+0x13f/0x1c0 kernel/task_work.c:113   tracehook_notify_resume include/linux/tracehook.h:188 [inline]   exit_to_usermode_loop+0x1d2/0x200 arch/x86/entry/common.c:163   prepare_exit_to_usermode arch/x86/entry/common.c:194 [inline]   syscall_return_slowpath arch/x86/entry/common.c:274 [inline]   do_syscall_64+0x45f/0x580 arch/x86/entry/common.c:299   entry_SYSCALL_64_after_hwframe+0x49/0xbe ",fc05481b2fcabaaeccf63e32ac1baab54e5b6963,1
bridge: check iface upper dev when setting master via ioctl,"When we set a bond slave's master to bridge via ioctl, we only check the IFF_BRIDGE_PORT flag. Although we will find the slave's real master at netdev_master_upper_dev_link() later, it already does some settings and allocates some resources. It would be better to return as early as possible.  v1 -> v2: use netdev_master_upper_dev_get() instead of netdev_has_any_upper_dev() to check if we have a master, because not all upper devs are masters, e.g. vlan device.  ",e8238fc2bd7b4c3c7554fa2df067e796610212fc,0
USB: w1 ds2490: Fix bug caused by improper use of altsetting array,"The syzkaller USB fuzzer spotted a slab-out-of-bounds bug in the ds2490 driver.  This bug is caused by improper use of the altsetting array in the usb_interface structure (the array's entries are not always stored in numerical order), combined with a naive assumption that all interfaces probed by the driver will have the expected number of altsettings.  The bug can be fixed by replacing references to the possibly non-existent intf->altsetting[alt] entry with the guaranteed-to-exist intf->cur_altsetting entry.  ",c114944d7d67f24e71562fcfc18d550ab787e4d4,1
rds: do not leak kernel memory to user land,"syzbot/KMSAN reported an uninit-value in put_cmsg(), originating from rds_cmsg_recv().  Simply clear the structure, since we have holes there, or since rx_traces might be smaller than RDS_MSG_RX_DGRAM_TRACE_MAX.  BUG: KMSAN: uninit-value in copy_to_user include/linux/uaccess.h:184 [inline] BUG: KMSAN: uninit-value in put_cmsg+0x600/0x870 net/core/scm.c:242 CPU: 0 PID: 4459 Comm: syz-executor582 Not tainted 4.16.0+ #87 Hardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 01/01/2011 Call Trace:  __dump_stack lib/dump_stack.c:17 [inline]  dump_stack+0x185/0x1d0 lib/dump_stack.c:53  kmsan_report+0x142/0x240 mm/kmsan/kmsan.c:1067  kmsan_internal_check_memory+0x135/0x1e0 mm/kmsan/kmsan.c:1157  kmsan_copy_to_user+0x69/0x160 mm/kmsan/kmsan.c:1199  copy_to_user include/linux/uaccess.h:184 [inline]  put_cmsg+0x600/0x870 net/core/scm.c:242  rds_cmsg_recv net/rds/recv.c:570 [inline]  rds_recvmsg+0x2db5/0x3170 net/rds/recv.c:657  sock_recvmsg_nosec net/socket.c:803 [inline]  sock_recvmsg+0x1d0/0x230 net/socket.c:810  ___sys_recvmsg+0x3fb/0x810 net/socket.c:2205  __sys_recvmsg net/socket.c:2250 [inline]  SYSC_recvmsg+0x298/0x3c0 net/socket.c:2262  SyS_recvmsg+0x54/0x80 net/socket.c:2257  do_syscall_64+0x309/0x430 arch/x86/entry/common.c:287  entry_SYSCALL_64_after_hwframe+0x3d/0xa2  ",eb80ca476ec11f67a62691a93604b405ffc7d80c,1
rxrpc: Fix local refcounting,"Fix rxrpc_unuse_local() to handle a NULL local pointer as it can be called on an unbound socket on which rx->local is not yet set.  The following reproduced (includes omitted):  	int main(void) 	{ 		socket(AF_RXRPC, SOCK_DGRAM, AF_INET); 		return 0; 	}  causes the following oops to occur:  	BUG: kernel NULL pointer dereference, ",68553f1a6f746bf860bce3eb42d78c26a717d9c0,1
net_sched: check error pointer in tcf_dump_walker(),"Although we take RTNL on dump path, it is possible to skip RTNL on insertion path. So the following race condition is possible:  rtnl_lock()		// no rtnl lock 			mutex_lock(&idrinfo->lock); 			// insert ERR_PTR(-EBUSY) 			mutex_unlock(&idrinfo->lock); tc_dump_action() rtnl_unlock()  So we have to skip those temporary -EBUSY entries on dump path too.  ",580e4273d7a883ececfefa692c1f96bdbacb99b5,1
block: fix locking in bdev_del_partition,"We need to hold the whole device bd_mutex to protect against other thread concurrently deleting out partition before we get to it, and thus causing a use after free.  ",08fc1ab6d748ab1a690fd483f41e2938984ce353,1
netfilter: ebtables: account ebt_table_info to kmemcg,"The [ip,ip6,arp]_tables use x_tables_info internally and the underlying memory is already accounted to kmemcg. Do the same for ebtables. The syzbot, by using setsockopt(EBT_SO_SET_ENTRIES), was able to OOM the whole system from a restricted memcg, a potential DoS.  By accounting the ebt_table_info, the memory used for ebt_table_info can be contained within the memcg of the allocating process. However the lifetime of ebt_table_info is independent of the allocating process and is tied to the network namespace. So, the oom-killer will not be able to relieve the memory pressure due to ebt_table_info memory. The memory for ebt_table_info is allocated through vmalloc. Currently vmalloc does not handle the oom-killed allocating process correctly and one large allocation can bypass memcg limit enforcement. So, with this patch, at least the small allocations will be contained. For large allocations, we need to fix vmalloc.  ",e2c8d550a973bb34fc28bc8d0ec996f84562fb8a,0
ipv6: Fix KASAN: slab-out-of-bounds Read in fib6_nh_flush_exceptions,Reported by syzbot: HEAD commit:    90c911ad Merge tag 'fixes' of git://git.kernel.org/pub/scm.. git tree:       git://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git master dashboard link: https://syzkaller.appspot.com/bug?extid=123aa35098fd3c000eb7 compiler:       Debian clang version 11.0.1-2  ,821bbf79fe46a8b1d18aa456e8ed0a3c208c3754,1
ath6kl: fix a NULL-ptr-deref bug in ath6kl_usb_alloc_urb_from_pipe(),"The `ar_usb` field of `ath6kl_usb_pipe_usb_pipe` objects are initialized to point to the containing `ath6kl_usb` object according to endpoint descriptors read from the device side, as shown below in `ath6kl_usb_setup_pipe_resources`:  for (i = 0; i < iface_desc->desc.bNumEndpoints; ++i) { 	endpoint = &iface_desc->endpoint[i].desc;  	// get the address from endpoint descriptor 	pipe_num = ath6kl_usb_get_logical_pipe_num(ar_usb, 						endpoint->bEndpointAddress, 						&urbcount); 	...... 	// select the pipe object 	pipe = &ar_usb->pipes[pipe_num];  	// initialize the ar_usb field 	pipe->ar_usb = ar_usb; }  The driver assumes that the addresses reported in endpoint descriptors from device side  to be complete. If a device is malicious and does not report complete addresses, it may trigger NULL-ptr-deref `ath6kl_usb_alloc_urb_from_pipe` and `ath6kl_usb_free_urb_to_pipe`.  This patch fixes the bug by preventing potential NULL-ptr-deref (CVE-2019-15098).  ",39d170b3cb62ba98567f5c4f40c27b5864b304e5,1
net: bridge: fix vlan stats use-after-free on destruction,"Syzbot reported a use-after-free of the global vlan context on port vlan destruction. When I added per-port vlan stats I missed the fact that the global vlan context can be freed before the per-port vlan rcu callback. There're a few different ways to deal with this, I've chosen to add a new private flag that is set only when per-port stats are allocated so we can directly check it on destruction without dereferencing the global context at all. The new field in net_bridge_vlan uses a hole.  v2: cosmetic change, move the check to br_process_vlan_info where the     other checks are done v3: add change log in the patch, add private (in-kernel only) flags in a     hole in net_bridge_vlan struct and use that instead of mixing     user-space flags with private flags  ",9d332e69c1dc74dcd748de7cbd2dac5c61bda265,1
staging: android: ion: Add __GFP_NOWARN for system contig heap,syzbot reported a warning from Ion:    ,0c75f10312a35b149b2cebb1832316b35c2337ca,0
sctp: initialize sin6_flowinfo for ipv6 addrs in sctp_inet6addr_event,"syzbot reported a kernel-infoleak, which is caused by an uninitialized field(sin6_flowinfo) of addr->a.v6 in sctp_inet6addr_event(). The call trace is as below:    BUG: KMSAN: kernel-infoleak in _copy_to_user+0x19a/0x230 lib/usercopy.c:33   CPU: 1 PID: 8164 Comm: syz-executor2 Not tainted 4.20.0-rc3+ #95   Hardware name: Google Google Compute Engine/Google Compute Engine, BIOS   Google 01/01/2011   Call Trace:     __dump_stack lib/dump_stack.c:77 [inline]     dump_stack+0x32d/0x480 lib/dump_stack.c:113     kmsan_report+0x12c/0x290 mm/kmsan/kmsan.c:683     kmsan_internal_check_memory+0x32a/0xa50 mm/kmsan/kmsan.c:743     kmsan_copy_to_user+0x78/0xd0 mm/kmsan/kmsan_hooks.c:634     _copy_to_user+0x19a/0x230 lib/usercopy.c:33     copy_to_user include/linux/uaccess.h:183 [inline]     sctp_getsockopt_local_addrs net/sctp/socket.c:5998 [inline]     sctp_getsockopt+0x15248/0x186f0 net/sctp/socket.c:7477     sock_common_getsockopt+0x13f/0x180 net/core/sock.c:2937     __sys_getsockopt+0x489/0x550 net/socket.c:1939     __do_sys_getsockopt net/socket.c:1950 [inline]     __se_sys_getsockopt+0xe1/0x100 net/socket.c:1947     __x64_sys_getsockopt+0x62/0x80 net/socket.c:1947     do_syscall_64+0xcf/0x110 arch/x86/entry/common.c:291     entry_SYSCALL_64_after_hwframe+0x63/0xe7  sin6_flowinfo is not really used by SCTP, so it will be fixed by simply setting it to 0.  The issue exists since very beginning. Thanks Alexander for the reproducer provided.  ",4a2eb0c37b4759416996fbb4c45b932500cf06d3,1
media: uvcvideo: Fix access to uninitialized fields on probe error,We need to check whether this work we are canceling actually is initialized.  ,11a087f484bf15ff65f0a9f277aa5a61fd07ed2a,1
io_uring: Fix return value from alloc_fixed_file_ref_node,"alloc_fixed_file_ref_node() currently returns an ERR_PTR on failure. io_sqe_files_unregister() expects it to return NULL and since it can only return -ENOMEM, it makes more sense to change alloc_fixed_file_ref_node() to behave that way.  ",3e2224c5867fead6c0b94b84727cc676ac6353a3,0
"Revert ""mm, thp: consolidate THP gfp handling into alloc_hugepage_direct_gfpmask""","This reverts commit 89c83fb539f95491be80cdd5158e6f0ce329e317.  This should have been done as part of 2f0799a0ffc0 (""mm, thp: restore node-local hugepage allocations"").  The movement of the thp allocation policy from alloc_pages_vma() to alloc_hugepage_direct_gfpmask() was intended to only set __GFP_THISNODE for mempolicies that are not MPOL_BIND whereas the revert could set this regardless of mempolicy.  While the check for MPOL_BIND between alloc_hugepage_direct_gfpmask() and alloc_pages_vma() was racy, that has since been removed since the revert.  What is left is the possibility to use __GFP_THISNODE in policy_node() when it is unexpected because the special handling for hugepages in alloc_pages_vma()  was removed as part of the consolidation.  Secondly, prior to 89c83fb539f9, alloc_pages_vma() implemented a somewhat different policy for hugepage allocations, which were allocated through alloc_hugepage_vma().  For hugepage allocations, if the allocating process's node is in the set of allowed nodes, allocate with __GFP_THISNODE for that node (for MPOL_PREFERRED, use that node with __GFP_THISNODE instead).  This was changed for shmem_alloc_hugepage() to allow fallback to other nodes in 89c83fb539f9 as it did for new_page() in mm/mempolicy.c which is functionally different behavior and removes the requirement to only allocate hugepages locally.  So this commit does a full revert of 89c83fb539f9 instead of the partial revert that was done in 2f0799a0ffc0.  The result is the same thp allocation policy for 4.20 that was in 4.19.  ",356ff8a9a78fb35d6482584d260c3754dcbdf669,1
fs/minix: check return value of sb_getblk(),"Patch series ""fs/minix: fix syzbot bugs and set s_maxbytes"".  This series fixes all syzbot bugs in the minix filesystem:  	KASAN: null-ptr-deref Write in get_block 	KASAN: use-after-free Write in get_block 	KASAN: use-after-free Read in get_block 	",da27e0a0e5f655f0d58d4e153c3182bb2b290f64,1
netlink: fix netlink_ack() extack race,"It seems that it's possible to toggle NETLINK_F_EXT_ACK through setsockopt() while another thread/CPU is building a message inside netlink_ack(), which could then trigger the WARN_ON()s I added since if it goes from being turned off to being turned on between allocating and filling the message, the skb could end up being too small.  Avoid this whole situation by storing the value of this flag in a separate variable and using that throughout the function instead.  ",48044eb490be71c203e14dd89e8bae87209eab52,1
llc: hold llc_sap before release_sock(),syzbot reported we still access llc->sap in llc_backlog_rcv() after it is freed in llc_sap_remove_socket():  Call Trace:  __dump_stack lib/dump_stack.c:77 [inline]  dump_stack+0x1b9/0x294 lib/dump_stack.c:113  print_address_description+0x6c/0x20b mm/kasan/report.c:256  kasan_report_error mm/kasan/report.c:354 [inline]  kasan_report.cold.7+0x242/0x2fe mm/kasan/report.c:412  __asan_report_load1_noabort+0x14/0x20 mm/kasan/report.c:430  llc_conn_ac_send_sabme_cmd_p_set_x+0x3a8/0x460 net/llc/llc_c_ac.c:785  llc_exec_conn_trans_actions net/llc/llc_conn.c:475 [inline]  llc_conn_service net/llc/llc_conn.c:400 [inline]  llc_conn_state_process+0x4e1/0x13a0 net/llc/llc_conn.c:75  llc_backlog_rcv+0x195/0x1e0 net/llc/llc_conn.c:891  sk_backlog_rcv include/net/sock.h:909 [inline]  __release_sock+0x12f/0x3a0 net/core/sock.c:2335  release_sock+0xa4/0x2b0 net/core/sock.c:2850  llc_ui_release+0xc8/0x220 net/llc/af_llc.c:204  llc->sap is refcount'ed and llc_sap_remove_socket() is paired with llc_sap_add_socket(). This can be amended by holding its refcount before llc_sap_remove_socket() and releasing it after release_sock().  ,f7e43672683b097bb074a8fe7af9bc600a23f231,0
netfilter: nat: fix error handling upon registering inet hook,A case of warning was reported by syzbot.  ,b4faef1739dd1f3b3981b8bf173a2266ea86b1eb,1
tty: Hold tty_ldisc_lock() during tty_reopen(),"tty_ldisc_reinit() doesn't race with neither tty_ldisc_hangup() nor set_ldisc() nor tty_ldisc_release() as they use tty lock. But it races with anyone who expects line discipline to be the same after hoding read semaphore in tty_ldisc_ref().  We've seen the following crash on v4.9.108 stable:  BUG: unable to handle kernel paging request at 0000000000002260 IP: [..] n_tty_receive_buf_common+0x5f/0x86d Workqueue: events_unbound flush_to_ldisc Call Trace:  [..] n_tty_receive_buf2  [..] tty_ldisc_receive_buf  [..] flush_to_ldisc  [..] process_one_work  [..] worker_thread  [..] kthread  [..] ret_from_fork  tty_ldisc_reinit() should be called with ldisc_sem hold for writing, which will protect any reader against line discipline changes.  ",83d817f41070c48bc3eb7ec18e43000a548fca5c,1
mac80211: fix deadlock in AP/VLAN handling,"Syzbot reports that when you have AP_VLAN interfaces that are up and close the AP interface they belong to, we get a deadlock. No surprise - since we dev_close() them with the wiphy mutex held, which goes back into the netdev notifier in cfg80211 and tries to acquire the wiphy mutex there.  To fix this, we need to do two things:  1) prevent changing iftype while AP_VLANs are up, we can't     easily fix this case since cfg80211 already calls us with     the wiphy mutex held, but change_interface() is relatively     rare in drivers anyway, so changing iftype isn't used much     (and userspace has to fall back to down/change/up anyway)  2) pull the dev_close() loop over VLANs out of the wiphy mutex     section in the normal stop case  ",d5befb224edbe53056c2c18999d630dafb4a08b9,1
io_uring: fix memory leak of UNIX domain socket inode,"Opening and closing an io_uring instance leaks a UNIX domain socket inode.  This is because the ->file of the io_uring instance's internal UNIX domain socket is set to point to the io_uring file, but then sock_release() sees the non-NULL ->file and assumes the inode reference is held by the file so doesn't call iput().  That's not the case here, since the reference is still meant to be held by the socket; the actual inode of the io_uring file is different.  Fix this leak by NULL-ing out ->file before releasing the socket.  ",355e8d26f719c207aa2e00e6f3cfab3acf21769b,1
RDMA/ucma: Put a lock around every call to the rdma_cm layer,"The rdma_cm must be used single threaded.  This appears to be a bug in the design, as it does have lots of locking that seems like it should allow concurrency. However, when it is all said and done every single place that uses the cma_exch() scheme is broken, and all the unlocked reads from the ucma of the cm_id data are wrong too.  syzkaller has been finding endless bugs related to this.  Fixing this in any elegant way is some enormous amount of work. Take a very big hammer and put a mutex around everything to do with the ucma_context at the top of every syscall.  ",7c11910783a1ea17e88777552ef146cace607b3c,1
srcu: Apply *_ONCE() to ->srcu_last_gp_end,"The ->srcu_last_gp_end field is accessed from any CPU at any time by synchronize_srcu(), so non-initialization references need to use READ_ONCE() and WRITE_ONCE().  This commit therefore makes that change.  ",844a378de3372c923909681706d62336d702531e,0
sctp: fix error return code in sctp_sendmsg_new_asoc(),Return error code -EINVAL in the address len check error handling case since 'err' can be overwrite to 0 by 'err = sctp_verify_addr()' in the for loop.  ,d98985dd6c2dc69e2ad5f5482a5237fb9487ed99,1
ife: error out when nla attributes are empty,"act_ife at least requires TCA_IFE_PARMS, so we have to bail out when there is no attribute passed in.  ",c8ec4632c6ac9cda0e8c3d51aa41eeab66585bd5,0
RDMA/ucma: Check that device exists prior to accessing it,Ensure that device exists prior to accessing its properties.  ,c8d3bcbfc5eab3f01cf373d039af725f3b488813,0
tcp: gso: avoid refcount_t warning from tcp_gso_segment(),"When a GSO skb of truesize O is segmented into 2 new skbs of truesize N1 and N2, we want to transfer socket ownership to the new fresh skbs.  In order to avoid expensive atomic operations on a cache line subject to cache bouncing, we replace the sequence :  refcount_add(N1, &sk->sk_wmem_alloc); refcount_add(N2, &sk->sk_wmem_alloc); // repeated by number of segments  refcount_sub(O, &sk->sk_wmem_alloc);  by a single  refcount_add(sum_of(N) - O, &sk->sk_wmem_alloc);  Problem is :  In some pathological cases, sum(N) - O might be a negative number, and syzkaller bot was apparently able to trigger this trace [1]  atomic_t was ok with this construct, but we need to take care of the negative delta with refcount_t  [1] refcount_t: saturated; leaking memory. ",7ec318feeed10a64c0359ec4d10889cb4defa39a,1
net/nfc: fix use-after-free llcp_sock_bind/connect,"Commits 8a4cd82d (""nfc: fix refcount leak in llcp_sock_connect()"") and c33b1cc62 (""nfc: fix refcount leak in llcp_sock_bind()"") fixed a refcount leak bug in bind/connect but introduced a use-after-free if the same local is assigned to 2 different sockets.  This can be triggered by the following simple program:     int sock1 = socket( AF_NFC, SOCK_STREAM, NFC_SOCKPROTO_LLCP );     int sock2 = socket( AF_NFC, SOCK_STREAM, NFC_SOCKPROTO_LLCP );     memset( &addr, 0, sizeof(struct sockaddr_nfc_llcp) );     addr.sa_family = AF_NFC;     addr.nfc_protocol = NFC_PROTO_NFC_DEP;     bind( sock1, (struct sockaddr*) &addr, sizeof(struct sockaddr_nfc_llcp) )     bind( sock2, (struct sockaddr*) &addr, sizeof(struct sockaddr_nfc_llcp) )     close(sock1);     close(sock2);  Fix this by assigning NULL to llcp_sock->local after calling nfc_llcp_local_put.  This addresses CVE-2021-23134.  ",c61760e6940dd4039a7f5e84a6afc9cdbf4d82b6,1
erofs: don't trigger WARN() when decompression fails,syzbot reported a ,a0961f351d82d43ab0b845304caa235dfe249ae9,0
net: get rid of lockdep_set_class_and_subclass(),"lockdep_set_class_and_subclass() is meant to reduce the _nested() annotations by assigning a default subclass. For addr_list_lock, we have to compute the subclass at run-time as the netdevice topology changes after creation.  So, we should just get rid of these lockdep_set_class_and_subclass() and stick with our _nested() annotations.  ",be74294ffa24f5fbc0d6643842e3e095447e17a2,0
inet: remove races in inet{6}_getname(),"syzbot reported data-races in inet_getname() multiple times, it is time we fix this instead of pretending applications should not trigger them.  getsockname() and getpeername() are not really considered fast path.  v2: added the missing BPF_CGROUP_RUN_SA_PROG() declaration     needed when CONFIG_CGROUP_BPF=n, as reported by     kernel test robot <lkp@intel.com>  syzbot typical report:  BUG: KCSAN: data-race in __inet_hash_connect / inet_getname  write to 0xffff888136d66cf8 of 2 bytes by task 14374 on cpu 1:  __inet_hash_connect+0x7ec/0x950 net/ipv4/inet_hashtables.c:831  inet_hash_connect+0x85/0x90 net/ipv4/inet_hashtables.c:853  tcp_v4_connect+0x782/0xbb0 net/ipv4/tcp_ipv4.c:275  __inet_stream_connect+0x156/0x6e0 net/ipv4/af_inet.c:664  inet_stream_connect+0x44/0x70 net/ipv4/af_inet.c:728  __sys_connect_file net/socket.c:1896 [inline]  __sys_connect+0x254/0x290 net/socket.c:1913  __do_sys_connect net/socket.c:1923 [inline]  __se_sys_connect net/socket.c:1920 [inline]  __x64_sys_connect+0x3d/0x50 net/socket.c:1920  do_syscall_x64 arch/x86/entry/common.c:50 [inline]  do_syscall_64+0x44/0xa0 arch/x86/entry/common.c:80  entry_SYSCALL_64_after_hwframe+0x44/0xae  read to 0xffff888136d66cf8 of 2 bytes by task 14408 on cpu 0:  inet_getname+0x11f/0x170 net/ipv4/af_inet.c:790  __sys_getsockname+0x11d/0x1b0 net/socket.c:1946  __do_sys_getsockname net/socket.c:1961 [inline]  __se_sys_getsockname net/socket.c:1958 [inline]  __x64_sys_getsockname+0x3e/0x50 net/socket.c:1958  do_syscall_x64 arch/x86/entry/common.c:50 [inline]  do_syscall_64+0x44/0xa0 arch/x86/entry/common.c:80  entry_SYSCALL_64_after_hwframe+0x44/0xae  value changed: 0x0000 -> 0xdee0  Reported by Kernel Concurrency Sanitizer on: CPU: 0 PID: 14408 Comm: syz-executor.3 Not tainted 5.15.0-rc3-syzkaller #0 Hardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 01/01/2011  ",9dfc685e0262d4c5e44e13302f89841fa75173ca,1
dccp: fool proof ccid_hc_[rt]x_parse_options(),"Similarly to commit 276bdb82dedb (""dccp: check ccid before dereferencing"") it is wise to test for a NULL ccid.  kasan: CONFIG_KASAN_INLINE enabled kasan: GPF could be caused by NULL-ptr deref or user memory access general protection fault: 0000 [#1] PREEMPT SMP KASAN CPU: 1 PID: 16 Comm: ksoftirqd/1 Not tainted 5.0.0-rc3+ #37 Hardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 01/01/2011 ",9b1f19d810e92d6cdc68455fbc22d9f961a58ce1,1
ipv6: don't let tb6_root node share routes with other node,"After commit 4512c43eac7e, if we add a route to the subtree of tb6_root which does not have any route attached to it yet, the current code will let tb6_root and the node in the subtree share the same route. This could cause problem cause tb6_root has RTN_INFO flag marked and the tree repair and clean up code will not work properly. This commit makes sure tb6_root->leaf points back to null_entry instead of sharing route with other node.  It fixes the following syzkaller reported issue: BUG: KASAN: use-after-free in ipv6_prefix_equal include/net/ipv6.h:540 [inline] BUG: KASAN: use-after-free in fib6_add_1+0x165f/0x1790 net/ipv6/ip6_fib.c:618 Read of size 8 at addr ffff8801bc043498 by task syz-executor5/19819  CPU: 1 PID: 19819 Comm: syz-executor5 Not tainted 4.15.0-rc7+ #186 Hardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 01/01/2011 Call Trace:  __dump_stack lib/dump_stack.c:17 [inline]  dump_stack+0x194/0x257 lib/dump_stack.c:53  print_address_description+0x73/0x250 mm/kasan/report.c:252  kasan_report_error mm/kasan/report.c:351 [inline]  kasan_report+0x25b/0x340 mm/kasan/report.c:409  __asan_report_load8_noabort+0x14/0x20 mm/kasan/report.c:430  ipv6_prefix_equal include/net/ipv6.h:540 [inline]  fib6_add_1+0x165f/0x1790 net/ipv6/ip6_fib.c:618  fib6_add+0x5fa/0x1540 net/ipv6/ip6_fib.c:1214  __ip6_ins_rt+0x6c/0x90 net/ipv6/route.c:1003  ip6_route_add+0x141/0x190 net/ipv6/route.c:2790  ipv6_route_ioctl+0x4db/0x6b0 net/ipv6/route.c:3299  inet6_ioctl+0xef/0x1e0 net/ipv6/af_inet6.c:520  sock_do_ioctl+0x65/0xb0 net/socket.c:958  sock_ioctl+0x2c2/0x440 net/socket.c:1055  vfs_ioctl fs/ioctl.c:46 [inline]  do_vfs_ioctl+0x1b1/0x1520 fs/ioctl.c:686  SYSC_ioctl fs/ioctl.c:701 [inline]  SyS_ioctl+0x8f/0xc0 fs/ioctl.c:692  entry_SYSCALL_64_fastpath+0x23/0x9a ",591ff9ea51cec683e4cb378a3469228ba1d69010,1
net_sched: fix error path in red_init(),"When ->init() fails, ->destroy() is called to clean up. So it is unnecessary to clean up in red_init(), and it would cause some refcount underflow.  ",5438dd45831ee33869779bd1919b05816ae4dbc9,1
"net: sock_map, fix missing ulp check in sock hash case","sock_map and ULP only work together when ULP is loaded after the sock map is loaded. In the sock_map case we added a check for this to fail the load if ULP is already set. However, we missed the check on the sock_hash side.  Add a ULP check to the sock_hash update path.  ",44580a0118d3ede95fec4dce32df5f75f73cd663,0
drop_monitor: Perform cleanup upon probe registration failure,"In the rare case that drop_monitor fails to register its probe on the 'napi_poll' tracepoint, it will not deactivate its hysteresis timer as part of the error path. If the hysteresis timer was armed by the shortly lived 'kfree_skb' probe and user space retries to initiate tracing, a warning will be emitted for trying to initialize an active object [1].  Fix this by properly undoing all the operations that were done prior to probe registration, in both software and hardware code paths.  Note that syzkaller managed to fail probe registration by injecting a slab allocation failure [2].  [1] ODEBUG: init active (active state 0) object type: timer_list hint: sched_send_work+0x0/0x60 include/linux/list.h:135 ",9398e9c0b1d44eeb700e9e766c02bcc765c82570,1
netns: restore ops before calling ops_exit_list,"ops has been iterated to first element when call pre_exit, and it needs to restore from save_ops, not save ops to save_ops  ",b272a0ad730103e84fb735fd0a8cc050cdf7f77c,0
autofs: fix autofs_sbi() does not check super block type,autofs_sbi() does not check the superblock magic number to verify it has been given an autofs super block.  ,0633da48f0793aeba27f82d30605624416723a91,0
block/loop: Use global lock for ioctl() operation.,"syzbot is reporting NULL pointer dereference [1] which is caused by race condition between ioctl(loop_fd, LOOP_CLR_FD, 0) versus ioctl(other_loop_fd, LOOP_SET_FD, loop_fd) due to traversing other loop devices at loop_validate_file() without holding corresponding lo->lo_ctl_mutex locks.  Since ioctl() request on loop devices is not frequent operation, we don't need fine grained locking. Let's use global lock in order to allow safe traversal at loop_validate_file().  Note that syzbot is also reporting circular locking dependency between bdev->bd_mutex and lo->lo_ctl_mutex [2] which is caused by calling blkdev_reread_part() with lock held. This patch does not address it.  [1] https://syzkaller.appspot.com/bug?id=f3cfe26e785d85f9ee259f385515291d21bd80a3 [2] https://syzkaller.appspot.com/bug?id=bf154052f0eea4bc7712499e4569505907d15889  ",310ca162d779efee8a2dc3731439680f3e9c1e86,1
fbcon: Fix global-out-of-bounds read in fbcon_get_font(),"fbcon_get_font() is reading out-of-bounds. A malicious user may resize `vc->vc_font.height` to a large value, causing fbcon_get_font() to read out of `fontdata`.  fbcon_get_font() handles both built-in and user-provided fonts. Fortunately, recently we have added FONT_EXTRA_WORDS support for built-in fonts, so fix it by adding range checks using FNTSIZE().  This patch depends on patch ""fbdev, newport_con: Move FONT_EXTRA_WORDS macros into linux/font.h"", and patch ""Fonts: Support FONT_EXTRA_WORDS macros for built-in fonts"".  ",5af08640795b2b9a940c9266c0260455377ae262,1
signal: Prevent sigqueue caching after task got released,"syzbot reported a memory leak related to sigqueue caching.  The assumption that a task cannot cache a sigqueue after the signal handler has been dropped and exit_task_sigqueue_cache() has been invoked turns out to be wrong.  Such a task can still invoke release_task(other_task), which cleans up the signals of 'other_task' and ends up in sigqueue_cache_or_free(), which in turn will cache the signal because task->sigqueue_cache is NULL. That's obviously bogus because nothing will free the cached signal of that task anymore, so the cached item is leaked.  This happens when e.g. the last non-leader thread exits and reaps the zombie leader.  Prevent this by setting tsk::sigqueue_cache to an error pointer value in exit_task_sigqueue_cache() which forces any subsequent invocation of sigqueue_cache_or_free() from that task to hand the sigqueue back to the kmemcache.  Add comments to all relevant places.  ",399f8dd9a866e107639eabd3c1979cd526ca3a98,1
netfilter: nfnetlink_cttimeout: pass default timeout policy to obj_to_nlattr,"Otherwise, we hit a NULL pointer deference since handlers always assume default timeout policy is passed.    netlink: 24 bytes leftover after parsing attributes in process `syz-executor2'.   kasan: CONFIG_KASAN_INLINE enabled   kasan: GPF could be caused by NULL-ptr deref or user memory access   general protection fault: 0000 [#1] PREEMPT SMP KASAN   CPU: 0 PID: 9575 Comm: syz-executor1 Not tainted 4.19.0+ #312   Hardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 01/01/2011   ",8866df9264a34e675b4ee8a151db819b87cce2d3,1
userfaultfd: check VM_MAYWRITE was set after verifying the uffd is registered,Calling UFFDIO_UNREGISTER on virtual ranges not yet registered in uffd could trigger an harmless false positive WARN_ON.  Check the vma is already registered before checking VM_MAYWRITE to shut off the false positive warning.  ,01e881f5a1fca4677e82733061868c6d6ea05ca7,0
media: v4l: ioctl: Fix memory leak in video_usercopy,"When an IOCTL with argument size larger than 128 that also used array arguments were handled, two memory allocations were made but alas, only the latter one of them was released. This happened because there was only a single local variable to hold such a temporary allocation.  Fix this by adding separate variables to hold the pointers to the temporary allocations.  ",fb18802a338b36f675a388fc03d2aa504a0d0899,1
net/smc: Ensure correct state of the socket in send path,"When smc_sendmsg() is called before the SMC socket initialization has completed, smc_tx_sendmsg() will access un-initialized fields of the SMC socket which results in a null-pointer dereference. Fix this by checking the socket state first in smc_tx_sendmsg().  ",17081633e22d83be928a779fd7acd04b247dec90,1
cgroup: Make rebind_subsystems() disable v2 controllers all at once,It was found that the following warning was displayed when remounting controllers from cgroup v2 to v1:  ,7ee285395b211cad474b2b989db52666e0430daf,0
vhost: correctly remove wait queue during poll failure,"We tried to remove vq poll from wait queue, but do not check whether or not it was in a list before. This will lead double free. Fixing this by switching to use vhost_poll_stop() which zeros poll->wqh after removing poll from waitqueue to make sure it won't be freed twice.  ",dc6455a71c7fc5117977e197f67f71b49f27baba,1
tipc: check return value of __tipc_dump_start(),"When __tipc_dump_start() fails with running out of memory, we have no reason to continue, especially we should avoid calling tipc_dump_done().  ",12a78b026f870c575d3a98998b25084aac5b3c61,0
io_uring: fix __tctx_task_work() ctx race,"There is an unlikely but possible race using a freed context. That's because req->task_work.func() can free a request, but we won't necessarily find a completion in submit_state.comp and so all ctx refs may be put by the time we do mutex_lock(&ctx->uring_ctx);  There are several reasons why it can miss going through submit_state.comp: 1) req->task_work.func() didn't complete it itself, but punted to iowq (e.g. reissue) and it got freed later, or a similar situation with it overflowing and getting flushed by someone else, or being submitted to IRQ completion, 2) As we don't hold the uring_lock, someone else can do io_submit_flush_completions() and put our ref. 3) Bugs and code obscurities, e.g. failing to propagate issue_flags properly.  One example is as follows    CPU1                                  |  CPU2 ",2c32395d8111037ae2cb8cab883e80bcdbb70713,1
fscache: Fix incomplete initialisation of inline key space,"The inline key in struct rxrpc_cookie is insufficiently initialized, zeroing only 3 of the 4 slots, therefore an index_key_len between 13 and 15 bytes will end up hashing uninitialized memory because the memcpy only partially fills the last buf[] element.  Fix this by clearing fscache_cookie objects on allocation rather than using the slab constructor to initialise them.  We're going to pretty much fill in the entire struct anyway, so bringing it into our dcache writably shouldn't incur much overhead.  This removes the need to do clearance in fscache_set_key() (where we aren't doing it correctly anyway).  Also, we don't need to set cookie->key_len in fscache_set_key() as we already did it in the only caller, so remove that.  ",1ff22883b0b2f7a73eb2609ffe879c9fd96f6328,1
Input: add safety guards to input_set_keycode(),"If we happen to have a garbage in input device's keycode table with values too big we'll end up doing clear_bit() with offset way outside of our bitmaps, damaging other objects within an input device or even outside of it. Let's add sanity checks to the returned old keycodes.  ",cb222aed03d798fc074be55e59d9a112338ee784,1
ipvs: fix rtnl_lock lockups caused by start_sync_thread,"syzkaller reports for wrong rtnl_lock usage in sync code [1] and [2]  We have 2 problems in start_sync_thread if error path is taken, eg. on memory allocation error or failure to configure sockets for mcast group or addr/port binding:  1. recursive locking: holding rtnl_lock while calling sock_release which in turn calls again rtnl_lock in ip_mc_drop_socket to leave the mcast group, as noticed by Florian Westphal. Additionally, sock_release can not be called while holding sync_mutex (ABBA deadlock).  2. task hung: holding rtnl_lock while calling kthread_stop to stop the running kthreads. As the kthreads do the same to leave the mcast group (sock_release -> ip_mc_drop_socket -> rtnl_lock) they hang.  Fix the problems by calling rtnl_unlock early in the error path, now sock_release is called after unlocking both mutexes.  Problem 3 (task hung reported by syzkaller [2]) is variant of problem 2: use _trylock to prevent one user to call rtnl_lock and then while waiting for sync_mutex to block kthreads that execute sock_release when they are stopped by stop_sync_thread.  [1] IPVS: stopping backup sync thread 4500 ... ",5c64576a77894a50be80be0024bed27171b55989,1
batman-adv: Only read OGM tvlv_len after buffer len check,Multiple batadv_ogm_packet can be stored in an skbuff. The functions batadv_iv_ogm_send_to_if()/batadv_iv_ogm_receive() use batadv_iv_ogm_aggr_packet() to check if there is another additional batadv_ogm_packet in the skb or not before they continue processing the packet.  The length for such an OGM is BATADV_OGM_HLEN + batadv_ogm_packet->tvlv_len. The check must first check that at least BATADV_OGM_HLEN bytes are available before it accesses tvlv_len (which is part of the header. Otherwise it might try read outside of the currently available skbuff to get the content of tvlv_len.  ,a15d56a60760aa9dbe26343b9a0ac5228f35d445,0
audit: check the length of userspace generated audit records,"Commit 756125289285 (""audit: always check the netlink payload length in audit_receive_msg()"") fixed a number of missing message length checks, but forgot to check the length of userspace generated audit records.  The good news is that you need CAP_AUDIT_WRITE to submit userspace audit records, which is generally only given to trusted processes, so the impact should be limited.  ",763dafc520add02a1f4639b500c509acc0ea8e5b,0
ip6_gre: fix null-ptr-deref in ip6gre_init_net(),"KASAN report null-ptr-deref error when register_netdev() failed:  KASAN: null-ptr-deref in range [0x00000000000003c0-0x00000000000003c7] CPU: 2 PID: 422 Comm: ip Not tainted 5.8.0-rc4+ #12 Call Trace:  ip6gre_init_net+0x4ab/0x580  ? ip6gre_tunnel_uninit+0x3f0/0x3f0  ops_init+0xa8/0x3c0  setup_net+0x2de/0x7e0  ? rcu_read_lock_bh_held+0xb0/0xb0  ? ops_init+0x3c0/0x3c0  ? kasan_unpoison_shadow+0x33/0x40  ? __kasan_kmalloc.constprop.0+0xc2/0xd0  copy_net_ns+0x27d/0x530  create_new_namespaces+0x382/0xa30  unshare_nsproxy_namespaces+0xa1/0x1d0  ksys_unshare+0x39c/0x780  ? walk_process_tree+0x2a0/0x2a0  ? trace_hardirqs_on+0x4a/0x1b0  ? _raw_spin_unlock_irq+0x1f/0x30  ? syscall_trace_enter+0x1a7/0x330  ? do_syscall_64+0x1c/0xa0  __x64_sys_unshare+0x2d/0x40  do_syscall_64+0x56/0xa0  entry_SYSCALL_64_after_hwframe+0x44/0xa9  ip6gre_tunnel_uninit() has set 'ign->fb_tunnel_dev' to NULL, later access to ign->fb_tunnel_dev cause null-ptr-deref. Fix it by saving 'ign->fb_tunnel_dev' to local variable ndev.  ",46ef5b89ec0ecf290d74c4aee844f063933c4da4,1
reiserfs: fix buffer overflow with long warning messages,"ReiserFS prepares log messages into a 1024-byte buffer with no bounds checks.  Long messages, such as the ""unknown mount option"" warning when userspace passes a crafted mount options string, overflow this buffer. This causes KASAN to report a global-out-of-bounds write.  Fix it by truncating messages to the buffer size.  ",fe10e398e860955bac4d28ec031b701d358465e4,1
sctp: do asoc update earlier in sctp_sf_do_dupcook_a,"There's a panic that occurs in a few of envs, the call trace is as below:    [] general protection fault, ... 0x29acd70f1000a: 0000 [#1] SMP PTI   [] ",35b4f24415c854cd718ccdf38dbea6297f010aae,0
vt: vt_ioctl: fix race in VT_RESIZEX,"We need to make sure vc_cons[i].d is not NULL after grabbing console_lock(), or risk a crash.  general protection fault, probably for non-canonical address 0xdffffc0000000068: 0000 [#1] PREEMPT SMP KASAN KASAN: null-ptr-deref in range [0x0000000000000340-0x0000000000000347] CPU: 1 PID: 19462 Comm: syz-executor.5 Not tainted 5.5.0-syzkaller #0 Hardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 01/01/2011 ",6cd1ed50efd88261298577cd92a14f2768eddeeb,1
RDMA/cma: Rollback source IP address if failing to acquire device,"If cma_acquire_dev_by_src_ip() returns error in addr_handler(), the device state changes back to RDMA_CM_ADDR_BOUND but the resolved source IP address is still left. After that, if rdma_destroy_id() is called after rdma_listen(), the device is freed without removed from listen_any_list in cma_cancel_operation(). Revert to the previous IP address if acquiring device fails.  ",5fc01fb846bce8fa6d5f95e2625b8ce0f8e86810,0
KVM: x86: Immediately reset the MMU context when the SMM flag is cleared,"Immediately reset the MMU context when the vCPU's SMM flag is cleared so that the SMM flag in the MMU role is always synchronized with the vCPU's flag.  If RSM fails (which isn't correctly emulated), KVM will bail without calling post_leave_smm() and leave the MMU in a bad state.  The bad MMU role can lead to a NULL pointer dereference when grabbing a shadow page's rmap for a page fault as the initial lookups for the gfn will happen with the vCPU's SMM flag (=0), whereas the rmap lookup will use the shadow page's SMM flag, which comes from the MMU (=1).  SMM has an entirely different set of memslots, and so the initial lookup can find a memslot (SMM=0) and then explode on the rmap memslot lookup (SMM=1).    general protection fault, probably for non-canonical address 0xdffffc0000000000: 0000 [#1] PREEMPT SMP KASAN   KASAN: null-ptr-deref in range [0x0000000000000000-0x0000000000000007]   CPU: 1 PID: 8410 Comm: syz-executor382 Not tainted 5.13.0-rc5-syzkaller #0   Hardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 01/01/2011   ",78fcb2c91adfec8ce3a2ba6b4d0dda89f2f4a7c6,1
bpf_lru_list: Read double-checked variable once without lock,"For double-checked locking in bpf_common_lru_push_free(), node->type is read outside the critical section and then re-checked under the lock. However, concurrent writes to node->type result in data races.  For example, the following concurrent access was observed by KCSAN:    write to 0xffff88801521bc22 of 1 bytes by task 10038 on cpu 1:    __bpf_lru_node_move_in        kernel/bpf/bpf_lru_list.c:91    __local_list_flush            kernel/bpf/bpf_lru_list.c:298    ...   read to 0xffff88801521bc22 of 1 bytes by task 10043 on cpu 0:    bpf_common_lru_push_free      kernel/bpf/bpf_lru_list.c:507    bpf_lru_push_free             kernel/bpf/bpf_lru_list.c:555    ...  Fix the data races where node->type is read outside the critical section (for double-checked locking) by marking the access with READ_ONCE() as well as ensuring the variable is only accessed once.  ",6df8fb83301d68ea0a0c0e1cbcc790fcc333ed12,1
net: bridge: fix net device refcount tracking issue in error path,"I left one dev_put() in br_add_if() error path and sure enough syzbot found its way.  As the tracker is allocated in new_nbp(), we must make sure to properly free it.  We have to call dev_put_track(dev, &p->dev_tracker) before @p object is freed, of course. This is not an issue because br_add_if() owns a reference on @dev.  ",fcfb894d5952786db3b2b2b9cd3a95cdcedb6ff0,0
block/loop: fix deadlock after loop_set_status,syzbot is reporting deadlocks at __blkdev_get() [1].  ,1e047eaab3bb5564f25b41e9cd3a053009f4e789,0
filldir[64]: remove WARN_ON_ONCE() for bad directory entries,"This was always meant to be a temporary thing, just for testing and to see if it actually ever triggered.  The only thing that reported it was syzbot doing disk image fuzzing, and then that warning is expected.  So let's just remove it before -rc4, because the extra sanity testing should probably go to -stable, but we don't want the warning to do so.  ",b9959c7a347d6adbb558fba7e36e9fef3cba3b07,0
selinux: skip bounded transition processing if the policy isn't loaded,"We can't do anything reasonable in security_bounded_transition() if we don't have a policy loaded, and in fact we could run into problems with some of the code inside expecting a policy.  Fix these problems like we do many others in security/selinux/ss/services.c by checking to see if the policy is loaded (ss_initialized) and returning quickly if it isn't.  ",4b14752ec4e0d87126e636384cf37c8dd9df157c,0
sctp: fix memleak on err handling of stream initialization,"syzbot reported a memory leak when an allocation fails within genradix_prealloc() for output streams. That's because genradix_prealloc() leaves initialized members initialized when the issue happens and SCTP stack will abort the current initialization but without cleaning up such members.  The fix here is to always call genradix_free() when genradix_prealloc() fails, for output and also input streams, as it suffers from the same issue.  ",951c6db954a1adefab492f6da805decacabbd1a7,1
pppoe: take ->needed_headroom of lower device into account on xmit,"In pppoe_sendmsg(), reserving dev->hard_header_len bytes of headroom was probably fine before the introduction of ->needed_headroom in commit f5184d267c1a (""net: Allow netdevices to specify needed head/tailroom"").  But now, virtual devices typically advertise the size of their overhead in dev->needed_headroom, so we must also take it into account in skb_reserve(). Allocation size of skb is also updated to take dev->needed_tailroom into account and replace the arbitrary 32 bytes with the real size of a PPPoE header.  This issue was discovered by syzbot, who connected a pppoe socket to a gre device which had dev->header_ops->create == ipgre_header and dev->hard_header_len == 0. Therefore, PPPoE didn't reserve any headroom, and dev_hard_header() crashed when ipgre_header() tried to prepend its header to skb->data.  skbuff: skb_under_panic: text:000000001d390b3a len:31 put:24 head:00000000d8ed776f data:000000008150e823 tail:0x7 end:0xc0 dev:gre0 ",02612bb05e51df8489db5e94d0cf8d1c81f87b0c,1
mm/compaction.c: correct zone boundary handling when isolating pages from a pageblock,"syzbot reported the following error from a tree with a head commit of baf76f0c58ae (""slip: make slhc_free() silently accept an error pointer"")    BUG: unable to handle kernel paging request at ffffea0003348000   #PF error: [normal kernel read fault]   PGD 12c3f9067 P4D 12c3f9067 PUD 12c3f8067 PMD 0   Oops: 0000 [#1] PREEMPT SMP KASAN   CPU: 1 PID: 28916 Comm: syz-executor.2 Not tainted 5.1.0-rc6+ #89   Hardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 01/01/2011   ",60fce36afa9c77c7ccbf980c4f670f3be3651fce,1
USB: chaoskey: fix error case of a timeout,"In case of a timeout or if a signal aborts a read communication with the device needs to be ended lest we overwrite an active URB the next time we do IO to the device, as the URB may still be active.  ",92aa5986f4f7b5a8bf282ca0f50967f4326559f5,0
ALSA: seq: Fix concurrent access to queue current tick/time,"snd_seq_check_queue() passes the current tick and time of the given queue as a pointer to snd_seq_prioq_cell_out(), but those might be updated concurrently by the seq timer update.  Fix it by retrieving the current tick and time via the proper helper functions at first, and pass those values to snd_seq_prioq_cell_out() later in the loops.  snd_seq_timer_get_cur_time() takes a new argument and adjusts with the current system time only when it's requested so; this update isn't needed for snd_seq_check_queue(), as it's called either from the interrupt handler or right after queuing.  Also, snd_seq_timer_get_cur_tick() is changed to read the value in the spinlock for the concurrency, too.  ",dc7497795e014d84699c3b8809ed6df35352dd74,1
block: fix use-after-free in disk_part_iter_next,Make sure that bdgrab() is done on the 'block_device' instance before referring to it for avoiding use-after-free.  ,aebf5db917055b38f4945ed6d621d9f07a44ff30,1
rtlwifi: rtl8192cu: fix error handle when usb probe failed,"rtl_usb_probe() must do error handle rtl_deinit_core() only if rtl_init_core() is done, otherwise goto error_out2.  | usb 1-1: New USB device strings: Mfr=0, Product=0, SerialNumber=0 | rtl_usb: reg 0xf0, usbctrl_vendorreq TimeOut! status:0xffffffb9 value=0x0 | rtl8192cu: Chip version 0x10 | rtl_usb: reg 0xa, usbctrl_vendorreq TimeOut! status:0xffffffb9 value=0x0 | rtl_usb: Too few input end points found | INFO: trying to register non-static key. | the code is fine but needs lockdep annotation. | turning off the locking correctness validator. | CPU: 0 PID: 12 Comm: kworker/0:1 Not tainted 5.1.0-rc4-319354-g9a33b36 #3 | Hardware name: Google Google Compute Engine/Google Compute Engine, BIOS | Google 01/01/2011 | Workqueue: usb_hub_wq hub_event | Call Trace: |   __dump_stack lib/dump_stack.c:77 [inline] |   dump_stack+0xe8/0x16e lib/dump_stack.c:113 |   assign_lock_key kernel/locking/lockdep.c:786 [inline] |   register_lock_class+0x11b8/0x1250 kernel/locking/lockdep.c:1095 |   __lock_acquire+0xfb/0x37c0 kernel/locking/lockdep.c:3582 |   lock_acquire+0x10d/0x2f0 kernel/locking/lockdep.c:4211 |   __raw_spin_lock_irqsave include/linux/spinlock_api_smp.h:110 [inline] |   _raw_spin_lock_irqsave+0x44/0x60 kernel/locking/spinlock.c:152 |   rtl_c2hcmd_launcher+0xd1/0x390 | drivers/net/wireless/realtek/rtlwifi/base.c:2344 |   rtl_deinit_core+0x25/0x2d0 drivers/net/wireless/realtek/rtlwifi/base.c:574 |   rtl_usb_probe.cold+0x861/0xa70 | drivers/net/wireless/realtek/rtlwifi/usb.c:1093 |   usb_probe_interface+0x31d/0x820 drivers/usb/core/driver.c:361 |   really_probe+0x2da/0xb10 drivers/base/dd.c:509 |   driver_probe_device+0x21d/0x350 drivers/base/dd.c:671 |   __device_attach_driver+0x1d8/0x290 drivers/base/dd.c:778 |   bus_for_each_drv+0x163/0x1e0 drivers/base/bus.c:454 |   __device_attach+0x223/0x3a0 drivers/base/dd.c:844 |   bus_probe_device+0x1f1/0x2a0 drivers/base/bus.c:514 |   device_add+0xad2/0x16e0 drivers/base/core.c:2106 |   usb_set_configuration+0xdf7/0x1740 drivers/usb/core/message.c:2021 |   generic_probe+0xa2/0xda drivers/usb/core/generic.c:210 |   usb_probe_device+0xc0/0x150 drivers/usb/core/driver.c:266 |   really_probe+0x2da/0xb10 drivers/base/dd.c:509 |   driver_probe_device+0x21d/0x350 drivers/base/dd.c:671 |   __device_attach_driver+0x1d8/0x290 drivers/base/dd.c:778 |   bus_for_each_drv+0x163/0x1e0 drivers/base/bus.c:454 |   __device_attach+0x223/0x3a0 drivers/base/dd.c:844 |   bus_probe_device+0x1f1/0x2a0 drivers/base/bus.c:514 |   device_add+0xad2/0x16e0 drivers/base/core.c:2106 |   usb_new_device.cold+0x537/0xccf drivers/usb/core/hub.c:2534 |   hub_port_connect drivers/usb/core/hub.c:5089 [inline] |   hub_port_connect_change drivers/usb/core/hub.c:5204 [inline] |   port_event drivers/usb/core/hub.c:5350 [inline] |   hub_event+0x138e/0x3b00 drivers/usb/core/hub.c:5432 |   process_one_work+0x90f/0x1580 kernel/workqueue.c:2269 |   worker_thread+0x9b/0xe20 kernel/workqueue.c:2415 |   kthread+0x313/0x420 kernel/kthread.c:253 |   ret_from_fork+0x3a/0x50 arch/x86/entry/entry_64.S:352  ",6c0ed66f1a5b84e2a812c7c2d6571a5621bf3396,0
sbitmap: silence data race warning,KCSAN complaints about the sbitmap hint update:  ,9f8b93a7df4d8e1e8715fb2a45a893cffad9da0b,1
bonding: avoid lockdep confusion in bond_get_stats(),"syzbot found that the following sequence produces a LOCKDEP splat [1]  ip link add bond10 type bond ip link add bond11 type bond ip link set bond11 master bond10  To fix this, we can use the already provided nest_level.  This patch also provides correct nesting for dev->addr_list_lock  [1] ",7e2556e40026a1b0c16f37446ab398d5a5a892e4,0
Bluetooth: defer cleanup of resources in hci_unregister_dev(),"syzbot is hitting might_sleep() warning at hci_sock_dev_event() due to calling lock_sock() with rw spinlock held [1].  It seems that history of this locking problem is a trial and error.  Commit b40df5743ee8 (""[PATCH] bluetooth: fix socket locking in hci_sock_dev_event()"") in 2.6.21-rc4 changed bh_lock_sock() to lock_sock() as an attempt to fix lockdep warning.  Then, commit 4ce61d1c7a8e (""[BLUETOOTH]: Fix locking in hci_sock_dev_event()."") in 2.6.22-rc2 changed lock_sock() to local_bh_disable() + bh_lock_sock_nested() as an attempt to fix the sleep in atomic context warning.  Then, commit 4b5dd696f81b (""Bluetooth: Remove local_bh_disable() from hci_sock.c"") in 3.3-rc1 removed local_bh_disable().  Then, commit e305509e678b (""Bluetooth: use correct lock to prevent UAF of hdev object"") in 5.13-rc5 again changed bh_lock_sock_nested() to lock_sock() as an attempt to fix CVE-2021-3573.  This difficulty comes from current implementation that hci_sock_dev_event(HCI_DEV_UNREG) is responsible for dropping all references from sockets because hci_unregister_dev() immediately reclaims resources as soon as returning from hci_sock_dev_event(HCI_DEV_UNREG).  But the history suggests that hci_sock_dev_event(HCI_DEV_UNREG) was not doing what it should do.  Therefore, instead of trying to detach sockets from device, let's accept not detaching sockets from device at hci_sock_dev_event(HCI_DEV_UNREG), by moving actual cleanup of resources from hci_unregister_dev() to hci_cleanup_dev() which is called by bt_host_release() when all references to this unregistered device (which is a kobject) are gone.  Since hci_sock_dev_event(HCI_DEV_UNREG) no longer resets hci_pi(sk)->hdev, we need to check whether this device was unregistered and return an error based on HCI_UNREGISTER flag.  There might be subtle behavioral difference in ""monitor the hdev"" functionality; please report if you found something went wrong due to this patch.  ",e04480920d1eec9c061841399aa6f35b6f987d8b,1
"bpf: sockmap, fix crash when ipv6 sock is added",This fixes a crash where we assign tcp_prot to IPv6 sockets instead of tcpv6_prot.  Previously we overwrote the sk->prot field with tcp_prot even in the AF_INET6 case. This patch ensures the correct tcp_prot and tcpv6_prot are used.  Tested with 'netserver -6' and 'netperf -H [IPv6]' as well as 'netperf -H [IPv4]'. The ESTABLISHED check resolves the previously crashing case here.  ,9901c5d77e969d8215a8e8d087ef02e6feddc84c,1
media: rtl28xxu: fix zero-length control request,The direction of the pipe argument must match the request-type direction bit or control requests may fail depending on the host-controller-driver implementation.  Control transfers without a data stage are treated as OUT requests by the USB stack and should be using usb_sndctrlpipe(). Failing to do so will now trigger a warning.  The driver uses a zero-length i2c-read request for type detection so update the control-request code to use usb_sndctrlpipe() in this case.  Note that actually trying to read the i2c register in question does not work as the register might not exist (e.g. depending on the demodulator) as reported by Eero Lehtinen <debiangamer2@gmail.com>.  ,76f22c93b209c811bd489950f17f8839adb31901,0
x86/fault: Fix wrong signal when vsyscall fails with pkey,"The function __bad_area_nosemaphore() calls kernelmode_fixup_or_oops() with the parameter @signal being actually @pkey, which will send a signal numbered with the argument in @pkey.  This bug can be triggered when the kernel fails to access user-given memory pages that are protected by a pkey, so it can go down the do_user_addr_fault() path and pass the !user_mode() check in __bad_area_nosemaphore().  Most cases will simply run the kernel fixup code to make an -EFAULT. But when another condition current->thread.sig_on_uaccess_err is met, which is only used to emulate vsyscall, the kernel will generate the wrong signal.  Add a new parameter @pkey to kernelmode_fixup_or_oops() to fix this.   ",d4ffd5df9d18031b6a53f934388726775b4452d3,1
l2tp: fix infoleak in l2tp_ip6_recvmsg(),"Back in 2013 Hannes took care of most of such leaks in commit bceaa90240b6 (""inet: prevent leakage of uninitialized memory to user in recv syscalls"")  But the bug in l2tp_ip6_recvmsg() has not been fixed.  syzbot report :  BUG: KMSAN: kernel-infoleak in _copy_to_user+0x16b/0x1f0 lib/usercopy.c:32 CPU: 1 PID: 10996 Comm: syz-executor362 Not tainted 5.0.0+ #11 Hardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 01/01/2011 Call Trace:  __dump_stack lib/dump_stack.c:77 [inline]  dump_stack+0x173/0x1d0 lib/dump_stack.c:113  kmsan_report+0x12e/0x2a0 mm/kmsan/kmsan.c:600  kmsan_internal_check_memory+0x9f4/0xb10 mm/kmsan/kmsan.c:694  kmsan_copy_to_user+0xab/0xc0 mm/kmsan/kmsan_hooks.c:601  _copy_to_user+0x16b/0x1f0 lib/usercopy.c:32  copy_to_user include/linux/uaccess.h:174 [inline]  move_addr_to_user+0x311/0x570 net/socket.c:227  ___sys_recvmsg+0xb65/0x1310 net/socket.c:2283  do_recvmmsg+0x646/0x10c0 net/socket.c:2390  __sys_recvmmsg net/socket.c:2469 [inline]  __do_sys_recvmmsg net/socket.c:2492 [inline]  __se_sys_recvmmsg+0x1d1/0x350 net/socket.c:2485  __x64_sys_recvmmsg+0x62/0x80 net/socket.c:2485  do_syscall_64+0xbc/0xf0 arch/x86/entry/common.c:291  entry_SYSCALL_64_after_hwframe+0x63/0xe7 ",163d1c3d6f17556ed3c340d3789ea93be95d6c28,1
smc: fix out of bound access in smc_nl_get_sys_info(),smc_clc_get_hostname() sets the host pointer to a buffer which is not NULL-terminated (see smc_clc_init()).  ,25fe2c9c4cd2e97c5f5b69f3aefe69aad3057936,1
tipc: fix unbalanced reference counter,"When a topology subscription is created, we may encounter (or KASAN may provoke) a failure to create a corresponding service instance in the binding table. Instead of letting the tipc_nametbl_subscribe() report the failure back to the caller, the function just makes a warning printout and returns, without incrementing the subscription reference counter as expected by the caller.  This makes the caller believe that the subscription was successful, so it will at a later moment try to unsubscribe the item. This involves a sub_put() call. Since the reference counter never was incremented in the first place, we get a premature delete of the subscription item, followed by a ""use-after-free"" warning.  We fix this by adding a return value to tipc_nametbl_subscribe() and make the caller aware of the failure to subscribe.  This bug seems to always have been around, but this fix only applies back to the commit shown below. Given the low risk of this happening we believe this to be sufficient.  ",c3317f4db831b7564ff8d1670326456a7fbbbcb3,1
Smack: fix another vsscanf out of bounds,"This is similar to commit 84e99e58e8d1 (""Smack: slab-out-of-bounds in vsscanf"") where we added a bounds check on ""rule"".  ",a6bd4f6d9b07452b0b19842044a6c3ea384b0b88,1
Bluetooth: hci_event: Rework hci_inquiry_result_with_rssi_evt,This rework the handling of hci_inquiry_result_with_rssi_evt to not use a union to represent the different inquiry responses.  ,72279d17df54d5e4e7910b39c61a3f3464e36633,1
ipsec: Fix aborted xfrm policy dump crash,"An independent security researcher, Mohamed Ghannam, has reported this vulnerability to Beyond Security's SecuriTeam Secure Disclosure program.  The xfrm_dump_policy_done function expects xfrm_dump_policy to have been called at least once or it will crash.  This can be triggered if a dump fails because the target socket's receive buffer is full.  This patch fixes it by using the cb->start mechanism to ensure that the initialisation is always done regardless of the buffer situation.  ",1137b5e2529a8f5ca8ee709288ecba3e68044df2,1
net: af_packet: fix race in PACKET_{R|T}X_RING,"In order to remove the race caught by syzbot [1], we need to lock the socket before using po->tp_version as this could change under us otherwise.  This means lock_sock() and release_sock() must be done by packet_set_ring() callers.  [1] : BUG: KMSAN: uninit-value in packet_set_ring+0x1254/0x3870 net/packet/af_packet.c:4249 CPU: 0 PID: 20195 Comm: syzkaller707632 Not tainted 4.16.0+ #83 Hardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 01/01/2011 Call Trace:  __dump_stack lib/dump_stack.c:17 [inline]  dump_stack+0x185/0x1d0 lib/dump_stack.c:53  kmsan_report+0x142/0x240 mm/kmsan/kmsan.c:1067  __msan_warning_32+0x6c/0xb0 mm/kmsan/kmsan_instr.c:676  packet_set_ring+0x1254/0x3870 net/packet/af_packet.c:4249  packet_setsockopt+0x12c6/0x5a90 net/packet/af_packet.c:3662  SYSC_setsockopt+0x4b8/0x570 net/socket.c:1849  SyS_setsockopt+0x76/0xa0 net/socket.c:1828  do_syscall_64+0x309/0x430 arch/x86/entry/common.c:287  entry_SYSCALL_64_after_hwframe+0x3d/0xa2 ",5171b37d959641bbc619781caf62e61f7b940871,1
pipe: Fix bogus dereference in iov_iter_alignment(),We cannot look at 'i->pipe' unless we know the iter is a pipe. Move the ring_size load to a branch in iov_iter_alignment() where we've already checked the iter is a pipe to avoid bogus dereference.  ,e0ff126ee7ad405c1ef531f9f3db92929de4f20f,1
ceph: avoid a use-after-free in ceph_destroy_options(),"syzbot reported a use-after-free in ceph_destroy_options(), called from ceph_mount().  The problem was that create_fs_client() consumed the opt pointer on some errors, but not on all of them.  Make sure it always consumes both libceph and ceph options.  ",8aaff15168cfbc7c8980fdb0e8a585f1afe56ec0,1
net: usb: fix memory leak in smsc75xx_bind,Syzbot reported memory leak in smsc75xx_bind(). The problem was is non-freed memory in case of errors after memory allocation.  backtrace:   [<ffffffff84245b62>] kmalloc include/linux/slab.h:556 [inline]   [<ffffffff84245b62>] kzalloc include/linux/slab.h:686 [inline]   [<ffffffff84245b62>] smsc75xx_bind+0x7a/0x334 drivers/net/usb/smsc75xx.c:1460   [<ffffffff82b5b2e6>] usbnet_probe+0x3b6/0xc30 drivers/net/usb/usbnet.c:1728  ,46a8b29c6306d8bbfd92b614ef65a47c900d8e70,1
netfilter: ebtables: reject non-bridge targets,"the ebtables evaluation loop expects targets to return positive values (jumps), or negative values (absolute verdicts).  This is completely different from what xtables does. In xtables, targets are expected to return the standard netfilter verdicts, i.e. NF_DROP, NF_ACCEPT, etc.  ebtables will consider these as jumps.  Therefore reject any target found due to unspec fallback. v2: also reject watchers.  ebtables ignores their return value, so a target that assumes skb ownership (and returns NF_STOLEN) causes use-after-free.  The only watchers in the 'ebtables' front-end are log and nflog; both have AF_BRIDGE specific wrappers on kernel side.  ",11ff7288beb2b7da889a014aff0a7b80bf8efcf3,1
"fou, fou6: do not assume linear skbs","Both gue_err() and gue6_err() incorrectly assume linear skbs. Fix them to use pskb_may_pull().  BUG: KMSAN: uninit-value in gue6_err+0x475/0xc40 net/ipv6/fou6.c:101 CPU: 0 PID: 18083 Comm: syz-executor1 Not tainted 5.0.0-rc1+ #7 Hardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 01/01/2011 Call Trace:  <IRQ>  __dump_stack lib/dump_stack.c:77 [inline]  dump_stack+0x173/0x1d0 lib/dump_stack.c:113  kmsan_report+0x12e/0x2a0 mm/kmsan/kmsan.c:600  __msan_warning+0x82/0xf0 mm/kmsan/kmsan_instr.c:313  gue6_err+0x475/0xc40 net/ipv6/fou6.c:101  __udp6_lib_err_encap_no_sk net/ipv6/udp.c:434 [inline]  __udp6_lib_err_encap net/ipv6/udp.c:491 [inline]  __udp6_lib_err+0x18d0/0x2590 net/ipv6/udp.c:522  udplitev6_err+0x118/0x130 net/ipv6/udplite.c:27  icmpv6_notify+0x462/0x9f0 net/ipv6/icmp.c:784  icmpv6_rcv+0x18ac/0x3fa0 net/ipv6/icmp.c:872  ip6_protocol_deliver_rcu+0xb5a/0x23a0 net/ipv6/ip6_input.c:394  ip6_input_finish net/ipv6/ip6_input.c:434 [inline]  NF_HOOK include/linux/netfilter.h:289 [inline]  ip6_input+0x2b6/0x350 net/ipv6/ip6_input.c:443  dst_input include/net/dst.h:450 [inline]  ip6_rcv_finish+0x4e7/0x6d0 net/ipv6/ip6_input.c:76  NF_HOOK include/linux/netfilter.h:289 [inline]  ipv6_rcv+0x34b/0x3f0 net/ipv6/ip6_input.c:272  __netif_receive_skb_one_core net/core/dev.c:4973 [inline]  __netif_receive_skb net/core/dev.c:5083 [inline]  process_backlog+0x756/0x10e0 net/core/dev.c:5923  napi_poll net/core/dev.c:6346 [inline]  net_rx_action+0x78b/0x1a60 net/core/dev.c:6412  __do_softirq+0x53f/0x93a kernel/softirq.c:293  do_softirq_own_stack+0x49/0x80 arch/x86/entry/entry_64.S:1039  </IRQ>  do_softirq kernel/softirq.c:338 [inline]  __local_bh_enable_ip+0x16f/0x1a0 kernel/softirq.c:190  local_bh_enable+0x36/0x40 include/linux/bottom_half.h:32  rcu_read_unlock_bh include/linux/rcupdate.h:696 [inline]  ip6_finish_output2+0x1d64/0x25f0 net/ipv6/ip6_output.c:121  ip6_finish_output+0xae4/0xbc0 net/ipv6/ip6_output.c:154  NF_HOOK_COND include/linux/netfilter.h:278 [inline]  ip6_output+0x5ca/0x710 net/ipv6/ip6_output.c:171  dst_output include/net/dst.h:444 [inline]  ip6_local_out+0x164/0x1d0 net/ipv6/output_core.c:176  ip6_send_skb+0xfa/0x390 net/ipv6/ip6_output.c:1727  udp_v6_send_skb+0x1733/0x1d20 net/ipv6/udp.c:1169  udpv6_sendmsg+0x424e/0x45d0 net/ipv6/udp.c:1466  inet_sendmsg+0x54a/0x720 net/ipv4/af_inet.c:798  sock_sendmsg_nosec net/socket.c:621 [inline]  sock_sendmsg net/socket.c:631 [inline]  ___sys_sendmsg+0xdb9/0x11b0 net/socket.c:2116  __sys_sendmmsg+0x580/0xad0 net/socket.c:2211  __do_sys_sendmmsg net/socket.c:2240 [inline]  __se_sys_sendmmsg+0xbd/0xe0 net/socket.c:2237  __x64_sys_sendmmsg+0x56/0x70 net/socket.c:2237  do_syscall_64+0xbc/0xf0 arch/x86/entry/common.c:291  entry_SYSCALL_64_after_hwframe+0x63/0xe7 ",26fc181e6cacacd4837da7ffe0c871134a421600,1
USB: rio500: refuse more than one device at a time,This driver is using a global variable. It cannot handle more than one device at a time. The issue has been existing since the dawn of the driver.  ,3864d33943b4a76c6e64616280e98d2410b1190f,0
mm: memcontrol: print proper OOM header when no eligible victim left,"When the memcg OOM killer runs out of killable tasks, it currently prints a WARN with no further OOM context.  This has caused some user confusion.  Warnings indicate a kernel problem.  In a reported case, however, the situation was triggered by a nonsensical memcg configuration (hard limit set to 0).  But without any VM context this wasn't obvious from the report, and it took some back and forth on the mailing list to identify what is actually a trivial issue.  Handle this OOM condition like we handle it in the global OOM killer: dump the full OOM context and tell the user we ran out of tasks.  This way the user can identify misconfigurations easily by themselves and rectify the problem - without having to go through the hassle of running into an obscure but unsettling warning, finding the appropriate kernel mailing list and waiting for a kernel developer to remote-analyze that the memcg configuration caused this.  If users cannot make sense of why the OOM killer was triggered or why it failed, they will still report it to the mailing list, we know that from experience.  So in case there is an actual kernel bug causing this, kernel developers will very likely hear about it.  ",3100dab2aa09dc6e082956e306fc9f81b3cc0f7a,0
io-wq: Fix UAF when wakeup wqe in hash waitqueue,"BUG: KASAN: use-after-free in __wake_up_common+0x637/0x650 Read of size 8 at addr ffff8880304250d8 by task iou-wrk-28796/28802  Call Trace:  __dump_stack [inline]  dump_stack+0x141/0x1d7  print_address_description.constprop.0.cold+0x5b/0x2c6  __kasan_report [inline]  kasan_report.cold+0x7c/0xd8  __wake_up_common+0x637/0x650  __wake_up_common_lock+0xd0/0x130  io_worker_handle_work+0x9dd/0x1790  io_wqe_worker+0xb2a/0xd40  ret_from_fork+0x1f/0x30  Allocated by task 28798:  kzalloc_node [inline]  io_wq_create+0x3c4/0xdd0  io_init_wq_offload [inline]  io_uring_alloc_task_context+0x1bf/0x6b0  __io_uring_add_task_file+0x29a/0x3c0  io_uring_add_task_file [inline]  io_uring_install_fd [inline]  io_uring_create [inline]  io_uring_setup+0x209a/0x2bd0  do_syscall_64+0x3a/0xb0  entry_SYSCALL_64_after_hwframe+0x44/0xae  Freed by task 28798:  kfree+0x106/0x2c0  io_wq_destroy+0x182/0x380  io_wq_put [inline]  io_wq_put_and_exit+0x7a/0xa0  io_uring_clean_tctx [inline]  __io_uring_cancel+0x428/0x530  io_uring_files_cancel  do_exit+0x299/0x2a60  do_group_exit+0x125/0x310  get_signal+0x47f/0x2150  arch_do_signal_or_restart+0x2a8/0x1eb0  handle_signal_work[inline]  exit_to_user_mode_loop [inline]  exit_to_user_mode_prepare+0x171/0x280  __syscall_exit_to_user_mode_work [inline]  syscall_exit_to_user_mode+0x19/0x60  do_syscall_64+0x47/0xb0  entry_SYSCALL_64_after_hwframe  There are the following scenarios, hash waitqueue is shared by io-wq1 and io-wq2. (note: wqe is worker)  io-wq1:worker2     | locks bit1 io-wq2:worker1     | waits bit1 io-wq1:worker3     | waits bit1  io-wq1:worker2     | completes all wqe bit1 work items io-wq1:worker2     | drop bit1, exit  io-wq2:worker1     | locks bit1 io-wq1:worker3     | can not locks bit1, waits bit1 and exit io-wq1             | exit and free io-wq1 io-wq2:worker1     | drops bit1 io-wq1:worker3     | be waked up, even though wqe is freed  After all iou-wrk belonging to io-wq1 have exited, remove wqe form hash waitqueue, it is guaranteed that there will be no more wqe belonging to io-wq1 in the hash waitqueue.  ",3743c1723bfc62e69dbf022417720eed3f431b29,1
wext: call cfg80211_change_iface() with wiphy lock held,This is needed now that all the driver callbacks are protected by the wiphy lock rather than (just) the RTNL.  ,bae173563cbf469533d0c38534b874d4a2df0c85,0
Input: appletouch - initialize work before device registration,"Syzbot has reported warning in __flush_work(). This warning is caused by work->func == NULL, which means missing work initialization.  This may happen, since input_dev->close() calls cancel_work_sync(&dev->work), but dev->work initalization happens _after_ input_register_device() call.  So this patch moves dev->work initialization before registering input device  ",9f3ccdc3f6ef10084ceb3a47df0961bec6196fd0,0
tty: Don't call panic() at tty_ldisc_init(),"syzbot is reporting kernel panic [1] triggered by memory allocation failure at tty_ldisc_get() from tty_ldisc_init(). But since both tty_ldisc_get() and caller of tty_ldisc_init() can cleanly handle errors, tty_ldisc_init() does not need to call panic() when tty_ldisc_get() failed.  [1] https://syzkaller.appspot.com/bug?id=883431818e036ae6a9981156a64b821110f39187  ",903f9db10f18f735e62ba447147b6c434b6af003,1
net: fix a potential recursive NETDEV_FEAT_CHANGE,"syzbot managed to trigger a recursive NETDEV_FEAT_CHANGE event between bonding master and slave. I managed to find a reproducer for this:    ip li set bond0 up   ifenslave bond0 eth0   brctl addbr br0   ethtool -K eth0 lro off   brctl addif br0 bond0   ip li set br0 up  When a NETDEV_FEAT_CHANGE event is triggered on a bonding slave, it captures this and calls bond_compute_features() to fixup its master's and other slaves' features. However, when syncing with its lower devices by netdev_sync_lower_features() this event is triggered again on slaves when the LRO feature fails to change, so it goes back and forth recursively until the kernel stack is exhausted.  Commit 17b85d29e82c intentionally lets __netdev_update_features() return -1 for such a failure case, so we have to just rely on the existing check inside netdev_sync_lower_features() and skip NETDEV_FEAT_CHANGE event only for this specific failure case.  ",dd912306ff008891c82cd9f63e8181e47a9cb2fb,0
net/wan: fix a double free in x25_asy_open_tty(),"When x25_asy_open() fails, it already cleans up by itself, so its caller doesn't need to free the memory again.  It seems we still have to call x25_asy_free() to clear the SLF_INUSE bit, so just set these pointers to NULL after kfree().  ",d5c7c745f254c6cb98b3b3f15fe789b8bd770c72,1
cfg80211: check dev_set_name() return value,"syzbot reported a warning from rfkill_alloc(), and after a while I think that the reason is that it was doing fault injection and the dev_set_name() failed, leaving the name NULL, and we didn't check the return value and got to rfkill_alloc() with a NULL name. Since we really don't want a NULL name, we ought to check the return value.  ",59b179b48ce2a6076448a44531242ac2b3f6cef2,0
mm/gup.c: teach get_user_pages_unlocked to handle FOLL_NOWAIT,"KVM is hanging during postcopy live migration with userfaultfd because get_user_pages_unlocked is not capable to handle FOLL_NOWAIT.  Earlier FOLL_NOWAIT was only ever passed to get_user_pages.  Specifically faultin_page (the callee of get_user_pages_unlocked caller) doesn't know that if FAULT_FLAG_RETRY_NOWAIT was set in the page fault flags, when VM_FAULT_RETRY is returned, the mmap_sem wasn't actually released (even if nonblocking is not NULL).  So it sets *nonblocking to zero and the caller won't release the mmap_sem thinking it was already released, but it wasn't because of FOLL_NOWAIT.  ",96312e61282ae3f6537a562625706498cbc75594,0
sctp: destroy bucket if failed to bind addr,"There is one memory leak bug report: BUG: memory leak unreferenced object 0xffff8881dc4c5ec0 (size 40):   comm ""syz-executor.0"", pid 5673, jiffies 4298198457 (age 27.578s)   ",29b99f54a8e63f871cf4060406d09fd8b0d744d8,1
x86/mm: Fix use-after-free of ldt_struct,"The following commit:    39a0526fb3f7 (""x86/mm: Factor out LDT init from context init"")  renamed init_new_context() to init_new_context_ldt() and added a new init_new_context() which calls init_new_context_ldt().  However, the error code of init_new_context_ldt() was ignored.  Consequently, if a memory allocation in alloc_ldt_struct() failed during a fork(), the ->context.ldt of the new task remained the same as that of the old task (due to the memcpy() in dup_mm()).  ldt_struct's are not intended to be shared, so a use-after-free occurred after one task exited.  Fix the bug by making init_new_context() pass through the error code of init_new_context_ldt().  This bug was found by syzkaller, which encountered the following splat:      BUG: KASAN: use-after-free in free_ldt_struct.part.2+0x10a/0x150 arch/x86/kernel/ldt.c:116     Read of size 4 at addr ffff88006d2cb7c8 by task kworker/u9:0/3710      CPU: 1 PID: 3710 Comm: kworker/u9:0 Not tainted 4.13.0-rc4-next-20170811 #2     Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS Bochs 01/01/2011     Call Trace:      __dump_stack lib/dump_stack.c:16 [inline]      dump_stack+0x194/0x257 lib/dump_stack.c:52      print_address_description+0x73/0x250 mm/kasan/report.c:252      kasan_report_error mm/kasan/report.c:351 [inline]      kasan_report+0x24e/0x340 mm/kasan/report.c:409      __asan_report_load4_noabort+0x14/0x20 mm/kasan/report.c:429      free_ldt_struct.part.2+0x10a/0x150 arch/x86/kernel/ldt.c:116      free_ldt_struct arch/x86/kernel/ldt.c:173 [inline]      destroy_context_ldt+0x60/0x80 arch/x86/kernel/ldt.c:171      destroy_context arch/x86/include/asm/mmu_context.h:157 [inline]      __mmdrop+0xe9/0x530 kernel/fork.c:889      mmdrop include/linux/sched/mm.h:42 [inline]      exec_mmap fs/exec.c:1061 [inline]      flush_old_exec+0x173c/0x1ff0 fs/exec.c:1291      load_elf_binary+0x81f/0x4ba0 fs/binfmt_elf.c:855      search_binary_handler+0x142/0x6b0 fs/exec.c:1652      exec_binprm fs/exec.c:1694 [inline]      do_execveat_common.isra.33+0x1746/0x22e0 fs/exec.c:1816      do_execve+0x31/0x40 fs/exec.c:1860      call_usermodehelper_exec_async+0x457/0x8f0 kernel/umh.c:100      ret_from_fork+0x2a/0x40 arch/x86/entry/entry_64.S:431      Allocated by task 3700:      save_stack_trace+0x16/0x20 arch/x86/kernel/stacktrace.c:59      save_stack+0x43/0xd0 mm/kasan/kasan.c:447      set_track mm/kasan/kasan.c:459 [inline]      kasan_kmalloc+0xad/0xe0 mm/kasan/kasan.c:551      kmem_cache_alloc_trace+0x136/0x750 mm/slab.c:3627      kmalloc include/linux/slab.h:493 [inline]      alloc_ldt_struct+0x52/0x140 arch/x86/kernel/ldt.c:67      write_ldt+0x7b7/0xab0 arch/x86/kernel/ldt.c:277      sys_modify_ldt+0x1ef/0x240 arch/x86/kernel/ldt.c:307      entry_SYSCALL_64_fastpath+0x1f/0xbe      Freed by task 3700:      save_stack_trace+0x16/0x20 arch/x86/kernel/stacktrace.c:59      save_stack+0x43/0xd0 mm/kasan/kasan.c:447      set_track mm/kasan/kasan.c:459 [inline]      kasan_slab_free+0x71/0xc0 mm/kasan/kasan.c:524      __cache_free mm/slab.c:3503 [inline]      kfree+0xca/0x250 mm/slab.c:3820      free_ldt_struct.part.2+0xdd/0x150 arch/x86/kernel/ldt.c:121      free_ldt_struct arch/x86/kernel/ldt.c:173 [inline]      destroy_context_ldt+0x60/0x80 arch/x86/kernel/ldt.c:171      destroy_context arch/x86/include/asm/mmu_context.h:157 [inline]      __mmdrop+0xe9/0x530 kernel/fork.c:889      mmdrop include/linux/sched/mm.h:42 [inline]      __mmput kernel/fork.c:916 [inline]      mmput+0x541/0x6e0 kernel/fork.c:927      copy_process.part.36+0x22e1/0x4af0 kernel/fork.c:1931      copy_process kernel/fork.c:1546 [inline]      _do_fork+0x1ef/0xfb0 kernel/fork.c:2025      SYSC_clone kernel/fork.c:2135 [inline]      SyS_clone+0x37/0x50 kernel/fork.c:2129      do_syscall_64+0x26c/0x8c0 arch/x86/entry/common.c:287      return_from_SYSCALL_64+0x0/0x7a  Here is a C reproducer:      #include <asm/ldt.h>     #include <pthread.h>     #include <signal.h>     #include <stdlib.h>     #include <sys/syscall.h>     #include <sys/wait.h>     #include <unistd.h>      static void *fork_thread(void *_arg)     {         fork();     }      int main(void)     {         struct user_desc desc = { .entry_number = 8191 };          syscall(__NR_modify_ldt, 1, &desc, sizeof(desc));          for (;;) {             if (fork() == 0) {                 pthread_t t;                  srand(getpid());                 pthread_create(&t, NULL, fork_thread, NULL);                 usleep(rand() % 10000);                 syscall(__NR_exit_group, 0);             }             wait(NULL);         }     }  Note: the reproducer takes advantage of the fact that alloc_ldt_struct() may use vmalloc() to allocate a large ->entries array, and after commit:    5d17a73a2ebe (""vmalloc: back off when the current task is killed"")  it is possible for userspace to fail a task's vmalloc() by sending a fatal signal, e.g. via exit_group().  It would be more difficult to reproduce this bug on kernels without that commit.  This bug only affected kernels with CONFIG_MODIFY_LDT_SYSCALL=y.  ",ccd5b3235180eef3cfec337df1c8554ab151b5cc,1
"Revert ""mm/slub: fix a memory leak in sysfs_slab_add()""","This reverts commit dde3c6b72a16c2db826f54b2d49bdea26c3534a2.  syzbot report a double-free bug. The following case can cause this bug.   - mm/slab_common.c: create_cache(): if the __kmem_cache_create() fails,    it does:  	out_free_cache: 		kmem_cache_free(kmem_cache, s);   - but __kmem_cache_create() - at least for slub() - will have done  	sysfs_slab_add(s) 		-> sysfs_create_group() .. fails .. 		-> kobject_del(&s->kobj); .. which frees s ...  We can't remove the kmem_cache_free() in create_cache(), because other error cases of __kmem_cache_create() do not free this.  So, revert the commit dde3c6b72a16 (""mm/slub: fix a memory leak in sysfs_slab_add()"") to fix this.  ",757fed1d0898b893d7daa84183947c70f27632f3,1
net: use skb_queue_empty_lockless() in poll() handlers,Many poll() handlers are lockless. Using skb_queue_empty_lockless() instead of skb_queue_empty() is more appropriate.  ,3ef7cf57c72f32f61e97f8fa401bc39ea1f1a5d4,0
sock: unlock on error in sock_setsockopt(),If copy_from_sockptr() then we need to unlock before returning.  ,271dbc31843244e5192f0f8a8be0da26995f944a,0
udp: avoid refcount_t saturation in __udp_gso_segment(),"For some reason, Willem thought that the issue we fixed for TCP in commit 7ec318feeed1 (""tcp: gso: avoid refcount_t warning from tcp_gso_segment()"") was not relevant for UDP GSO.  But syzbot found its way.  refcount_t: saturated; leaking memory. ",575b65bc5bff37ec502d5eab9fc91d0a8d5ec40e,0
video: vga16fb: Only probe for EGA and VGA 16 color graphic cards,"The vga16fb framebuffer driver only supports Enhanced Graphics Adapter (EGA) and Video Graphics Array (VGA) 16 color graphic cards.  But it doesn't check if the adapter is one of those or if a VGA16 mode is used. This means that the driver will be probed even if a VESA BIOS Extensions (VBE) or Graphics Output Protocol (GOP) interface is used.  This issue has been present for a long time but it was only exposed by commit d391c5827107 (""drivers/firmware: move x86 Generic System Framebuffers support"") since the platform device registration to match the {vesa,efi}fb drivers is done later as a consequence of that change.  All non-x86 architectures though treat orig_video_isVGA as a boolean so only do the supported video mode check for x86 and not for other arches.  ",0499f419b76f94ede08304aad5851144813ac55c,0
USB: usbfs: fix mmap dma mismatch,"In commit 2bef9aed6f0e (""usb: usbfs: correct kernel->user page attribute mismatch"") we switched from always calling remap_pfn_range() to call dma_mmap_coherent() to handle issues with systems with non-coherent USB host controller drivers.  Unfortunatly, as syzbot quickly told us, not all the world is host controllers with DMA support, so we need to check what host controller we are attempting to talk to before doing this type of allocation.  ",a0e710a7def471b8eb779ff551fc27701da49599,0
mac802154: tx: fix use-after-free,"syzbot reported a bug in ieee802154_tx() [1]  A similar issue in ieee802154_xmit_worker() is also fixed in this patch.  [1] BUG: KASAN: use-after-free in ieee802154_tx+0x3d2/0x480 net/mac802154/tx.c:88 Read of size 4 at addr ffff8880251a8c70 by task syz-executor.3/928  CPU: 0 PID: 928 Comm: syz-executor.3 Not tainted 5.9.0-rc3-syzkaller #0 Hardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 01/01/2011 Call Trace:  __dump_stack lib/dump_stack.c:77 [inline]  dump_stack+0x198/0x1fd lib/dump_stack.c:118  print_address_description.constprop.0.cold+0xae/0x497 mm/kasan/report.c:383  __kasan_report mm/kasan/report.c:513 [inline]  kasan_report.cold+0x1f/0x37 mm/kasan/report.c:530  ieee802154_tx+0x3d2/0x480 net/mac802154/tx.c:88  ieee802154_subif_start_xmit+0xbe/0xe4 net/mac802154/tx.c:130  __netdev_start_xmit include/linux/netdevice.h:4634 [inline]  netdev_start_xmit include/linux/netdevice.h:4648 [inline]  dev_direct_xmit+0x4e9/0x6e0 net/core/dev.c:4203  packet_snd net/packet/af_packet.c:2989 [inline]  packet_sendmsg+0x2413/0x5290 net/packet/af_packet.c:3014  sock_sendmsg_nosec net/socket.c:651 [inline]  sock_sendmsg+0xcf/0x120 net/socket.c:671  ____sys_sendmsg+0x6e8/0x810 net/socket.c:2353  ___sys_sendmsg+0xf3/0x170 net/socket.c:2407  __sys_sendmsg+0xe5/0x1b0 net/socket.c:2440  do_syscall_64+0x2d/0x70 arch/x86/entry/common.c:46  entry_SYSCALL_64_after_hwframe+0x44/0xa9 ",0ff4628f4c6c1ab87eef9f16b25355cadc426d64,1
ALSA: usb-audio: Fix NULL dereference at parsing BADD,"snd_usb_mixer_controls_badd() that parses UAC3 BADD profiles misses a NULL check for the given interfaces.  When a malformed USB descriptor is passed, this may lead to an Oops, as spotted by syzkaller. Skip the iteration if the interface doesn't exist for avoiding the crash.  ",9435f2bb66874a0c4dd25e7c978957a7ca2c93b1,1
crypto: dh - fix calculating encoded key size,"It was forgotten to increase DH_KPP_SECRET_MIN_SIZE to include 'q_size', causing an out-of-bounds write of 4 bytes in crypto_dh_encode_key(), and an out-of-bounds read of 4 bytes in crypto_dh_decode_key().  Fix it, and fix the lengths of the test vectors to match this.  ",35f7d5225ffcbf1b759f641aec1735e3a89b1914,1
net_sched: use validated TCA_KIND attribute in tc_new_tfilter(),"sysbot found another issue in tc_new_tfilter(). We probably should use @name which contains the sanitized version of TCA_KIND.  BUG: KMSAN: uninit-value in string_nocheck lib/vsprintf.c:608 [inline] BUG: KMSAN: uninit-value in string+0x522/0x690 lib/vsprintf.c:689 CPU: 1 PID: 10753 Comm: syz-executor.1 Not tainted 5.5.0-rc5-syzkaller #0 Hardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 01/01/2011 Call Trace:  __dump_stack lib/dump_stack.c:77 [inline]  dump_stack+0x1c9/0x220 lib/dump_stack.c:118  kmsan_report+0xf7/0x1e0 mm/kmsan/kmsan_report.c:118  __msan_warning+0x58/0xa0 mm/kmsan/kmsan_instr.c:215  string_nocheck lib/vsprintf.c:608 [inline]  string+0x522/0x690 lib/vsprintf.c:689  vsnprintf+0x207d/0x31b0 lib/vsprintf.c:2574  __request_module+0x2ad/0x11c0 kernel/kmod.c:143  tcf_proto_lookup_ops+0x241/0x720 net/sched/cls_api.c:139  tcf_proto_create net/sched/cls_api.c:262 [inline]  tc_new_tfilter+0x2a4e/0x5010 net/sched/cls_api.c:2058  rtnetlink_rcv_msg+0xcb7/0x1570 net/core/rtnetlink.c:5415  netlink_rcv_skb+0x451/0x650 net/netlink/af_netlink.c:2477  rtnetlink_rcv+0x50/0x60 net/core/rtnetlink.c:5442  netlink_unicast_kernel net/netlink/af_netlink.c:1302 [inline]  netlink_unicast+0xf9e/0x1100 net/netlink/af_netlink.c:1328  netlink_sendmsg+0x1248/0x14d0 net/netlink/af_netlink.c:1917  sock_sendmsg_nosec net/socket.c:639 [inline]  sock_sendmsg net/socket.c:659 [inline]  ____sys_sendmsg+0x12b6/0x1350 net/socket.c:2330  ___sys_sendmsg net/socket.c:2384 [inline]  __sys_sendmsg+0x451/0x5f0 net/socket.c:2417  __do_sys_sendmsg net/socket.c:2426 [inline]  __se_sys_sendmsg+0x97/0xb0 net/socket.c:2424  __x64_sys_sendmsg+0x4a/0x70 net/socket.c:2424  do_syscall_64+0xb8/0x160 arch/x86/entry/common.c:296  entry_SYSCALL_64_after_hwframe+0x44/0xa9 ",36d79af7fb59d6d9106feb9c1855eb93d6d53fe6,1
ext4: fix EXT4_IOC_SWAP_BOOT,"The code EXT4_IOC_SWAP_BOOT ioctl hasn't been updated in a while, and it's a bit broken with respect to more modern ext4 kernels, especially metadata checksums.  Other problems fixed with this commit:  * Don't allow installing a DAX, swap file, or an encrypted file as a   boot loader.  * Respect the immutable and append-only flags.  * Wait until any DIO operations are finished *before* calling   truncate_inode_pages().  * Don't swap inode->i_flags, since these flags have nothing to do with   the inode blocks ",18aded17492088962ef43f00825179598b3e8c58,0
bpf: tcp: Remove comma which is causing build error,"Currently, building the bpf-next source with the CONFIG_BPF_SYSCALL enabled is causing a compilation error:  ""net/ipv4/bpf_tcp_ca.c:209:28: error: expected identifier or '(' before ',' token""  Fix this by removing an unnecessary comma.  ",7e32a09fdcb38d97f148f72bf78a3b49e8d1612d,0
io_uring: fix unchecked error in switch_start(),"io_rsrc_node_switch_start() can fail, don't forget to check returned error code.  ",47b228ce6f66830768eac145efa7746637969101,0
netrom: Decrease sock refcount when sock timers expire,"Commit 63346650c1a9 (""netrom: switch to sock timer API"") switched to use sock timer API. It replaces mod_timer() by sk_reset_timer(), and del_timer() by sk_stop_timer().  Function sk_reset_timer() will increase the refcount of sock if it is called on an inactive timer, hence, in case the timer expires, we need to decrease the refcount ourselves in the handler, otherwise, the sock refcount will be unbalanced and the sock will never be freed.  ",517a16b1a88bdb6b530f48d5d153478b2552d9a8,0
vhost: reset metadata cache when initializing new IOTLB,"We need to reset metadata cache during new IOTLB initialization, otherwise the stale pointers to previous IOTLB may be still accessed which will lead a use after free.  ",b13f9c6364373a1b9f71e9846dc4fb199296f926,1
tipc: fix a potental access after delete in tipc_sk_join(),"In commit d12d2e12cec2 ""tipc: send out join messages as soon as new member is discovered"") we added a call to the function tipc_group_join() without considering the case that the preceding tipc_sk_publish() might have failed, and the group item already deleted.  We fix this by returning from tipc_sk_join() directly after the failed tipc_sk_publish.  ",febafc8455fdbb0ba53d596075068a683b75f355,0
userfaultfd: clear the vma->vm_userfaultfd_ctx if UFFD_EVENT_FORK fails,"The previous fix in commit 384632e67e08 (""userfaultfd: non-cooperative: fix fork use after free"") corrected the refcounting in case of UFFD_EVENT_FORK failure for the fork userfault paths.  That still didn't clear the vma->vm_userfaultfd_ctx of the vmas that were set to point to the aborted new uffd ctx earlier in dup_userfaultfd.  ",0cbb4b4f4c44f54af268969b18d8deda63aded59,1
squashfs: add more sanity checks in inode lookup,"Sysbot has reported an ""slab-out-of-bounds read"" error which has been identified as being caused by a corrupted ""ino_num"" value read from the inode.  This could be because the metadata block is uncompressed, or because the ""compression"" bit has been corrupted (turning a compressed block into an uncompressed block).  This patch adds additional sanity checks to detect this, and the following corruption.  1. It checks against corruption of the inodes count.  This can either    lead to a larger table to be read, or a smaller than expected    table to be read.     In the case of a too large inodes count, this would often have been    trapped by the existing sanity checks, but this patch introduces    a more exact check, which can identify too small values.  2. It checks the contents of the index table for corruption.  [phillip@squashfs.org.uk: fix checkpatch issue]    ",eabac19e40c095543def79cb6ffeb3a8588aaff4,1
io_uring: ensure consistent view of original task ->mm from SQPOLL,"Ensure we get a valid view of the task mm, by using task_lock() when attempting to grab the original task mm.  ",4b70cf9dea4cd239b425f3282fa56ce19e234c8a,0
ipv6: Fix dangling pointer when ipv6 fragment,"At the beginning of ip6_fragment func, the prevhdr pointer is obtained in the ip6_find_1stfragopt func. However, all the pointers pointing into skb header may change when calling skb_checksum_help func with skb->ip_summed = CHECKSUM_PARTIAL condition. The prevhdr pointe will be dangling if it is not reloaded after calling __skb_linearize func in skb_checksum_help func.  Here, I add a variable, nexthdr_offset, to evaluate the offset, which does not changes even after calling __skb_linearize func.  ",ef0efcd3bd3fd0589732b67fb586ffd3c8705806,0
io_uring: use cond_resched() in io_ring_ctx_wait_and_kill(),"While working on to make io_uring sqpoll mode support syscalls that need struct files_struct, I got cpu soft lockup in io_ring_ctx_wait_and_kill(),      while (ctx->sqo_thread && !wq_has_sleeper(&ctx->sqo_wait))         cpu_relax();  above loop never has an chance to exit, it's because preempt isn't enabled in the kernel, and the context calling io_ring_ctx_wait_and_kill() and io_sq_thread() run in the same cpu, if io_sq_thread calls a cond_resched() yield cpu and another context enters above loop, then io_sq_thread() will always in runqueue and never exit.  Use cond_resched() can fix this issue.   ",3fd44c86711f71156b586c22b0495c58f69358bb,0
vlan: fix memory leak in vlan_dev_set_egress_priority,"There are few cases where the ndo_uninit() handler might be not called if an error happens while device is initialized.  Since vlan_newlink() calls vlan_changelink() before trying to register the netdevice, we need to make sure vlan_dev_uninit() has been called at least once, or we might leak allocated memory.  BUG: memory leak unreferenced object 0xffff888122a206c0 (size 32):   comm ""syz-executor511"", pid 7124, jiffies 4294950399 (age 32.240s)   ",9bbd917e0bec9aebdbd0c8dbc966caec15eb33e9,1
net_sched: commit action insertions together,"syzbot is able to trigger a failure case inside the loop in tcf_action_init(), and when this happens we clean up with tcf_action_destroy(). But, as these actions are already inserted into the global IDR, other parallel process could free them before tcf_action_destroy(), then we will trigger a use-after-free.  Fix this by deferring the insertions even later, after the loop, and committing all the insertions in a separate loop, so we will never fail in the middle of the insertions any more.  One side effect is that the window between alloction and final insertion becomes larger, now it is more likely that the loop in tcf_del_walker() sees the placeholder -EBUSY pointer. So we have to check for error pointer in tcf_del_walker().  ",0fedc63fadf0404a729e73a35349481c8009c02f,1
USB: chaoskey: fix use-after-free on release,The driver was accessing its struct usb_interface in its release() callback without holding a reference. This would lead to a use-after-free whenever the device was disconnected while the character device was still open.  ,93ddb1f56ae102f14f9e46a9a9c8017faa970003,1
net: bridge: fix stale eth hdr pointer in br_dev_xmit,"In br_dev_xmit() we perform vlan filtering in br_allowed_ingress() but if the packet has the vlan header inside (e.g. bridge with disabled tx-vlan-offload) then the vlan filtering code will use skb_vlan_untag() to extract the vid before filtering which in turn calls pskb_may_pull() and we may end up with a stale eth pointer. Moreover the cached eth header pointer will generally be wrong after that operation. Remove the eth header caching and just use eth_hdr() directly, the compiler does the right thing and calculates it only once so we don't lose anything.  ",823d81b0fa2cd83a640734e74caee338b5d3c093,0
io_uring: use bottom half safe lock for fixed file data,"io_file_data_ref_zero() can be invoked from soft-irq from the RCU core, hence we need to ensure that the file_data lock is bottom half safe. Use the _bh() variants when grabbing this lock.  ",ac0648a56c1ff66c1cbf735075ad33a26cbc50de,0
tun: fix memory leak in error path,"syzbot reported a warning [1] that triggered after recent Jiri patch.  This exposes a bug that we hit already in the past (see commit ff244c6b29b1 (""tun: handle register_netdevice() failures properly"") for details)  tun uses priv->destructor without an ndo_init() method.  register_netdevice() can return an error, but will not call priv->destructor() in some cases. Jiri recent patch added one more.  A long term fix would be to transfer the initialization of what we destroy in ->destructor() in the ndo_init()  This looks a bit risky given the complexity of tun driver.  A simpler fix is to detect after the failed register_netdevice() if the tun_free_netdev() function was called already.  [1] ODEBUG: free active (active state 0) object type: timer_list hint: tun_flow_cleanup+0x0/0x280 drivers/net/tun.c:457 ",11fc7d5a0a2d458cae8ce5d5ee3ebfdabe2cb35a,1
ipmr: Fix RCU list debugging warning,"ipmr_for_each_table() macro uses list_for_each_entry_rcu() for traversing outside of an RCU read side critical section but under the protection of rtnl_mutex. Hence, add the corresponding lockdep expression to silence the following false-positive warning at boot:  ",a14fbcd4f157a5a97b6013289205559d246c5021,0
soreuseport: fix mem leak in reuseport_add_sock(),"reuseport_add_sock() needs to deal with attaching a socket having its own sk_reuseport_cb, after a prior setsockopt(SO_ATTACH_REUSEPORT_?BPF)  Without this fix, not only a WARN_ONCE() was issued, but we were also leaking memory.  ",4db428a7c9ab07e08783e0fcdc4ca0f555da0567,0
media: dvb: usb: fix use after free in dvb_usb_device_exit,dvb_usb_device_exit() frees and uses the device name in that order. Fix by storing the name in a buffer before freeing it.  ,6cf97230cd5f36b7665099083272595c55d72be7,1
bdi: Fix use after free bug in debugfs_remove(),"syzbot is reporting use after free bug in debugfs_remove() [1].  This is because fault injection made memory allocation for debugfs_create_file() from bdi_debug_register() from bdi_register_va() fail and continued with setting WB_registered. But when debugfs_remove() is called from debugfs_remove(bdi->debug_dir) from bdi_debug_unregister()  from bdi_unregister() from release_bdi() because WB_registered was set by bdi_register_va(), IS_ERR_OR_NULL(bdi->debug_dir) == false despite debugfs_remove(bdi->debug_dir) was already called from bdi_register_va().  Fix this by making IS_ERR_OR_NULL(bdi->debug_dir) == true.  [1] https://syzkaller.appspot.com/bug?id=5ab4efd91a96dcea9b68104f159adf4af2a6dfc1  ",f53823c18131e755905b4f654196fd2cc3953f6e,1
mm: check shrinker is memcg-aware in register_shrinker_prepared(),"There is a sad BUG introduced in patch adding SHRINKER_REGISTERING. shrinker_idr business is only for memcg-aware shrinkers.  Only such type of shrinkers have id and they must be finaly installed via idr_replace() in this function.  For !memcg-aware shrinkers we never initialize shrinker->id field.  But there are all types of shrinkers passed to idr_replace(), and every !memcg-aware shrinker with random ID (most probably, its id is 0) replaces memcg-aware shrinker pointed by the ID in IDR.  This patch fixes the problem.  ",8df4a44cc46bf9dcfb80a37a59ae5dea2232dc58,1
netfilter: nft_ct: protect nft_ct_pcpu_template_refcnt with mutex,"Syzbot hit use-after-free in nf_tables_dump_sets. The problem was in missing lock protection for nft_ct_pcpu_template_refcnt.  Before commit f102d66b335a (""netfilter: nf_tables: use dedicated mutex to guard transactions"") all transactions were serialized by global mutex, but then global mutex was changed to local per netnamespace commit_mutex.  This change causes use-after-free bug, when 2 netnamespaces concurently changing nft_ct_pcpu_template_refcnt without proper locking. Fix it by adding nft_ct_pcpu_mutex and protect all nft_ct_pcpu_template_refcnt changes with it.  ",e3245a7b7b34bd2e97f744fd79463add6e9d41f4,1
net/packet: refine check for priv area size,"syzbot was able to trick af_packet again [1]  Various commits tried to address the problem in the past, but failed to take into account V3 header size.  [1]  tpacket_rcv: packet too big, clamped from 72 to 4294967224. macoff=96 BUG: KASAN: use-after-free in prb_run_all_ft_ops net/packet/af_packet.c:1016 [inline] BUG: KASAN: use-after-free in prb_fill_curr_block.isra.59+0x4e5/0x5c0 net/packet/af_packet.c:1039 Write of size 2 at addr ffff8801cb62000e by task kworker/1:2/2106  CPU: 1 PID: 2106 Comm: kworker/1:2 Not tainted 4.17.0-rc7+ #77 Hardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 01/01/2011 Workqueue: ipv6_addrconf addrconf_dad_work Call Trace:  __dump_stack lib/dump_stack.c:77 [inline]  dump_stack+0x1b9/0x294 lib/dump_stack.c:113  print_address_description+0x6c/0x20b mm/kasan/report.c:256  kasan_report_error mm/kasan/report.c:354 [inline]  kasan_report.cold.7+0x242/0x2fe mm/kasan/report.c:412  __asan_report_store2_noabort+0x17/0x20 mm/kasan/report.c:436  prb_run_all_ft_ops net/packet/af_packet.c:1016 [inline]  prb_fill_curr_block.isra.59+0x4e5/0x5c0 net/packet/af_packet.c:1039  __packet_lookup_frame_in_block net/packet/af_packet.c:1094 [inline]  packet_current_rx_frame net/packet/af_packet.c:1117 [inline]  tpacket_rcv+0x1866/0x3340 net/packet/af_packet.c:2282  dev_queue_xmit_nit+0x891/0xb90 net/core/dev.c:2018  xmit_one net/core/dev.c:3049 [inline]  dev_hard_start_xmit+0x16b/0xc10 net/core/dev.c:3069  __dev_queue_xmit+0x2724/0x34c0 net/core/dev.c:3584  dev_queue_xmit+0x17/0x20 net/core/dev.c:3617  neigh_resolve_output+0x679/0xad0 net/core/neighbour.c:1358  neigh_output include/net/neighbour.h:482 [inline]  ip6_finish_output2+0xc9c/0x2810 net/ipv6/ip6_output.c:120  ip6_finish_output+0x5fe/0xbc0 net/ipv6/ip6_output.c:154  NF_HOOK_COND include/linux/netfilter.h:277 [inline]  ip6_output+0x227/0x9b0 net/ipv6/ip6_output.c:171  dst_output include/net/dst.h:444 [inline]  NF_HOOK include/linux/netfilter.h:288 [inline]  ndisc_send_skb+0x100d/0x1570 net/ipv6/ndisc.c:491  ndisc_send_ns+0x3c1/0x8d0 net/ipv6/ndisc.c:633  addrconf_dad_work+0xbef/0x1340 net/ipv6/addrconf.c:4033  process_one_work+0xc1e/0x1b50 kernel/workqueue.c:2145  worker_thread+0x1cc/0x1440 kernel/workqueue.c:2279  kthread+0x345/0x410 kernel/kthread.c:240  ret_from_fork+0x3a/0x50 arch/x86/entry/entry_64.S:412  The buggy address belongs to the page: page:ffffea00072d8800 count:0 mapcount:-127 mapping:0000000000000000 index:0xffff8801cb620e80 flags: 0x2fffc0000000000() raw: 02fffc0000000000 0000000000000000 ffff8801cb620e80 00000000ffffff80 raw: ffffea00072e3820 ffffea0007132d20 0000000000000002 0000000000000000 page dumped because: kasan: bad access detected  Memory state around the buggy ",eb73190f4fbeedf762394e92d6a4ec9ace684c88,1
netfilter: nf_tables: free chain context when BINDING flag is missing,syzbot found a memory leak in nf_tables_addchain() because the chain object is not free'd correctly on error.  ,59136aa3b2649796a3a1fd90158675f1f640ce0e,1
RDMA/ucma: Limit possible option size,"Users of ucma are supposed to provide size of option level, in most paths it is supposed to be equal to u8 or u16, but it is not the case for the IB path record, where it can be multiple of struct ib_path_rec_data.  This patch takes simplest possible approach and prevents providing values more than possible to allocate.  ",6a21dfc0d0db7b7e0acedce67ca533a6eb19283c,0
vsock: fix potential deadlock in transport->release(),"Some transports (hyperv, virtio) acquire the sock lock during the .release() callback.  In the vsock_stream_connect() we call vsock_assign_transport(); if the socket was previously assigned to another transport, the vsk->transport->release() is called, but the sock lock is already held in the vsock_stream_connect(), causing a deadlock reported by syzbot:      INFO: task syz-executor280:9768 blocked for more than 143 seconds.       Not tainted 5.6.0-rc1-syzkaller #0     ""echo 0 > /proc/sys/kernel/hung_task_timeout_secs"" disables this message.     syz-executor280 D27912  9768   9766 0x00000000     Call Trace:      context_switch kernel/sched/core.c:3386 [inline]      __schedule+0x934/0x1f90 kernel/sched/core.c:4082      schedule+0xdc/0x2b0 kernel/sched/core.c:4156      __lock_sock+0x165/0x290 net/core/sock.c:2413      lock_sock_nested+0xfe/0x120 net/core/sock.c:2938      virtio_transport_release+0xc4/0xd60 net/vmw_vsock/virtio_transport_common.c:832      vsock_assign_transport+0xf3/0x3b0 net/vmw_vsock/af_vsock.c:454      vsock_stream_connect+0x2b3/0xc70 net/vmw_vsock/af_vsock.c:1288      __sys_connect_file+0x161/0x1c0 net/socket.c:1857      __sys_connect+0x174/0x1b0 net/socket.c:1874      __do_sys_connect net/socket.c:1885 [inline]      __se_sys_connect net/socket.c:1882 [inline]      __x64_sys_connect+0x73/0xb0 net/socket.c:1882      do_syscall_64+0xfa/0x790 arch/x86/entry/common.c:294      entry_SYSCALL_64_after_hwframe+0x49/0xbe  To avoid this issue, this patch remove the lock acquiring in the .release() callback of hyperv and virtio transports, and it holds the lock when we call vsk->transport->release() in the vsock core.  ",3f74957fcbeab703297ed0f135430414ed7e0dd0,1
net/af_unix: fix a data-race in unix_dgram_sendmsg / unix_release_sock,"While unix_may_send(sk, osk) is called while osk is locked, it appears unix_release_sock() can overwrite unix_peer() after this lock has been released, making KCSAN unhappy.  Changing unix_release_sock() to access/change unix_peer() before lock is released should fix this issue.  BUG: KCSAN: data-race in unix_dgram_sendmsg / unix_release_sock  write to 0xffff88810465a338 of 8 bytes by task 20852 on cpu 1:  unix_release_sock+0x4ed/0x6e0 net/unix/af_unix.c:558  unix_release+0x2f/0x50 net/unix/af_unix.c:859  __sock_release net/socket.c:599 [inline]  sock_close+0x6c/0x150 net/socket.c:1258  __fput+0x25b/0x4e0 fs/file_table.c:280  ____fput+0x11/0x20 fs/file_table.c:313  task_work_run+0xae/0x130 kernel/task_work.c:164  tracehook_notify_resume include/linux/tracehook.h:189 [inline]  exit_to_user_mode_loop kernel/entry/common.c:175 [inline]  exit_to_user_mode_prepare+0x156/0x190 kernel/entry/common.c:209  __syscall_exit_to_user_mode_work kernel/entry/common.c:291 [inline]  syscall_exit_to_user_mode+0x20/0x40 kernel/entry/common.c:302  do_syscall_64+0x56/0x90 arch/x86/entry/common.c:57  entry_SYSCALL_64_after_hwframe+0x44/0xae  read to 0xffff88810465a338 of 8 bytes by task 20888 on cpu 0:  unix_may_send net/unix/af_unix.c:189 [inline]  unix_dgram_sendmsg+0x923/0x1610 net/unix/af_unix.c:1712  sock_sendmsg_nosec net/socket.c:654 [inline]  sock_sendmsg net/socket.c:674 [inline]  ____sys_sendmsg+0x360/0x4d0 net/socket.c:2350  ___sys_sendmsg net/socket.c:2404 [inline]  __sys_sendmmsg+0x315/0x4b0 net/socket.c:2490  __do_sys_sendmmsg net/socket.c:2519 [inline]  __se_sys_sendmmsg net/socket.c:2516 [inline]  __x64_sys_sendmmsg+0x53/0x60 net/socket.c:2516  do_syscall_64+0x4a/0x90 arch/x86/entry/common.c:47  entry_SYSCALL_64_after_hwframe+0x44/0xae  value changed: 0xffff888167905400 -> 0x0000000000000000  Reported by Kernel Concurrency Sanitizer on: CPU: 0 PID: 20888 Comm: syz-executor.0 Not tainted 5.13.0-rc5-syzkaller #0 Hardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 01/01/2011  ",a494bd642d9120648b06bb7d28ce6d05f55a7819,1
block: fix memleak when __blk_rq_map_user_iov() is failed,"When I doing fuzzy test, get the memleak report:  BUG: memory leak unreferenced object 0xffff88837af80000 (size 4096):   comm ""memleak"", pid 3557, jiffies 4294817681 (age 112.499s)   ",3b7995a98ad76da5597b488fa84aa5a56d43b608,1
KVM: x86: don't forget vcpu_put() in kvm_arch_vcpu_ioctl_set_sregs(),"Due to a bad merge resolution between commit f29810335965 (""KVM/x86: Check input paging mode when cs.l is set"") and commit b4ef9d4e8cb8 (""KVM: Move vcpu_load to arch-specific kvm_arch_vcpu_ioctl_set_sregs""), there is a case in kvm_arch_vcpu_ioctl_set_sregs() where vcpu_put() is not called after vcpu_get().  Fix it.  ",8dbfb2bf1bb3848a8069164e205635b2675c24fe,0
"mm, oom: make the calculation of oom badness more accurate","Recently we found an issue on our production environment that when memcg oom is triggered the oom killer doesn't chose the process with largest resident memory but chose the first scanned process.  Note that all processes in this memcg have the same oom_score_adj, so the oom killer should chose the process with largest resident memory.  Bellow is part of the oom info, which is enough to analyze this issue. [7516987.983223] memory: usage 16777216kB, limit 16777216kB, failcnt 52843037 [7516987.983224] memory+swap: usage 16777216kB, limit 9007199254740988kB, failcnt 0 [7516987.983225] kmem: usage 301464kB, limit 9007199254740988kB, failcnt 0 [...] [7516987.983293] ",9066e5cfb73cdbcdbb49e87999482ab615e9fc76,0
net: rose: fix a possible stack overflow,"rose_write_internal() uses a temp buffer of 100 bytes, but a manual inspection showed that given arbitrary input, rose_create_facilities() can fill up to 110 bytes.  Lets use a tailroom of 256 bytes for peace of mind, and remove the bounce buffer : we can simply allocate a big enough skb and adjust its length as needed.  syzbot report :  BUG: KASAN: stack-out-of-bounds in memcpy include/linux/string.h:352 [inline] BUG: KASAN: stack-out-of-bounds in rose_create_facilities net/rose/rose_subr.c:521 [inline] BUG: KASAN: stack-out-of-bounds in rose_write_internal+0x597/0x15d0 net/rose/rose_subr.c:116 Write of size 7 at addr ffff88808b1ffbef by task syz-executor.0/24854  CPU: 0 PID: 24854 Comm: syz-executor.0 Not tainted 5.0.0+ #97 Hardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 01/01/2011 Call Trace:  __dump_stack lib/dump_stack.c:77 [inline]  dump_stack+0x172/0x1f0 lib/dump_stack.c:113  print_address_description.cold+0x7c/0x20d mm/kasan/report.c:187  kasan_report.cold+0x1b/0x40 mm/kasan/report.c:317  check_memory_region_inline mm/kasan/generic.c:185 [inline]  check_memory_region+0x123/0x190 mm/kasan/generic.c:191  memcpy+0x38/0x50 mm/kasan/common.c:131  memcpy include/linux/string.h:352 [inline]  rose_create_facilities net/rose/rose_subr.c:521 [inline]  rose_write_internal+0x597/0x15d0 net/rose/rose_subr.c:116  rose_connect+0x7cb/0x1510 net/rose/af_rose.c:826  __sys_connect+0x266/0x330 net/socket.c:1685  __do_sys_connect net/socket.c:1696 [inline]  __se_sys_connect net/socket.c:1693 [inline]  __x64_sys_connect+0x73/0xb0 net/socket.c:1693  do_syscall_64+0x103/0x610 arch/x86/entry/common.c:290  entry_SYSCALL_64_after_hwframe+0x49/0xbe ",e5dcc0c3223c45c94100f05f28d8ef814db3d82c,1
net: introduce and use lock_sock_fast_nested(),"Syzkaller reported a false positive deadlock involving the nl socket lock and the subflow socket lock:  MPTCP: kernel_bind error, err=-98 ",49054556289e8787501630b7c7a9d407da02e296,0
inet: annotate data race in inet_send_prepare() and inet_dgram_connect(),Both functions are known to be racy when reading inet_num as we do not want to grab locks for the common case the socket has been bound already. The race is resolved in inet_autobind() by reading again inet_num under the socket lock.  ,dcd01eeac14486b56a790f5cce9b823440ba5b34,1
ext4: fix memory leak in ext4_fill_super,"static int kthread(void *_create) will return -ENOMEM or -EINTR in case of internal failure or kthread_stop() call happens before threadfn call.  To prevent fancy error checking and make code more straightforward we moved all cleanup code out of kmmpd threadfn.  Also, dropped struct mmpd_data at all. Now struct super_block is a threadfn data and struct buffer_head embedded into struct ext4_sb_info.  ",618f003199c6188e01472b03cdbba227f1dc5f24,1
packet: hold bind lock when rebinding to fanout hook,"Packet socket bind operations must hold the po->bind_lock. This keeps po->running consistent with whether the socket is actually on a ptype list to receive packets.  fanout_add unbinds a socket and its packet_rcv/tpacket_rcv call, then binds the fanout object to receive through packet_rcv_fanout.  Make it hold the po->bind_lock when testing po->running and rebinding. Else, it can race with other rebind operations, such as that in packet_set_ring from packet_rcv to tpacket_rcv. Concurrent updates can result in a socket being added to a fanout group twice, causing use-after-free KASAN bug reports, among others.  Reported independently by both trinity and syzkaller. Verified that the syzkaller reproducer passes after this patch.  ",008ba2a13f2d04c947adc536d19debb8fe66f110,1
mac80211_hwsim: calculate if_combination.max_interfaces,"If we just set this to 2048, and have multiple limits you can select from, the total number might run over and cause a warning in cfg80211. This doesn't make sense, so we just calculate the total max_interfaces now.  ",45fcef8b727b6f171bc5443e8153181a367d7a15,0
shmem: pin the file in shmem_fault() if mmap_sem is dropped,"syzbot found the following crash:    BUG: KASAN: use-after-free in perf_trace_lock_acquire+0x401/0x530 include/trace/events/lock.h:13   Read of size 8 at addr ffff8880a5cf2c50 by task syz-executor.0/26173    CPU: 0 PID: 26173 Comm: syz-executor.0 Not tainted 5.3.0-rc6 #146   Hardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 01/01/2011   Call Trace:      perf_trace_lock_acquire+0x401/0x530 include/trace/events/lock.h:13      trace_lock_acquire include/trace/events/lock.h:13 [inline]      lock_acquire+0x2de/0x410 kernel/locking/lockdep.c:4411      __raw_spin_lock include/linux/spinlock_api_smp.h:142 [inline]      _raw_spin_lock+0x2f/0x40 kernel/locking/spinlock.c:151      spin_lock include/linux/spinlock.h:338 [inline]      shmem_fault+0x5ec/0x7b0 mm/shmem.c:2034      __do_fault+0x111/0x540 mm/memory.c:3083      do_shared_fault mm/memory.c:3535 [inline]      do_fault mm/memory.c:3613 [inline]      handle_pte_fault mm/memory.c:3840 [inline]      __handle_mm_fault+0x2adf/0x3f20 mm/memory.c:3964      handle_mm_fault+0x1b5/0x6b0 mm/memory.c:4001      do_user_addr_fault arch/x86/mm/fault.c:1441 [inline]      __do_page_fault+0x536/0xdd0 arch/x86/mm/fault.c:1506      do_page_fault+0x38/0x590 arch/x86/mm/fault.c:1530      page_fault+0x39/0x40 arch/x86/entry/entry_64.S:1202  It happens if the VMA got unmapped under us while we dropped mmap_sem and inode got freed.  Pinning the file if we drop mmap_sem fixes the issue.  ",8897c1b1a1795cab23d5ac13e4e23bf0b5f4e0c6,1
spi: fix use-after-free of the add_lock mutex,"Commit 6098475d4cb4 (""spi: Fix deadlock when adding SPI controllers on SPI buses"") introduced a per-controller mutex. But mutex_unlock() of said lock is called after the controller is already freed:    spi_unregister_controller(ctlr)   -> put_device(&ctlr->dev)     -> spi_controller_release(dev)   -> mutex_unlock(&ctrl->add_lock)  Move the put_device() after the mutex_unlock().  ",6c53b45c71b4920b5e62f0ea8079a1da382b9434,1
net/rds: Check laddr_check before calling it,"In rds_bind(), laddr_check is called without checking if it is NULL or not.  And rs_transport should be reset if rds_add_bound() fails.  ",05733434ee9ae6548723a808647248583e347cca,0
gso: validate gso_type in GSO handlers,"Validate gso_type during segmentation as SKB_GSO_DODGY sources may pass packets where the gso_type does not match the contents.  Syzkaller was able to enter the SCTP gso handler with a packet of gso_type SKB_GSO_TCPV4.  On entry of transport layer gso handlers, verify that the gso_type matches the transport protocol.  ",121d57af308d0cf943f08f4738d24d3966c38cd9,0
io_uring: fix io_sq_thread_stop running in front of io_sq_thread,"INFO: task syz-executor.5:8634 blocked for more than 143 seconds.        Not tainted 5.2.0-rc5+ #3 ""echo 0 > /proc/sys/kernel/hung_task_timeout_secs"" disables this message. syz-executor.5  D25632  8634   8224 0x00004004 Call Trace:   context_switch kernel/sched/core.c:2818 [inline]   __schedule+0x658/0x9e0 kernel/sched/core.c:3445   schedule+0x131/0x1d0 kernel/sched/core.c:3509   schedule_timeout+0x9a/0x2b0 kernel/time/timer.c:1783   do_wait_for_common+0x35e/0x5a0 kernel/sched/completion.c:83   __wait_for_common kernel/sched/completion.c:104 [inline]   wait_for_common kernel/sched/completion.c:115 [inline]   wait_for_completion+0x47/0x60 kernel/sched/completion.c:136   kthread_stop+0xb4/0x150 kernel/kthread.c:559   io_sq_thread_stop fs/io_uring.c:2252 [inline]   io_finish_async fs/io_uring.c:2259 [inline]   io_ring_ctx_free fs/io_uring.c:2770 [inline]   io_ring_ctx_wait_and_kill+0x268/0x880 fs/io_uring.c:2834   io_uring_release+0x5d/0x70 fs/io_uring.c:2842   __fput+0x2e4/0x740 fs/file_table.c:280   ____fput+0x15/0x20 fs/file_table.c:313   task_work_run+0x17e/0x1b0 kernel/task_work.c:113   tracehook_notify_resume include/linux/tracehook.h:185 [inline]   exit_to_usermode_loop arch/x86/entry/common.c:168 [inline]   prepare_exit_to_usermode+0x402/0x4f0 arch/x86/entry/common.c:199   syscall_return_slowpath+0x110/0x440 arch/x86/entry/common.c:279   do_syscall_64+0x126/0x140 arch/x86/entry/common.c:304   entry_SYSCALL_64_after_hwframe+0x49/0xbe ",a4c0b3decb33fb4a2b5ecc6234a50680f0b21e7d,0
ALSA: line6: Sync the pending work cancel at disconnection,"Recently syzkaller reported a UAF in LINE6 driver, and it's likely because we call cancel_delayed_work() at the disconnect callback instead of cancel_delayed_work_sync().  Let's use the correct one instead.  ",68359a1ad8447c99732ebeab8c169bfed543667a,1
block: don't use blocking queue entered for recursive bio submits,"If we end up splitting a bio and the queue goes away between the initial submission and the later split submission, then we can block forever in blk_queue_enter() waiting for the reference to drop to zero. This will never happen, since we already hold a reference.  Mark a split bio as already having entered the queue, so we can just use the live non-blocking queue enter variant.  ",cd4a4ae4683dc2e09380118e205e057896dcda2b,0
staging: comedi: check validity of wMaxPacketSize of usb endpoints found,"While finding usb endpoints in vmk80xx_find_usb_endpoints(), check if wMaxPacketSize = 0 for the endpoints found.  Some devices have isochronous endpoints that have wMaxPacketSize = 0 (as required by the USB-2 spec). However, since this doesn't apply here, wMaxPacketSize = 0 can be considered to be invalid.  ",e1f13c879a7c21bd207dc6242455e8e3a1e88b40,0
crypto: hash - prevent using keyed hashes without setting key,"Currently, almost none of the keyed hash algorithms check whether a key has been set before proceeding.  Some algorithms are okay with this and will effectively just use a key of all 0's or some other bogus default. However, others will severely break, as demonstrated using ""hmac(sha3-512-generic)"", the unkeyed use of which causes a kernel crash via a (potentially exploitable) stack buffer overflow.  A while ago, this problem was solved for AF_ALG by pairing each hash transform with a 'has_key' bool.  However, there are still other places in the kernel where userspace can specify an arbitrary hash algorithm by name, and the kernel uses it as unkeyed hash without checking whether it is really unkeyed.  Examples of this include:      - KEYCTL_DH_COMPUTE, via the KDF extension     - dm-verity     - dm-crypt, via the ESSIV support     - dm-integrity, via the ""internal hash"" mode with no key given     - drbd (Distributed Replicated Block Device)  This bug is especially bad for KEYCTL_DH_COMPUTE as that requires no privileges to call.  Fix the bug for all users by adding a flag CRYPTO_TFM_NEED_KEY to the ->crt_flags of each hash transform that indicates whether the transform still needs to be keyed or not.  Then, make the hash init, import, and digest functions return -ENOKEY if the key is still needed.  The new flag also replaces the 'has_key' bool which algif_hash was previously using, thereby simplifying the algif_hash implementation.  ",9fa68f620041be04720d0cbfb1bd3ddfc6310b24,1
libfs: fix infoleak in simple_attr_read(),"Reading from a debugfs file at a nonzero position, without first reading at position 0, leaks uninitialized memory to userspace.  It's a bit tricky to do this, since lseek() and pread() aren't allowed on these files, and write() doesn't update the position on them.  But writing to them with splice() *does* update the position:  	",a65cab7d7f05c2061a3e2490257d3086ff3202c6,1
net: ieee802154: handle iftypes as u32,"This patch fixes an issue that an u32 netlink value is handled as a signed enum value which doesn't fit into the range of u32 netlink type. If it's handled as -1 value some BIT() evaluation ends in a shift-out-of-bounds issue. To solve the issue we set the to u32 max which is s32 ""-1"" value to keep backwards compatibility and let the followed enum values start counting at 0. This brings the compiler to never handle the enum as signed and a check if the value is above NL802154_IFTYPE_MAX should filter -1 out.  ",451dc48c806a7ce9fbec5e7a24ccf4b2c936e834,1
mptcp: adjust to use netns refcount tracker,"MPTCP can change sk_net_refcnt after sock_create_kern() call.  We need to change its corresponding get_net() to avoid a splat at release time, as in :  refcount_t: decrement hit 0; leaking memory. ",1d2f3d3c62684b793339d0ae841ac67b555d8c8d,0
netfilter: nat: cope with negative port range,syzbot reported a division by 0 bug in the netfilter nat code:  divide error: 0000 [#1] SMP KASAN Dumping ftrace buffer:     (ftrace buffer empty) ,db57ccf0f2f4624b4c4758379f8165277504fbd7,1
sched: Fix race against ptrace_freeze_trace(),"There is apparently one site that violates the rule that only current and ttwu() will modify task->state, namely ptrace_{,un}freeze_traced() will change task->state for a remote task.  Oleg explains:    ""TASK_TRACED/TASK_STOPPED was always protected by siglock. In particular, ttwu(__TASK_TRACED) must be always called with siglock held. That is why ptrace_freeze_traced() assumes it can safely do s/TASK_TRACED/__TASK_TRACED/ under spin_lock(siglock).""  This breaks the ordering scheme introduced by commit:    dbfb089d360b (""sched: Fix loadavg accounting race"")  Specifically, the reload not matching no longer implies we don't have to block.  Simply things by noting that what we need is a LOAD->STORE ordering and this can be provided by a control dependency.  So replace:  	prev_state = prev->state; 	raw_spin_lock(&rq->lock); 	smp_mb__after_spinlock(); ",d136122f58458479fd8926020ba2937de61d7f65,1
kobject: Don't trigger kobject_uevent(KOBJ_REMOVE) twice.,"syzbot is hitting use-after-free bug in uinput module [1]. This is because kobject_uevent(KOBJ_REMOVE) is called again due to commit 0f4dafc0563c6c49 (""Kobject: auto-cleanup on final unref"") after memory allocation fault injection made kobject_uevent(KOBJ_REMOVE) from device_del() from input_unregister_device() fail, while uinput_destroy_device() is expecting that kobject_uevent(KOBJ_REMOVE) is not called after device_del() from input_unregister_device() completed.  That commit intended to catch cases where nobody even attempted to send ""remove"" uevents. But there is no guarantee that an event will ultimately be sent. We are at the point of no return as far as the rest of the kernel is concerned; there are no repeats or do-overs.  Also, it is not clear whether some subsystem depends on that commit. If no subsystem depends on that commit, it will be better to remove the state_{add,remove}_uevent_sent logic. But we don't want to risk a regression (in a patch which will be backported) by trying to remove that logic. Therefore, as a first step, let's avoid the use-after-free bug by making sure that kobject_uevent(KOBJ_REMOVE) won't be triggered twice.  [1] https://syzkaller.appspot.com/bug?id=8b17c134fe938bbddd75a45afaa9e68af43a362d  ",c03a0fd0b609e2f5c669c2b7f27c8e1928e9196e,1
xfrm6: avoid potential infinite loop in _decode_session6(),"syzbot found a way to trigger an infinitie loop by overflowing @offset variable that has been forced to use u16 for some very obscure reason in the past.  We probably want to look at NEXTHDR_FRAGMENT handling which looks wrong, in a separate patch.  In net-next, we shall try to use skb_header_pointer() instead of pskb_may_pull().  watchdog: BUG: soft lockup - CPU#1 stuck for 134s! [syz-executor738:4553] ",d9f92772e8ec388d070752ee8f187ef8fa18621f,1
ath9k: Fix out-of-bound memcpy in ath9k_hif_usb_rx_stream,"Large pkt_len can lead to out-out-bound memcpy. Current ath9k_hif_usb_rx_stream allows combining the content of two urb inputs to one pkt. The first input can indicate the size of the pkt. Any remaining size is saved in hif_dev->rx_remain_len. While processing the next input, memcpy is used with rx_remain_len.  4-byte pkt_len can go up to 0xffff, while a single input is 0x4000 maximum in size (MAX_RX_BUF_SIZE). Thus, the patch adds a check for pkt_len which must not exceed 2 * MAX_RX_BUG_SIZE.  BUG: KASAN: slab-out-of-bounds in ath9k_hif_usb_rx_cb+0x490/0xed7 [ath9k_htc] Read of size 46393 at addr ffff888018798000 by task kworker/0:1/23  CPU: 0 PID: 23 Comm: kworker/0:1 Not tainted 5.6.0 #63 Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS rel-1.10.2-0-g5f4c7b1-prebuilt.qemu-project.org 04/01/2014 Workqueue: events request_firmware_work_func Call Trace:  <IRQ>  dump_stack+0x76/0xa0  print_address_description.constprop.0+0x16/0x200  ? ath9k_hif_usb_rx_cb+0x490/0xed7 [ath9k_htc]  ? ath9k_hif_usb_rx_cb+0x490/0xed7 [ath9k_htc]  __kasan_report.cold+0x37/0x7c  ? ath9k_hif_usb_rx_cb+0x490/0xed7 [ath9k_htc]  kasan_report+0xe/0x20  check_memory_region+0x15a/0x1d0  memcpy+0x20/0x50  ath9k_hif_usb_rx_cb+0x490/0xed7 [ath9k_htc]  ? hif_usb_mgmt_cb+0x2d9/0x2d9 [ath9k_htc]  ? _raw_spin_lock_irqsave+0x7b/0xd0  ? _raw_spin_trylock_bh+0x120/0x120  ? __usb_unanchor_urb+0x12f/0x210  __usb_hcd_giveback_urb+0x1e4/0x380  usb_giveback_urb_bh+0x241/0x4f0  ? __hrtimer_run_queues+0x316/0x740  ? __usb_hcd_giveback_urb+0x380/0x380  tasklet_action_common.isra.0+0x135/0x330  __do_softirq+0x18c/0x634  irq_exit+0x114/0x140  smp_apic_timer_interrupt+0xde/0x380  apic_timer_interrupt+0xf/0x20  I found the bug using a custome USBFuzz port. It's a research work to fuzz USB stack/drivers. I modified it to fuzz ath9k driver only, providing hand-crafted usb descriptors to QEMU.  After fixing the value of pkt_tag to ATH_USB_RX_STREAM_MODE_TAG in QEMU emulation, I found the KASAN report. The bug is triggerable whenever pkt_len is above two MAX_RX_BUG_SIZE. I used the same input that crashes to test the driver works when applying the patch.  ",6ce708f54cc8d73beca213cec66ede5ce100a781,1
futex: Fix more put_pi_state() vs. exit_pi_state_list() races,"Dmitry (through syzbot) reported being able to trigger the WARN in get_pi_state() and a use-after-free on:  	raw_spin_lock_irq(&pi_state->pi_mutex.wait_lock);  Both are due to this race:    exit_pi_state_list()				put_pi_state()    lock(&curr->pi_lock)   while() { 	pi_state = list_first_entry(head); 	hb = hash_futex(&pi_state->key); 	unlock(&curr->pi_lock);  						dec_and_test(&pi_state->refcount);  	lock(&hb->lock) 	lock(&pi_state->pi_mutex.wait_lock)	// uaf if pi_state free'd 	lock(&curr->pi_lock);  	....  	unlock(&curr->pi_lock); 	get_pi_state();				// WARN; refcount==0  The problem is we take the reference count too late, and don't allow it being 0. Fix it by using inc_not_zero() and simply retrying the loop when we fail to get a refcount. In that case put_pi_state() should remove the entry from the list.  ",153fbd1226fb30b8630802aa5047b8af5ef53c9f,1
ALSA: line6: Fix write on zero-sized buffer,"LINE6 drivers allocate the buffers based on the value returned from usb_maxpacket() calls.  The manipulated device may return zero for this, and this results in the kmalloc() with zero size (and it may succeed) while the other part of the driver code writes the packet data with the fixed size -- which eventually overwrites.  This patch adds a simple sanity check for the invalid buffer size for avoiding that problem.  ",3450121997ce872eb7f1248417225827ea249710,1
block: Fix __blkdev_direct_IO() for bio fragments,"The recent fix to properly handle IOCB_NOWAIT for async O_DIRECT IO (patch 6a43074e2f46) introduced two problems with BIO fragment handling for direct IOs: 1) The dio size processed is calculated by incrementing the ret variable by the size of the bio fragment issued for the dio. However, this size is obtained directly from bio->bi_iter.bi_size AFTER the bio submission which may result in referencing the bi_size value after the bio completed, resulting in an incorrect value use. 2) The ret variable is not incremented by the size of the last bio fragment issued for the bio, leading to an invalid IO size being returned to the user.  Fix both problem by using dio->size (which is incremented before the bio submission) to update the value of ret after bio submissions, including for the last bio fragment issued.  ",0eb6ddfb865c7d7ec05cb330050671363515e67f,1
packet: avoid panic in packet_getsockopt(),"syzkaller got crashes in packet_getsockopt() processing PACKET_ROLLOVER_STATS command while another thread was managing to change po->rollover  Using RCU will fix this bug. We might later add proper RCU annotations for sparse sake.  In v2: I replaced kfree(rollover) in fanout_add() to kfree_rcu() variant, as spotted by John.  ",509c7a1ecc8601f94ffba8a00889fefb239c00c6,1
mm/mempolicy.c: fix out of bounds write in mpol_parse_str(),What we are trying to do is change the '=' character to a NUL terminator and then at the end of the function we restore it back to an '='.  The problem is there are two error paths where we jump to the end of the function before we have replaced the '=' with NUL.  We end up putting the '=' in the wrong place (possibly one element before the start of the buffer).  ,c7a91bc7c2e17e0a9c8b9745a2cb118891218fd1,1
netfilter: xt_cgroup: initialize info->priv in cgroup_mt_check_v1(),"xt_cgroup_info_v1->priv is an internal pointer only used for kernel, we should not trust what user-space provides.  ",ba7cd5d95f25cc6005f687dabdb4e7a6063adda9,0
mac80211_hwsim: don't use WQ_MEM_RECLAIM,"We're obviously not part of a memory reclaim path, so don't set the flag.  This also causes a warning in check_flush_dependency() since we end up in a code path that flushes a non-reclaim workqueue, and we shouldn't do that if we were really part of reclaim.  ",ce162bfbc0b601841886965baba14877127c7c7c,0
netrom: fix a memory leak in nr_rx_frame(),"When the skb is associated with a new sock, just assigning it to skb->sk is not sufficient, we have to set its destructor to free the sock properly too.  ",c8c8218ec5af5d2598381883acbefbf604e56b5e,1
block: remove an incorrect check from blk_rq_append_bio,"blk_rq_append_bio is also used for the copy case, not just the map case, so tis debug check is not correct.  ",cbb749cf377aa8aa32a036ebe9dd9f2d89037bf0,0
net_sched: keep alloc_hash updated after hash allocation,"In commit 599be01ee567 (""net_sched: fix an OOB access in cls_tcindex"") I moved cp->hash calculation before the first tcindex_alloc_perfect_hash(), but cp->alloc_hash is left untouched. This difference could lead to another out of bound access.  cp->alloc_hash should always be the size allocated, we should update it after this tcindex_alloc_perfect_hash().  ",0d1c3530e1bd38382edef72591b78e877e0edcd3,1
net: bridge: delete local fdb on device init failure,On initialization failure we have to delete the local fdb which was inserted due to the default pvid creation. This problem has been present since the inception of default_pvid. Note that currently there are 2 cases: 1) in br_dev_init() when br_multicast_init() fails 2) if register_netdevice() fails after calling ndo_init()  This patch takes care of both since br_vlan_flush() is called on both occasions. Also the new fdb delete would be a no-op on normal bridge device destruction since the local fdb would've been already flushed by br_dev_delete(). This is not an issue for ports since nbp_vlan_init() is called last when adding a port thus nothing can fail after it.  ,d7bae09fa008c6c9a489580db0a5a12063b97f97,0
net: qdisc_pkt_len_init() should be more robust,"Without proper validation of DODGY packets, we might very well feed qdisc_pkt_len_init() with invalid GSO packets.  tcp_hdrlen() might access out-of-bound data, so let's use skb_header_pointer() and proper checks.  Whole story is described in commit d0c081b49137 (""flow_dissector: properly cap thoff field"")  We have the goal of validating DODGY packets earlier in the stack, so we might very well revert this fix in the future.  ",7c68d1a6b4db9012790af7ac0f0fdc0d2083422a,1
netfilter: nf_tables: unlink table before deleting it,"syzbot reports following UAF: BUG: KASAN: use-after-free in memcmp+0x18f/0x1c0 lib/string.c:955  nla_strcmp+0xf2/0x130 lib/nlattr.c:836  nft_table_lookup.part.0+0x1a2/0x460 net/netfilter/nf_tables_api.c:570  nft_table_lookup net/netfilter/nf_tables_api.c:4064 [inline]  nf_tables_getset+0x1b3/0x860 net/netfilter/nf_tables_api.c:4064  nfnetlink_rcv_msg+0x659/0x13f0 net/netfilter/nfnetlink.c:285  netlink_rcv_skb+0x153/0x420 net/netlink/af_netlink.c:2504  Problem is that all get operations are lockless, so the commit_mutex held by nft_rcv_nl_event() isn't enough to stop a parallel GET request from doing read-accesses to the table object even after synchronize_rcu().  To avoid this, unlink the table first and store the table objects in on-stack scratch space.  ",a499b03bf36b0c2e3b958a381d828678ab0ffc5e,1
quota: Sanity-check quota file headers on load,Perform basic sanity checks of quota headers to avoid kernel crashes on corrupted quota files.  CC: stable@vger.kernel.org ,11c514a99bb960941535134f0587102855e8ddee,1
net: partially revert dynamic lockdep key changes,"This patch reverts the folowing commits:  commit 064ff66e2bef84f1153087612032b5b9eab005bd ""bonding: add missing netdev_update_lockdep_key()""  commit 53d374979ef147ab51f5d632dfe20b14aebeccd0 ""net: avoid updating qdisc_xmit_lock_key in netdev_update_lockdep_key()""  commit 1f26c0d3d24125992ab0026b0dab16c08df947c7 ""net: fix kernel-doc warning in <linux/netdevice.h>""  commit ab92d68fc22f9afab480153bd82a20f6e2533769 ""net: core: add generic lockdep keys""  but keeps the addr_list_lock_key because we still lock addr_list_lock nestedly on stack devices, unlikely xmit_lock this is safe because we don't take addr_list_lock on any fast path.  ",1a33e10e4a95cb109ff1145098175df3113313ef,0
selinux: fix sidtab string cache locking,"Avoiding taking a lock in an IRQ context is not enough to prevent deadlocks, as discovered by syzbot:  === ",39a706fbcf2694bfb651bed9041d44c3f4fa8078,0
RDMA/ucma: Rework ucma_migrate_id() to avoid races with destroy,"ucma_destroy_id() assumes that all things accessing the ctx will do so via the xarray. This assumption violated only in the case the FD is being closed, then the ctx is reached via the ctx_list. Normally this is OK since ucma_destroy_id() cannot run concurrenty with release(), however with ucma_migrate_id() is involved this can violated as the close of the 2nd FD can run concurrently with destroy on the first:                  CPU0                      CPU1         ucma_destroy_id(fda)                                   ucma_migrate_id(fda -> fdb)                                        ucma_get_ctx()         xa_lock()          _ucma_find_context()          xa_erase()         xa_unlock()                                        xa_lock()                                         ctx->file = new_file                                         list_move()                                        xa_unlock()                                       ucma_put_ctx()                                     ucma_close(fdb)                                       _destroy_id()                                       kfree(ctx)          _destroy_id()           wait_for_completion()           // boom, ctx was freed  The ctx->file must be modified under the handler and xa_lock, and prior to modification the ID must be rechecked that it is still reachable from cur_file, ie there is no parallel destroy or migrate.  To make this work remove the double locking and streamline the control flow. The double locking was obsoleted by the handler lock now directly preventing new uevents from being created, and the ctx_list cannot be read while holding fgets on both files. Removing the double locking also removes the need to check for the same file.  ",f5449e74802c1112dea984aec8af7a33c4516af1,1
ALSA: virmidi: Fix too long output trigger loop,"The virmidi output trigger tries to parse the all available bytes and process sequencer events as much as possible.  In a normal situation, this is supposed to be relatively short, but a program may give a huge buffer and it'll take a long time in a single spin lock, which may eventually lead to a soft lockup.  This patch simply adds a workaround, a cond_resched() call in the loop if applicable.  A better solution would be to move the event processor into a work, but let's put a duct-tape quickly at first.  ",50e9ffb1996a5d11ff5040a266585bad4ceeca0a,0
xfrm: policy: delete inexact policies from inexact list on hash rebuild,"An xfrm hash rebuild has to reset the inexact policy list before the policies get re-inserted: A change of hash thresholds will result in policies to get moved from inexact tree to the policy hash table.  If the thresholds are increased again later, they get moved from hash table to inexact tree.  We must unlink all policies from the inexact tree before re-insertion.  Otherwise 'migrate' may find policies that are in main hash table a second time, when it searches the inexact lists.  Furthermore, re-insertion without deletion can cause elements ->next to point back to itself, causing soft lockups or double-frees.  ",1548bc4e0512700cf757192c106b3a20ab639223,0
netfilter: conntrack: annotate data-races around ct->timeout,"(struct nf_conn)->timeout can be read/written locklessly, add READ_ONCE()/WRITE_ONCE() to prevent load/store tearing.  BUG: KCSAN: data-race in __nf_conntrack_alloc / __nf_conntrack_find_get  write to 0xffff888132e78c08 of 4 bytes by task 6029 on cpu 0:  __nf_conntrack_alloc+0x158/0x280 net/netfilter/nf_conntrack_core.c:1563  init_conntrack+0x1da/0xb30 net/netfilter/nf_conntrack_core.c:1635  resolve_normal_ct+0x502/0x610 net/netfilter/nf_conntrack_core.c:1746  nf_conntrack_in+0x1c5/0x88f net/netfilter/nf_conntrack_core.c:1901  ipv6_conntrack_local+0x19/0x20 net/netfilter/nf_conntrack_proto.c:414  nf_hook_entry_hookfn include/linux/netfilter.h:142 [inline]  nf_hook_slow+0x72/0x170 net/netfilter/core.c:619  nf_hook include/linux/netfilter.h:262 [inline]  NF_HOOK include/linux/netfilter.h:305 [inline]  ip6_xmit+0xa3a/0xa60 net/ipv6/ip6_output.c:324  inet6_csk_xmit+0x1a2/0x1e0 net/ipv6/inet6_connection_sock.c:135  __tcp_transmit_skb+0x132a/0x1840 net/ipv4/tcp_output.c:1402  tcp_transmit_skb net/ipv4/tcp_output.c:1420 [inline]  tcp_write_xmit+0x1450/0x4460 net/ipv4/tcp_output.c:2680  __tcp_push_pending_frames+0x68/0x1c0 net/ipv4/tcp_output.c:2864  tcp_push_pending_frames include/net/tcp.h:1897 [inline]  tcp_data_snd_check+0x62/0x2e0 net/ipv4/tcp_input.c:5452  tcp_rcv_established+0x880/0x10e0 net/ipv4/tcp_input.c:5947  tcp_v6_do_rcv+0x36e/0xa50 net/ipv6/tcp_ipv6.c:1521  sk_backlog_rcv include/net/sock.h:1030 [inline]  __release_sock+0xf2/0x270 net/core/sock.c:2768  release_sock+0x40/0x110 net/core/sock.c:3300  sk_stream_wait_memory+0x435/0x700 net/core/stream.c:145  tcp_sendmsg_locked+0xb85/0x25a0 net/ipv4/tcp.c:1402  tcp_sendmsg+0x2c/0x40 net/ipv4/tcp.c:1440  inet6_sendmsg+0x5f/0x80 net/ipv6/af_inet6.c:644  sock_sendmsg_nosec net/socket.c:704 [inline]  sock_sendmsg net/socket.c:724 [inline]  __sys_sendto+0x21e/0x2c0 net/socket.c:2036  __do_sys_sendto net/socket.c:2048 [inline]  __se_sys_sendto net/socket.c:2044 [inline]  __x64_sys_sendto+0x74/0x90 net/socket.c:2044  do_syscall_x64 arch/x86/entry/common.c:50 [inline]  do_syscall_64+0x44/0xd0 arch/x86/entry/common.c:80  entry_SYSCALL_64_after_hwframe+0x44/0xae  read to 0xffff888132e78c08 of 4 bytes by task 17446 on cpu 1:  nf_ct_is_expired include/net/netfilter/nf_conntrack.h:286 [inline]  ____nf_conntrack_find net/netfilter/nf_conntrack_core.c:776 [inline]  __nf_conntrack_find_get+0x1c7/0xac0 net/netfilter/nf_conntrack_core.c:807  resolve_normal_ct+0x273/0x610 net/netfilter/nf_conntrack_core.c:1734  nf_conntrack_in+0x1c5/0x88f net/netfilter/nf_conntrack_core.c:1901  ipv6_conntrack_local+0x19/0x20 net/netfilter/nf_conntrack_proto.c:414  nf_hook_entry_hookfn include/linux/netfilter.h:142 [inline]  nf_hook_slow+0x72/0x170 net/netfilter/core.c:619  nf_hook include/linux/netfilter.h:262 [inline]  NF_HOOK include/linux/netfilter.h:305 [inline]  ip6_xmit+0xa3a/0xa60 net/ipv6/ip6_output.c:324  inet6_csk_xmit+0x1a2/0x1e0 net/ipv6/inet6_connection_sock.c:135  __tcp_transmit_skb+0x132a/0x1840 net/ipv4/tcp_output.c:1402  __tcp_send_ack+0x1fd/0x300 net/ipv4/tcp_output.c:3956  tcp_send_ack+0x23/0x30 net/ipv4/tcp_output.c:3962  __tcp_ack_snd_check+0x2d8/0x510 net/ipv4/tcp_input.c:5478  tcp_ack_snd_check net/ipv4/tcp_input.c:5523 [inline]  tcp_rcv_established+0x8c2/0x10e0 net/ipv4/tcp_input.c:5948  tcp_v6_do_rcv+0x36e/0xa50 net/ipv6/tcp_ipv6.c:1521  sk_backlog_rcv include/net/sock.h:1030 [inline]  __release_sock+0xf2/0x270 net/core/sock.c:2768  release_sock+0x40/0x110 net/core/sock.c:3300  tcp_sendpage+0x94/0xb0 net/ipv4/tcp.c:1114  inet_sendpage+0x7f/0xc0 net/ipv4/af_inet.c:833  rds_tcp_xmit+0x376/0x5f0 net/rds/tcp_send.c:118  rds_send_xmit+0xbed/0x1500 net/rds/send.c:367  rds_send_worker+0x43/0x200 net/rds/threads.c:200  process_one_work+0x3fc/0x980 kernel/workqueue.c:2298  worker_thread+0x616/0xa70 kernel/workqueue.c:2445  kthread+0x2c7/0x2e0 kernel/kthread.c:327  ret_from_fork+0x1f/0x30  value changed: 0x00027cc2 -> 0x00000000  Reported by Kernel Concurrency Sanitizer on: CPU: 1 PID: 17446 Comm: kworker/u4:5 Tainted: G        W         5.16.0-rc4-syzkaller #0 Hardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 01/01/2011 Workqueue: krdsd rds_send_worker  Note: I chose an arbitrary commit for the ",802a7dc5cf1bef06f7b290ce76d478138408d6b1,1
sctp: break out if skb_header_pointer returns NULL in sctp_rcv_ootb,"We should always check if skb_header_pointer's return is NULL before using it, otherwise it may cause null-ptr-deref, as ",f7e745f8e94492a8ac0b0a26e25f2b19d342918f,0
asix: fix uninit-value in asix_mdio_read(),asix_read_cmd() may read less than sizeof(smsr) bytes and in this case smsr will be uninitialized.  Fail log: BUG: KMSAN: uninit-value in asix_check_host_enable drivers/net/usb/asix_common.c:82 [inline] BUG: KMSAN: uninit-value in asix_check_host_enable drivers/net/usb/asix_common.c:82 [inline] drivers/net/usb/asix_common.c:497 BUG: KMSAN: uninit-value in asix_mdio_read+0x3c1/0xb00 drivers/net/usb/asix_common.c:497 drivers/net/usb/asix_common.c:497  asix_check_host_enable drivers/net/usb/asix_common.c:82 [inline]  asix_check_host_enable drivers/net/usb/asix_common.c:82 [inline] drivers/net/usb/asix_common.c:497  asix_mdio_read+0x3c1/0xb00 drivers/net/usb/asix_common.c:497 drivers/net/usb/asix_common.c:497  ,8035b1a2a37a29d8c717ef84fca8fe7278bc9f03,1
tipc: Fix missing RTNL lock protection during setting link properties,"Currently when user changes link properties, TIPC first checks if user's command message contains media name or bearer name through tipc_media_find() or tipc_bearer_find() which is protected by RTNL lock. But when tipc_nl_compat_link_set() conducts the checking with the two functions, it doesn't hold RTNL lock at all, as a result, the following complaints were reported:  audit: type=1400 audit(1514679888.244:9): avc:  denied  { write } for pid=3194 comm=""syzkaller021477"" path=""socket:[11143]"" dev=""sockfs"" ino=11143 scontext=unconfined_u:system_r:insmod_t:s0-s0:c0.c1023 tcontext=unconfined_u:system_r:insmod_t:s0-s0:c0.c1023 tclass=netlink_generic_socket permissive=1 ",ed4ffdfec26dfe1bb02435afd1e01f61426f7212,1
umh: fix race condition,"kasan reported use-after-free: BUG: KASAN: use-after-free in call_usermodehelper_exec_work+0x2d3/0x310 kernel/umh.c:195 Write of size 4 at addr ffff8801d9202370 by task kworker/u4:2/50 Workqueue: events_unbound call_usermodehelper_exec_work Call Trace:  __dump_stack lib/dump_stack.c:77 [inline]  dump_stack+0x1b9/0x294 lib/dump_stack.c:113  print_address_description+0x6c/0x20b mm/kasan/report.c:256  kasan_report_error mm/kasan/report.c:354 [inline]  kasan_report.cold.7+0x242/0x2fe mm/kasan/report.c:412  __asan_report_store4_noabort+0x17/0x20 mm/kasan/report.c:437  call_usermodehelper_exec_work+0x2d3/0x310 kernel/umh.c:195  process_one_work+0xc1e/0x1b50 kernel/workqueue.c:2145  worker_thread+0x1cc/0x1440 kernel/workqueue.c:2279  kthread+0x345/0x410 kernel/kthread.c:240  ret_from_fork+0x3a/0x50 arch/x86/entry/entry_64.S:412  The reason is that 'sub_info' cannot be accessed out of parent task context, since it will be freed by the child. Instead remember the pid in the child task.  ",bf956be520fb534510e31564231163aa05f7f091,1
mptcp: reset last_snd on subflow close,"Send logic caches last active subflow in the msk, so it needs to be cleared when the cached subflow is closed.  ",e0be4931f3fee2e04dec4013ea4f27ec2db8556f,0
tipc: fix a double kfree_skb(),"tipc_udp_xmit() drops the packet on error, there is no need to drop it again.  ",acb4a33e9856d5fa3384b87d3d8369229be06d31,0
af_key: Always verify length of provided sadb_key,"Key extensions (struct sadb_key) include a user-specified number of key bits.  The kernel uses that number to determine how much key data to copy out of the message in pfkey_msg2xfrm_state().  The length of the sadb_key message must be verified to be long enough, even in the case of SADB_X_AALG_NULL.  Furthermore, the sadb_key_len value must be long enough to include both the key data and the struct sadb_key itself.  Introduce a helper function verify_key_len(), and call it from parse_exthdrs() where other exthdr types are similarly checked for correctness.  ",4b66af2d6356a00e94bcdea3e7fea324e8b5c6f4,0
VMCI: check return value of get_user_pages_fast() for errors,"In a couple of places in qp_host_get_user_memory(), get_user_pages_fast() is called without properly checking for errors. If e.g. -EFAULT is returned, this negative value will then be passed on to qp_release_pages(), which expects a u64 as input.  Fix this by only calling qp_release_pages() when we have a positive number returned.  ",90ca6333fd65f318c47bff425e1ea36c0a5539f6,0
net: ieee802154: stop dump llsec params for monitors,This patch stops dumping llsec params for monitors which we don't support yet. Otherwise we will access llsec mib which isn't initialized for monitors.  ,1534efc7bbc1121e92c86c2dabebaf2c9dcece19,0
sock_map: Fix a potential use-after-free in sock_map_close(),"The last refcnt of the psock can be gone right after sock_map_remove_links(), so sk_psock_stop() could trigger a UAF. The reason why I placed sk_psock_stop() there is to avoid RCU read critical section, and more importantly, some callee of sock_map_remove_links() is supposed to be called with RCU read lock, we can not simply get rid of RCU read lock here. Therefore, the only choice we have is to grab an additional refcnt with sk_psock_get() and put it back after sk_psock_stop().  ",aadb2bb83ff789de63b48b4edeab7329423a50d3,1
mm: don't warn about large allocations for slab,"Slub does not call kmalloc_slab() for sizes > KMALLOC_MAX_CACHE_SIZE, instead it falls back to kmalloc_large().  For slab KMALLOC_MAX_CACHE_SIZE == KMALLOC_MAX_SIZE and it calls kmalloc_slab() for all allocations relying on NULL return value for over-sized allocations.  This inconsistency leads to unwanted warnings from kmalloc_slab() for over-sized allocations for slab.  Returning NULL for failed allocations is the expected behavior.  Make slub and slab code consistent by checking size > KMALLOC_MAX_CACHE_SIZE in slab before calling kmalloc_slab().  While we are here also fix the check in kmalloc_slab().  We should check against KMALLOC_MAX_CACHE_SIZE rather than KMALLOC_MAX_SIZE.  It all kinda worked because for slab the constants are the same, and slub always checks the size against KMALLOC_MAX_CACHE_SIZE before kmalloc_slab().  But if we get there with size > KMALLOC_MAX_CACHE_SIZE anyhow bad things will happen.  For example, in case of a newly introduced bug in slub code.  Also move the check in kmalloc_slab() from function entry to the size > 192 case.  This partially compensates for the additional check in slab code and makes slub code a bit faster (at least theoretically).  Also drop __GFP_NOWARN in the warning check.  This warning means a bug in slab code itself, user-passed flags have nothing to do with it.  Nothing of this affects slob.  ",61448479a9f2c954cde0cfe778cb6bec5d0a748d,0
Bluetooth: Fix race condition in hci_release_sock(),"Syzbot managed to trigger a use after free ""KASAN: use-after-free Write in hci_sock_bind"".  I have reviewed the code manually and one possibly cause I have found is that we are not holding lock_sock(sk) when we do the hci_dev_put(hdev) in hci_sock_release().  My theory is that the bind and the release are racing against each other which results in this use after free.  ",11eb85ec42dc8c7a7ec519b90ccf2eeae9409de8,1
block: fix missing queue put in error path,"If we fail the submission queue checks, we don't put the queue afterwards. This can cause various issues like stalls on scheduler switch or failure to remove the device, or like in the original bug report, timeout waiting for the device on reboot/restart.  While in there, fix a few whitespace discrepancies in the surrounding code.  ",95febeb61bf87ca803a1270498cd4cd61554a68f,0
mptcp: avoid potential infinite loop in mptcp_recvmsg(),"If a packet is ready in receive queue, and application isssues a recvmsg()/recvfrom()/recvmmsg() request asking for zero bytes, we hang in mptcp_recvmsg().  ",05e3ecea4a6305597a060da0a123c80df8827bf1,1
"mm, page_alloc: do not wake kswapd with zone lock held",syzbot reported the following regression in the latest merge window and it was confirmed by Qian Cai that a similar bug was visible from a different context.    ,73444bc4d8f92e46a20cb6bd3342fc2ea75c6787,0
f2fs: avoid bug_on on corrupted inode,"syzbot has tested the proposed patch but the reproducer still triggered crash: kernel BUG at fs/f2fs/inode.c:LINE!  F2FS-fs (loop1): invalid crc value F2FS-fs (loop5): Magic Mismatch, valid(0xf2f52010) - read(0x0) F2FS-fs (loop5): Can't find valid F2FS filesystem in 1th superblock F2FS-fs (loop5): invalid crc value ",5d64600d4f337dc2bb89cd59da99f452f5e4f3c3,1
ip_tunnel: better validate user provided tunnel names,"Use dev_valid_name() to make sure user does not provide illegal device name.  syzbot caught the following bug :  BUG: KASAN: stack-out-of-bounds in strlcpy include/linux/string.h:300 [inline] BUG: KASAN: stack-out-of-bounds in __ip_tunnel_create+0xca/0x6b0 net/ipv4/ip_tunnel.c:257 Write of size 20 at addr ffff8801ac79f810 by task syzkaller268107/4482  CPU: 0 PID: 4482 Comm: syzkaller268107 Not tainted 4.16.0+ #1 Hardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 01/01/2011 Call Trace:  __dump_stack lib/dump_stack.c:17 [inline]  dump_stack+0x1b9/0x29f lib/dump_stack.c:53  print_address_description+0x6c/0x20b mm/kasan/report.c:256  kasan_report_error mm/kasan/report.c:354 [inline]  kasan_report.cold.7+0xac/0x2f5 mm/kasan/report.c:412  check_memory_region_inline mm/kasan/kasan.c:260 [inline]  check_memory_region+0x13e/0x1b0 mm/kasan/kasan.c:267  memcpy+0x37/0x50 mm/kasan/kasan.c:303  strlcpy include/linux/string.h:300 [inline]  __ip_tunnel_create+0xca/0x6b0 net/ipv4/ip_tunnel.c:257  ip_tunnel_create net/ipv4/ip_tunnel.c:352 [inline]  ip_tunnel_ioctl+0x818/0xd40 net/ipv4/ip_tunnel.c:861  ipip_tunnel_ioctl+0x1c5/0x420 net/ipv4/ipip.c:350  dev_ifsioc+0x43e/0xb90 net/core/dev_ioctl.c:334  dev_ioctl+0x69a/0xcc0 net/core/dev_ioctl.c:525  sock_ioctl+0x47e/0x680 net/socket.c:1015  vfs_ioctl fs/ioctl.c:46 [inline]  file_ioctl fs/ioctl.c:500 [inline]  do_vfs_ioctl+0x1cf/0x1650 fs/ioctl.c:684  ksys_ioctl+0xa9/0xd0 fs/ioctl.c:701  SYSC_ioctl fs/ioctl.c:708 [inline]  SyS_ioctl+0x24/0x30 fs/ioctl.c:706  do_syscall_64+0x29e/0x9d0 arch/x86/entry/common.c:287  entry_SYSCALL_64_after_hwframe+0x42/0xb7  ",9cb726a212a82c88c98aa9f0037fd04777cd8fe5,1
RDS: Heap OOB write in rds_message_alloc_sgs(),"When args->nr_local is 0, nr_pages gets also 0 due some size calculation via rds_rm_size(), which is later used to allocate pages for DMA, this bug produces a heap Out-Of-Bound write access to a specific memory region.  ",c095508770aebf1b9218e77026e48345d719b17c,1
libertas: Add missing sentinel at end of if_usb.c fw_table,This sentinel tells the firmware loading process when to stop.  ,764f3f1ecffc434096e0a2b02f1a6cc964a89df6,0
HID: usbhid: free raw_report buffers in usbhid_stop,Free the unsent raw_report buffers when the device is removed.  Fixes a memory leak reported by syzbot at: https://syzkaller.appspot.com/bug?id=7b4fa7cb1a7c2d3342a2a8a6c53371c8c418ab47  ,f7744fa16b96da57187dc8e5634152d3b63d72de,1
libata: fix length validation of ATAPI-relayed SCSI commands,"syzkaller reported a crash in ata_bmdma_fill_sg() when writing to /dev/sg1.  The immediate cause was that the ATA command's scatterlist was not DMA-mapped, which causes 'pi - 1' to underflow, resulting in a write to 'qc->ap->bmdma_prd[0xffffffff]'.  Strangely though, the flag ATA_QCFLAG_DMAMAP was set in qc->flags.  The root cause is that when __ata_scsi_queuecmd() is preparing to relay a SCSI command to an ATAPI device, it doesn't correctly validate the CDB length before copying it into the 16-byte buffer 'cdb' in 'struct ata_queued_cmd'.  Namely, it validates the fixed CDB length expected based on the SCSI opcode but not the actual CDB length, which can be larger due to the use of the SG_NEXT_CMD_LEN ioctl.  Since 'flags' is the next member in ata_queued_cmd, a buffer overflow corrupts it.  Fix it by requiring that the actual CDB length be <= 16 (ATAPI_CDB_LEN).  [Really it seems the length should be required to be <= dev->cdb_len, but the current behavior seems to have been intentionally introduced by commit 607126c2a21c (""libata-scsi: be tolerant of 12-byte ATAPI commands in 16-byte CDBs"") to work around a userspace bug in mplayer.  Probably the workaround is no longer needed (mplayer was fixed in 2007), but continuing to allow lengths to up 16 appears harmless for now.]  Here's a reproducer that works in QEMU when /dev/sg1 refers to the CD-ROM drive that qemu-system-x86_64 creates by default:      #include <fcntl.h>     #include <sys/ioctl.h>     #include <unistd.h>      ",058f58e235cbe03e923b30ea7c49995a46a8725f,1
HID: core: Correctly handle ReportSize being zero,"It appears that a ReportSize value of zero is legal, even if a bit non-sensical. Most of the HID code seems to handle that gracefully, except when computing the total size in bytes. When fed as input to memset, this leads to some funky outcomes.  Detect the corner case and correctly compute the size.  ",bce1305c0ece3dc549663605e567655dd701752c,0
net: ipv4: fix rcu lockdep splat due to wrong annotation,"syzbot triggered following splat when strict netlink validation is enabled:  net/ipv4/devinet.c:1766 suspicious rcu_dereference_check() usage!  This occurs because we hold RTNL mutex, but no rcu read lock. The second call site holds both, so just switch to the _rtnl variant.  ",d3e6e285fff3494a5c12154c8e7d79f5181d3ddc,1
netfilter: ebtables: compat: reject all padding in matches/watchers,"syzbot reported following splat:  BUG: KASAN: vmalloc-out-of-bounds in size_entry_mwt net/bridge/netfilter/ebtables.c:2063 [inline] BUG: KASAN: vmalloc-out-of-bounds in compat_copy_entries+0x128b/0x1380 net/bridge/netfilter/ebtables.c:2155 Read of size 4 at addr ffffc900004461f4 by task syz-executor267/7937  CPU: 1 PID: 7937 Comm: syz-executor267 Not tainted 5.5.0-rc1-syzkaller #0  size_entry_mwt net/bridge/netfilter/ebtables.c:2063 [inline]  compat_copy_entries+0x128b/0x1380 net/bridge/netfilter/ebtables.c:2155  compat_do_replace+0x344/0x720 net/bridge/netfilter/ebtables.c:2249  compat_do_ebt_set_ctl+0x22f/0x27e net/bridge/netfilter/ebtables.c:2333  [..]  Because padding isn't considered during computation of ->buf_user_offset, ""total"" is decremented by fewer bytes than it should.  Therefore, the first part of  if (*total < sizeof(*entry) || entry->next_offset < sizeof(*entry))  will pass, -- it should not have.  This causes oob access: entry->next_offset is past the vmalloced size.  Reject padding and check that computed user offset (sum of ebt_entry structure plus all individual matches/watchers/targets) is same value that userspace gave us as the offset of the next entry.  ",e608f631f0ba5f1fc5ee2e260a3a35d13107cbfe,1
KVM: x86: degrade WARN to pr_warn_ratelimited,"This warning can be triggered easily by userspace, so it should certainly not cause a panic if panic_on_warn is set.  ",3f16a5c318392cbb5a0c7a3d19dff8c8ef3c38ee,0
tipc: fix use-after-free in tipc_bcast_get_mode,Syzbot has reported those issues as:  ,fdeba99b1e58ecd18c2940c453e19e4ef20ff591,1
udp: drop head states only when all skb references are gone,"After commit 0ddf3fb2c43d (""udp: preserve skb->dst if required for IP options processing"") we clear the skb head state as soon as the skb carrying them is first processed.  Since the same skb can be processed several times when MSG_PEEK is used, we can end up lacking the required head states, and eventually oopsing.  Fix this clearing the skb head state only when processing the last skb reference.  ",ca2c1418efe9f7fe37aa1f355efdf4eb293673ce,1
mac80211_hwsim: Use kstrndup() in place of kasprintf(),syzbot reports a warning:  precision 33020 too large ,7ea862048317aa76d0f22334202779a25530980c,0
locking/lockdep: Reuse freed chain_hlocks entries,"Once a lock class is zapped, all the lock chains that include the zapped class are essentially useless. The lock_chain structure itself can be reused, but not the corresponding chain_hlocks[] entries. Over time, we will run out of chain_hlocks entries while there are still plenty of other lockdep array entries available.  To fix this imbalance, we have to make chain_hlocks entries reusable just like the others. As the freed chain_hlocks entries are in blocks of various lengths. A simple bitmap like the one used in the other reusable lockdep arrays isn't applicable. Instead the chain_hlocks entries are put into bucketed lists (MAX_CHAIN_BUCKETS) of chain blocks.  Bucket 0 is the variable size bucket which houses chain blocks of size larger than MAX_CHAIN_BUCKETS sorted in decreasing size order.  Initially, the whole array is in one chain block (the primordial chain block) in bucket 0.  The minimum size of a chain block is 2 chain_hlocks entries. That will be the minimum allocation size. In other word, allocation requests for one chain_hlocks entry will cause 2-entry block to be returned and hence 1 entry will be wasted.  Allocation requests for the chain_hlocks are fulfilled first by looking for chain block of matching size. If not found, the first chain block from bucket[0] (the largest one) is split. That can cause hlock entries fragmentation and reduce allocation efficiency if a chain block of size > MAX_CHAIN_BUCKETS is ever zapped and put back to after the primordial chain block. So the MAX_CHAIN_BUCKETS must be large enough that this should seldom happen.  By reusing the chain_hlocks entries, we are able to handle workloads that add and zap a lot of lock classes without the risk of running out of chain_hlocks entries as long as the total number of outstanding lock classes at any time remain within a reasonable limit.  Two new tracking counters, nr_free_chain_hlocks & nr_large_chain_blocks, are added to track the total number of chain_hlocks entries in the free bucketed lists and the number of large chain blocks in buckets[0] respectively. The nr_free_chain_hlocks replaces nr_chain_hlocks.  The nr_large_chain_blocks counter enables to see if we should increase the number of buckets (MAX_CHAIN_BUCKETS) available so as to avoid to avoid the fragmentation problem in bucket[0].  An internal nfsd test that ran for more than an hour and kept on loading and unloading kernel modules could cause the following message to be displayed.    ",810507fe6fd5ff3de429121adff49523fabb643a,0
rxrpc: Fix call RCU cleanup using non-bh-safe locks,"rxrpc_rcu_destroy_call(), which is called as an RCU callback to clean up a put call, calls rxrpc_put_connection() which, deep in its bowels, takes a number of spinlocks in a non-BH-safe way, including rxrpc_conn_id_lock and local->client_conns_lock.  RCU callbacks, however, are normally called from softirq context, which can cause lockdep to notice the locking inconsistency.  To get lockdep to detect this, it's necessary to have the connection cleaned up on the put at the end of the last of its calls, though normally the clean up is deferred.  This can be induced, however, by starting a call on an AF_RXRPC socket and then closing the socket without reading the reply.  Fix this by having rxrpc_rcu_destroy_call() punt the destruction to a workqueue if in softirq-mode and defer the destruction to process context.  Note that another way to fix this could be to add a bunch of bh-disable annotations to the spinlocks concerned - and there might be more than just those two - but that means spending more time with BHs disabled.  Note also that some of these places were covered by bh-disable spinlocks belonging to the rxrpc_transport object, but these got removed without the _bh annotation being retained on the next lock in.  ",963485d436ccc2810177a7b08af22336ec2af67b,0
net: make skb_partial_csum_set() more robust against overflows,"syzbot managed to crash in skb_checksum_help() [1] :          BUG_ON(offset + sizeof(__sum16) > skb_headlen(skb));  Root cause is the following check in skb_partial_csum_set()  	if (unlikely(start > skb_headlen(skb)) || 	    unlikely((int)start + off > skb_headlen(skb) - 2)) 		return false;  If skb_headlen(skb) is 1, then (skb_headlen(skb) - 2) becomes 0xffffffff and the check fails to detect that ((int)start + off) is off the limit, since the compare is unsigned.  When we fix that, then the first condition (start > skb_headlen(skb)) becomes obsolete.  Then we should also check that (skb_headroom(skb) + start) wont overflow 16bit field.  [1] kernel BUG at net/core/dev.c:2880! invalid opcode: 0000 [#1] PREEMPT SMP KASAN CPU: 1 PID: 7330 Comm: syz-executor4 Not tainted 4.19.0-rc6+ #253 Hardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 01/01/2011 ",52b5d6f5dcf0e5201392f7d417148ccb537dbf6f,1
ipv6: use GFP_ATOMIC in rt6_probe(),"syzbot reminded me that rt6_probe() can run from atomic contexts.  stack backtrace:  CPU: 1 PID: 7461 Comm: syz-executor.2 Not tainted 5.16.0-rc4-next-20211210-syzkaller #0 Hardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 01/01/2011 Call Trace:  <IRQ>  __dump_stack lib/dump_stack.c:88 [inline]  dump_stack_lvl+0xcd/0x134 lib/dump_stack.c:106  print_usage_bug kernel/locking/lockdep.c:203 [inline]  valid_state kernel/locking/lockdep.c:3945 [inline]  mark_lock_irq kernel/locking/lockdep.c:4148 [inline]  mark_lock.cold+0x61/0x8e kernel/locking/lockdep.c:4605  mark_usage kernel/locking/lockdep.c:4500 [inline]  __lock_acquire+0x11d5/0x54a0 kernel/locking/lockdep.c:4981  lock_acquire kernel/locking/lockdep.c:5639 [inline]  lock_acquire+0x1ab/0x510 kernel/locking/lockdep.c:5604  __fs_reclaim_acquire mm/page_alloc.c:4550 [inline]  fs_reclaim_acquire+0x115/0x160 mm/page_alloc.c:4564  might_alloc include/linux/sched/mm.h:253 [inline]  slab_pre_alloc_hook mm/slab.h:739 [inline]  slab_alloc_node mm/slub.c:3145 [inline]  slab_alloc mm/slub.c:3239 [inline]  kmem_cache_alloc_trace+0x3b/0x2c0 mm/slub.c:3256  kmalloc include/linux/slab.h:581 [inline]  kzalloc include/linux/slab.h:715 [inline]  ref_tracker_alloc+0xe1/0x430 lib/ref_tracker.c:74  netdev_tracker_alloc include/linux/netdevice.h:3860 [inline]  dev_hold_track include/linux/netdevice.h:3877 [inline]  rt6_probe net/ipv6/route.c:661 [inline]  find_match.part.0+0xac9/0xd00 net/ipv6/route.c:752  find_match net/ipv6/route.c:825 [inline]  __find_rr_leaf+0x17f/0xd20 net/ipv6/route.c:826  find_rr_leaf net/ipv6/route.c:847 [inline]  rt6_select net/ipv6/route.c:891 [inline]  fib6_table_lookup+0x649/0xa20 net/ipv6/route.c:2185  ip6_pol_route+0x1c5/0x11e0 net/ipv6/route.c:2221  pol_lookup_func include/net/ip6_fib.h:580 [inline]  fib6_rule_lookup+0x52a/0x6f0 net/ipv6/fib6_rules.c:120  ip6_route_output_flags_noref+0x2e2/0x380 net/ipv6/route.c:2629  ip6_route_output_flags+0x72/0x320 net/ipv6/route.c:2642  ip6_route_output include/net/ip6_route.h:98 [inline]  ip6_dst_lookup_tail+0x5ab/0x1620 net/ipv6/ip6_output.c:1070  ip6_dst_lookup_flow+0x8c/0x1d0 net/ipv6/ip6_output.c:1200  geneve_get_v6_dst+0x46f/0x9a0 drivers/net/geneve.c:858  geneve6_xmit_skb drivers/net/geneve.c:991 [inline]  geneve_xmit+0x520/0x3530 drivers/net/geneve.c:1074  __netdev_start_xmit include/linux/netdevice.h:4685 [inline]  netdev_start_xmit include/linux/netdevice.h:4699 [inline]  xmit_one net/core/dev.c:3473 [inline]  dev_hard_start_xmit+0x1eb/0x920 net/core/dev.c:3489  __dev_queue_xmit+0x2983/0x3640 net/core/dev.c:4112  neigh_resolve_output net/core/neighbour.c:1522 [inline]  neigh_resolve_output+0x50e/0x820 net/core/neighbour.c:1502  neigh_output include/net/neighbour.h:541 [inline]  ip6_finish_output2+0x56e/0x14f0 net/ipv6/ip6_output.c:126  __ip6_finish_output net/ipv6/ip6_output.c:191 [inline]  __ip6_finish_output+0x61e/0xe80 net/ipv6/ip6_output.c:170  ip6_finish_output+0x32/0x200 net/ipv6/ip6_output.c:201  NF_HOOK_COND include/linux/netfilter.h:296 [inline]  ip6_output+0x1e4/0x530 net/ipv6/ip6_output.c:224  dst_output include/net/dst.h:451 [inline]  NF_HOOK include/linux/netfilter.h:307 [inline]  ndisc_send_skb+0xa99/0x17f0 net/ipv6/ndisc.c:508  ndisc_send_rs+0x12e/0x6f0 net/ipv6/ndisc.c:702  addrconf_rs_timer+0x3f2/0x820 net/ipv6/addrconf.c:3898  call_timer_fn+0x1a5/0x6b0 kernel/time/timer.c:1421  expire_timers kernel/time/timer.c:1466 [inline]  __run_timers.part.0+0x675/0xa20 kernel/time/timer.c:1734  __run_timers kernel/time/timer.c:1715 [inline]  run_timer_softirq+0xb3/0x1d0 kernel/time/timer.c:1747  __do_softirq+0x29b/0x9c2 kernel/softirq.c:558  invoke_softirq kernel/softirq.c:432 [inline]  __irq_exit_rcu+0x123/0x180 kernel/softirq.c:637  irq_exit_rcu+0x5/0x20 kernel/softirq.c:649  sysvec_apic_timer_interrupt+0x93/0xc0 arch/x86/kernel/apic/apic.c:1097  </IRQ>  ",8b40a9d53d4f1705899be0a1518368d770ea95cc,1
io-wq: ensure all pending work is canceled on exit,"If we race on shutting down the io-wq, then we should ensure that any work that was queued after workers shutdown is canceled. Harden the add work check a bit too, checking for IO_WQ_BIT_EXIT and cancel if it's set.  Add a WARN_ON() for having any work before we kill the io-wq context.  ",f01272541d2cd7b7f24909d63ea2b028a6a66293,1
aio: Fix locking in aio_poll(),"wake_up_locked() may but does not have to be called with interrupts disabled. Since the fuse filesystem calls wake_up_locked() without disabling interrupts aio_poll_wake() may be called with interrupts enabled. Since the kioctx.ctx_lock may be acquired from IRQ context, all code that acquires that lock from thread context must disable interrupts. Hence change the spin_trylock() call in aio_poll_wake() into a spin_trylock_irqsave() call. This patch fixes the following lockdep complaint:  ",d3d6a18d7d351cbcc9b33dbedf710e65f8ce1595,0
"netfilter: nfnetlink_cttimeout: fetch timeouts for udplite and gre, too","syzbot was able to trigger the WARN in cttimeout_default_get() by passing UDPLITE as l4protocol.  Alias UDPLITE to UDP, both use same timeout values.  Furthermore, also fetch GRE timeouts.  GRE is a bit more complicated, as it still can be a module and its netns_proto_gre struct layout isn't visible outside of the gre module. Can't move timeouts around, it appears conntrack sysctl unregister assumes net_generic() returns nf_proto_net, so we get crash. Expose layout of netns_proto_gre instead.  A followup nf-next patch could make gre tracker be built-in as well if needed, its not that large.  Last, make the WARN() mention the missing protocol value in case anything else is missing.  ",89259088c1b7fecb43e8e245dc931909132a4e03,1
"xsk: Validate socket state in xsk_recvmsg, prior touching socket members","In AF_XDP the socket state needs to be checked, prior touching the members of the socket. This was not the case for the recvmsg implementation. Fix that by moving the xsk_is_bound() call.  ",3546b9b8eced9799b35ef953f766a0973b17fda2,0
tls: fix use after free in tls_sk_proto_close,"syzbot reported a use-after-free in tls_sk_proto_close  Add a boolean value to cleanup a bit this function.  BUG: KASAN: use-after-free in tls_sk_proto_close+0x8ab/0x9c0 net/tls/tls_main.c:297 Read of size 1 at addr ffff8801ae40a858 by task syz-executor363/4503  CPU: 0 PID: 4503 Comm: syz-executor363 Not tainted 4.17.0-rc3+ #34 Hardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 01/01/2011 Call Trace:  __dump_stack lib/dump_stack.c:77 [inline]  dump_stack+0x1b9/0x294 lib/dump_stack.c:113  print_address_description+0x6c/0x20b mm/kasan/report.c:256  kasan_report_error mm/kasan/report.c:354 [inline]  kasan_report.cold.7+0x242/0x2fe mm/kasan/report.c:412  __asan_report_load1_noabort+0x14/0x20 mm/kasan/report.c:430  tls_sk_proto_close+0x8ab/0x9c0 net/tls/tls_main.c:297  inet_release+0x104/0x1f0 net/ipv4/af_inet.c:427  inet6_release+0x50/0x70 net/ipv6/af_inet6.c:460  sock_release+0x96/0x1b0 net/socket.c:594  sock_close+0x16/0x20 net/socket.c:1149  __fput+0x34d/0x890 fs/file_table.c:209  ____fput+0x15/0x20 fs/file_table.c:243  task_work_run+0x1e4/0x290 kernel/task_work.c:113  exit_task_work include/linux/task_work.h:22 [inline]  do_exit+0x1aee/0x2730 kernel/exit.c:865  do_group_exit+0x16f/0x430 kernel/exit.c:968  get_signal+0x886/0x1960 kernel/signal.c:2469  do_signal+0x98/0x2040 arch/x86/kernel/signal.c:810  exit_to_usermode_loop+0x28a/0x310 arch/x86/entry/common.c:162  prepare_exit_to_usermode arch/x86/entry/common.c:196 [inline]  syscall_return_slowpath arch/x86/entry/common.c:265 [inline]  do_syscall_64+0x6ac/0x800 arch/x86/entry/common.c:290  entry_SYSCALL_64_after_hwframe+0x49/0xbe ",98f0a39529e553bb45c0a7d775d2cc2afe9ed91d,1
staging: rtl8712: handle firmware load failure,when firmware fails to load we should not call unregister_netdev() this patch fixes a race condition between rtl871x_load_fw_cb() and r871xu_dev_remove() and fixes the bug reported by syzbot  ,b4383c971bc5263efe2b0915ba67ebf2bf3f1ee5,1
fuse: fix deadlock with aio poll and fuse_iqueue::waitq.lock,"When IOCB_CMD_POLL is used on the FUSE device, aio_poll() disables IRQs and takes kioctx::ctx_lock, then fuse_iqueue::waitq.lock.  This may have to wait for fuse_iqueue::waitq.lock to be released by one of many places that take it with IRQs enabled.  Since the IRQ handler may take kioctx::ctx_lock, lockdep reports that a deadlock is possible.  Fix it by protecting the state of struct fuse_iqueue with a separate spinlock, and only accessing fuse_iqueue::waitq using the versions of the waitqueue functions which do IRQ-safe locking internally.  Reproducer:  	#include <fcntl.h> 	#include <stdio.h> 	#include <sys/mount.h> 	#include <sys/stat.h> 	#include <sys/syscall.h> 	#include <unistd.h> 	#include <linux/aio_abi.h>  	int main() 	{ 		char opts[128]; 		int fd = open(""/dev/fuse"", O_RDWR); 		aio_context_t ctx = 0; 		struct iocb cb = { .aio_lio_opcode = IOCB_CMD_POLL, .aio_fildes = fd }; 		struct iocb *cbp = &cb;  		sprintf(opts, ""fd=%d,rootmode=040000,user_id=0,group_id=0"", fd); 		mkdir(""mnt"", 0700); 		mount(""foo"",  ""mnt"", ""fuse"", 0, opts); 		syscall(__NR_io_setup, 1, &ctx); 		syscall(__NR_io_submit, ctx, 1, &cbp); 	}  Beginning of lockdep output:  	",76e43c8ccaa35c30d5df853013561145a0f750a5,0
HID: logitech: Fix general protection fault caused by Logitech driver,"The syzbot fuzzer found a general protection fault in the HID subsystem:  kasan: CONFIG_KASAN_INLINE enabled kasan: GPF could be caused by NULL-ptr deref or user memory access general protection fault: 0000 [#1] SMP KASAN CPU: 0 PID: 3715 Comm: syz-executor.3 Not tainted 5.2.0-rc6+ #15 Hardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 01/01/2011 ",5f9242775bb61f390f0885f23fc16397262c7538,1
netfilter: bridge: make sure to pull arp header in br_nf_forward_arp(),"syzbot is kind enough to remind us we need to call skb_may_pull()  BUG: KMSAN: uninit-value in br_nf_forward_arp+0xe61/0x1230 net/bridge/br_netfilter_hooks.c:665 CPU: 1 PID: 11631 Comm: syz-executor.1 Not tainted 5.4.0-rc8-syzkaller #0 Hardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 01/01/2011 Call Trace:  <IRQ>  __dump_stack lib/dump_stack.c:77 [inline]  dump_stack+0x1c9/0x220 lib/dump_stack.c:118  kmsan_report+0x128/0x220 mm/kmsan/kmsan_report.c:108  __msan_warning+0x64/0xc0 mm/kmsan/kmsan_instr.c:245  br_nf_forward_arp+0xe61/0x1230 net/bridge/br_netfilter_hooks.c:665  nf_hook_entry_hookfn include/linux/netfilter.h:135 [inline]  nf_hook_slow+0x18b/0x3f0 net/netfilter/core.c:512  nf_hook include/linux/netfilter.h:260 [inline]  NF_HOOK include/linux/netfilter.h:303 [inline]  __br_forward+0x78f/0xe30 net/bridge/br_forward.c:109  br_flood+0xef0/0xfe0 net/bridge/br_forward.c:234  br_handle_frame_finish+0x1a77/0x1c20 net/bridge/br_input.c:162  nf_hook_bridge_pre net/bridge/br_input.c:245 [inline]  br_handle_frame+0xfb6/0x1eb0 net/bridge/br_input.c:348  __netif_receive_skb_core+0x20b9/0x51a0 net/core/dev.c:4830  __netif_receive_skb_one_core net/core/dev.c:4927 [inline]  __netif_receive_skb net/core/dev.c:5043 [inline]  process_backlog+0x610/0x13c0 net/core/dev.c:5874  napi_poll net/core/dev.c:6311 [inline]  net_rx_action+0x7a6/0x1aa0 net/core/dev.c:6379  __do_softirq+0x4a1/0x83a kernel/softirq.c:293  do_softirq_own_stack+0x49/0x80 arch/x86/entry/entry_64.S:1091  </IRQ>  do_softirq kernel/softirq.c:338 [inline]  __local_bh_enable_ip+0x184/0x1d0 kernel/softirq.c:190  local_bh_enable+0x36/0x40 include/linux/bottom_half.h:32  rcu_read_unlock_bh include/linux/rcupdate.h:688 [inline]  __dev_queue_xmit+0x38e8/0x4200 net/core/dev.c:3819  dev_queue_xmit+0x4b/0x60 net/core/dev.c:3825  packet_snd net/packet/af_packet.c:2959 [inline]  packet_sendmsg+0x8234/0x9100 net/packet/af_packet.c:2984  sock_sendmsg_nosec net/socket.c:637 [inline]  sock_sendmsg net/socket.c:657 [inline]  __sys_sendto+0xc44/0xc70 net/socket.c:1952  __do_sys_sendto net/socket.c:1964 [inline]  __se_sys_sendto+0x107/0x130 net/socket.c:1960  __x64_sys_sendto+0x6e/0x90 net/socket.c:1960  do_syscall_64+0xb6/0x160 arch/x86/entry/common.c:291  entry_SYSCALL_64_after_hwframe+0x44/0xa9 ",5604285839aaedfb23ebe297799c6e558939334d,1
staging: comedi: vmk80xx: Fix use of uninitialized semaphore,"If `vmk80xx_auto_attach()` returns an error, the core comedi module code will call `vmk80xx_detach()` to clean up.  If `vmk80xx_auto_attach()` successfully allocated the comedi device private data, `vmk80xx_detach()` assumes that a `struct semaphore limit_sem` contained in the private data has been initialized and uses it.  Unfortunately, there are a couple of places where `vmk80xx_auto_attach()` can return an error after allocating the device private data but before initializing the semaphore, so this assumption is invalid.  Fix it by initializing the semaphore just after allocating the private data in `vmk80xx_auto_attach()` before any other errors can be returned.  I believe this was the cause of the following syzbot crash report <https://syzkaller.appspot.com/bug?extid=54c2f58f15fe6876b6ad>:  usb 1-1: config 0 has no interface number 0 usb 1-1: New USB device found, idVendor=10cf, idProduct=8068, bcdDevice=e6.8d usb 1-1: New USB device strings: Mfr=0, Product=0, SerialNumber=0 usb 1-1: config 0 descriptor?? vmk80xx 1-1:0.117: driver 'vmk80xx' failed to auto-configure device. INFO: trying to register non-static key. the code is fine but needs lockdep annotation. turning off the locking correctness validator. CPU: 0 PID: 12 Comm: kworker/0:1 Not tainted 5.1.0-rc4-319354-g9a33b36 #3 Hardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 01/01/2011 Workqueue: usb_hub_wq hub_event Call Trace:  __dump_stack lib/dump_stack.c:77 [inline]  dump_stack+0xe8/0x16e lib/dump_stack.c:113  assign_lock_key kernel/locking/lockdep.c:786 [inline]  register_lock_class+0x11b8/0x1250 kernel/locking/lockdep.c:1095  __lock_acquire+0xfb/0x37c0 kernel/locking/lockdep.c:3582  lock_acquire+0x10d/0x2f0 kernel/locking/lockdep.c:4211  __raw_spin_lock_irqsave include/linux/spinlock_api_smp.h:110 [inline]  _raw_spin_lock_irqsave+0x44/0x60 kernel/locking/spinlock.c:152  down+0x12/0x80 kernel/locking/semaphore.c:58  vmk80xx_detach+0x59/0x100 drivers/staging/comedi/drivers/vmk80xx.c:829  comedi_device_detach+0xed/0x800 drivers/staging/comedi/drivers.c:204  comedi_device_cleanup.part.0+0x68/0x140 drivers/staging/comedi/comedi_fops.c:156  comedi_device_cleanup drivers/staging/comedi/comedi_fops.c:187 [inline]  comedi_free_board_dev.part.0+0x16/0x90 drivers/staging/comedi/comedi_fops.c:190  comedi_free_board_dev drivers/staging/comedi/comedi_fops.c:189 [inline]  comedi_release_hardware_device+0x111/0x140 drivers/staging/comedi/comedi_fops.c:2880  comedi_auto_config.cold+0x124/0x1b0 drivers/staging/comedi/drivers.c:1068  usb_probe_interface+0x31d/0x820 drivers/usb/core/driver.c:361  really_probe+0x2da/0xb10 drivers/base/dd.c:509  driver_probe_device+0x21d/0x350 drivers/base/dd.c:671  __device_attach_driver+0x1d8/0x290 drivers/base/dd.c:778  bus_for_each_drv+0x163/0x1e0 drivers/base/bus.c:454  __device_attach+0x223/0x3a0 drivers/base/dd.c:844  bus_probe_device+0x1f1/0x2a0 drivers/base/bus.c:514  device_add+0xad2/0x16e0 drivers/base/core.c:2106  usb_set_configuration+0xdf7/0x1740 drivers/usb/core/message.c:2021  generic_probe+0xa2/0xda drivers/usb/core/generic.c:210  usb_probe_device+0xc0/0x150 drivers/usb/core/driver.c:266  really_probe+0x2da/0xb10 drivers/base/dd.c:509  driver_probe_device+0x21d/0x350 drivers/base/dd.c:671  __device_attach_driver+0x1d8/0x290 drivers/base/dd.c:778  bus_for_each_drv+0x163/0x1e0 drivers/base/bus.c:454  __device_attach+0x223/0x3a0 drivers/base/dd.c:844  bus_probe_device+0x1f1/0x2a0 drivers/base/bus.c:514  device_add+0xad2/0x16e0 drivers/base/core.c:2106  usb_new_device.cold+0x537/0xccf drivers/usb/core/hub.c:2534  hub_port_connect drivers/usb/core/hub.c:5089 [inline]  hub_port_connect_change drivers/usb/core/hub.c:5204 [inline]  port_event drivers/usb/core/hub.c:5350 [inline]  hub_event+0x138e/0x3b00 drivers/usb/core/hub.c:5432  process_one_work+0x90f/0x1580 kernel/workqueue.c:2269  worker_thread+0x9b/0xe20 kernel/workqueue.c:2415  kthread+0x313/0x420 kernel/kthread.c:253  ret_from_fork+0x3a/0x50 arch/x86/entry/entry_64.S:352  ",08b7c2f9208f0e2a32159e4e7a4831b7adb10a3e,1
btrfs: remove dio iomap DSYNC workaround,"This effectively reverts 09745ff88d93 (""btrfs: dio iomap DSYNC workaround"") now that the iomap API has been updated to allow iomap_dio_complete() not to be called under i_rwsem anymore.  ",ecfdc08b8cc65d737eebc26a1ee1875a097fd6a0,0
netfilter: x_tables: avoid out-of-bounds reads in xt_request_find_{match|target},"It looks like syzbot found its way into netfilter territory.  Issue here is that @name comes from user space and might not be null terminated.  Out-of-bound reads happen, KASAN is not happy.  v2 added similar fix for xt_request_find_target(), as Florian advised.  ",da17c73b6eb74aad3c3c0654394635675b623b3e,1
macvlan: do not assume mac_header is set in macvlan_broadcast(),"Use of eth_hdr() in tx path is error prone.  Many drivers call skb_reset_mac_header() before using it, but others do not.  Commit 6d1ccff62780 (""net: reset mac header in dev_start_xmit()"") attempted to fix this generically, but commit d346a3fae3ff (""packet: introduce PACKET_QDISC_BYPASS socket option"") brought back the macvlan bug.  Lets add a new helper, so that tx paths no longer have to call skb_reset_mac_header() only to get a pointer to skb->data.  Hopefully we will be able to revert 6d1ccff62780 (""net: reset mac header in dev_start_xmit()"") and save few cycles in transmit fast path.  BUG: KASAN: use-after-free in __get_unaligned_cpu32 include/linux/unaligned/packed_struct.h:19 [inline] BUG: KASAN: use-after-free in mc_hash drivers/net/macvlan.c:251 [inline] BUG: KASAN: use-after-free in macvlan_broadcast+0x547/0x620 drivers/net/macvlan.c:277 Read of size 4 at addr ffff8880a4932401 by task syz-executor947/9579  CPU: 0 PID: 9579 Comm: syz-executor947 Not tainted 5.5.0-rc4-syzkaller #0 Hardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 01/01/2011 Call Trace:  __dump_stack lib/dump_stack.c:77 [inline]  dump_stack+0x197/0x210 lib/dump_stack.c:118  print_address_description.constprop.0.cold+0xd4/0x30b mm/kasan/report.c:374  __kasan_report.cold+0x1b/0x41 mm/kasan/report.c:506  kasan_report+0x12/0x20 mm/kasan/common.c:639  __asan_report_load_n_noabort+0xf/0x20 mm/kasan/generic_report.c:145  __get_unaligned_cpu32 include/linux/unaligned/packed_struct.h:19 [inline]  mc_hash drivers/net/macvlan.c:251 [inline]  macvlan_broadcast+0x547/0x620 drivers/net/macvlan.c:277  macvlan_queue_xmit drivers/net/macvlan.c:520 [inline]  macvlan_start_xmit+0x402/0x77f drivers/net/macvlan.c:559  __netdev_start_xmit include/linux/netdevice.h:4447 [inline]  netdev_start_xmit include/linux/netdevice.h:4461 [inline]  dev_direct_xmit+0x419/0x630 net/core/dev.c:4079  packet_direct_xmit+0x1a9/0x250 net/packet/af_packet.c:240  packet_snd net/packet/af_packet.c:2966 [inline]  packet_sendmsg+0x260d/0x6220 net/packet/af_packet.c:2991  sock_sendmsg_nosec net/socket.c:639 [inline]  sock_sendmsg+0xd7/0x130 net/socket.c:659  __sys_sendto+0x262/0x380 net/socket.c:1985  __do_sys_sendto net/socket.c:1997 [inline]  __se_sys_sendto net/socket.c:1993 [inline]  __x64_sys_sendto+0xe1/0x1a0 net/socket.c:1993  do_syscall_64+0xfa/0x790 arch/x86/entry/common.c:294  entry_SYSCALL_64_after_hwframe+0x49/0xbe ",96cc4b69581db68efc9749ef32e9cf8e0160c509,1
tracing: Fix bad use of igrab in trace_uprobe.c,"As Miklos reported and suggested:    This pattern repeats two times in trace_uprobe.c and in   kernel/events/core.c as well:        ret = kern_path(filename, LOOKUP_FOLLOW, &path);       if (ret)           goto fail_address_parse;        inode = igrab(d_inode(path.dentry));       path_put(&path);    And it's wrong.  You can only hold a reference to the inode if you   have an active ref to the superblock as well (which is normally   through path.mnt) or holding s_umount.    This way unmounting the containing filesystem while the tracepoint is   active will give you the ""VFS: Busy inodes after unmount..."" message   and a crash when the inode is finally put.    Solution: store path instead of inode.  This patch fixes two instances in trace_uprobe.c. struct path is added to struct trace_uprobe to keep the inode and containing mount point referenced.   ",0c92c7a3c5d416f47b32c5f20a611dfeca5d5f2e,1
hsr: fix interface leak in error path of hsr_dev_finalize(),"To release hsr(upper) interface, it should release its own lower interfaces first. Then, hsr(upper) interface can be released safely. In the current code of error path of hsr_dev_finalize(), it releases hsr interface before releasing a lower interface. So, a warning occurs, which warns about the leak of lower interfaces. In order to fix this problem, changing the ordering of the error path of hsr_dev_finalize() is needed.  Test commands:     ip link add dummy0 type dummy     ip link add dummy1 type dummy     ip link add dummy2 type dummy     ip link add hsr0 type hsr slave1 dummy0 slave2 dummy1     ip link add hsr1 type hsr slave1 dummy2 slave2 dummy0  Splat looks like: ",ccfc9df1352be5b2f391091e18c4b2395d30ce78,0
ovl: detect overlapping layers,"Overlapping overlay layers are not supported and can cause unexpected behavior, but overlayfs does not currently check or warn about these configurations.  User is not supposed to specify the same directory for upper and lower dirs or for different lower layers and user is not supposed to specify directories that are descendants of each other for overlay layers, but that is exactly what this zysbot repro did:      https://syzkaller.appspot.com/x/repro.syz?x=12c7a94f400000  Moving layer root directories into other layers while overlayfs is mounted could also result in unexpected behavior.  This commit places ""traps"" in the overlay inode hash table. Those traps are dummy overlay inodes that are hashed by the layers root inodes.  On mount, the hash table trap entries are used to verify that overlay layers are not overlapping.  While at it, we also verify that overlay layers are not overlapping with directories ""in-use"" by other overlay instances as upperdir/workdir.  On lookup, the trap entries are used to verify that overlay layers root inodes have not been moved into other layers after mount.  Some examples:  $ ./run --ov --samefs -s ... ( mkdir -p base/upper/0/u base/upper/0/w base/lower lower upper mnt   mount -o bind base/lower lower   mount -o bind base/upper upper   mount -t overlay none mnt ...         -o lowerdir=lower,upperdir=upper/0/u,workdir=upper/0/w)  $ umount mnt $ mount -t overlay none mnt ...         -o lowerdir=base,upperdir=upper/0/u,workdir=upper/0/w    ",146d62e5a5867fbf84490d82455718bfb10fe824,1
netfilter: bridge: prevent UAF in brnf_exit_net(),Prevent a UAF in brnf_exit_net().  When unregister_net_sysctl_table() is called the ctl_hdr pointer will obviously be freed and so accessing it righter after is invalid. Fix this by stashing a pointer to the table we want to free before we unregister the sysctl header.  Note that syzkaller falsely chased this down to the drm tree so the Fixes tag that syzkaller requested would be wrong. This commit uses a different but the correct Fixes tag.  ,7e6daf50e1f4ea0ecd56406beb64ffc66e1e94db,1
proc: proc_pid_ns takes super_block as an argument,"syzbot found that    touch /proc/testfile  causes NULL pointer dereference at tomoyo_get_local_path() because inode of the dentry is NULL.  Before c59f415a7cb6, Tomoyo received pid_ns from proc's s_fs_info directly. Since proc_pid_ns() can only work with inode, using it in the tomoyo_get_local_path() was wrong.  To avoid creating more functions for getting proc_ns, change the argument type of the proc_pid_ns() function. Then, Tomoyo can use the existing super_block to get pid_ns.  ",9d78edeaec759f997c303f286ecd39daee166f2a,1
gfs2: Don't leave s_fs_info pointing to freed memory in init_sbd,"When alloc_percpu() fails, sdp gets freed but sb->s_fs_info still points to the same address. Move the assignment after that error check so that s_fs_info can only point to a valid sdp or NULL, which is checked for later in the error path, in gfs2_kill_super().  ",4c62bd9cea7bcf10292f7e4c57a2bca332942697,0
crypto: don't optimize keccakf(),"keccakf() is the only function in kernel that uses __optimize() macro. __optimize() breaks frame pointer unwinder as optimized code uses RBP, and amusingly this always lead to degraded performance as gcc does not inline across different optimizations levels, so keccakf() wasn't inlined into its callers and keccakf_round() wasn't inlined into keccakf().  Drop __optimize() to resolve both problems.  ",f044a84e040b85cd609851ac88ae8b54b2cc0b75,0
udp: fix data-race in udp_set_dev_scratch(),"KCSAN reported a data-race in udp_set_dev_scratch() [1]  The issue here is that we must not write over skb fields if skb is shared. A similar issue has been fixed in commit 89c22d8c3b27 (""net: Fix skb csum races when peeking"")  While we are at it, use a helper only dealing with udp_skb_scratch(skb)->csum_unnecessary, as this allows udp_set_dev_scratch() to be called once and thus inlined.  [1] BUG: KCSAN: data-race in udp_set_dev_scratch / udpv6_recvmsg  write to 0xffff888120278317 of 1 bytes by task 10411 on cpu 1:  udp_set_dev_scratch+0xea/0x200 net/ipv4/udp.c:1308  __first_packet_length+0x147/0x420 net/ipv4/udp.c:1556  first_packet_length+0x68/0x2a0 net/ipv4/udp.c:1579  udp_poll+0xea/0x110 net/ipv4/udp.c:2720  sock_poll+0xed/0x250 net/socket.c:1256  vfs_poll include/linux/poll.h:90 [inline]  do_select+0x7d0/0x1020 fs/select.c:534  core_sys_select+0x381/0x550 fs/select.c:677  do_pselect.constprop.0+0x11d/0x160 fs/select.c:759  __do_sys_pselect6 fs/select.c:784 [inline]  __se_sys_pselect6 fs/select.c:769 [inline]  __x64_sys_pselect6+0x12e/0x170 fs/select.c:769  do_syscall_64+0xcc/0x370 arch/x86/entry/common.c:290  entry_SYSCALL_64_after_hwframe+0x44/0xa9  read to 0xffff888120278317 of 1 bytes by task 10413 on cpu 0:  udp_skb_csum_unnecessary include/net/udp.h:358 [inline]  udpv6_recvmsg+0x43e/0xe90 net/ipv6/udp.c:310  inet6_recvmsg+0xbb/0x240 net/ipv6/af_inet6.c:592  sock_recvmsg_nosec+0x5c/0x70 net/socket.c:871  ___sys_recvmsg+0x1a0/0x3e0 net/socket.c:2480  do_recvmmsg+0x19a/0x5c0 net/socket.c:2601  __sys_recvmmsg+0x1ef/0x200 net/socket.c:2680  __do_sys_recvmmsg net/socket.c:2703 [inline]  __se_sys_recvmmsg net/socket.c:2696 [inline]  __x64_sys_recvmmsg+0x89/0xb0 net/socket.c:2696  do_syscall_64+0xcc/0x370 arch/x86/entry/common.c:290  entry_SYSCALL_64_after_hwframe+0x44/0xa9  Reported by Kernel Concurrency Sanitizer on: CPU: 0 PID: 10413 Comm: syz-executor.0 Not tainted 5.4.0-rc3+ #0 Hardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 01/01/2011  ",a793183caa9afae907a0d7ddd2ffd57329369bf5,1
xfrm: Fix stack-out-of-bounds with misconfigured transport mode policies.,"On policies with a transport mode template, we pass the addresses from the flowi to xfrm_state_find(), assuming that the IP addresses (and address family) don't change during transformation.  Unfortunately our policy template validation is not strict enough. It is possible to configure policies with transport mode template where the address family of the template does not match the selectors address family. This lead to stack-out-of-bound reads because we compare arddesses of the wrong family. Fix this by refusing such a configuration, address family can not change on transport mode.  We use the assumption that, on transport mode, the first templates address family must match the address family of the policy selector. Subsequent transport mode templates must mach the address family of the previous template.  ",732706afe1cc46ef48493b3d2b69c98f36314ae4,1
RDS: RDMA: Fix the NULL-ptr deref in rds_ib_get_mr,"Registration of a memory region(MR) through FRMR/fastreg(unlike FMR) needs a connection/qp. With a proxy qp, this dependency on connection will be removed, but that needs more infrastructure patches, which is a work in progress.  As an intermediate fix, the get_mr returns EOPNOTSUPP when connection details are not populated. The MR registration through sendmsg() will continue to work even with fast registration, since connection in this case is formed upfront.  This patch fixes the following crash: kasan: GPF could be caused by NULL-ptr deref or user memory access general protection fault: 0000 [#1] SMP KASAN ",9e630bcb7701f94dbd729fe57d37c089c763ad9f,1
crypto: af_alg - Initialize sg_num_bytes in error code path,"The RX SGL in processing is already registered with the RX SGL tracking list to support proper cleanup. The cleanup code path uses the sg_num_bytes variable which must therefore be always initialized, even in the error code path.  ",2546da99212f22034aecf279da9c47cbfac6c981,0
tun: fix use after free for ptr_ring,"We used to initialize ptr_ring during TUNSETIFF, this is because its size depends on the tx_queue_len of netdevice. And we try to clean it up when socket were detached from netdevice. A race were spotted when trying to do uninit during a read which will lead a use after free for pointer ring. Solving this by always initialize a zero size ptr_ring in open() and do resizing during TUNSETIFF, and then we can safely do cleanup during close(). With this, there's no need for the workaround that was introduced by commit 4df0bfc79904 (""tun: fix a memory leak for tfile->tx_array"").  ",b196d88aba8ac72b775137854121097f4c4c6862,1
Bluetooth: stop proccessing malicious adv data,"Syzbot reported slab-out-of-bounds read in hci_le_adv_report_evt(). The problem was in missing validaion check.  We should check if data is not malicious and we can read next data block. If we won't check ptr validness, code can read a way beyond skb->end and it can cause problems, of course.  ",3a56ef719f0b9682afb8a86d64b2399e36faa4e6,1
jbd2: fix use after free in jbd2_log_do_checkpoint(),"The code cleaning transaction's lists of checkpoint buffers has a bug where it increases bh refcount only after releasing journal->j_list_lock. Thus the following race is possible:  CPU0					CPU1 jbd2_log_do_checkpoint() 					jbd2_journal_try_to_free_buffers() 					  __journal_try_to_free_buffer(bh)   ...   while (transaction->t_checkpoint_io_list)   ...     if (buffer_locked(bh)) {  <-- IO completes now, buffer gets unlocked -->        spin_unlock(&journal->j_list_lock); 					    spin_lock(&journal->j_list_lock); 					    __jbd2_journal_remove_checkpoint(jh); 					    spin_unlock(&journal->j_list_lock); 					  try_to_free_buffers(page);       get_bh(bh) <-- accesses freed bh  Fix the problem by grabbing bh reference before unlocking journal->j_list_lock.  ",ccd3c4373eacb044eb3832966299d13d2631f66f,1
tipc: check bearer name with right length in tipc_nl_compat_bearer_enable,Syzbot reported the following crash:  BUG: KMSAN: uninit-value in memchr+0xce/0x110 lib/string.c:961   memchr+0xce/0x110 lib/string.c:961   string_is_valid net/tipc/netlink_compat.c:176 [inline]   tipc_nl_compat_bearer_enable+0x2c4/0x910 net/tipc/netlink_compat.c:401   __tipc_nl_compat_doit net/tipc/netlink_compat.c:321 [inline]   tipc_nl_compat_doit+0x3aa/0xaf0 net/tipc/netlink_compat.c:354   tipc_nl_compat_handle net/tipc/netlink_compat.c:1162 [inline]   tipc_nl_compat_recv+0x1ae7/0x2750 net/tipc/netlink_compat.c:1265   genl_family_rcv_msg net/netlink/genetlink.c:601 [inline]   genl_rcv_msg+0x185f/0x1a60 net/netlink/genetlink.c:626   netlink_rcv_skb+0x431/0x620 net/netlink/af_netlink.c:2477   genl_rcv+0x63/0x80 net/netlink/genetlink.c:637   netlink_unicast_kernel net/netlink/af_netlink.c:1310 [inline]   netlink_unicast+0xf3e/0x1020 net/netlink/af_netlink.c:1336   netlink_sendmsg+0x127f/0x1300 net/netlink/af_netlink.c:1917   sock_sendmsg_nosec net/socket.c:622 [inline]   sock_sendmsg net/socket.c:632 [inline]  ,6f07e5f06c8712acc423485f657799fc8e11e56c,1
net: linkwatch: be more careful about dev->linkwatch_dev_tracker,Apparently a concurrent linkwatch_add_event() could run while we are in __linkwatch_run_queue().  We need to free dev->linkwatch_dev_tracker tracker under lweventlist_lock protection to avoid this race.  syzbot report: ,123e495ecc25d32cf3e7958f794013236abdf0d4,1
packet: unconditionally free po->rollover,"Rollover used to use a complex RCU mechanism for assignment, which had a race condition. The below patch fixed the bug and greatly simplified the logic.  The feature depends on fanout, but the state is private to the socket. Fanout_release returns f only when the last member leaves and the fanout struct is to be freed.  Destroy rollover unconditionally, regardless of fanout state.  ",afa0925c6fcc6a8f610e996ca09bc3215048033c,1
net_sched: reject silly cell_log in qdisc_get_rtab(),"iproute2 probably never goes beyond 8 for the cell exponent, but stick to the max shift exponent for signed 32bit.  UBSAN reported: UBSAN: shift-out-of-bounds in net/sched/sch_api.c:389:22 shift exponent 130 is too large for 32-bit type 'int' CPU: 1 PID: 8450 Comm: syz-executor586 Not tainted 5.11.0-rc3-syzkaller #0 Hardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 01/01/2011 Call Trace:  __dump_stack lib/dump_stack.c:79 [inline]  dump_stack+0x183/0x22e lib/dump_stack.c:120  ubsan_epilogue lib/ubsan.c:148 [inline]  __ubsan_handle_shift_out_of_bounds+0x432/0x4d0 lib/ubsan.c:395  __detect_linklayer+0x2a9/0x330 net/sched/sch_api.c:389  qdisc_get_rtab+0x2b5/0x410 net/sched/sch_api.c:435  cbq_init+0x28f/0x12c0 net/sched/sch_cbq.c:1180  qdisc_create+0x801/0x1470 net/sched/sch_api.c:1246  tc_modify_qdisc+0x9e3/0x1fc0 net/sched/sch_api.c:1662  rtnetlink_rcv_msg+0xb1d/0xe60 net/core/rtnetlink.c:5564  netlink_rcv_skb+0x1f0/0x460 net/netlink/af_netlink.c:2494  netlink_unicast_kernel net/netlink/af_netlink.c:1304 [inline]  netlink_unicast+0x7de/0x9b0 net/netlink/af_netlink.c:1330  netlink_sendmsg+0xaa6/0xe90 net/netlink/af_netlink.c:1919  sock_sendmsg_nosec net/socket.c:652 [inline]  sock_sendmsg net/socket.c:672 [inline]  ____sys_sendmsg+0x5a2/0x900 net/socket.c:2345  ___sys_sendmsg net/socket.c:2399 [inline]  __sys_sendmsg+0x319/0x400 net/socket.c:2432  do_syscall_64+0x2d/0x70 arch/x86/entry/common.c:46  entry_SYSCALL_64_after_hwframe+0x44/0xa9  ",e4bedf48aaa5552bc1f49703abd17606e7e6e82a,1
hsr: fix a race condition in node list insertion and deletion,hsr nodes are protected by RCU and there is no write side lock. But node insertions and deletions could be being operated concurrently. So write side locking is needed.  Test commands:     ip netns add nst     ip link add veth0 type veth peer name veth1     ip link add veth2 type veth peer name veth3     ip link set veth1 netns nst     ip link set veth3 netns nst     ip link set veth0 up     ip link set veth2 up     ip link add hsr0 type hsr slave1 veth0 slave2 veth2     ip a a 192.168.100.1/24 dev hsr0     ip link set hsr0 up     ip netns exec nst ip link set veth1 up     ip netns exec nst ip link set veth3 up     ip netns exec nst ip link add hsr1 type hsr slave1 veth1 slave2 veth3     ip netns exec nst ip a a 192.168.100.2/24 dev hsr1     ip netns exec nst ip link set hsr1 up      for i in {0..9}     do         for j in {0..9} 	do 	    for k in {0..9} 	    do 	        for l in {0..9} 		do 	        arping 192.168.100.2 -I hsr0 -s 00:01:3$i:4$j:5$k:6$l -c1 & 		done 	    done 	done     done  Splat looks like: ,92a35678ec075100ce666a2fb6969151affb0e5d,1
ALSA: rawmidi: Change resized buffers atomically,"The SNDRV_RAWMIDI_IOCTL_PARAMS ioctl may resize the buffers and the current code is racy.  For example, the sequencer client may write to buffer while it being resized.  As a simple workaround, let's switch to the resized buffer inside the stream runtime lock.  ",39675f7a7c7e7702f7d5341f1e0d01db746543a0,0
crypto: x86 - remove SHA multibuffer routines and mcryptd,"As it turns out, the AVX2 multibuffer SHA routines are currently broken [0], in a way that would have likely been noticed if this code were in wide use. Since the code is too complicated to be maintained by anyone except the original authors, and since the performance benefits for real-world use cases are debatable to begin with, it is better to drop it entirely for the moment.  [0] https://marc.info/?l=linux-crypto-vger&m=153476243825350&w=2  Suggested-by: Eric Biggers <ebiggers@google.com> ",ab8085c130edd65be0d95cc95c28b51c4c6faf9d,0
kcm: disable preemption in kcm_parse_func_strparser(),"After commit a2c11b034142 (""kcm: use BPF_PROG_RUN"") syzbot easily triggers the warning in cant_sleep().  As explained in commit 6cab5e90ab2b (""bpf: run bpf programs with preemption disabled"") we need to disable preemption before running bpf programs.  BUG: assuming atomic context at net/kcm/kcmsock.c:382 in_atomic(): 0, irqs_disabled(): 0, pid: 7, name: kworker/u4:0 3 locks held by kworker/u4:0/7:  #0: ffff888216726128 ((wq_completion)kstrp){+.+.}, at: __write_once_size include/linux/compiler.h:226 [inline]  #0: ffff888216726128 ((wq_completion)kstrp){+.+.}, at: arch_atomic64_set arch/x86/include/asm/atomic64_64.h:34 [inline]  #0: ffff888216726128 ((wq_completion)kstrp){+.+.}, at: atomic64_set include/asm-generic/atomic-instrumented.h:855 [inline]  #0: ffff888216726128 ((wq_completion)kstrp){+.+.}, at: atomic_long_set include/asm-generic/atomic-long.h:40 [inline]  #0: ffff888216726128 ((wq_completion)kstrp){+.+.}, at: set_work_data kernel/workqueue.c:620 [inline]  #0: ffff888216726128 ((wq_completion)kstrp){+.+.}, at: set_work_pool_and_clear_pending kernel/workqueue.c:647 [inline]  #0: ffff888216726128 ((wq_completion)kstrp){+.+.}, at: process_one_work+0x88b/0x1740 kernel/workqueue.c:2240  #1: ffff8880a989fdc0 ((work_completion)(&strp->work)){+.+.}, at: process_one_work+0x8c1/0x1740 kernel/workqueue.c:2244  #2: ffff888098998d10 (sk_lock-AF_INET){+.+.}, at: lock_sock include/net/sock.h:1522 [inline]  #2: ffff888098998d10 (sk_lock-AF_INET){+.+.}, at: strp_sock_lock+0x2e/0x40 net/strparser/strparser.c:440 CPU: 0 PID: 7 Comm: kworker/u4:0 Not tainted 5.3.0+ #0 Hardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 01/01/2011 Workqueue: kstrp strp_work Call Trace:  __dump_stack lib/dump_stack.c:77 [inline]  dump_stack+0x172/0x1f0 lib/dump_stack.c:113  __cant_sleep kernel/sched/core.c:6826 [inline]  __cant_sleep.cold+0xa4/0xbc kernel/sched/core.c:6803  kcm_parse_func_strparser+0x54/0x200 net/kcm/kcmsock.c:382  __strp_recv+0x5dc/0x1b20 net/strparser/strparser.c:221  strp_recv+0xcf/0x10b net/strparser/strparser.c:343  tcp_read_sock+0x285/0xa00 net/ipv4/tcp.c:1639  strp_read_sock+0x14d/0x200 net/strparser/strparser.c:366  do_strp_work net/strparser/strparser.c:414 [inline]  strp_work+0xe3/0x130 net/strparser/strparser.c:423  process_one_work+0x9af/0x1740 kernel/workqueue.c:2269  ",0355d6c1d591b8f9e281783ec0cf95fbed893194,1
net/hamradio/6pack: use mod_timer() to rearm timers,"Using del_timer() + add_timer() is generally unsafe on SMP, as noticed by syzbot. Use mod_timer() instead.  kernel BUG at kernel/time/timer.c:1136! invalid opcode: 0000 [#1] PREEMPT SMP KASAN CPU: 1 PID: 1026 Comm: kworker/u4:4 Not tainted 4.20.0+ #2 Hardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 01/01/2011 Workqueue: events_unbound flush_to_ldisc ",202700e30740c6568b5a6943662f3829566dd533,1
loop: Fix deadlock when calling blkdev_reread_part(),"Calling blkdev_reread_part() under loop_ctl_mutex causes lockdep to complain about circular lock dependency between bdev->bd_mutex and lo->lo_ctl_mutex. The problem is that on loop device open or close lo_open() and lo_release() get called with bdev->bd_mutex held and they need to acquire loop_ctl_mutex. OTOH when loop_reread_partitions() is called with loop_ctl_mutex held, it will call blkdev_reread_part() which acquires bdev->bd_mutex. See syzbot report for details [1].  Move call to blkdev_reread_part() in __loop_clr_fd() from under loop_ctl_mutex to finish fixing of the lockdep warning and the possible deadlock.  [1] https://syzkaller.appspot.com/bug?id=bf154052f0eea4bc7712499e4569505907d1588  ",0da03cab87e6323ff2e05b14bc7d5c6fcc531efd,1
can: j1939: j1939_can_recv(): add priv refcounting,j1939_can_recv() can be called in parallel with socket release. In this case sk_release and sk_destruct can be done earlier than j1939_can_recv() is processed.  ,ddeeb7d4822ed06d79fc15e822b70dce3fa77e39,0
USB: usbdevfs: sanitize flags more,Requesting a ZERO_PACKET or not is sensible only for output. In the input direction the device decides. Likewise accepting short packets makes sense only for input.  This allows operation with panic_on_warn without opening up a local DOS.  ,7a68d9fb851012829c29e770621905529bd9490b,0
fork: fix incorrect fput of ->exe_file causing use-after-free,"Commit 7c051267931a (""mm, fork: make dup_mmap wait for mmap_sem for write killable"") made it possible to kill a forking task while it is waiting to acquire its ->mmap_sem for write, in dup_mmap().  However, it was overlooked that this introduced an new error path before a reference is taken on the mm_struct's ->exe_file.  Since the ->exe_file of the new mm_struct was already set to the old ->exe_file by the memcpy() in dup_mm(), it was possible for the mmput() in the error path of dup_mm() to drop a reference to ->exe_file which was never taken.  This caused the struct file to later be freed prematurely.  Fix it by updating mm_init() to NULL out the ->exe_file, in the same place it clears other things like the list of mmaps.  This bug was found by syzkaller.  It can be reproduced using the following C program:      ",2b7e8665b4ff51c034c55df3cff76518d1a9ee3a,1
netrom: hold sock when setting skb->destructor,"sock_efree() releases the sock refcnt, if we don't hold this refcnt when setting skb->destructor to it, the refcnt would not be balanced. This leads to several bug reports from syzbot.  I have checked other users of sock_efree(), all of them hold the sock refcnt.  ",4638faac032756f7eab5524be7be56bee77e426b,0
netfilter: x_tables: make allocation less aggressive,"syzbot has noticed that xt_alloc_table_info can allocate a lot of memory. This is an admin only interface but an admin in a namespace is sufficient as well.  eacd86ca3b03 (""net/netfilter/x_tables.c: use kvmalloc() in xt_alloc_table_info()"") has changed the opencoded kmalloc->vmalloc fallback into kvmalloc.  It has dropped __GFP_NORETRY on the way because vmalloc has simply never fully supported __GFP_NORETRY semantic.  This is still the case because e.g.  page tables backing the vmalloc area are hardcoded GFP_KERNEL.  Revert back to __GFP_NORETRY as a poors man defence against excessively large allocation request here.  We will not rule out the OOM killer completely but __GFP_NORETRY should at least stop the large request in most cases.  [akpm@linux-foundation.org: coding-style fixes] ",0537250fdc6c876ed4cbbe874c739aebef493ee2,0
"Revert ""exec: make de_thread() freezable""","Revert commit c22397888f1e ""exec: make de_thread() freezable"" as requested by Ingo Molnar:  ""So there's a new regression in v4.20-rc4, my desktop produces this lockdep splat:  ",a72173ecfc6774cf2d55de9fb29421ce69e3428c,0
xsk: use state member for socket synchronization,"Prior the state variable was introduced by Ilya, the dev member was used to determine whether the socket was bound or not. However, when dev was read, proper SMP barriers and READ_ONCE were missing. In order to address the missing barriers and READ_ONCE, we start using the state variable as a point of synchronization. The state member read/write is paired with proper SMP barriers, and from this follows that the members described above does not need READ_ONCE if used in conjunction with state check.  In all syscalls and the xsk_rcv path we check if state is XSK_BOUND. If that is the case we do a SMP read barrier, and this implies that the dev, umem and all rings are correctly setup. Note that no READ_ONCE are needed for these variable if used when state is XSK_BOUND (plus the read barrier).  To summarize: The members struct xdp_sock members dev, queue_id, umem, fq, cq, tx, rx, and state were read lock-less, with incorrect barriers and missing {READ, WRITE}_ONCE. Now, umem, fq, cq, tx, rx, and state are read lock-less. When these members are updated, WRITE_ONCE is used. When read, READ_ONCE are only used when read outside the control mutex (e.g. mmap) or, not synchronized with the state member (XSK_BOUND plus smp_rmb())  Note that dev and queue_id do not need a WRITE_ONCE or READ_ONCE, due to the introduce state synchronization (XSK_BOUND plus smp_rmb()).  Introducing the state check also fixes a race, found by syzcaller, in xsk_poll() where umem could be accessed when stale.  Suggested-by: Hillf Danton <hdanton@sina.com> ",42fddcc7c64b723a867c7b2f5f7505e244212f13,1
tracepoint: Do not fail unregistering a probe due to memory failure,"The list of tracepoint callbacks is managed by an array that is protected by RCU. To update this array, a new array is allocated, the updates are copied over to the new array, and then the list of functions for the tracepoint is switched over to the new array. After a completion of an RCU grace period, the old array is freed.  This process happens for both adding a callback as well as removing one. But on removing a callback, if the new array fails to be allocated, the callback is not removed, and may be used after it is freed by the clients of the tracepoint.  There's really no reason to fail if the allocation for a new array fails when removing a function. Instead, the function can simply be replaced by a stub function that could be cleaned up on the next modification of the array. That is, instead of calling the function registered to the tracepoint, it would call a stub function in its place.   ",befe6d946551d65cddbd32b9cb0170b0249fd5ed,0
ipv6: fix general protection fault in fib6_add(),"In fib6_add(), pn could be NULL if fib6_add_1() failed to return a fib6 node. Checking pn != fn before accessing pn->leaf makes sure pn is not NULL. This fixes the following GPF reported by syzkaller: general protection fault: 0000 [#1] SMP KASAN Dumping ftrace buffer:    (ftrace buffer empty) ",7bbfe00e025240505db3e04c3b296d7c023b2a26,1
Bluetooth: hci_h5: close serdev device and free hu in h5_close,"When h5_close() gets called, the memory allocated for the hu gets freed only if hu->serdev doesn't exist. This leads to a memory leak. So when h5_close() is requested, close the serdev device instance and free the memory allocated to the hu entirely instead.  ",70f259a3f4276b71db365b1d6ff1eab805ea6ec3,1
kcm: Call strp_stop before strp_done in kcm_attach,In kcm_attach strp_done is called when sk_user_data is already set to fail the attach. strp_done needs the strp to be stopped and warns if it isn't. Call strp_stop in this case to eliminate the warning message.  ,dff8baa261174de689a44572d0ea182d7aa70598,0
bonding: Fix negative jump label count on nested bonding,With nested bonding devices the nested bond device's ndo_bpf was called without a program causing it to decrement the static key without a prior increment leading to negative count.  Fix the issue by 1) only calling slave's ndo_bpf when there's a program to be loaded and 2) only decrement the count when a program is unloaded.  ,6d5f1ef838683efba01bacb7854f6516fbcbae17,0
io_uring: fix UAF due to missing POLLFREE handling,"Fixes a problem described in 50252e4b5e989 (""aio: fix use-after-free due to missing POLLFREE handling"") and copies the approach used there.  In short, we have to forcibly eject a poll entry when we meet POLLFREE. We can't rely on io_poll_get_ownership() as can't wait for potentially running tw handlers, so we use the fact that wqs are RCU freed. See Eric's patch and comments for more details.  ",791f3465c4afde02d7f16cf7424ca87070b69396,1
netlink: fix state reallocation in policy export,"Evidently, when I did this previously, we didn't have more than 10 policies and didn't run into the reallocation path, because it's missing a memset() for the unused policies. Fix that.  ",d1fb55592909ea249af70170c7a52e637009564d,0
inet: annotate date races around sk->sk_txhash,"UDP sendmsg() path can be lockless, it is possible for another thread to re-connect an change sk->sk_txhash under us.  There is no serious impact, but we can use READ_ONCE()/WRITE_ONCE() pair to document the race.  BUG: KCSAN: data-race in __ip4_datagram_connect / skb_set_owner_w  write to 0xffff88813397920c of 4 bytes by task 30997 on cpu 1:  sk_set_txhash include/net/sock.h:1937 [inline]  __ip4_datagram_connect+0x69e/0x710 net/ipv4/datagram.c:75  __ip6_datagram_connect+0x551/0x840 net/ipv6/datagram.c:189  ip6_datagram_connect+0x2a/0x40 net/ipv6/datagram.c:272  inet_dgram_connect+0xfd/0x180 net/ipv4/af_inet.c:580  __sys_connect_file net/socket.c:1837 [inline]  __sys_connect+0x245/0x280 net/socket.c:1854  __do_sys_connect net/socket.c:1864 [inline]  __se_sys_connect net/socket.c:1861 [inline]  __x64_sys_connect+0x3d/0x50 net/socket.c:1861  do_syscall_64+0x4a/0x90 arch/x86/entry/common.c:47  entry_SYSCALL_64_after_hwframe+0x44/0xae  read to 0xffff88813397920c of 4 bytes by task 31039 on cpu 0:  skb_set_hash_from_sk include/net/sock.h:2211 [inline]  skb_set_owner_w+0x118/0x220 net/core/sock.c:2101  sock_alloc_send_pskb+0x452/0x4e0 net/core/sock.c:2359  sock_alloc_send_skb+0x2d/0x40 net/core/sock.c:2373  __ip6_append_data+0x1743/0x21a0 net/ipv6/ip6_output.c:1621  ip6_make_skb+0x258/0x420 net/ipv6/ip6_output.c:1983  udpv6_sendmsg+0x160a/0x16b0 net/ipv6/udp.c:1527  inet6_sendmsg+0x5f/0x80 net/ipv6/af_inet6.c:642  sock_sendmsg_nosec net/socket.c:654 [inline]  sock_sendmsg net/socket.c:674 [inline]  ____sys_sendmsg+0x360/0x4d0 net/socket.c:2350  ___sys_sendmsg net/socket.c:2404 [inline]  __sys_sendmmsg+0x315/0x4b0 net/socket.c:2490  __do_sys_sendmmsg net/socket.c:2519 [inline]  __se_sys_sendmmsg net/socket.c:2516 [inline]  __x64_sys_sendmmsg+0x53/0x60 net/socket.c:2516  do_syscall_64+0x4a/0x90 arch/x86/entry/common.c:47  entry_SYSCALL_64_after_hwframe+0x44/0xae  value changed: 0xbca3c43d -> 0xfdb309e0  Reported by Kernel Concurrency Sanitizer on: CPU: 0 PID: 31039 Comm: syz-executor.2 Not tainted 5.13.0-rc3-syzkaller #0 Hardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 01/01/2011  ",b71eaed8c04f72a919a9c44e83e4ee254e69e7f3,1
netfilter: restore NF_INET_NUMHOOKS,"This definition is used by the iptables legacy UAPI, restore it.  ",d25e2e9388eda61b6e298585024ee3355f50c493,0
crypto: drbg - always try to free Jitter RNG instance,"The Jitter RNG is unconditionally allocated as a seed source follwoing the patch 97f2650e5040. Thus, the instance must always be deallocated.  ",819966c06b759022e9932f328284314d9272b9f3,0
NFS: reject request for id_legacy key without auxdata,"nfs_idmap_legacy_upcall() is supposed to be called with 'aux' pointing to a 'struct idmap', via the call to request_key_with_auxdata() in nfs_idmap_request_key().  However it can also be reached via the request_key() system call in which case 'aux' will be NULL, causing a NULL pointer dereference in nfs_idmap_prepare_pipe_upcall(), assuming that the key description is valid enough to get that far.  Fix this by making nfs_idmap_legacy_upcall() negate the key if no auxdata is provided.  As usual, this bug was found by syzkaller.  A simple reproducer using the command-line keyctl program is:      keyctl request2 id_legacy uid:0 '' @s  ",49686cbbb3ebafe42e63868222f269d8053ead00,1
ALSA: seq: Fix OSS sysex delivery in OSS emulation,"The SYSEX event delivery in OSS sequencer emulation assumed that the event is encoded in the variable-length data with the straight buffering.  This was the normal behavior in the past, but during the development, the chained buffers were introduced for carrying more data, while the OSS code was left intact.  As a result, when a SYSEX event with the chained buffer data is passed to OSS sequencer port, it may end up with the wrong memory access, as if it were having a too large buffer.  This patch addresses the bug, by applying the buffer data expansion by the generic snd_seq_dump_var_event() helper function.  ",132d358b183ac6ad8b3fea32ad5e0663456d18d1,0
netfilter: ebtables: CONFIG_COMPAT: drop a bogus WARN_ON,It means userspace gave us a ruleset where there is some other data after the ebtables target but before the beginning of the next rule.  ,7caa56f006e9d712b44f27b32520c66420d5cbc6,0
media: radio/si470x: kill urb on error,In the probe() function radio->int_in_urb was not killed if an error occurred in the probe sequence. It was also missing in the disconnect.  This caused this syzbot issue:  https://syzkaller.appspot.com/bug?extid=2d4fc2a0c45ad8da7e99  ,0d616f2a3fdbf1304db44d451d9f07008556923b,1
pipe: Remove assertion from pipe_poll(),"An assertion check was added to pipe_poll() to make sure that the ring occupancy isn't seen to overflow the ring size.  However, since no locks are held when the three values are read, it is possible for F_SETPIPE_SZ to intervene and muck up the calculation, thereby causing the oops.  Fix this by simply removing the assertion and accepting that the calculation might be approximate.  Note that the previous code also had a similar issue, though there was no assertion check, since the occupancy counter and the ring size were not read with a lock held, so it's possible that the poll check might have malfunctioned then too.  Also wake up all the waiters so that they can reissue their checks if there was a competing read or write.  ",8c7b8c34ae952cc062c12d7db9ee2f298c09dca4,1
tipc: fix use-after-free in tipc_nametbl_stop,"When we delete a service item in tipc_nametbl_stop() we loop over all service ranges in the service's RB tree, and for each service range we loop over its pertaining publications while calling tipc_service_remove_publ() for each of them.  However, tipc_service_remove_publ() has the side effect that it also removes the comprising service range item when there are no publications left. This leads to a ""use-after-free"" access when the inner loop continues to the next iteration, since the range item holding the list we are looping no longer exists.  We fix this by moving the delete of the service range item outside the said function. Instead, we now let the two functions calling it test if the list is empty and perform the removal when that is the case.  ",be47e41d77fba5bc17e9fb5f1c99217bb6691989,1
xsk: Fix use-after-free in failed shared_umem bind,"Fix use-after-free when a shared umem bind fails. The code incorrectly tried to free the allocated buffer pool both in the bind code and then later also when the socket was released. Fix this by setting the buffer pool pointer to NULL after the bind code has freed the pool, so that the socket release code will not try to free the pool. This is the same solution as the regular, non-shared umem code path has. This was missing from the shared umem path.  ",83cf5c68d663fc78ce529c41bf24f9f6be88bef4,1
mac80211: limit injected vht mcs/nss in ieee80211_parse_tx_radiotap,Limit max values for vht mcs and nss in ieee80211_parse_tx_radiotap routine in order to fix the following warning reported by syzbot:  ,13cb6d826e0ac0d144b0d48191ff1a111d32f0c6,0
ext4: fix timer use-after-free on failed mount,When filesystem mount fails because of corrupted filesystem we first cancel the s_err_report timer reminding fs errors every day and only then we flush s_error_work. However s_error_work may report another fs error and re-arm timer thus resulting in timer use-after-free. Fix the problem by first flushing the work and only after that canceling the s_err_report timer.  ,2a4ae3bcdf05b8639406eaa09a2939f3c6dd8e75,1
HID: betop: fix slab-out-of-bounds Write in betop_probe,Syzbot reported slab-out-of-bounds Write bug in hid-betopff driver. The problem is the driver assumes the device must have an input report but some malicious devices violate this assumption.  So this patch checks hid_device's input is non empty before it's been used.  ,689e453a9b9c9158522b508876a1ff02ab0c3aa8,1
crypto: skcipher - set walk.iv for zero-length inputs,"All the ChaCha20 algorithms as well as the ARM bit-sliced AES-XTS algorithms call skcipher_walk_virt(), then access the IV (walk.iv) before checking whether any bytes need to be processed (walk.nbytes).  But if the input is empty, then skcipher_walk_virt() doesn't set the IV, and the algorithms crash trying to use the uninitialized IV pointer.  Fix it by setting the IV earlier in skcipher_walk_virt().  Also fix it for the AEAD walk functions.  This isn't a perfect solution because we can't actually align the IV to ->cra_alignmask unless there are bytes to process, for one because the temporary buffer for the aligned IV is freed by skcipher_walk_done(), which is only called when there are bytes to process.  Thus, algorithms that require aligned IVs will still need to avoid accessing the IV when walk.nbytes == 0.  Still, many algorithms/architectures are fine with IVs having any alignment, and even for those that aren't, a misaligned pointer bug is much less severe than an uninitialized pointer bug.  This change also matches the behavior of the older blkcipher_walk API.  ",2b4f27c36bcd46e820ddb9a8e6fe6a63fa4250b8,1
ipv6: fix possible deadlock in rt6_age_examine_exception(),"syzbot reported a LOCKDEP splat [1] in rt6_age_examine_exception()  rt6_age_examine_exception() is called while rt6_exception_lock is held. This lock is the lower one in the lock hierarchy, thus we can not call dst_neigh_lookup() function, as it can fallback to neigh_create()  We should instead do a pure RCU lookup. As a bonus we avoid a pair of atomic operations on neigh refcount.  [1]  ",1bfa26ff8c4b7512f4e4efa6df211239223033d4,0
userfaultfd: disable irqs when taking the waitqueue lock,"userfaultfd contains howe-grown locking of the waitqueue lock, and does not disable interrupts.  This relies on the fact that no one else takes it from interrupt context and violates an invariat of the normal waitqueue locking scheme.  With aio poll it is easy to trigger other locks that disable interrupts (or are called from interrupt context).  ",ae62c16e105a869524afcf8a07ee85c5ae5d0479,0
mptcp: full disconnect implementation,"The current mptcp_disconnect() implementation lacks several steps, we additionally need to reset the msk socket state and flush the subflow list.  Factor out the needed helper to avoid code duplication.  Additionally ensure that the initial subflow is disposed only after mptcp_close(), just reset it at disconnect time.  ",b29fcfb54cd70caca5b11c80d8d238854938884a,0
ax88172a: fix ax88172a_unbind() failures,"If ax88172a_unbind() fails, make sure that the return code is less than zero so that cleanup is done properly and avoid UAF.  ",c28d9a285668c799eeae2f7f93e929a6028a4d6d,0
vsock: avoid to assign transport if its initialization fails,"If transport->init() fails, we can't assign the transport to the socket, because it's not initialized correctly, and any future calls to the transport callbacks would have an unexpected behavior.  ",039fcccaed338b2ff6587178c1219c1ef383a1d9,0
vt: Reject zero-sized screen buffer size.,"syzbot is reporting general protection fault in do_con_write() [1] caused by vc->vc_screenbuf == ZERO_SIZE_PTR caused by vc->vc_screenbuf_size == 0 caused by vc->vc_cols == vc->vc_rows == vc->vc_size_row == 0 caused by fb_set_var() from ioctl(FBIOPUT_VSCREENINFO) on /dev/fb0 , for gotoxy(vc, 0, 0) from reset_terminal() from vc_init() from vc_allocate()  from con_install() from tty_init_dev() from tty_open() on such console causes vc->vc_pos == 0x10000000e due to ((unsigned long) ZERO_SIZE_PTR) + -1U * 0 + (-1U << 1).  I don't think that a console with 0 column or 0 row makes sense. And it seems that vc_do_resize() does not intend to allow resizing a console to 0 column or 0 row due to    new_cols = (cols ? cols : vc->vc_cols);   new_rows = (lines ? lines : vc->vc_rows);  exception.  Theoretically, cols and rows can be any range as long as 0 < cols * rows * 2 <= KMALLOC_MAX_SIZE is satisfied (e.g. cols == 1048576 && rows == 2 is possible) because of    vc->vc_size_row = vc->vc_cols << 1;   vc->vc_screenbuf_size = vc->vc_rows * vc->vc_size_row;  in visual_init() and kzalloc(vc->vc_screenbuf_size) in vc_allocate().  Since we can detect cols == 0 or rows == 0 via screenbuf_size = 0 in visual_init(), we can reject kzalloc(0). Then, vc_allocate() will return an error, and con_write() will not be called on a console with 0 column or 0 row.  We need to make sure that integer overflow in visual_init() won't happen. Since vc_do_resize() restricts cols <= 32767 and rows <= 32767, applying 1 <= cols <= 32767 and 1 <= rows <= 32767 restrictions to vc_allocate() will be practically fine.  This patch does not touch con_init(), for returning -EINVAL there does not help when we are not returning -ENOMEM.  [1] https://syzkaller.appspot.com/bug?extid=017265e8553724e514e8  ",ce684552a266cb1c7cc2f7e623f38567adec6653,1
media: v4l2-ctrls.c/uvc: zero v4l2_event,"Control events can leak kernel memory since they do not fully zero the event. The same code is present in both v4l2-ctrls.c and uvc_ctrl.c, so fix both.  It appears that all other event code is properly zeroing the structure, it's these two places.  ",f45f3f753b0a3d739acda8e311b4f744d82dc52a,0
libata: remove WARN() for DMA or PIO command without data,"syzkaller hit a WARN() in ata_qc_issue() when writing to /dev/sg0.  This happened because it issued a READ_6 command with no data buffer.  Just remove the WARN(), as it doesn't appear indicate a kernel bug.  The expected behavior is to fail the command, which the code does.  Here's a reproducer that works in QEMU when /dev/sg0 refers to a disk of the default type (""82371SB PIIX3 IDE""):      #include <fcntl.h>     #include <unistd.h>      int main()     {             char buf[42] = { [36] = 0x8 ",9173e5e80729c8434b8d27531527c5245f4a5594,1
net: tipc: prepare attrs in __tipc_nl_compat_dumpit(),__tipc_nl_compat_dumpit() calls tipc_nl_publ_dump() which expects the attrs to be available by genl_dumpit_info(cb)->attrs. Add info struct and attr parsing in compat dumpit function.  ,6ea67769ff33018195e3ec2a610b8ecc03efe504,0
ipvs: move old_secure_tcp into struct netns_ipvs,"syzbot reported the following issue :  BUG: KCSAN: data-race in update_defense_level / update_defense_level  read to 0xffffffff861a6260 of 4 bytes by task 3006 on cpu 1:  update_defense_level+0x621/0xb30 net/netfilter/ipvs/ip_vs_ctl.c:177  defense_work_handler+0x3d/0xd0 net/netfilter/ipvs/ip_vs_ctl.c:225  process_one_work+0x3d4/0x890 kernel/workqueue.c:2269  worker_thread+0xa0/0x800 kernel/workqueue.c:2415  kthread+0x1d4/0x200 drivers/block/aoe/aoecmd.c:1253  ret_from_fork+0x1f/0x30 arch/x86/entry/entry_64.S:352  write to 0xffffffff861a6260 of 4 bytes by task 7333 on cpu 0:  update_defense_level+0xa62/0xb30 net/netfilter/ipvs/ip_vs_ctl.c:205  defense_work_handler+0x3d/0xd0 net/netfilter/ipvs/ip_vs_ctl.c:225  process_one_work+0x3d4/0x890 kernel/workqueue.c:2269  worker_thread+0xa0/0x800 kernel/workqueue.c:2415  kthread+0x1d4/0x200 drivers/block/aoe/aoecmd.c:1253  ret_from_fork+0x1f/0x30 arch/x86/entry/entry_64.S:352  Reported by Kernel Concurrency Sanitizer on: CPU: 0 PID: 7333 Comm: kworker/0:5 Not tainted 5.4.0-rc3+ #0 Hardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 01/01/2011 Workqueue: events defense_work_handler  Indeed, old_secure_tcp is currently a static variable, while it needs to be a per netns variable.  ",c24b75e0f9239e78105f81c5f03a751641eb07ef,1
mac80211_hwsim: validate number of different channels,"When creating a new radio on the fly, hwsim allows this to be done with an arbitrary number of channels, but cfg80211 only supports a limited number of simultaneous channels, leading to a warning.  Fix this by validating the number - this requires moving the define for the maximum out to a visible header file.  ",51a1aaa631c90223888d8beac4d649dc11d2ca55,0
io_uring: fix work_exit sqpoll cancellations,"After closing an SQPOLL ring, io_ring_exit_work() kicks in and starts doing cancellations via io_uring_try_cancel_requests(). It will go through io_uring_try_cancel_iowq(), which uses ctx->tctx_list, but as SQPOLL task don't have a ctx note, its io-wq won't be reachable and so is left not cancelled.  It will eventually cancelled when one of the tasks dies, but if a thread group survives for long and changes rings, it will spawn lots of unreclaimed resources and live locked works.  Cancel SQPOLL task's io-wq separately in io_ring_exit_work().  ",28090c133869b461c5366195a856d73469ab87d9,0
crypto: x86/chacha - avoid sleeping under kernel_fpu_begin(),"Passing atomic=true to skcipher_walk_virt() only makes the later skcipher_walk_done() calls use atomic memory allocations, not skcipher_walk_virt() itself.  Thus, we have to move it outside of the preemption-disabled region (kernel_fpu_begin()/kernel_fpu_end()).  (skcipher_walk_virt() only allocates memory for certain layouts of the input scatterlist, hence why I didn't notice this earlier...)  ",f9c9bdb5131eee60dc3b92e5126d4c0e291703e2,0
vcs: prevent write access to vcsu devices,"Commit d21b0be246bf (""vt: introduce unicode mode for /dev/vcs"") guarded against using devices containing attributes as this is not yet implemented. It however failed to guard against writes to any devices as this is also unimplemented.  ",0c9acb1af77a3cb8707e43f45b72c95266903cee,0
hsr: switch ->dellink() to ->ndo_uninit(),"Switching from ->priv_destructor to dellink() has an unexpected consequence: existing RCU readers, that is, hsr_port_get_hsr() callers, may still be able to read the port list.  Instead of checking the return value of each hsr_port_get_hsr(), we can just move it to ->ndo_uninit() which is called after device unregister and synchronize_net(), and we still have RTNL lock there.  ",311633b604063a8a5d3fbc74d0565b42df721f68,0
sit: do not call ipip6_dev_free() from sit_init_net(),"ipip6_dev_free is sit dev->priv_destructor, already called by register_netdevice() if something goes wrong.  Alternative would be to make ipip6_dev_free() robust against multiple invocations, but other drivers do not implement this strategy.  ",e28587cc491ef0f3c51258fdc87fbc386b1d4c59,0
fuse: fix initial parallel dirops,"If parallel dirops are enabled in FUSE_INIT reply, then first operation may leave fi->mutex held.  ",63576c13bd17848376c8ba4a98f5d5151140c4ac,0
media: drivers/media/usb: fix memory leak in zr364xx_probe,syzbot reported memory leak in zr364xx_probe()[1]. The problem was in invalid error handling order. All error conditions rigth after v4l2_ctrl_handler_init() must call v4l2_ctrl_handler_free().  ,9c39be40c0155c43343f53e3a439290c0fec5542,1
KVM: validate userspace input in kvm_clear_dirty_log_protect(),"The function at issue does not fully validate the content of the structure pointed by the log parameter, though its content has just been copied from userspace and lacks validation. Fix that.  Moreover, change the type of n to unsigned long as that is the type returned by kvm_dirty_bitmap_bytes().  ",98938aa8edd66dc95024d7c936a4bc315f6615ff,0
slip: make slhc_free() silently accept an error pointer,"This way, slhc_free() accepts what slhc_init() returns, whether that is an error or not.  In particular, the pattern in sl_alloc_bufs() is          slcomp = slhc_init(16, 16);         ...         slhc_free(slcomp);  for the error handling path, and rather than complicate that code, just make it ok to always free what was returned by the init function.  That's what the code used to do before commit 4ab42d78e37a (""ppp, slip: Validate VJ compression slot parameters completely"") when slhc_init() just returned NULL for the error case, with no actual indication of the details of the error.  ",baf76f0c58aec435a3a864075b8f6d8ee5d1f17e,1
fuse: always initialize sb->s_fs_info,"Syzkaller reports a null pointer dereference in fuse_test_super() that is caused by sb->s_fs_info being NULL.  This is due to the fact that fuse_fill_super() is initializing s_fs_info, which is too late, it's already on the fs_supers list.  The initialization needs to be done in sget_fc() with the sb_lock held.  Move allocation of fuse_mount and fuse_conn from fuse_fill_super() into fuse_get_tree().  After this ->kill_sb() will always be called with non-NULL ->s_fs_info, hence fuse_mount_destroy() can drop the test for non-NULL ""fm"".  ",80019f1138324b6f35ae728b4f25eeb08899b452,1
nfc: fix memory leak in llcp_sock_bind(),"sysbot reported a memory leak after a bind() has failed.  While we are at it, abort the operation if kmemdup() has failed.  BUG: memory leak unreferenced object 0xffff888105d83ec0 (size 32):   comm ""syz-executor067"", pid 7207, jiffies 4294956228 (age 19.430s)   ",a0c2dc1fe63e2869b74c1c7f6a81d1745c8a695d,1
gro_cells: make sure device is up in gro_cells_receive(),"We keep receiving syzbot reports [1] that show that tunnels do not play the rcu/IFF_UP rules properly.  At device dismantle phase, gro_cells_destroy() will be called only after a full rcu grace period is observed after IFF_UP has been cleared.  This means that IFF_UP needs to be tested before queueing packets into netif_rx() or gro_cells.  This patch implements the test in gro_cells_receive() because too many callers do not seem to bother enough.  [1] BUG: unable to handle kernel paging request at fffff4ca0b9ffffe PGD 0 P4D 0 Oops: 0000 [#1] PREEMPT SMP KASAN CPU: 0 PID: 21 Comm: kworker/u4:1 Not tainted 5.0.0+ #97 Hardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 01/01/2011 Workqueue: netns cleanup_net ",2a5ff07a0eb945f291e361aa6f6becca8340ba46,1
erspan: fix version 1 check in gre_parse_header(),"Both version 0 and version 1 use ETH_P_ERSPAN, but version 0 does not have an erspan header. So the check in gre_parse_header() is wrong, we have to distinguish version 1 from version 0.  We can just check the gre header length like is_erspan_type1().  ",085c7c4e1c0e50d90b7d90f61a12e12b317a91e2,0
ALSA: usb-audio: Fix OOB access of mixer element list,"The USB-audio mixer code holds a linked list of usb_mixer_elem_list, and several operations are performed for each mixer element.  A few of them (snd_usb_mixer_notify_id() and snd_usb_mixer_interrupt_v2()) assume each mixer element being a usb_mixer_elem_info object that is a subclass of usb_mixer_elem_list, cast via container_of() and access it members.  This may result in an out-of-bound access when a non-standard list element has been added, as spotted by syzkaller recently.  This patch adds a new field, is_std_info, in usb_mixer_elem_list to indicate that the element is the usb_mixer_elem_info type or not, and skip the access to such an element if needed.  ",220345e98f1cdc768eeb6e3364a0fa7ab9647fe7,1
net: team: fix memory leak in __team_options_register,"The variable ""i"" isn't initialized back correctly after the first loop under the label inst_rollback gets executed.  The value of ""i"" is assigned to be option_count - 1, and the ensuing loop (under alloc_rollback) begins by initializing i--. Thus, the value of i when the loop begins execution will now become i = option_count - 2.  Thus, when kfree(dst_opts[i]) is called in the second loop in this order, (i.e., inst_rollback followed by alloc_rollback), dst_optsp[option_count - 2] is the first element freed, and dst_opts[option_count - 1] does not get freed, and thus, a memory leak is caused.  This memory leak can be fixed, by assigning i = option_count (instead of option_count - 1).  ",9a9e77495958c7382b2438bc19746dd3aaaabb8e,1
alloc_super(): do ->s_umount initialization earlier,... so that failure exits could count on it having been done.  ,ca0168e8a77cf833f8c9ac1d26a3a4012bab4f72,0
net/rose: fix unbound loop in rose_loopback_timer(),"This patch adds a limit on the number of skbs that fuzzers can queue into loopback_queue. 1000 packets for rose loopback seems more than enough.  Then, since we now have multiple cpus in most linux hosts, we also need to limit the number of skbs rose_loopback_timer() can dequeue at each round.  rose_loopback_queue() can be drop-monitor friendly, calling consume_skb() or kfree_skb() appropriately.  Finally, use mod_timer() instead of del_timer() + add_timer()  syzbot report was :  rcu: INFO: rcu_preempt self-detected stall on CPU rcu:    0-...!: (10499 ticks this GP) idle=536/1/0x4000000000000002 softirq=103291/103291 fqs=34 rcu:     (t=10500 jiffies g=140321 q=323) rcu: rcu_preempt kthread starved for 10426 jiffies! g140321 f0x0 RCU_GP_WAIT_FQS(5) ->state=0x402 ->cpu=1 rcu: RCU grace-period kthread stack dump: rcu_preempt     I29168    10      2 0x80000000 Call Trace:  context_switch kernel/sched/core.c:2877 [inline]  __schedule+0x813/0x1cc0 kernel/sched/core.c:3518  schedule+0x92/0x180 kernel/sched/core.c:3562  schedule_timeout+0x4db/0xfd0 kernel/time/timer.c:1803  rcu_gp_fqs_loop kernel/rcu/tree.c:1971 [inline]  rcu_gp_kthread+0x962/0x17b0 kernel/rcu/tree.c:2128  kthread+0x357/0x430 kernel/kthread.c:253  ret_from_fork+0x3a/0x50 arch/x86/entry/entry_64.S:352 NMI backtrace for cpu 0 CPU: 0 PID: 7632 Comm: kworker/0:4 Not tainted 5.1.0-rc5+ #172 Hardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 01/01/2011 Workqueue: events iterate_cleanup_work Call Trace:  <IRQ>  __dump_stack lib/dump_stack.c:77 [inline]  dump_stack+0x172/0x1f0 lib/dump_stack.c:113  nmi_cpu_backtrace.cold+0x63/0xa4 lib/nmi_backtrace.c:101  nmi_trigger_cpumask_backtrace+0x1be/0x236 lib/nmi_backtrace.c:62  arch_trigger_cpumask_backtrace+0x14/0x20 arch/x86/kernel/apic/hw_nmi.c:38  trigger_single_cpu_backtrace include/linux/nmi.h:164 [inline]  rcu_dump_cpu_stacks+0x183/0x1cf kernel/rcu/tree.c:1223  print_cpu_stall kernel/rcu/tree.c:1360 [inline]  check_cpu_stall kernel/rcu/tree.c:1434 [inline]  rcu_pending kernel/rcu/tree.c:3103 [inline]  rcu_sched_clock_irq.cold+0x500/0xa4a kernel/rcu/tree.c:2544  update_process_times+0x32/0x80 kernel/time/timer.c:1635  tick_sched_handle+0xa2/0x190 kernel/time/tick-sched.c:161  tick_sched_timer+0x47/0x130 kernel/time/tick-sched.c:1271  __run_hrtimer kernel/time/hrtimer.c:1389 [inline]  __hrtimer_run_queues+0x33e/0xde0 kernel/time/hrtimer.c:1451  hrtimer_interrupt+0x314/0x770 kernel/time/hrtimer.c:1509  local_apic_timer_interrupt arch/x86/kernel/apic/apic.c:1035 [inline]  smp_apic_timer_interrupt+0x120/0x570 arch/x86/kernel/apic/apic.c:1060  apic_timer_interrupt+0xf/0x20 arch/x86/entry/entry_64.S:807 ",0453c682459583910d611a96de928f4442205493,0
net: sched: sch_htb: don't call qdisc_put() while holding tree lock,"Recent changes that removed rtnl dependency from rules update path of tc also made tcf_block_put() function sleeping. This function is called from ops->destroy() of several Qdisc implementations, which in turn is called by qdisc_put(). Some Qdiscs call qdisc_put() while holding sch tree spinlock, which results sleeping-while-atomic BUG.  Steps to reproduce for htb:  tc qdisc add dev ens1f0 root handle 1: htb default 12 tc class add dev ens1f0 parent 1: classid 1:1 htb rate 100kbps ceil 100kbps tc qdisc add dev ens1f0 parent 1:1 handle 40: sfq perturb 10 tc class add dev ens1f0 parent 1:1 classid 1:2 htb rate 100kbps ceil 100kbps  Resulting dmesg:  ",4ce70b4aed5752332b268909336b351721965dc4,1
staging: android: ashmem: Don't call fallocate() with ashmem_mutex held.,syzbot is hitting lockdep warnings [1][2][3]. This patch tries to fix the warning by eliminating ashmem_shrink_scan() => {shmem|vfs}_fallocate() sequence.  [1] https://syzkaller.appspot.com/bug?id=87c399f6fa6955006080b24142e2ce7680295ad4 [2] https://syzkaller.appspot.com/bug?id=7ebea492de7521048355fc84210220e1038a7908 [3] https://syzkaller.appspot.com/bug?id=e02419c12131c24e2a957ea050c2ab6dcbbc3270  ,fb4415a12632f0b9078a0aa80c16745d48fcfc74,1
net: usb: asix: do not call phy_disconnect() for ax88178,"Fix crash on reboot on a system with ASIX AX88178 USB adapter attached to it: | asix 1-1.4:1.0 eth0: unregister 'asix' usb-ci_hdrc.0-1.4, ASIX AX88178 USB 2.0 Ethernet | 8<",1406e8cb4b05fdc67692b1af2da39d7ca5278713,1
net_sched: fix a crash in tc_new_tfilter(),"When tcf_block_find() fails, it already rollbacks the qdisc refcnt, so its caller doesn't need to clean up this again. Avoid calling qdisc_put() again by resetting qdisc to NULL for callers.  ",460b360104d51552a57f39e54b2589c9fd7fa0b3,1
vlan: Fix reading memory beyond skb->tail in skb_vlan_tagged_multi,"Syzkaller spotted an old bug which leads to reading skb beyond tail by 4 bytes on vlan tagged packets. This is caused because skb_vlan_tagged_multi() did not check skb_headlen.  BUG: KMSAN: uninit-value in eth_type_vlan include/linux/if_vlan.h:283 [inline] BUG: KMSAN: uninit-value in skb_vlan_tagged_multi include/linux/if_vlan.h:656 [inline] BUG: KMSAN: uninit-value in vlan_features_check include/linux/if_vlan.h:672 [inline] BUG: KMSAN: uninit-value in dflt_features_check net/core/dev.c:2949 [inline] BUG: KMSAN: uninit-value in netif_skb_features+0xd1b/0xdc0 net/core/dev.c:3009 CPU: 1 PID: 3582 Comm: syzkaller435149 Not tainted 4.16.0+ #82 Hardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 01/01/2011 Call Trace:   __dump_stack lib/dump_stack.c:17 [inline]   dump_stack+0x185/0x1d0 lib/dump_stack.c:53   kmsan_report+0x142/0x240 mm/kmsan/kmsan.c:1067   __msan_warning_32+0x6c/0xb0 mm/kmsan/kmsan_instr.c:676   eth_type_vlan include/linux/if_vlan.h:283 [inline]   skb_vlan_tagged_multi include/linux/if_vlan.h:656 [inline]   vlan_features_check include/linux/if_vlan.h:672 [inline]   dflt_features_check net/core/dev.c:2949 [inline]   netif_skb_features+0xd1b/0xdc0 net/core/dev.c:3009   validate_xmit_skb+0x89/0x1320 net/core/dev.c:3084   __dev_queue_xmit+0x1cb2/0x2b60 net/core/dev.c:3549   dev_queue_xmit+0x4b/0x60 net/core/dev.c:3590   packet_snd net/packet/af_packet.c:2944 [inline]   packet_sendmsg+0x7c57/0x8a10 net/packet/af_packet.c:2969   sock_sendmsg_nosec net/socket.c:630 [inline]   sock_sendmsg net/socket.c:640 [inline]   sock_write_iter+0x3b9/0x470 net/socket.c:909   do_iter_readv_writev+0x7bb/0x970 include/linux/fs.h:1776   do_iter_write+0x30d/0xd40 fs/read_write.c:932   vfs_writev fs/read_write.c:977 [inline]   do_writev+0x3c9/0x830 fs/read_write.c:1012   SYSC_writev+0x9b/0xb0 fs/read_write.c:1085   SyS_writev+0x56/0x80 fs/read_write.c:1082   do_syscall_64+0x309/0x430 arch/x86/entry/common.c:287   entry_SYSCALL_64_after_hwframe+0x3d/0xa2 ",7ce2367254e84753bceb07327aaf5c953cfce117,1
f2fs: sanity check for total valid node blocks,"This patch enhances sanity check for SIT entries.  syzbot hit the following crash on upstream commit 83beed7b2b26f232d782127792dd0cd4362fdc41 (Fri Apr 20 17:56:32 2018 +0000) Merge branch 'fixes' of git://git.kernel.org/pub/scm/linux/kernel/git/evalenti/linux-soc-thermal syzbot dashboard link: https://syzkaller.appspot.com/bug?extid=bf9253040425feb155ad  syzkaller reproducer: https://syzkaller.appspot.com/x/repro.syz?id=5692130282438656 Raw console output: https://syzkaller.appspot.com/x/log.txt?id=5095924598571008 Kernel config: https://syzkaller.appspot.com/x/.config?id=1808800213120130118 compiler: gcc (GCC) 8.0.1 20180413 (experimental)  IMPORTANT: if you fix the bug, please add the following tag to the commit: ",8a29c1260e24e7c9c6ab138aa0017558d8b28208,1
can: peak_usb: pcan_usb_pro: Fix info-leaks to USB devices,Uninitialized Kernel memory can leak to USB devices.  Fix by using kzalloc() instead of kmalloc() on the affected buffers.  ,ead16e53c2f0ed946d82d4037c630e2f60f4ab69,0
io-uring: drop completion when removing file,"A case of task hung was reported by syzbot,  INFO: task syz-executor975:9880 blocked for more than 143 seconds.       Not tainted 5.6.0-rc6-syzkaller #0 ""echo 0 > /proc/sys/kernel/hung_task_timeout_secs"" disables this message. syz-executor975 D27576  9880   9878 0x80004000 Call Trace:  schedule+0xd0/0x2a0 kernel/sched/core.c:4154  schedule_timeout+0x6db/0xba0 kernel/time/timer.c:1871  do_wait_for_common kernel/sched/completion.c:83 [inline]  __wait_for_common kernel/sched/completion.c:104 [inline]  wait_for_common kernel/sched/completion.c:115 [inline]  wait_for_completion+0x26a/0x3c0 kernel/sched/completion.c:136  io_queue_file_removal+0x1af/0x1e0 fs/io_uring.c:5826  __io_sqe_files_update.isra.0+0x3a1/0xb00 fs/io_uring.c:5867  io_sqe_files_update fs/io_uring.c:5918 [inline]  __io_uring_register+0x377/0x2c00 fs/io_uring.c:7131  __do_sys_io_uring_register fs/io_uring.c:7202 [inline]  __se_sys_io_uring_register fs/io_uring.c:7184 [inline]  __x64_sys_io_uring_register+0x192/0x560 fs/io_uring.c:7184  do_syscall_64+0xf6/0x7d0 arch/x86/entry/common.c:294  entry_SYSCALL_64_after_hwframe+0x49/0xbe  and bisect pointed to 05f3fb3c5397 (""io_uring: avoid ring quiesce for fixed file set unregister and update"").  It is down to the order that we wait for work done before flushing it while nobody is likely going to wake us up.  We can drop that completion on stack as flushing work itself is a sync operation we need and no more is left behind it.  To that end, io_file_put::done is re-used for indicating if it can be freed in the workqueue worker context.  Reported-and-Inspired-by: syzbot <syzbot+538d1957ce178382a394@syzkaller.appspotmail.com> ",4afdb733b1606c6cb86e7833f9335f4870cf7ddd,1
bpf: Fix NULL pointer dereference in __btf_resolve_helper_id(),Prevent __btf_resolve_helper_id() from dereferencing `btf_vmlinux` as NULL. This patch fixes the following syzbot bug:      https://syzkaller.appspot.com/bug?id=f823224ada908fa5c207902a5a62065e53ca0fcc  ,5b801dfb7feb2738975d80223efc2fc193e55573,1
ALSA: usb-audio: fix use after free in usb_audio_disconnect,"The problem was in wrong ""if"" placement. chip->quirk_type is freed in snd_card_free_when_closed(), but inside if statement it's accesed.  ",c5aa956eaeb05fe87e33433d7fd9f5e4d23c7416,1
tcp: do not leave dangling pointers in tp->highest_sack,"Latest commit 853697504de0 (""tcp: Fix highest_sack and highest_sack_seq"") apparently allowed syzbot to trigger various crashes in TCP stack [1]  I believe this commit only made things easier for syzbot to find its way into triggering use-after-frees. But really the bugs could lead to bad TCP behavior or even plain crashes even for non malicious peers.  I have audited all calls to tcp_rtx_queue_unlink() and tcp_rtx_queue_unlink_and_free() and made sure tp->highest_sack would be updated if we are removing from rtx queue the skb that tp->highest_sack points to.  These updates were missing in three locations :  1) tcp_clean_rtx_queue() [This one seems quite serious,                           I have no idea why this was not caught earlier]  2) tcp_rtx_queue_purge() [Probably not a big deal for normal operations]  3) tcp_send_synack()     [Probably not a big deal for normal operations]  [1] BUG: KASAN: use-after-free in tcp_highest_sack_seq include/net/tcp.h:1864 [inline] BUG: KASAN: use-after-free in tcp_highest_sack_seq include/net/tcp.h:1856 [inline] BUG: KASAN: use-after-free in tcp_check_sack_reordering+0x33c/0x3a0 net/ipv4/tcp_input.c:891 Read of size 4 at addr ffff8880a488d068 by task ksoftirqd/1/16  CPU: 1 PID: 16 Comm: ksoftirqd/1 Not tainted 5.5.0-rc5-syzkaller #0 Hardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 01/01/2011 Call Trace:  __dump_stack lib/dump_stack.c:77 [inline]  dump_stack+0x197/0x210 lib/dump_stack.c:118  print_address_description.constprop.0.cold+0xd4/0x30b mm/kasan/report.c:374  __kasan_report.cold+0x1b/0x41 mm/kasan/report.c:506  kasan_report+0x12/0x20 mm/kasan/common.c:639  __asan_report_load4_noabort+0x14/0x20 mm/kasan/generic_report.c:134  tcp_highest_sack_seq include/net/tcp.h:1864 [inline]  tcp_highest_sack_seq include/net/tcp.h:1856 [inline]  tcp_check_sack_reordering+0x33c/0x3a0 net/ipv4/tcp_input.c:891  tcp_try_undo_partial net/ipv4/tcp_input.c:2730 [inline]  tcp_fastretrans_alert+0xf74/0x23f0 net/ipv4/tcp_input.c:2847  tcp_ack+0x2577/0x5bf0 net/ipv4/tcp_input.c:3710  tcp_rcv_established+0x6dd/0x1e90 net/ipv4/tcp_input.c:5706  tcp_v4_do_rcv+0x619/0x8d0 net/ipv4/tcp_ipv4.c:1619  tcp_v4_rcv+0x307f/0x3b40 net/ipv4/tcp_ipv4.c:2001  ip_protocol_deliver_rcu+0x5a/0x880 net/ipv4/ip_input.c:204  ip_local_deliver_finish+0x23b/0x380 net/ipv4/ip_input.c:231  NF_HOOK include/linux/netfilter.h:307 [inline]  NF_HOOK include/linux/netfilter.h:301 [inline]  ip_local_deliver+0x1e9/0x520 net/ipv4/ip_input.c:252  dst_input include/net/dst.h:442 [inline]  ip_rcv_finish+0x1db/0x2f0 net/ipv4/ip_input.c:428  NF_HOOK include/linux/netfilter.h:307 [inline]  NF_HOOK include/linux/netfilter.h:301 [inline]  ip_rcv+0xe8/0x3f0 net/ipv4/ip_input.c:538  __netif_receive_skb_one_core+0x113/0x1a0 net/core/dev.c:5148  __netif_receive_skb+0x2c/0x1d0 net/core/dev.c:5262  process_backlog+0x206/0x750 net/core/dev.c:6093  napi_poll net/core/dev.c:6530 [inline]  net_rx_action+0x508/0x1120 net/core/dev.c:6598  __do_softirq+0x262/0x98c kernel/softirq.c:292  run_ksoftirqd kernel/softirq.c:603 [inline]  run_ksoftirqd+0x8e/0x110 kernel/softirq.c:595  smpboot_thread_fn+0x6a3/0xa40 kernel/smpboot.c:165  kthread+0x361/0x430 kernel/kthread.c:255  ret_from_fork+0x24/0x30 arch/x86/entry/entry_64.S:352  Allocated by task 10091:  save_stack+0x23/0x90 mm/kasan/common.c:72  set_track mm/kasan/common.c:80 [inline]  __kasan_kmalloc mm/kasan/common.c:513 [inline]  __kasan_kmalloc.constprop.0+0xcf/0xe0 mm/kasan/common.c:486  kasan_slab_alloc+0xf/0x20 mm/kasan/common.c:521  slab_post_alloc_hook mm/slab.h:584 [inline]  slab_alloc_node mm/slab.c:3263 [inline]  kmem_cache_alloc_node+0x138/0x740 mm/slab.c:3575  __alloc_skb+0xd5/0x5e0 net/core/skbuff.c:198  alloc_skb_fclone include/linux/skbuff.h:1099 [inline]  sk_stream_alloc_skb net/ipv4/tcp.c:875 [inline]  sk_stream_alloc_skb+0x113/0xc90 net/ipv4/tcp.c:852  tcp_sendmsg_locked+0xcf9/0x3470 net/ipv4/tcp.c:1282  tcp_sendmsg+0x30/0x50 net/ipv4/tcp.c:1432  inet_sendmsg+0x9e/0xe0 net/ipv4/af_inet.c:807  sock_sendmsg_nosec net/socket.c:652 [inline]  sock_sendmsg+0xd7/0x130 net/socket.c:672  __sys_sendto+0x262/0x380 net/socket.c:1998  __do_sys_sendto net/socket.c:2010 [inline]  __se_sys_sendto net/socket.c:2006 [inline]  __x64_sys_sendto+0xe1/0x1a0 net/socket.c:2006  do_syscall_64+0xfa/0x790 arch/x86/entry/common.c:294  entry_SYSCALL_64_after_hwframe+0x49/0xbe  Freed by task 10095:  save_stack+0x23/0x90 mm/kasan/common.c:72  set_track mm/kasan/common.c:80 [inline]  kasan_set_free_info mm/kasan/common.c:335 [inline]  __kasan_slab_free+0x102/0x150 mm/kasan/common.c:474  kasan_slab_free+0xe/0x10 mm/kasan/common.c:483  __cache_free mm/slab.c:3426 [inline]  kmem_cache_free+0x86/0x320 mm/slab.c:3694  kfree_skbmem+0x178/0x1c0 net/core/skbuff.c:645  __kfree_skb+0x1e/0x30 net/core/skbuff.c:681  sk_eat_skb include/net/sock.h:2453 [inline]  tcp_recvmsg+0x1252/0x2930 net/ipv4/tcp.c:2166  inet_recvmsg+0x136/0x610 net/ipv4/af_inet.c:838  sock_recvmsg_nosec net/socket.c:886 [inline]  sock_recvmsg net/socket.c:904 [inline]  sock_recvmsg+0xce/0x110 net/socket.c:900  __sys_recvfrom+0x1ff/0x350 net/socket.c:2055  __do_sys_recvfrom net/socket.c:2073 [inline]  __se_sys_recvfrom net/socket.c:2069 [inline]  __x64_sys_recvfrom+0xe1/0x1a0 net/socket.c:2069  do_syscall_64+0xfa/0x790 arch/x86/entry/common.c:294  entry_SYSCALL_64_after_hwframe+0x49/0xbe  The buggy address belongs to the object at ffff8880a488d040  which belongs to the cache skbuff_fclone_cache of size 456 The buggy address is located 40 bytes inside of  456-byte region [ffff8880a488d040, ffff8880a488d208) The buggy address belongs to the page: page:ffffea0002922340 refcount:1 mapcount:0 mapping:ffff88821b057000 index:0x0 raw: 00fffe0000000200 ffffea00022a5788 ffffea0002624a48 ffff88821b057000 raw: 0000000000000000 ffff8880a488d040 0000000100000006 0000000000000000 page dumped because: kasan: bad access detected  Memory state around the buggy ",2bec445f9bf35e52e395b971df48d3e1e5dc704a,1
tipc: check group dests after tipc_wait_for_cond(),"Similar to commit 143ece654f9f (""tipc: check tsk->group in tipc_wait_for_cond()"") we have to reload grp->dests too after we re-take the sock lock. This means we need to move the dsts check after tipc_wait_for_cond() too.  ",3c6306d44082ef007a258ae1b86ea58e6974ee3f,0
net: Fix memory leak in ieee802154_raw_deliver,"If IEEE-802.15.4-RAW is closed before receive skb, skb is leaked. Fix this, by freeing sk_receive_queue in sk->sk_destruct().  syzbot report: BUG: memory leak unreferenced object 0xffff88810f644600 (size 232):   comm ""softirq"", pid 0, jiffies 4294967032 (age 81.270s)   ",1090340f7ee53e824fd4eef66a4855d548110c5b,1
USB: serial: garmin_gps: add sanity checking for data length,We must not process packets shorter than a packet ID  ,e9b3c610a05c1cdf8e959a6d89c38807ff758ee6,1
bpf: sockmap only allow ESTABLISHED sock state,After this patch we only allow socks that are in ESTABLISHED state or are being added via a sock_ops event that is transitioning into an ESTABLISHED state. By allowing sock_ops events we allow users to manage sockmaps directly from sock ops programs. The two supported sock_ops ops are BPF_SOCK_OPS_PASSIVE_ESTABLISHED_CB and BPF_SOCK_OPS_ACTIVE_ESTABLISHED_CB.  Similar to TLS ULP this ensures sk_user_data is correct.  ,5607fff303636d48b88414c6be353d9fed700af2,0
afs: Fix NULL deref in afs_dynroot_depopulate(),"If an error occurs during the construction of an afs superblock, it's possible that an error occurs after a superblock is created, but before we've created the root dentry.  If the superblock has a dynamic root (ie.  what's normally mounted on /afs), the afs_kill_super() will call afs_dynroot_depopulate() to unpin any created dentries - but this will oops if the root hasn't been created yet.  Fix this by skipping that bit of code if there is no root dentry.  This leads to an oops looking like:  	general protection fault, ... 	KASAN: null-ptr-deref in range [0x0000000000000068-0x000000000000006f] 	... 	",5e0b17b026eb7c6de9baa9b0d45a51b05f05abe1,1
ALSA: pcm: oss: Avoid plugin buffer overflow,"Each OSS PCM plugins allocate its internal buffer per pre-calculation of the max buffer size through the chain of plugins (calling src_frames and dst_frames callbacks).  This works for most plugins, but the rate plugin might behave incorrectly.  The calculation in the rate plugin involves with the fractional position, i.e. it may vary depending on the input position.  Since the buffer size pre-calculation is always done with the offset zero, it may return a shorter size than it might be; this may result in the out-of-bound access as spotted by fuzzer.  This patch addresses those possible buffer overflow accesses by simply setting the upper limit per the given buffer size for each plugin before src_frames() and after dst_frames() calls.  ",f2ecf903ef06eb1bbbfa969db9889643d487e73a,1
kvm: x86/vmx: Use kzalloc for cached_vmcs12,"This changes the allocation of cached_vmcs12 to use kzalloc instead of kmalloc. This removes the information leak found by Syzkaller (see Reported-by) in this case and prevents similar leaks from happening based on cached_vmcs12.  It also changes vmx_get_nested_state to copy out the full 4k VMCS12_SIZE in copy_to_user rather than only the size of the struct.  Tested: rebuilt against head, booted, and ran the syszkaller repro   https://syzkaller.appspot.com/text?tag=ReproC&x=174efca3400000 without   observing any problems.  ",3a33d030daaa7c507e1c12d5adcf828248429593,1
xfrm: add the missing verify_sec_ctx_len check in xfrm_add_acquire,"Without doing verify_sec_ctx_len() check in xfrm_add_acquire(), it may be out-of-bounds to access uctx->ctx_str with uctx->ctx_len, as noticed by syz:    BUG: KASAN: slab-out-of-bounds in selinux_xfrm_alloc_user+0x237/0x430   Read of size 768 at addr ffff8880123be9b4 by task syz-executor.1/11650    Call Trace:    dump_stack+0xe8/0x16e    print_address_description.cold.3+0x9/0x23b    kasan_report.cold.4+0x64/0x95    memcpy+0x1f/0x50    selinux_xfrm_alloc_user+0x237/0x430    security_xfrm_policy_alloc+0x5c/0xb0    xfrm_policy_construct+0x2b1/0x650    xfrm_add_acquire+0x21d/0xa10    xfrm_user_rcv_msg+0x431/0x6f0    netlink_rcv_skb+0x15a/0x410    xfrm_netlink_rcv+0x6d/0x90    netlink_unicast+0x50e/0x6a0    netlink_sendmsg+0x8ae/0xd40    sock_sendmsg+0x133/0x170    ___sys_sendmsg+0x834/0x9a0    __sys_sendmsg+0x100/0x1e0    do_syscall_64+0xe5/0x660    entry_SYSCALL_64_after_hwframe+0x6a/0xdf  So fix it by adding the missing verify_sec_ctx_len check there.  ",a1a7e3a36e01ca6e67014f8cf673cb8e47be5550,1
netfilter: arp_tables: init netns pointer in xt_tgdtor_param struct,"An earlier commit (1b789577f655060d98d20e, ""netfilter: arp_tables: init netns pointer in xt_tgchk_param struct"") fixed missing net initialization for arptables, but turns out it was incomplete.  We can get a very similar struct net NULL deref during error unwinding:  general protection fault: 0000 [#1] PREEMPT SMP KASAN ",212e7f56605ef9688d0846db60c6c6ec06544095,1
"bpf: skmsg, fix psock create on existing kcm/tls port","Before using the psock returned by sk_psock_get() when adding it to a sockmap we need to ensure it is actually a sockmap based psock. Previously we were only checking this after incrementing the reference counter which was an error. This resulted in a slab-out-of-bounds error when the psock was not actually a sockmap type.  This moves the check up so the reference counter is only used if it is a sockmap psock.  Eric reported the following KASAN BUG,  BUG: KASAN: slab-out-of-bounds in atomic_read include/asm-generic/atomic-instrumented.h:21 [inline] BUG: KASAN: slab-out-of-bounds in refcount_inc_not_zero_checked+0x97/0x2f0 lib/refcount.c:120 Read of size 4 at addr ffff88019548be58 by task syz-executor4/22387  CPU: 1 PID: 22387 Comm: syz-executor4 Not tainted 4.19.0-rc7+ #264 Hardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 01/01/2011 Call Trace:  __dump_stack lib/dump_stack.c:77 [inline]  dump_stack+0x1c4/0x2b4 lib/dump_stack.c:113  print_address_description.cold.8+0x9/0x1ff mm/kasan/report.c:256  kasan_report_error mm/kasan/report.c:354 [inline]  kasan_report.cold.9+0x242/0x309 mm/kasan/report.c:412  check_memory_region_inline mm/kasan/kasan.c:260 [inline]  check_memory_region+0x13e/0x1b0 mm/kasan/kasan.c:267  kasan_check_read+0x11/0x20 mm/kasan/kasan.c:272  atomic_read include/asm-generic/atomic-instrumented.h:21 [inline]  refcount_inc_not_zero_checked+0x97/0x2f0 lib/refcount.c:120  sk_psock_get include/linux/skmsg.h:379 [inline]  sock_map_link.isra.6+0x41f/0xe30 net/core/sock_map.c:178  sock_hash_update_common+0x19b/0x11e0 net/core/sock_map.c:669  sock_hash_update_elem+0x306/0x470 net/core/sock_map.c:738  map_update_elem+0x819/0xdf0 kernel/bpf/syscall.c:818  ",5032d079909d1ac5c2535acc32d5f01cd245d8ea,1
Input: usbtouchscreen - initialize PM mutex before using it,Mutexes shall be initialized before they are used.  ,b55d996f057bf2e7ba9422a80b5e17e99860cb0b,0
drm/compat: Clear bounce structures,"Some of them have gaps, or fields we don't clear. Native ioctl code does full copies plus zero-extends on size mismatch, so nothing can leak. But compat is more hand-rolled so need to be careful.  None of these matter for performance, so just memset.  Also I didn't fix up the CONFIG_DRM_LEGACY or CONFIG_DRM_AGP ioctl, those are security holes anyway.  ",de066e116306baf3a6a62691ac63cfc0b1dabddb,0
packet: fix data-race in fanout_flow_is_huge(),"KCSAN reported the following data-race [1]  Adding a couple of READ_ONCE()/WRITE_ONCE() should silence it.  Since the report hinted about multiple cpus using the history concurrently, I added a test avoiding writing on it if the victim slot already contains the desired value.  [1]  BUG: KCSAN: data-race in fanout_demux_rollover / fanout_demux_rollover  read to 0xffff8880b01786cc of 4 bytes by task 18921 on cpu 1:  fanout_flow_is_huge net/packet/af_packet.c:1303 [inline]  fanout_demux_rollover+0x33e/0x3f0 net/packet/af_packet.c:1353  packet_rcv_fanout+0x34e/0x490 net/packet/af_packet.c:1453  deliver_skb net/core/dev.c:1888 [inline]  dev_queue_xmit_nit+0x15b/0x540 net/core/dev.c:1958  xmit_one net/core/dev.c:3195 [inline]  dev_hard_start_xmit+0x3f5/0x430 net/core/dev.c:3215  __dev_queue_xmit+0x14ab/0x1b40 net/core/dev.c:3792  dev_queue_xmit+0x21/0x30 net/core/dev.c:3825  neigh_direct_output+0x1f/0x30 net/core/neighbour.c:1530  neigh_output include/net/neighbour.h:511 [inline]  ip6_finish_output2+0x7a2/0xec0 net/ipv6/ip6_output.c:116  __ip6_finish_output net/ipv6/ip6_output.c:142 [inline]  __ip6_finish_output+0x2d7/0x330 net/ipv6/ip6_output.c:127  ip6_finish_output+0x41/0x160 net/ipv6/ip6_output.c:152  NF_HOOK_COND include/linux/netfilter.h:294 [inline]  ip6_output+0xf2/0x280 net/ipv6/ip6_output.c:175  dst_output include/net/dst.h:436 [inline]  ip6_local_out+0x74/0x90 net/ipv6/output_core.c:179  ip6_send_skb+0x53/0x110 net/ipv6/ip6_output.c:1795  udp_v6_send_skb.isra.0+0x3ec/0xa70 net/ipv6/udp.c:1173  udpv6_sendmsg+0x1906/0x1c20 net/ipv6/udp.c:1471  inet6_sendmsg+0x6d/0x90 net/ipv6/af_inet6.c:576  sock_sendmsg_nosec net/socket.c:637 [inline]  sock_sendmsg+0x9f/0xc0 net/socket.c:657  ___sys_sendmsg+0x2b7/0x5d0 net/socket.c:2311  __sys_sendmmsg+0x123/0x350 net/socket.c:2413  __do_sys_sendmmsg net/socket.c:2442 [inline]  __se_sys_sendmmsg net/socket.c:2439 [inline]  __x64_sys_sendmmsg+0x64/0x80 net/socket.c:2439  do_syscall_64+0xcc/0x370 arch/x86/entry/common.c:290  entry_SYSCALL_64_after_hwframe+0x44/0xa9  write to 0xffff8880b01786cc of 4 bytes by task 18922 on cpu 0:  fanout_flow_is_huge net/packet/af_packet.c:1306 [inline]  fanout_demux_rollover+0x3a4/0x3f0 net/packet/af_packet.c:1353  packet_rcv_fanout+0x34e/0x490 net/packet/af_packet.c:1453  deliver_skb net/core/dev.c:1888 [inline]  dev_queue_xmit_nit+0x15b/0x540 net/core/dev.c:1958  xmit_one net/core/dev.c:3195 [inline]  dev_hard_start_xmit+0x3f5/0x430 net/core/dev.c:3215  __dev_queue_xmit+0x14ab/0x1b40 net/core/dev.c:3792  dev_queue_xmit+0x21/0x30 net/core/dev.c:3825  neigh_direct_output+0x1f/0x30 net/core/neighbour.c:1530  neigh_output include/net/neighbour.h:511 [inline]  ip6_finish_output2+0x7a2/0xec0 net/ipv6/ip6_output.c:116  __ip6_finish_output net/ipv6/ip6_output.c:142 [inline]  __ip6_finish_output+0x2d7/0x330 net/ipv6/ip6_output.c:127  ip6_finish_output+0x41/0x160 net/ipv6/ip6_output.c:152  NF_HOOK_COND include/linux/netfilter.h:294 [inline]  ip6_output+0xf2/0x280 net/ipv6/ip6_output.c:175  dst_output include/net/dst.h:436 [inline]  ip6_local_out+0x74/0x90 net/ipv6/output_core.c:179  ip6_send_skb+0x53/0x110 net/ipv6/ip6_output.c:1795  udp_v6_send_skb.isra.0+0x3ec/0xa70 net/ipv6/udp.c:1173  udpv6_sendmsg+0x1906/0x1c20 net/ipv6/udp.c:1471  inet6_sendmsg+0x6d/0x90 net/ipv6/af_inet6.c:576  sock_sendmsg_nosec net/socket.c:637 [inline]  sock_sendmsg+0x9f/0xc0 net/socket.c:657  ___sys_sendmsg+0x2b7/0x5d0 net/socket.c:2311  __sys_sendmmsg+0x123/0x350 net/socket.c:2413  __do_sys_sendmmsg net/socket.c:2442 [inline]  __se_sys_sendmmsg net/socket.c:2439 [inline]  __x64_sys_sendmmsg+0x64/0x80 net/socket.c:2439  do_syscall_64+0xcc/0x370 arch/x86/entry/common.c:290  entry_SYSCALL_64_after_hwframe+0x44/0xa9  Reported by Kernel Concurrency Sanitizer on: CPU: 0 PID: 18922 Comm: syz-executor.3 Not tainted 5.4.0-rc6+ #0 Hardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 01/01/2011  ",b756ad928d98e5ef0b74af7546a6a31a8dadde00,1
tipc: fix possible crash in __tipc_nl_net_set(),syzbot reported a crash in __tipc_nl_net_set() caused by NULL dereference.  We need to check that both TIPC_NLA_NET_NODEID and TIPC_NLA_NET_NODEID_W1 are present.  We also need to make sure userland provided u64 attributes.  ,c6404122cb18f1fbd2a6dc85ab687f6fa2e454cf,1
HID: holtek: test for sanity of intfdata,"The ioctl handler uses the intfdata of a second interface, which may not be present in a broken or malicious device, hence the intfdata needs to be checked for NULL.  [jkosina@suse.cz: fix newly added spurious space] ",01ec0a5f19c8c82960a07f6c7410fc9e01d7fb51,0
packet: fix bitfield update race,"Updates to the bitfields in struct packet_sock are not atomic. Serialize these read-modify-write cycles.  Move po->running into a separate variable. Its writes are protected by po->bind_lock (except for one startup case at packet_create). Also replace a textual precondition warning with lockdep annotation.  All others are set only in packet_setsockopt. Serialize these updates by holding the socket lock. Analogous to other field updates, also hold the lock when testing whether a ring is active (pg_vec).  ",a6361f0ca4b25460f2cdf3235ebe8115f622901e,1
net/sched: act_ct: fix lockdep splat in tcf_ct_flow_table_get,"Convert zones_lock spinlock to zones_mutex mutex, and struct (tcf_ct_flow_table)->ref to a refcount, so that control path can use regular GFP_KERNEL allocations from standard process context. This is more robust in case of memory pressure.  The refcount is needed because tcf_ct_flow_table_put() can be called from RCU callback, thus in BH context.  The issue was spotted by syzbot, as rhashtable_init() was called with a spinlock held, which is bad since GFP_KERNEL allocations can sleep.  Note to developers : Please make sure your patches are tested with CONFIG_DEBUG_ATOMIC_SLEEP=y  BUG: sleeping function called from invalid context at mm/slab.h:565 in_atomic(): 1, irqs_disabled(): 0, non_block: 0, pid: 9582, name: syz-executor610 2 locks held by syz-executor610/9582:  #0: ffffffff8a34eb80 (rtnl_mutex){+.+.}, at: rtnl_lock net/core/rtnetlink.c:72 [inline]  #0: ffffffff8a34eb80 (rtnl_mutex){+.+.}, at: rtnetlink_rcv_msg+0x3f9/0xad0 net/core/rtnetlink.c:5437  #1: ffffffff8a3961b8 (zones_lock){+...}, at: spin_lock_bh include/linux/spinlock.h:343 [inline]  #1: ffffffff8a3961b8 (zones_lock){+...}, at: tcf_ct_flow_table_get+0xa3/0x1700 net/sched/act_ct.c:67 Preemption disabled at: [<0000000000000000>] 0x0 CPU: 0 PID: 9582 Comm: syz-executor610 Not tainted 5.6.0-rc3-syzkaller #0 Hardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 01/01/2011 Call Trace:  __dump_stack lib/dump_stack.c:77 [inline]  dump_stack+0x188/0x20d lib/dump_stack.c:118  ___might_sleep.cold+0x1f4/0x23d kernel/sched/core.c:6798  slab_pre_alloc_hook mm/slab.h:565 [inline]  slab_alloc_node mm/slab.c:3227 [inline]  kmem_cache_alloc_node_trace+0x272/0x790 mm/slab.c:3593  __do_kmalloc_node mm/slab.c:3615 [inline]  __kmalloc_node+0x38/0x60 mm/slab.c:3623  kmalloc_node include/linux/slab.h:578 [inline]  kvmalloc_node+0x61/0xf0 mm/util.c:574  kvmalloc include/linux/mm.h:645 [inline]  kvzalloc include/linux/mm.h:653 [inline]  bucket_table_alloc+0x8b/0x480 lib/rhashtable.c:175  rhashtable_init+0x3d2/0x750 lib/rhashtable.c:1054  nf_flow_table_init+0x16d/0x310 net/netfilter/nf_flow_table_core.c:498  tcf_ct_flow_table_get+0xe33/0x1700 net/sched/act_ct.c:82  tcf_ct_init+0xba4/0x18a6 net/sched/act_ct.c:1050  tcf_action_init_1+0x697/0xa20 net/sched/act_api.c:945  tcf_action_init+0x1e9/0x2f0 net/sched/act_api.c:1001  tcf_action_add+0xdb/0x370 net/sched/act_api.c:1411  tc_ctl_action+0x366/0x456 net/sched/act_api.c:1466  rtnetlink_rcv_msg+0x44e/0xad0 net/core/rtnetlink.c:5440  netlink_rcv_skb+0x15a/0x410 net/netlink/af_netlink.c:2478  netlink_unicast_kernel net/netlink/af_netlink.c:1303 [inline]  netlink_unicast+0x537/0x740 net/netlink/af_netlink.c:1329  netlink_sendmsg+0x882/0xe10 net/netlink/af_netlink.c:1918  sock_sendmsg_nosec net/socket.c:652 [inline]  sock_sendmsg+0xcf/0x120 net/socket.c:672  ____sys_sendmsg+0x6b9/0x7d0 net/socket.c:2343  ___sys_sendmsg+0x100/0x170 net/socket.c:2397  __sys_sendmsg+0xec/0x1b0 net/socket.c:2430  do_syscall_64+0xf6/0x790 arch/x86/entry/common.c:294  entry_SYSCALL_64_after_hwframe+0x49/0xbe ",138470a9b2cc2e26e6018300394afc3858a54e6a,1
rds: Fix NULL pointer dereference in __rds_rdma_map,"This is a fix for syzkaller719569, where memory registration was attempted without any underlying transport being loaded.  Analysis of the case reveals that it is the setsockopt() RDS_GET_MR (2) and RDS_GET_MR_FOR_DEST (7) that are vulnerable.  Here is an example stack trace when the bug is hit:  BUG: unable to handle kernel NULL pointer dereference at 00000000000000c0 IP: __rds_rdma_map+0x36/0x440 [rds] PGD 2f93d03067 P4D 2f93d03067 PUD 2f93d02067 PMD 0 Oops: 0000 [#1] SMP ",f3069c6d33f6ae63a1668737bc78aaaa51bff7ca,1
ipvs: initialize tbl->entries in ip_vs_lblc_init_svc(),"Similarly, tbl->entries is not initialized after kmalloc(), therefore causes an uninit-value warning in ip_vs_lblc_check_expire(), as reported by syzbot.  ",8b2ebb6cf064247d60cccbf1750610ac9bb2e672,0
nbd: fix order of cleaning up the queue and freeing the tagset,We must release the queue before freeing the tagset.  ,16ad3db3b24cd9f70aa24e93cef0d4a83dece7ac,0
ipvs: fix tinfo memory leak in start_sync_thread,"syzkaller reports for memory leak in start_sync_thread [1]  As Eric points out, kthread may start and stop before the threadfn function is called, so there is no chance the data (tinfo in our case) to be released in thread.  Fix this by releasing tinfo in the controlling code instead.  [1] BUG: memory leak unreferenced object 0xffff8881206bf700 (size 32):  comm ""syz-executor761"", pid 7268, jiffies 4294943441 (age 20.470s)  ",5db7c8b9f9fc2aeec671ae3ca6375752c162e0e7,1
nbd: Fix memory leak in nbd_add_socket,"When adding first socket to nbd, if nsock's allocation failed, the data structure member ""config->socks"" was reallocated, but the data structure member ""config->num_connections"" was not updated. A memory leak will occur then because the function ""nbd_config_put"" will free ""config->socks"" only when ""config->num_connections"" is not zero.  ",579dd91ab3a5446b148e7f179b6596b270dace46,1
io_uring: use correct pointer for io_uring_show_cred(),"Previous commit changed how we index the registered credentials, but neglected to update one spot that is used when the personalities are iterated through ->show_fdinfo(). Ensure we use the right struct type for the iteration.  ",6b47ab81c9a9b56a94882815e9949d40e4207c92,0
bpf: undo prog rejection on read-only lock failure,"Partially undo commit 9facc336876f (""bpf: reject any prog that failed read-only lock"") since it caused a regression, that is, syzkaller was able to manage to cause a panic via fault injection deep in set_memory_ro() path by letting an allocation fail: In x86's __change_page_attr_set_clr() it was able to change the attributes of the primary mapping but not in the alias mapping via cpa_process_alias(), so the second, inner call to the __change_page_attr() via __change_page_attr_set_clr() had to split a larger page and failed in the alloc_pages() with the artifically triggered allocation error which is then propagated down to the call site.  Thus, for set_memory_ro() this means that it returned with an error, but from debugging a probe_kernel_write() revealed EFAULT on that memory since the primary mapping succeeded to get changed. Therefore the subsequent hdr->locked = 0 reset triggered the panic as it was performed on read-only memory, so call-site assumptions were infact wrong to assume that it would either succeed /or/ not succeed at all since there's no such rollback in set_memory_*() calls from partial change of mappings, in other words, we're left in a state that is ""half done"". A later undo via set_memory_rw() is succeeding though due to matching permissions on that part (aka due to the try_preserve_large_page() succeeding). While reproducing locally with explicitly triggering this error, the initial splitting only happens on rare occasions and in real world it would additionally need oom conditions, but that said, it could partially fail. Therefore, it is definitely wrong to bail out on set_memory_ro() error and reject the program with the set_memory_*() semantics we have today. Shouldn't have gone the extra mile since no other user in tree today infact checks for any set_memory_*() errors, e.g. neither module_enable_ro() / module_disable_ro() for module RO/NX handling which is mostly default these days nor kprobes core with alloc_insn_page() / free_insn_page() as examples that could be invoked long after bootup and original 314beb9bcabf (""x86: bpf_jit_comp: secure bpf jit against spraying attacks"") did neither when it got first introduced to BPF so ""improving"" with bailing out was clearly not right when set_memory_*() cannot handle it today.  Kees suggested that if set_memory_*() can fail, we should annotate it with __must_check, and all callers need to deal with it gracefully given those set_memory_*() markings aren't ""advisory"", but they're expected to actually do what they say. This might be an option worth to move forward in future but would at the same time require that set_memory_*() calls from supporting archs are guaranteed to be ""atomic"" in that they provide rollback if part of the range fails, once that happened, the transition from RW -> RO could be made more robust that way, while subsequent RO -> RW transition /must/ continue guaranteeing to always succeed the undo part.  ",85782e037f8aba8922dadb24a1523ca0b82ab8bc,1
blk-mq: remove WARN_ON(!q->elevator) from blk_mq_sched_free_requests,"blk_mq_sched_free_requests() may be called in failure path in which q->elevator may not be setup yet, so remove WARN_ON(!q->elevator) from blk_mq_sched_free_requests for avoiding the false positive.  This function is actually safe to call in case of !q->elevator because hctx->sched_tags is checked.  ",c326f846ebc2a30eca386b85dffba96e23803d81,0
netfilter: arp_tables: init netns pointer in xt_tgchk_param struct,"We get crash when the targets checkentry function tries to make use of the network namespace pointer for arptables.  When the net pointer got added back in 2010, only ip/ip6/ebtables were changed to initialize it, so arptables has this set to NULL.  This isn't a problem for normal arptables because no existing arptables target has a checkentry function that makes use of par->net.  However, direct users of the setsockopt interface can provide any target they want as long as its registered for ARP or UNPSEC protocols.  syzkaller managed to send a semi-valid arptables rule for RATEEST target which is enough to trigger NULL deref:  kasan: GPF could be caused by NULL-ptr deref or user memory access general protection fault: 0000 [#1] PREEMPT SMP KASAN ",1b789577f655060d98d20ed0c6f9fbd469d6ba63,1
"fix regression in ""epoll: Keep a reference on files added to the check list""",epoll_loop_check_proc() can run into a file already committed to destruction; we can't grab a reference on those and don't need to add them to the set for reverse path check anyway.  ,77f4689de17c0887775bb77896f4cc11a39bf848,0
ALSA: usb-audio: Fix race against the error recovery URB submission,"USB MIDI driver has an error recovery mechanism to resubmit the URB in the delayed timer handler, and this may race with the standard start / stop operations.  Although both start and stop operations themselves don't race with each other due to the umidi->mutex protection, but this isn't applied to the timer handler.  For fixing this potential race, the following changes are applied:  - Since the timer handler can't use the mutex, we apply the   umidi->disc_lock protection at each input stream URB submission;   this also needs to change the GFP flag to GFP_ATOMIC - Add a check of the URB refcount and skip if already submitted - Move the timer cancel call at disconnection to the beginning of the   procedure; this assures the in-flight timer handler is gone properly   before killing all pending URBs  ",9b7e5208a941e2e491a83eb5fa83d889e888fa2f,1
pid: Handle failure to allocate the first pid in a pid namespace,With the replacement of the pid bitmap and hashtable with an idr in alloc_pid started occassionally failing when allocating the first pid in a pid namespace.  Things were not completely reset resulting in the first allocated pid getting the number 2 (not 1).  Which further resulted in ns->proc_mnt not getting set and eventually causing an oops in proc_flush_task.  Oops: 0000 [#1] SMP CPU: 2 PID: 6743 Comm: trinity-c117 Not tainted 4.15.0-rc4-think+ #2 ,c0ee554906c3d6554fbddf95ae664cd9f817082b,1
binder: Remove bogus warning on failed same-process transaction,"While binder transactions with the same binder_proc as sender and recipient are forbidden, transactions with the same task_struct as sender and recipient are possible (even though currently there is a weird check in binder_transaction() that rejects them in the target==0 case). Therefore, task_struct identities can't be used to distinguish whether the caller is running in the context of the sender or the recipient.  Since I see no easy way to make this WARN_ON() useful and correct, let's just remove it.  ",e8b8ae7ce32e17a5c29f0289e9e2a39c7dcaa1b8,0
USB: usbfs: Don't WARN about excessively large memory allocations,"Syzbot found that the kernel generates a WARNing if the user tries to submit a bulk transfer through usbfs with a buffer that is way too large.  This isn't a bug in the kernel; it's merely an invalid request from the user and the usbfs code does handle it correctly.  In theory the same thing can happen with async transfers, or with the packet descriptor table for isochronous transfers.  To prevent the MM subsystem from complaining about these bad allocation requests, add the __GFP_NOWARN flag to the kmalloc calls for these buffers.  CC: Andrew Morton <akpm@linux-foundation.org> CC: <stable@vger.kernel.org> ",4f2629ea67e7225c3fd292c7fe4f5b3c9d6392de,0
mptcp: never allow the PM to close a listener subflow,"Currently, when deleting an endpoint the netlink PM treverses all the local MPTCP sockets, regardless of their status.  If an MPTCP listener socket is bound to the IP matching the delete endpoint, the listener TCP socket will be closed. That is unexpected, the PM should only affect data subflows.  Additionally, syzbot was able to trigger a NULL ptr dereference due to the above:  general protection fault, probably for non-canonical address 0xdffffc0000000003: 0000 [#1] PREEMPT SMP KASAN KASAN: null-ptr-deref in range [0x0000000000000018-0x000000000000001f] CPU: 1 PID: 6550 Comm: syz-executor122 Not tainted 5.16.0-rc4-syzkaller #0 Hardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 01/01/2011 ",b0cdc5dbcf2ba0d99785da5aabf1b17943805b8a,1
udp: disable gso with no_check_tx,Syzbot managed to send a udp gso packet without checksum offload into the gso stack by disabling tx checksum (UDP_NO_CHECK6_TX). This triggered the skb_warn_bad_offload.    ,a8c744a8b43733509b5625e65fee1985fbb901d7,0
tcp: add TCP_ZEROCOPY_RECEIVE support for zerocopy receive,"When adding tcp mmap() implementation, I forgot that socket lock had to be taken before current->mm->mmap_sem. syzbot eventually caught the bug.  Since we can not lock the socket in tcp mmap() handler we have to split the operation in two phases.  1) mmap() on a tcp socket simply reserves VMA space, and nothing else.   This operation does not involve any TCP locking.  2) getsockopt(fd, IPPROTO_TCP, TCP_ZEROCOPY_RECEIVE, ...) implements  the transfert of pages from skbs to one VMA.   This operation only uses down_read(&current->mm->mmap_sem) after   holding TCP lock, thus solving the lockdep issue.  This new implementation was suggested by Andy Lutomirski with great details.  Benefits are :  - Better scalability, in case multiple threads reuse VMAS    (without mmap()/munmap() calls) since mmap_sem wont be write locked.  - Better error recovery.    The previous mmap() model had to provide the expected size of the    mapping. If for some reason one part could not be mapped (partial MSS),    the whole operation had to be aborted.    With the tcp_zerocopy_receive struct, kernel can report how    many bytes were successfuly mapped, and how many bytes should    be read to skip the problematic sequence.  - No more memory allocation to hold an array of page pointers.   16 MB mappings needed 32 KB for this array, potentially using vmalloc() :/  - skbs are freed while mmap_sem has been released  Following patch makes the change in tcp_mmap tool to demonstrate one possible use of mmap() and setsockopt(... TCP_ZEROCOPY_RECEIVE ...)  Note that memcg might require additional changes.  ",05255b823a6173525587f29c4e8f1ca33fd7677d,0
neighbour: remove neigh_cleanup() method,"neigh_cleanup() has not been used for seven years, and was a wrong design.  Messing with shared pointer in bond_neigh_init() without proper memory barriers would at least trigger syzbot complains eventually.  It is time to remove this stuff.  ",f394722fb0d0f701119368959d7cd0ecbc46363a,0
net ticp:fix a kernel-infoleak in __tipc_sendmsg(),"struct tipc_socket_addr.ref has a 4-byte hole,and __tipc_getname() currently copying it to user space,causing kernel-infoleak.  BUG: KMSAN: kernel-infoleak in instrument_copy_to_user include/linux/instrumented.h:121 [inline] BUG: KMSAN: kernel-infoleak in instrument_copy_to_user include/linux/instrumented.h:121 [inline] lib/usercopy.c:33 BUG: KMSAN: kernel-infoleak in _copy_to_user+0x1c9/0x270 lib/usercopy.c:33 lib/usercopy.c:33  instrument_copy_to_user include/linux/instrumented.h:121 [inline]  instrument_copy_to_user include/linux/instrumented.h:121 [inline] lib/usercopy.c:33  _copy_to_user+0x1c9/0x270 lib/usercopy.c:33 lib/usercopy.c:33  copy_to_user include/linux/uaccess.h:209 [inline]  copy_to_user include/linux/uaccess.h:209 [inline] net/socket.c:287  move_addr_to_user+0x3f6/0x600 net/socket.c:287 net/socket.c:287  __sys_getpeername+0x470/0x6b0 net/socket.c:1987 net/socket.c:1987  __do_sys_getpeername net/socket.c:1997 [inline]  __se_sys_getpeername net/socket.c:1994 [inline]  __do_sys_getpeername net/socket.c:1997 [inline] net/socket.c:1994  __se_sys_getpeername net/socket.c:1994 [inline] net/socket.c:1994  __x64_sys_getpeername+0xda/0x120 net/socket.c:1994 net/socket.c:1994  do_syscall_x64 arch/x86/entry/common.c:51 [inline]  do_syscall_x64 arch/x86/entry/common.c:51 [inline] arch/x86/entry/common.c:82  do_syscall_64+0x54/0xd0 arch/x86/entry/common.c:82 arch/x86/entry/common.c:82  entry_SYSCALL_64_after_hwframe+0x44/0xae  ",d6d86830705f173fca6087a3e67ceaf68db80523,1
appledisplay: fix error handling in the scheduled work,The work item can operate on  1. stale memory left over from the last transfer the actual length of the data transfered needs to be checked 2. memory already freed the error handling in appledisplay_probe() needs to cancel the work in that case  ,91feb01596e5efc0cc922cc73f5583114dccf4d2,1
ALSA: usb-audio: Sanity checks for each pipe and EP types,"The recent USB core code performs sanity checks for the given pipe and EP types, and it can be hit by manipulated USB descriptors by syzbot. For making syzbot happier, this patch introduces a local helper for a sanity check in the driver side and calls it at each place before the message handling, so that we can avoid the ",801ebf1043ae7b182588554cc9b9ad3c14bc2ab5,1
netfilter: conntrack: avoid possible false sharing,"As hinted by KCSAN, we need at least one READ_ONCE() to prevent a compiler optimization.  More details on : https://github.com/google/ktsan/wiki/READ_ONCE-and-WRITE_ONCE#it-may-improve-performance  sysbot report : BUG: KCSAN: data-race in __nf_ct_refresh_acct / __nf_ct_refresh_acct  read to 0xffff888123eb4f08 of 4 bytes by interrupt on cpu 0:  __nf_ct_refresh_acct+0xd4/0x1b0 net/netfilter/nf_conntrack_core.c:1796  nf_ct_refresh_acct include/net/netfilter/nf_conntrack.h:201 [inline]  nf_conntrack_tcp_packet+0xd40/0x3390 net/netfilter/nf_conntrack_proto_tcp.c:1161  nf_conntrack_handle_packet net/netfilter/nf_conntrack_core.c:1633 [inline]  nf_conntrack_in+0x410/0xaa0 net/netfilter/nf_conntrack_core.c:1727  ipv4_conntrack_in+0x27/0x40 net/netfilter/nf_conntrack_proto.c:178  nf_hook_entry_hookfn include/linux/netfilter.h:135 [inline]  nf_hook_slow+0x83/0x160 net/netfilter/core.c:512  nf_hook include/linux/netfilter.h:260 [inline]  NF_HOOK include/linux/netfilter.h:303 [inline]  ip_rcv+0x12f/0x1a0 net/ipv4/ip_input.c:523  __netif_receive_skb_one_core+0xa7/0xe0 net/core/dev.c:5004  __netif_receive_skb+0x37/0xf0 net/core/dev.c:5118  netif_receive_skb_internal+0x59/0x190 net/core/dev.c:5208  napi_skb_finish net/core/dev.c:5671 [inline]  napi_gro_receive+0x28f/0x330 net/core/dev.c:5704  receive_buf+0x284/0x30b0 drivers/net/virtio_net.c:1061  virtnet_receive drivers/net/virtio_net.c:1323 [inline]  virtnet_poll+0x436/0x7d0 drivers/net/virtio_net.c:1428  napi_poll net/core/dev.c:6352 [inline]  net_rx_action+0x3ae/0xa50 net/core/dev.c:6418  __do_softirq+0x115/0x33f kernel/softirq.c:292  write to 0xffff888123eb4f08 of 4 bytes by task 7191 on cpu 1:  __nf_ct_refresh_acct+0xfb/0x1b0 net/netfilter/nf_conntrack_core.c:1797  nf_ct_refresh_acct include/net/netfilter/nf_conntrack.h:201 [inline]  nf_conntrack_tcp_packet+0xd40/0x3390 net/netfilter/nf_conntrack_proto_tcp.c:1161  nf_conntrack_handle_packet net/netfilter/nf_conntrack_core.c:1633 [inline]  nf_conntrack_in+0x410/0xaa0 net/netfilter/nf_conntrack_core.c:1727  ipv4_conntrack_local+0xbe/0x130 net/netfilter/nf_conntrack_proto.c:200  nf_hook_entry_hookfn include/linux/netfilter.h:135 [inline]  nf_hook_slow+0x83/0x160 net/netfilter/core.c:512  nf_hook include/linux/netfilter.h:260 [inline]  __ip_local_out+0x1f7/0x2b0 net/ipv4/ip_output.c:114  ip_local_out+0x31/0x90 net/ipv4/ip_output.c:123  __ip_queue_xmit+0x3a8/0xa40 net/ipv4/ip_output.c:532  ip_queue_xmit+0x45/0x60 include/net/ip.h:236  __tcp_transmit_skb+0xdeb/0x1cd0 net/ipv4/tcp_output.c:1158  __tcp_send_ack+0x246/0x300 net/ipv4/tcp_output.c:3685  tcp_send_ack+0x34/0x40 net/ipv4/tcp_output.c:3691  tcp_cleanup_rbuf+0x130/0x360 net/ipv4/tcp.c:1575  Reported by Kernel Concurrency Sanitizer on: CPU: 1 PID: 7191 Comm: syz-fuzzer Not tainted 5.3.0+ #0 Hardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 01/01/2011  ",e37542ba111f3974dc622ae0a21c1787318de500,1
usb: gadget: dummy_hcd: fix gpf in gadget_setup,"Fix a general protection fault reported by syzbot due to a race between gadget_setup() and gadget_unbind() in raw_gadget.  The gadget core is supposed to guarantee that there won't be any more callbacks to the gadget driver once the driver's unbind routine is called. That guarantee is enforced in usb_gadget_remove_driver as follows:          usb_gadget_disconnect(udc->gadget);         if (udc->gadget->irq)                 synchronize_irq(udc->gadget->irq);         udc->driver->unbind(udc->gadget);         usb_gadget_udc_stop(udc);  usb_gadget_disconnect turns off the pullup resistor, telling the host that the gadget is no longer connected and preventing the transmission of any more USB packets. Any packets that have already been received are sure to processed by the UDC driver's interrupt handler by the time synchronize_irq returns.  But this doesn't work with dummy_hcd, because dummy_hcd doesn't use interrupts; it uses a timer instead. It does have code to emulate the effect of synchronize_irq, but that code doesn't get invoked at the right time -- it currently runs in usb_gadget_udc_stop, after the unbind callback instead of before. Indeed, there's no way for usb_gadget_remove_driver to invoke this code before the unbind callback.  To fix this, move the synchronize_irq() emulation code to dummy_pullup so that it runs before unbind. Also, add a comment explaining why it is necessary to have it there.  ",4a5d797a9f9c4f18585544237216d7812686a71f,1
net/smc: take sock lock in smc_ioctl(),SMC ioctl processing requires the sock lock to work properly in all thinkable scenarios. Problem has been found with RaceFuzzer and fixes:    KASAN: null-ptr-deref Read in smc_ioctl  ,1992d99882afda6dc17f9d49c06150856a91282f,1
cgroup: Use open-time cgroup namespace for process migration perm checks,cgroup process migration permission checks are performed at write time as whether a given operation is allowed or not is dependent on the content of the write - the PID. This currently uses current's cgroup namespace which is a potential security weakness as it may allow scenarios where a less privileged process tricks a more privileged one into writing into a fd that it created.  This patch makes cgroup remember the cgroup namespace at the time of open and uses it for migration permission checks instad of current's. Note that this only applies to cgroup2 as cgroup1 doesn't have namespace support.  This also fixes a use-after-free bug on cgroupns reported in   https://lore.kernel.org/r/00000000000048c15c05d0083397@google.com  Note that backporting this fix also requires the preceding patch.  ,e57457641613fef0d147ede8bd6a3047df588b95,1
KVM: fix rcu warning on VM_CREATE errors,"commit 3898da947bba (""KVM: avoid using rcu_dereference_protected"") can trigger the following lockdep/rcu splat if the VM_CREATE ioctl fails, for example if kvm_arch_init_vm fails:  ",021086e383fa408a219f6c6541b37f495f59d576,1
tipc: fix uninit-value in tipc_nl_compat_link_reset_stats,"syzbot reports following splat:  BUG: KMSAN: uninit-value in strlen+0x3b/0xa0 lib/string.c:486 CPU: 1 PID: 11057 Comm: syz-executor0 Not tainted 4.20.0-rc7+ #2 Hardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 01/01/2011 Call Trace:  __dump_stack lib/dump_stack.c:77 [inline]  dump_stack+0x173/0x1d0 lib/dump_stack.c:113  kmsan_report+0x12e/0x2a0 mm/kmsan/kmsan.c:613  __msan_warning+0x82/0xf0 mm/kmsan/kmsan_instr.c:295  strlen+0x3b/0xa0 lib/string.c:486  nla_put_string include/net/netlink.h:1154 [inline]  tipc_nl_compat_link_reset_stats+0x1f0/0x360 net/tipc/netlink_compat.c:760  __tipc_nl_compat_doit net/tipc/netlink_compat.c:311 [inline]  tipc_nl_compat_doit+0x3aa/0xaf0 net/tipc/netlink_compat.c:344  tipc_nl_compat_handle net/tipc/netlink_compat.c:1107 [inline]  tipc_nl_compat_recv+0x14d7/0x2760 net/tipc/netlink_compat.c:1210  genl_family_rcv_msg net/netlink/genetlink.c:601 [inline]  genl_rcv_msg+0x185f/0x1a60 net/netlink/genetlink.c:626  netlink_rcv_skb+0x444/0x640 net/netlink/af_netlink.c:2477  genl_rcv+0x63/0x80 net/netlink/genetlink.c:637  netlink_unicast_kernel net/netlink/af_netlink.c:1310 [inline]  netlink_unicast+0xf40/0x1020 net/netlink/af_netlink.c:1336  netlink_sendmsg+0x127f/0x1300 net/netlink/af_netlink.c:1917  sock_sendmsg_nosec net/socket.c:621 [inline]  sock_sendmsg net/socket.c:631 [inline]  ___sys_sendmsg+0xdb9/0x11b0 net/socket.c:2116  __sys_sendmsg net/socket.c:2154 [inline]  __do_sys_sendmsg net/socket.c:2163 [inline]  __se_sys_sendmsg+0x305/0x460 net/socket.c:2161  __x64_sys_sendmsg+0x4a/0x70 net/socket.c:2161  do_syscall_64+0xbc/0xf0 arch/x86/entry/common.c:291  entry_SYSCALL_64_after_hwframe+0x63/0xe7 ",8b66fee7f8ee18f9c51260e7a43ab37db5177a05,1
netfilter: IDLETIMER: be syzkaller friendly,"We had one report from syzkaller [1]  First issue is that INIT_WORK() should be done before mod_timer() or we risk timer being fired too soon, even with a 1 second timer.  Second issue is that we need to reject too big info->timeout to avoid overflows in msecs_to_jiffies(info->timeout * 1000), or risk looping, if result after overflow is 0.  [1] ",cfc2c740533368b96e2be5e0a4e8c3cace7d9814,1
tcp: annotate sk->sk_wmem_queued lockless reads,"For the sake of tcp_poll(), there are few places where we fetch sk->sk_wmem_queued while this field can change from IRQ or other cpu.  We need to add READ_ONCE() annotations, and also make sure write sides use corresponding WRITE_ONCE() to avoid store-tearing.  sk_wmem_queued_add() helper is added so that we can in the future convert to ADD_ONCE() or equivalent if/when available.  ",ab4e846a82d0ae00176de19f2db3c5c64f8eb5f2,0
kcsan: Never set up watchpoints on NULL pointers,"Avoid setting up watchpoints on NULL pointers, as otherwise we would crash inside the KCSAN runtime (when checking for value changes) instead of the instrumented code.  Because that may be confusing, skip any address less than PAGE_SIZE.  ",55a2346c7ac4bbf6ee6972394237bf31e29a1c05,1
smc: disallow TCP_ULP in smc_setsockopt(),"syzbot is able to setup kTLS on an SMC socket which coincidentally uses sk_user_data too. Later, kTLS treats it as psock so triggers a refcnt warning. The root cause is that smc_setsockopt() simply calls TCP setsockopt() which includes TCP_ULP. I do not think it makes sense to setup kTLS on top of SMC sockets, so we should just disallow this setup.  It is hard to find a commit to blame, but we can apply this patch since the beginning of TCP_ULP.  ",8621436671f3a4bba5db57482e1ee604708bf1eb,0
keys: Fix memory leak in copy_net_ns,"If copy_net_ns() failed after net_alloc(), net->key_domain is leaked. Fix this, by freeing key_domain in error path.  syzbot report: BUG: memory leak unreferenced object 0xffff8881175007e0 (size 32):   comm ""syz-executor902"", pid 7069, jiffies 4294944350 (age 28.400s)   ",82ecff655e7968151b0047f1b5de03b249e5c1c4,1
media: au0828: fix null dereference in error path,"au0828_usb_disconnect() gets the au0828_dev struct via usb_get_intfdata, so it needs to set up for the error paths.  ",6d0d1ff9ff21fbb06b867c13a1d41ce8ddcd8230,1
USB: yurex: Fix bad gfp argument,"The syzbot fuzzer identified a bug in the yurex driver: It passes GFP_KERNEL as a memory-allocation flag to usb_submit_urb() at a time when its state is TASK_INTERRUPTIBLE, not TASK_RUNNING:  do not call blocking ops when !TASK_RUNNING; state=1 set at [<00000000370c7c68>] prepare_to_wait+0xb1/0x2a0 kernel/sched/wait.c:247 ",f176ede3a3bde5b398a6777a7f9ff091baa2d3ff,0
net: igmp: add a missing rcu locking section,Newly added igmpv3_get_srcaddr() needs to be called under rcu lock.  Timer callbacks do not ensure this locking.  ,e7aadb27a5415e8125834b84a74477bfbee4eff5,0
net: check and errout if res->fi is NULL when RTM_F_FIB_MATCH is set,Syzkaller hit 'general protection fault in fib_dump_info' bug on commit 4.13-rc5..  Guilty file: net/ipv4/fib_semantics.c  kasan: GPF could be caused by NULL-ptr deref or user memory access general protection fault: 0000 [#1] SMP KASAN ,bc3aae2bbac46dd894c89db5d5e98f7f0ef9e205,1
net-gro: fix use-after-free read in napi_gro_frags(),"If a network driver provides to napi_gro_frags() an skb with a page fragment of exactly 14 bytes, the call to gro_pull_from_frag0() will 'consume' the fragment by calling skb_frag_unref(skb, 0), and the page might be freed and reused.  Reading eth->h_proto at the end of napi_frags_skb() might read mangled data, or crash under specific debugging features.  BUG: KASAN: use-after-free in napi_frags_skb net/core/dev.c:5833 [inline] BUG: KASAN: use-after-free in napi_gro_frags+0xc6f/0xd10 net/core/dev.c:5841 Read of size 2 at addr ffff88809366840c by task syz-executor599/8957  CPU: 1 PID: 8957 Comm: syz-executor599 Not tainted 5.2.0-rc1+ #32 Hardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 01/01/2011 Call Trace:  __dump_stack lib/dump_stack.c:77 [inline]  dump_stack+0x172/0x1f0 lib/dump_stack.c:113  print_address_description.cold+0x7c/0x20d mm/kasan/report.c:188  __kasan_report.cold+0x1b/0x40 mm/kasan/report.c:317  kasan_report+0x12/0x20 mm/kasan/common.c:614  __asan_report_load_n_noabort+0xf/0x20 mm/kasan/generic_report.c:142  napi_frags_skb net/core/dev.c:5833 [inline]  napi_gro_frags+0xc6f/0xd10 net/core/dev.c:5841  tun_get_user+0x2f3c/0x3ff0 drivers/net/tun.c:1991  tun_chr_write_iter+0xbd/0x156 drivers/net/tun.c:2037  call_write_iter include/linux/fs.h:1872 [inline]  do_iter_readv_writev+0x5f8/0x8f0 fs/read_write.c:693  do_iter_write fs/read_write.c:970 [inline]  do_iter_write+0x184/0x610 fs/read_write.c:951  vfs_writev+0x1b3/0x2f0 fs/read_write.c:1015  do_writev+0x15b/0x330 fs/read_write.c:1058  ",a4270d6795b0580287453ea55974d948393e66ef,1
io_uring: fail poll arm on queue proc failure,"Check the ipt.error value, it must have been either cleared to zero or set to another error than the default -EINVAL if we don't go through the waitqueue proc addition. Just give up on poll at that point and return failure, this will fallback to async work.  io_poll_add() doesn't suffer from this failure case, as it returns the error value directly.  ",a36da65c46565d2527eec3efdb546251e38253fd,0
mac80211: validate extended element ID is present,"Before attempting to parse an extended element, verify that the extended element ID is present.  ",768c0b19b50665e337c96858aa2b7928d6dcf756,0
ALSA: usb-audio: fix NULL ptr dereference in usb_audio_probe,"syzbot reported null pointer dereference in usb_audio_probe. The problem was in case, when quirk == NULL. It's not an error condition, so quirk must be checked before dereferencing.  Call Trace:  usb_probe_interface+0x315/0x7f0 drivers/usb/core/driver.c:396  really_probe+0x291/0xe60 drivers/base/dd.c:554  driver_probe_device+0x26b/0x3d0 drivers/base/dd.c:740  __device_attach_driver+0x1d1/0x290 drivers/base/dd.c:846  bus_for_each_drv+0x15f/0x1e0 drivers/base/bus.c:431  __device_attach+0x228/0x4a0 drivers/base/dd.c:914  bus_probe_device+0x1e4/0x290 drivers/base/bus.c:491  device_add+0xbdb/0x1db0 drivers/base/core.c:3242  usb_set_configuration+0x113f/0x1910 drivers/usb/core/message.c:2164  usb_generic_driver_probe+0xba/0x100 drivers/usb/core/generic.c:238  usb_probe_device+0xd9/0x2c0 drivers/usb/core/driver.c:293  really_probe+0x291/0xe60 drivers/base/dd.c:554  driver_probe_device+0x26b/0x3d0 drivers/base/dd.c:740  __device_attach_driver+0x1d1/0x290 drivers/base/dd.c:846  bus_for_each_drv+0x15f/0x1e0 drivers/base/bus.c:431  __device_attach+0x228/0x4a0 drivers/base/dd.c:914  bus_probe_device+0x1e4/0x290 drivers/base/bus.c:491  device_add+0xbdb/0x1db0 drivers/base/core.c:3242  usb_new_device.cold+0x721/0x1058 drivers/usb/core/hub.c:2555  hub_port_connect drivers/usb/core/hub.c:5223 [inline]  hub_port_connect_change drivers/usb/core/hub.c:5363 [inline]  port_event drivers/usb/core/hub.c:5509 [inline]  hub_event+0x2357/0x4320 drivers/usb/core/hub.c:5591  process_one_work+0x98d/0x1600 kernel/workqueue.c:2275  worker_thread+0x64c/0x1120 kernel/workqueue.c:2421  kthread+0x3b1/0x4a0 kernel/kthread.c:292  ret_from_fork+0x1f/0x30 arch/x86/entry/entry_64.S:294  ",30dea07180de3aa0ad613af88431ef4e34b5ef68,1
kasan: don't assume percpu shadow allocations will succeed,"syzkaller and the fault injector showed that I was wrong to assume that we could ignore percpu shadow allocation failures.  Handle failures properly.  Merge all the allocated areas back into the free list and release the shadow, then clean up and return NULL.  The shadow is released unconditionally, which relies upon the fact that the release function is able to tolerate pages not being present.  Also clean up shadows in the recovery path - currently they are not released, which leaks a bit of memory.  ",253a496d8e57275d458eb3c988470525b0b2c545,1
netfilter: arptables: use pernet ops struct during unregister,"Like with iptables and ebtables, hook unregistration has to use the pernet ops struct, not the template.  This triggered following splat:   hook not found, pf 3 num 0   ",43016d02cf6e46edfc4696452251d34bba0c0435,0
neigh: fix use-after-free read in pneigh_get_next,"Nine years ago, I added RCU handling to neighbours, not pneighbours. (pneigh are not commonly used)  Unfortunately I missed that /proc dump operations would use a common entry and exit point : neigh_seq_start() and neigh_seq_stop()  We need to read_lock(tbl->lock) or risk use-after-free while iterating the pneigh structures.  We might later convert pneigh to RCU and revert this patch.  sysbot reported :  BUG: KASAN: use-after-free in pneigh_get_next.isra.0+0x24b/0x280 net/core/neighbour.c:3158 Read of size 8 at addr ffff888097f2a700 by task syz-executor.0/9825  CPU: 1 PID: 9825 Comm: syz-executor.0 Not tainted 5.2.0-rc4+ #32 Hardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 01/01/2011 Call Trace:  __dump_stack lib/dump_stack.c:77 [inline]  dump_stack+0x172/0x1f0 lib/dump_stack.c:113  print_address_description.cold+0x7c/0x20d mm/kasan/report.c:188  __kasan_report.cold+0x1b/0x40 mm/kasan/report.c:317  kasan_report+0x12/0x20 mm/kasan/common.c:614  __asan_report_load8_noabort+0x14/0x20 mm/kasan/generic_report.c:132  pneigh_get_next.isra.0+0x24b/0x280 net/core/neighbour.c:3158  neigh_seq_next+0xdb/0x210 net/core/neighbour.c:3240  seq_read+0x9cf/0x1110 fs/seq_file.c:258  proc_reg_read+0x1fc/0x2c0 fs/proc/inode.c:221  do_loop_readv_writev fs/read_write.c:714 [inline]  do_loop_readv_writev fs/read_write.c:701 [inline]  do_iter_read+0x4a4/0x660 fs/read_write.c:935  vfs_readv+0xf0/0x160 fs/read_write.c:997  kernel_readv fs/splice.c:359 [inline]  default_file_splice_read+0x475/0x890 fs/splice.c:414  do_splice_to+0x127/0x180 fs/splice.c:877  splice_direct_to_actor+0x2d2/0x970 fs/splice.c:954  do_splice_direct+0x1da/0x2a0 fs/splice.c:1063  do_sendfile+0x597/0xd00 fs/read_write.c:1464  __do_sys_sendfile64 fs/read_write.c:1525 [inline]  __se_sys_sendfile64 fs/read_write.c:1511 [inline]  __x64_sys_sendfile64+0x1dd/0x220 fs/read_write.c:1511  do_syscall_64+0xfd/0x680 arch/x86/entry/common.c:301  entry_SYSCALL_64_after_hwframe+0x49/0xbe ",f3e92cb8e2eb8c27d109e6fd73d3a69a8c09e288,1
net: add strict checks in netdev_name_node_alt_destroy(),"netdev_name_node_alt_destroy() does a lookup over all device names of a namespace.  We need to make sure the name belongs to the device of interest, and that we do not destroy its primary name, since we rely on it being not deleted : dev->name_node would indeed point to freed memory.  syzbot report was the following :  BUG: KASAN: use-after-free in dev_net include/linux/netdevice.h:2206 [inline] BUG: KASAN: use-after-free in mld_force_mld_version net/ipv6/mcast.c:1172 [inline] BUG: KASAN: use-after-free in mld_in_v2_mode_only net/ipv6/mcast.c:1180 [inline] BUG: KASAN: use-after-free in mld_in_v1_mode+0x203/0x230 net/ipv6/mcast.c:1190 Read of size 8 at addr ffff88809886c588 by task swapper/1/0  CPU: 1 PID: 0 Comm: swapper/1 Not tainted 5.6.0-rc1-syzkaller #0 Hardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 01/01/2011 Call Trace:  <IRQ>  __dump_stack lib/dump_stack.c:77 [inline]  dump_stack+0x197/0x210 lib/dump_stack.c:118  print_address_description.constprop.0.cold+0xd4/0x30b mm/kasan/report.c:374  __kasan_report.cold+0x1b/0x32 mm/kasan/report.c:506  kasan_report+0x12/0x20 mm/kasan/common.c:641  __asan_report_load8_noabort+0x14/0x20 mm/kasan/generic_report.c:135  dev_net include/linux/netdevice.h:2206 [inline]  mld_force_mld_version net/ipv6/mcast.c:1172 [inline]  mld_in_v2_mode_only net/ipv6/mcast.c:1180 [inline]  mld_in_v1_mode+0x203/0x230 net/ipv6/mcast.c:1190  mld_send_initial_cr net/ipv6/mcast.c:2083 [inline]  mld_dad_timer_expire+0x24/0x230 net/ipv6/mcast.c:2118  call_timer_fn+0x1ac/0x780 kernel/time/timer.c:1404  expire_timers kernel/time/timer.c:1449 [inline]  __run_timers kernel/time/timer.c:1773 [inline]  __run_timers kernel/time/timer.c:1740 [inline]  run_timer_softirq+0x6c3/0x1790 kernel/time/timer.c:1786  __do_softirq+0x262/0x98c kernel/softirq.c:292  invoke_softirq kernel/softirq.c:373 [inline]  irq_exit+0x19b/0x1e0 kernel/softirq.c:413  exiting_irq arch/x86/include/asm/apic.h:546 [inline]  smp_apic_timer_interrupt+0x1a3/0x610 arch/x86/kernel/apic/apic.c:1146  apic_timer_interrupt+0xf/0x20 arch/x86/entry/entry_64.S:829  </IRQ> ",e08ad80551b4b33c02f2fce1522f6c227d3976cf,1
media: dvb-usb: fix memory leak in dvb_usb_adapter_init,"syzbot reported memory leak in dvb-usb. The problem was in invalid error handling in dvb_usb_adapter_init().  for (n = 0; n < d->props.num_adapters; n++) { .... 	if ((ret = dvb_usb_adapter_stream_init(adap)) || 		(ret = dvb_usb_adapter_dvb_init(adap, adapter_nrs)) || 		(ret = dvb_usb_adapter_frontend_init(adap))) { 		return ret; 	} ... 	d->num_adapters_initialized++; ... }  In case of error in dvb_usb_adapter_dvb_init() or dvb_usb_adapter_dvb_init() d->num_adapters_initialized won't be incremented, but dvb_usb_adapter_exit() relies on it:  	for (n = 0; n < d->num_adapters_initialized; n++)  So, allocated objects won't be freed.  ",b7cd0da982e3043f2eec7235ac5530cb18d6af1d,1
memcg: fix per_node_info cleanup,syzbot has triggered a NULL ptr dereference when allocation fault injection enforces a failure and alloc_mem_cgroup_per_node_info initializes memcg->nodeinfo only half way through.  But __mem_cgroup_free still tries to free all per-node data and dereferences pn->lruvec_stat_cpu unconditioanlly even if the specific per-node data hasn't been initialized.  The bug is quite unlikely to hit because small allocations do not fail and we would need quite some numa nodes to make struct mem_cgroup_per_node large enough to cross the costly order.  ,4eaf431f6f71bbed40a4c733ffe93a7e8cedf9d9,1
net: sched: tapr: prevent cycle_time == 0 in parse_taprio_schedule,"There is a reproducible sequence from the userland that will trigger a WARN_ON() condition in taprio_get_start_time, which causes kernel to panic if configured as ""panic_on_warn"". Catch this condition in parse_taprio_schedule to prevent this condition.  Reported as bug on syzkaller: https://syzkaller.appspot.com/bug?extid=d50710fd0873a9c6b40c  ",ed8157f1ebf1ae81a8fa2653e3f20d2076fad1c9,1
rds: tcp: correctly sequence cleanup on netns deletion.,"Commit 8edc3affc077 (""rds: tcp: Take explicit refcounts on struct net"") introduces a regression in rds-tcp netns cleanup. The cleanup_net(), (and thus rds_tcp_dev_event notification) is only called from put_net() when all netns refcounts go to 0, but this cannot happen if the rds_connection itself is holding a c_net ref that it expects to release in rds_tcp_kill_sock.  Instead, the rds_tcp_kill_sock callback should make sure to tear down state carefully, ensuring that the socket teardown is only done after all data-structures and workqs that depend on it are quiesced.  The original motivation for commit 8edc3affc077 (""rds: tcp: Take explicit refcounts on struct net"") was to resolve a race condition reported by syzkaller where workqs for tx/rx/connect were triggered after the namespace was deleted. Those worker threads should have been cancelled/flushed before socket tear-down and indeed, rds_conn_path_destroy() does try to sequence this by doing      ",681648e67d43cf269c5590ecf021ed481f4551fc,1
xfrm: don't call xfrm_policy_cache_flush while holding spinlock,"xfrm_policy_cache_flush can sleep, so it cannot be called while holding a spinlock.  We could release the lock first, but I don't see why we need to invoke this function here in first place, the packet path won't reuse an xdst entry unless its still valid.  While at it, add an annotation to xfrm_policy_cache_flush, it would have probably caught this bug sooner.  ",b1bdcb59b64f806ef08d25a85c39ffb3ad841ce6,0
ipv6: fix static key imbalance in fl_create(),"fl_create() should call static_branch_deferred_inc() only in case of success.  Also we should not call fl_free() in error path, as this could cause a static key imbalance.  jump label: negative count! ",d44e3fa5d7e6e9573c69f6f9f4f7f3200b0c9eee,0
fou: Prevent unbounded recursion in GUE error handler also with UDP-Lite,"In commit 11789039da53 (""fou: Prevent unbounded recursion in GUE error handler""), I didn't take care of the case where UDP-Lite is encapsulated into UDP or UDP-Lite with GUE. From a syzbot report about a possibly similar issue with GUE on IPv6, I just realised the same thing might happen with a UDP-Lite inner payload.  Also skip exception handling for inner UDP-Lite protocol.  ",bc6e019b6ee65ff4ebf3ca272f774cf6c67db669,1
chardev: Avoid potential use-after-free in 'chrdev_open()',"'chrdev_open()' calls 'cdev_get()' to obtain a reference to the 'struct cdev *' stashed in the 'i_cdev' field of the target inode structure. If the pointer is NULL, then it is initialised lazily by looking up the kobject in the 'cdev_map' and so the whole procedure is protected by the 'cdev_lock' spinlock to serialise initialisation of the shared pointer.  Unfortunately, it is possible for the initialising thread to fail *after* installing the new pointer, for example if the subsequent '->open()' call on the file fails. In this case, 'cdev_put()' is called, the reference count on the kobject is dropped and, if nobody else has taken a reference, the release function is called which finally clears 'inode->i_cdev' from 'cdev_purge()' before potentially freeing the object. The problem here is that a racing thread can happily take the 'cdev_lock' and see the non-NULL pointer in the inode, which can result in a refcount increment from zero and a warning:    |  ",68faa679b8be1a74e6663c21c3a9d25d32f1c079,1
net-sysfs: Call dev_hold always in rx_queue_add_kobject,Dev_hold has to be called always in rx_queue_add_kobject. Otherwise usage count drops below 0 in case of failure in kobject_init_and_add.  ,ddd9b5e3e765d8ed5a35786a6cb00111713fe161,0
"Revert ""vc_screen: extract vcs_read_buf_header""","This reverts commit b1c32fcfadf5593ab7a63261cc8a5747c36e627e, because Syzkaller reports a use-after-free, a write in vcs_read:  BUG: KASAN: use-after-free in vcs_read_buf drivers/tty/vt/vc_screen.c:357 [inline] BUG: KASAN: use-after-free in vcs_read+0xaa7/0xb40 drivers/tty/vt/vc_screen.c:449 Write of size 2 at addr ffff8880a8014000 by task syz-executor.5/16936 CPU: 1 PID: 16936 Comm: syz-executor.5 Not tainted 5.9.0-rc1-next-20200820-syzkaller #0 Hardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 01/01/2011 Call Trace: ...  kasan_report.cold+0x1f/0x37 mm/kasan/report.c:530  vcs_read_buf drivers/tty/vt/vc_screen.c:357 [inline]  vcs_read+0xaa7/0xb40 drivers/tty/vt/vc_screen.c:449  There are two issues with the patch: 1) vcs_read rounds the 'count' *up* to an even number. So if we read odd    bytes from the header (3 bytes in the reproducer), the second byte of    a (2-byte/ushort) write to temporary con_buf won't fit. It is because    with the patch applied, we only subtract the real number read (3 bytes)    and not the whole header (4 bytes).  2) in this scenario, we perform unaligned accesses now: there are    2-byte/ushort writes to odd addresses. Due to the same reason as    above.  Revert this for now, re-think and retry later.  ",52c3c3a59234a9725b5dcfe9729ed737d7843980,1
ieee802154: hwsim: Fix memory leak in hwsim_add_one,"No matter from hwsim_remove or hwsim_del_radio_nl, hwsim_del fails to remove the entry in the edges list. Take the example below, phy0, phy1 and e0 will be deleted, resulting in e1 not freed and accessed in the future.                hwsim_phys                   |     ",28a5501c3383f0e6643012c187b7c2027ef42aea,1
net/neigh: fix NULL deref in pneigh_dump_table(),"pneigh can have NULL device pointer, so we need to make neigh_master_filtered() and neigh_ifindex_filtered() more robust.  syzbot report :  kasan: CONFIG_KASAN_INLINE enabled kasan: GPF could be caused by NULL-ptr deref or user memory access general protection fault: 0000 [#1] PREEMPT SMP KASAN CPU: 0 PID: 15867 Comm: syz-executor2 Not tainted 4.19.0+ #276 Hardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 01/01/2011 ",aab456dfa404f3a16d6f1780e62a6a8533c4d008,1
RDMA/cma: Execute rdma_cm destruction from a handler properly,"When a rdma_cm_id needs to be destroyed after a handler callback fails, part of the destruction pattern is open coded into each call site.  Unfortunately the blind assignment to state discards important information needed to do cma_cancel_operation(). This results in active operations being left running after rdma_destroy_id() completes, and the use-after-free bugs from KASAN.  Consolidate this entire pattern into destroy_id_handler_unlock() and manage the locking correctly. The state should be set to RDMA_CM_DESTROYING under the handler_lock to atomically ensure no futher handlers are called.  ",f6a9d47ae6854980fc4b1676f1fe9f9fa45ea4e2,1
ipv6: tunnels: fix two use-after-free,"xfrm6_policy_check() might have re-allocated skb->head, we need to reload ipv6 header pointer.  sysbot reported :  BUG: KASAN: use-after-free in __ipv6_addr_type+0x302/0x32f net/ipv6/addrconf_core.c:40 Read of size 4 at addr ffff888191b8cb70 by task syz-executor2/1304  CPU: 0 PID: 1304 Comm: syz-executor2 Not tainted 4.20.0-rc7+ #356 Hardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 01/01/2011 Call Trace:  <IRQ>  __dump_stack lib/dump_stack.c:77 [inline]  dump_stack+0x244/0x39d lib/dump_stack.c:113  print_address_description.cold.7+0x9/0x1ff mm/kasan/report.c:256  kasan_report_error mm/kasan/report.c:354 [inline]  kasan_report.cold.8+0x242/0x309 mm/kasan/report.c:412  __asan_report_load4_noabort+0x14/0x20 mm/kasan/report.c:432  __ipv6_addr_type+0x302/0x32f net/ipv6/addrconf_core.c:40  ipv6_addr_type include/net/ipv6.h:403 [inline]  ip6_tnl_get_cap+0x27/0x190 net/ipv6/ip6_tunnel.c:727  ip6_tnl_rcv_ctl+0xdb/0x2a0 net/ipv6/ip6_tunnel.c:757  vti6_rcv+0x336/0x8f3 net/ipv6/ip6_vti.c:321  xfrm6_ipcomp_rcv+0x1a5/0x3a0 net/ipv6/xfrm6_protocol.c:132  ip6_protocol_deliver_rcu+0x372/0x1940 net/ipv6/ip6_input.c:394  ip6_input_finish+0x84/0x170 net/ipv6/ip6_input.c:434  NF_HOOK include/linux/netfilter.h:289 [inline]  ip6_input+0xe9/0x600 net/ipv6/ip6_input.c:443 IPVS: ftp: loaded support on port[0] = 21  ip6_mc_input+0x514/0x11c0 net/ipv6/ip6_input.c:537  dst_input include/net/dst.h:450 [inline]  ip6_rcv_finish+0x17a/0x330 net/ipv6/ip6_input.c:76  NF_HOOK include/linux/netfilter.h:289 [inline]  ipv6_rcv+0x115/0x640 net/ipv6/ip6_input.c:272  __netif_receive_skb_one_core+0x14d/0x200 net/core/dev.c:4973  __netif_receive_skb+0x2c/0x1e0 net/core/dev.c:5083  process_backlog+0x24e/0x7a0 net/core/dev.c:5923  napi_poll net/core/dev.c:6346 [inline]  net_rx_action+0x7fa/0x19b0 net/core/dev.c:6412  __do_softirq+0x308/0xb7e kernel/softirq.c:292  do_softirq_own_stack+0x2a/0x40 arch/x86/entry/entry_64.S:1027  </IRQ>  do_softirq.part.14+0x126/0x160 kernel/softirq.c:337  do_softirq+0x19/0x20 kernel/softirq.c:340  netif_rx_ni+0x521/0x860 net/core/dev.c:4569  dev_loopback_xmit+0x287/0x8c0 net/core/dev.c:3576  NF_HOOK include/linux/netfilter.h:289 [inline]  ip6_finish_output2+0x193a/0x2930 net/ipv6/ip6_output.c:84  ip6_fragment+0x2b06/0x3850 net/ipv6/ip6_output.c:727  ip6_finish_output+0x6b7/0xc50 net/ipv6/ip6_output.c:152  NF_HOOK_COND include/linux/netfilter.h:278 [inline]  ip6_output+0x232/0x9d0 net/ipv6/ip6_output.c:171  dst_output include/net/dst.h:444 [inline]  ip6_local_out+0xc5/0x1b0 net/ipv6/output_core.c:176  ip6_send_skb+0xbc/0x340 net/ipv6/ip6_output.c:1727  ip6_push_pending_frames+0xc5/0xf0 net/ipv6/ip6_output.c:1747  rawv6_push_pending_frames net/ipv6/raw.c:615 [inline]  rawv6_sendmsg+0x3a3e/0x4b40 net/ipv6/raw.c:945 kobject: 'queues' (0000000089e6eea2): kobject_add_internal: parent: 'tunl0', set: '<NULL>' kobject: 'queues' (0000000089e6eea2): kobject_uevent_env  inet_sendmsg+0x1a1/0x690 net/ipv4/af_inet.c:798 kobject: 'queues' (0000000089e6eea2): kobject_uevent_env: filter function caused the event to drop!  sock_sendmsg_nosec net/socket.c:621 [inline]  sock_sendmsg+0xd5/0x120 net/socket.c:631  sock_write_iter+0x35e/0x5c0 net/socket.c:900  call_write_iter include/linux/fs.h:1857 [inline]  new_sync_write fs/read_write.c:474 [inline]  __vfs_write+0x6b8/0x9f0 fs/read_write.c:487 kobject: 'rx-0' (00000000e2d902d9): kobject_add_internal: parent: 'queues', set: 'queues' kobject: 'rx-0' (00000000e2d902d9): kobject_uevent_env  vfs_write+0x1fc/0x560 fs/read_write.c:549  ksys_write+0x101/0x260 fs/read_write.c:598 kobject: 'rx-0' (00000000e2d902d9): fill_kobj_path: path = '/devices/virtual/net/tunl0/queues/rx-0'  __do_sys_write fs/read_write.c:610 [inline]  __se_sys_write fs/read_write.c:607 [inline]  __x64_sys_write+0x73/0xb0 fs/read_write.c:607  do_syscall_64+0x1b9/0x820 arch/x86/entry/common.c:290 kobject: 'tx-0' (00000000443b70ac): kobject_add_internal: parent: 'queues', set: 'queues'  entry_SYSCALL_64_after_hwframe+0x49/0xbe ",cbb49697d5512ce9e61b45ce75d3ee43d7ea5524,1
"netfilter: ipset: Fix ""INFO: rcu detected stall in hash_xxx"" reports","In the case of huge hash:* types of sets, due to the single spinlock of a set the processing of the whole set under spinlock protection could take too long.  There were four places where the whole hash table of the set was processed from bucket to bucket under holding the spinlock:  - During resizing a set, the original set was locked to exclude kernel side   add/del element operations (userspace add/del is excluded by the   nfnetlink mutex). The original set is actually just read during the   resize, so the spinlocking is replaced with rcu locking of regions.   However, thus there can be parallel kernel side add/del of entries.   In order not to loose those operations a backlog is added and replayed   after the successful resize. - Garbage collection of timed out entries was also protected by the spinlock.   In order not to lock too long, region locking is introduced and a single   region is processed in one gc go. Also, the simple timer based gc running   is replaced with a workqueue based solution. The internal book-keeping   (number of elements, size of extensions) is moved to region level due to   the region locking. - Adding elements: when the max number of the elements is reached, the gc   was called to evict the timed out entries. The new approach is that the gc   is called just for the matching region, assuming that if the region   (proportionally) seems to be full, then the whole set does. We could scan   the other regions to check every entry under rcu locking, but for huge   sets it'd mean a slowdown at adding elements. - Listing the set header data: when the set was defined with timeout   support, the garbage collector was called to clean up timed out entries   to get the correct element numbers and set size values. Now the set is   scanned to check non-timed out entries, without actually calling the gc   for the whole set.  ",f66ee0410b1c3481ee75e5db9b34547b4d582465,0
ALSA: control: Fix race between adding and removing a user element,"The procedure for adding a user control element has some window opened for race against the concurrent removal of a user element.  This was caught by syzkaller, hitting a KASAN use-after-free error.  This patch addresses the bug by wrapping the whole procedure to add a user control element with the card->controls_rwsem, instead of only around the increment of card->user_ctl_count.  This required a slight code refactoring, too.  The function snd_ctl_add() is split to two parts: a core function to add the control element and a part calling it.  The former is called from the function for adding a user control element inside the controls_rwsem.  One change to be noted is that snd_ctl_notify() for adding a control element gets called inside the controls_rwsem as well while it was called outside the rwsem.  But this should be OK, as snd_ctl_notify() takes another (finer) rwlock instead of rwsem, and the call of snd_ctl_notify() inside rwsem is already done in another code path.  ",e1a7bfe3807974e66f971f2589d4e0197ec0fced,1
bpf: Add oversize check before call kvcalloc(),"Commit 7661809d493b (""mm: don't allow oversized kvmalloc() calls"") add the oversize check. When the allocation is larger than what kmalloc() supports, the following warning triggered:  ",0e6491b559704da720f6da09dd0a52c4df44c514,0
ucma: fix a use-after-free in ucma_resolve_ip(),"There is a race condition between ucma_close() and ucma_resolve_ip():  CPU0				CPU1 ucma_resolve_ip():		ucma_close():  ctx = ucma_get_ctx(file, cmd.id);          list_for_each_entry_safe(ctx, tmp, &file->ctx_list, list) {                 mutex_lock(&mut);                 idr_remove(&ctx_idr, ctx->id);                 mutex_unlock(&mut); 		...                 mutex_lock(&mut);                 if (!ctx->closing) {                         mutex_unlock(&mut);                         rdma_destroy_id(ctx->cm_id); 		...                 ucma_free_ctx(ctx);  ret = rdma_resolve_addr(); ucma_put_ctx(ctx);  Before idr_remove(), ucma_get_ctx() could still find the ctx and after rdma_destroy_id(), rdma_resolve_addr() may still access id_priv pointer. Also, ucma_put_ctx() may use ctx after ucma_free_ctx() too.  ucma_close() should call ucma_put_ctx() too which tests the refcnt and waits for the last one releasing it. The similar pattern is already used by ucma_destroy_id().  ",5fe23f262e0548ca7f19fb79f89059a60d087d22,1
binder: Don't use mmput() from shrinker function.,"syzbot is reporting that mmput() from shrinker function has a risk of deadlock [1], for delayed_uprobe_add() from update_ref_ctr() calls kzalloc(GFP_KERNEL) with delayed_uprobe_lock held, and uprobe_clear_state() from __mmput() also holds delayed_uprobe_lock.  Commit a1b2289cef92ef0e (""android: binder: drop lru lock in isolate callback"") replaced mmput() with mmput_async() in order to avoid sleeping with spinlock held. But this patch replaces mmput() with mmput_async() in order not to start __mmput() from shrinker context.  [1] https://syzkaller.appspot.com/bug?id=bc9e7303f537c41b2b0cc2dfcea3fc42964c2d45  ",f867c771f98891841c217fa8459244ed0dd28921,1
USB: Fix slab-out-of-bounds write in usb_get_bos_descriptor,"The syzkaller USB fuzzer found a slab-out-of-bounds write bug in the USB core, caused by a failure to check the actual size of a BOS descriptor.  This patch adds a check to make sure the descriptor is at least as large as it is supposed to be, so that the code doesn't inadvertently access memory beyond the end of the allocated region when assigning to dev->bos->desc->bNumDeviceCaps later on.  ",a03ff54460817c76105f81f3aa8ef655759ccc9a,1
sctp: update active_key for asoc when old key is being replaced,"syzbot reported a call trace:    BUG: KASAN: use-after-free in sctp_auth_shkey_hold+0x22/0xa0 net/sctp/auth.c:112   Call Trace:    sctp_auth_shkey_hold+0x22/0xa0 net/sctp/auth.c:112    sctp_set_owner_w net/sctp/socket.c:131 [inline]    sctp_sendmsg_to_asoc+0x152e/0x2180 net/sctp/socket.c:1865    sctp_sendmsg+0x103b/0x1d30 net/sctp/socket.c:2027    inet_sendmsg+0x99/0xe0 net/ipv4/af_inet.c:821    sock_sendmsg_nosec net/socket.c:703 [inline]    sock_sendmsg+0xcf/0x120 net/socket.c:723  This is an use-after-free issue caused by not updating asoc->shkey after it was replaced in the key list asoc->endpoint_shared_keys, and the old key was freed.  This patch is to fix by also updating active_key for asoc when old key is being replaced with a new one. Note that this issue doesn't exist in sctp_auth_del_key_id(), as it's not allowed to delete the active_key from the asoc.  ",58acd10092268831e49de279446c314727101292,1
tcp: annotate tp->copied_seq lockless reads,"There are few places where we fetch tp->copied_seq while this field can change from IRQ or other cpu.  We need to add READ_ONCE() annotations, and also make sure write sides use corresponding WRITE_ONCE() to avoid store-tearing.  Note that tcp_inq_hint() was already using READ_ONCE(tp->copied_seq)  ",7db48e983930285b765743ebd665aecf9850582b,0
dccp: defer ccid_hc_tx_delete() at dismantle time,"syszkaller team reported another problem in DCCP [1]  Problem here is that the structure holding RTO timer (ccid2_hc_tx_rto_expire() handler) is freed too soon.  We can not use del_timer_sync() to cancel the timer since this timer wants to grab socket lock (that would risk a dead lock)  Solution is to defer the freeing of memory when all references to the socket were released. Socket timers do own a reference, so this should fix the issue.  [1]  ",120e9dabaf551c6dc03d3a10a1f026376cb1811c,0
Bluetooth: add a mutex lock to avoid UAF in do_enale_set,"In the case we set or free the global value listen_chan in different threads, we can encounter the UAF problems because the method is not protected by any lock, add one to avoid this bug.  BUG: KASAN: use-after-free in l2cap_chan_close+0x48/0x990 net/bluetooth/l2cap_core.c:730 Read of size 8 at addr ffff888096950000 by task kworker/1:102/2868  CPU: 1 PID: 2868 Comm: kworker/1:102 Not tainted 5.5.0-syzkaller #0 Hardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 01/01/2011 Workqueue: events do_enable_set Call Trace:  __dump_stack lib/dump_stack.c:77 [inline]  dump_stack+0x1fb/0x318 lib/dump_stack.c:118  print_address_description+0x74/0x5c0 mm/kasan/report.c:374  __kasan_report+0x149/0x1c0 mm/kasan/report.c:506  kasan_report+0x26/0x50 mm/kasan/common.c:641  __asan_report_load8_noabort+0x14/0x20 mm/kasan/generic_report.c:135  l2cap_chan_close+0x48/0x990 net/bluetooth/l2cap_core.c:730  do_enable_set+0x660/0x900 net/bluetooth/6lowpan.c:1074  process_one_work+0x7f5/0x10f0 kernel/workqueue.c:2264  worker_thread+0xbbc/0x1630 kernel/workqueue.c:2410  kthread+0x332/0x350 kernel/kthread.c:255  ret_from_fork+0x24/0x30 arch/x86/entry/entry_64.S:352  Allocated by task 2870:  save_stack mm/kasan/common.c:72 [inline]  set_track mm/kasan/common.c:80 [inline]  __kasan_kmalloc+0x118/0x1c0 mm/kasan/common.c:515  kasan_kmalloc+0x9/0x10 mm/kasan/common.c:529  kmem_cache_alloc_trace+0x221/0x2f0 mm/slab.c:3551  kmalloc include/linux/slab.h:555 [inline]  kzalloc include/linux/slab.h:669 [inline]  l2cap_chan_create+0x50/0x320 net/bluetooth/l2cap_core.c:446  chan_create net/bluetooth/6lowpan.c:640 [inline]  bt_6lowpan_listen net/bluetooth/6lowpan.c:959 [inline]  do_enable_set+0x6a4/0x900 net/bluetooth/6lowpan.c:1078  process_one_work+0x7f5/0x10f0 kernel/workqueue.c:2264  worker_thread+0xbbc/0x1630 kernel/workqueue.c:2410  kthread+0x332/0x350 kernel/kthread.c:255  ret_from_fork+0x24/0x30 arch/x86/entry/entry_64.S:352  Freed by task 2870:  save_stack mm/kasan/common.c:72 [inline]  set_track mm/kasan/common.c:80 [inline]  kasan_set_free_info mm/kasan/common.c:337 [inline]  __kasan_slab_free+0x12e/0x1e0 mm/kasan/common.c:476  kasan_slab_free+0xe/0x10 mm/kasan/common.c:485  __cache_free mm/slab.c:3426 [inline]  kfree+0x10d/0x220 mm/slab.c:3757  l2cap_chan_destroy net/bluetooth/l2cap_core.c:484 [inline]  kref_put include/linux/kref.h:65 [inline]  l2cap_chan_put+0x170/0x190 net/bluetooth/l2cap_core.c:498  do_enable_set+0x66c/0x900 net/bluetooth/6lowpan.c:1075  process_one_work+0x7f5/0x10f0 kernel/workqueue.c:2264  worker_thread+0xbbc/0x1630 kernel/workqueue.c:2410  kthread+0x332/0x350 kernel/kthread.c:255  ret_from_fork+0x24/0x30 arch/x86/entry/entry_64.S:352  The buggy address belongs to the object at ffff888096950000  which belongs to the cache kmalloc-2k of size 2048 The buggy address is located 0 bytes inside of  2048-byte region [ffff888096950000, ffff888096950800) The buggy address belongs to the page: page:ffffea00025a5400 refcount:1 mapcount:0 mapping:ffff8880aa400e00 index:0x0 flags: 0xfffe0000000200(slab) raw: 00fffe0000000200 ffffea00027d1548 ffffea0002397808 ffff8880aa400e00 raw: 0000000000000000 ffff888096950000 0000000100000001 0000000000000000 page dumped because: kasan: bad access detected  Memory state around the buggy ",f9c70bdc279b191da8d60777c627702c06e4a37d,1
net/smc: propagate file from SMC to TCP socket,"fcntl(fd, F_SETOWN, getpid()) selects the recipient of SIGURG signals that are delivered when out-of-band data arrives on socket fd. If an SMC socket program makes use of such an fcntl() call, it fails in case of fallback to TCP-mode. In case of fallback the traffic is processed with the internal TCP socket. Propagating field ""file"" from the SMC socket to the internal TCP socket fixes the issue.  ",07603b230895a74ebb1e2a1231ac45c29c2a8cd3,0
staging: android: ashmem: Fix possible deadlock in ashmem_ioctl,ashmem_mutex may create a chain of dependencies like:  CPU0                                    CPU1  mmap syscall                           ioctl syscall  -> mmap_sem (acquired)                 -> ashmem_ioctl  -> ashmem_mmap                            -> ashmem_mutex (acquired)     -> ashmem_mutex (try to acquire)       -> copy_from_user                                               -> mmap_sem (try to acquire)  There is a lock odering problem between mmap_sem and ashmem_mutex causing a lockdep splat[1] during a syzcaller test. This patch fixes the problem by move copy_from_user out of ashmem_mutex.  [1] https://www.spinics.net/lists/kernel/msg2733200.html  ,740a5759bf222332fbb5eda42f89aa25ba38f9b2,0
ALSA: seq: Fix race of snd_seq_timer_open(),"The timer instance per queue is exclusive, and snd_seq_timer_open() should have managed the concurrent accesses.  It looks as if it's checking the already existing timer instance at the beginning, but it's not right, because there is no protection, hence any later concurrent call of snd_seq_timer_open() may override the timer instance easily.  This may result in UAF, as the leftover timer instance can keep running while the queue itself gets closed, as spotted by syzkaller recently.  For avoiding the race, add a proper check at the assignment of tmr->timeri again, and return -EBUSY if it's been already registered.  ",83e197a8414c0ba545e7e3916ce05f836f349273,1
"bpf, sockhash: Synchronize delete from bucket list on map free","We can end up modifying the sockhash bucket list from two CPUs when a sockhash is being destroyed (sock_hash_free) on one CPU, while a socket that is in the sockhash is unlinking itself from it on another CPU it (sock_hash_delete_from_link).  This results in accessing a list element that is in an undefined state as reported by KASAN:  | ",75e68e5bf2c7fa9d3e874099139df03d5952a3e1,1
netdevsim: fix nsim_fib6_rt_create() error path,It seems nsim_fib6_rt_create() intent was to return either a valid pointer or an embedded error code.  BUG: unable to handle page fault for ,41cdc741048b0d04604c02aad9ec19f7d9130b70,1
exfat: fix use of uninitialized spinlock on error path,"syzbot reported warning message:  Call Trace:  __dump_stack lib/dump_stack.c:77 [inline]  dump_stack+0x1d6/0x29e lib/dump_stack.c:118  register_lock_class+0xf06/0x1520 kernel/locking/lockdep.c:893  __lock_acquire+0xfd/0x2ae0 kernel/locking/lockdep.c:4320  lock_acquire+0x148/0x720 kernel/locking/lockdep.c:5029  __raw_spin_lock include/linux/spinlock_api_smp.h:142 [inline]  _raw_spin_lock+0x2a/0x40 kernel/locking/spinlock.c:151  spin_lock include/linux/spinlock.h:354 [inline]  exfat_cache_inval_inode+0x30/0x280 fs/exfat/cache.c:226  exfat_evict_inode+0x124/0x270 fs/exfat/inode.c:660  evict+0x2bb/0x6d0 fs/inode.c:576  exfat_fill_super+0x1e07/0x27d0 fs/exfat/super.c:681  get_tree_bdev+0x3e9/0x5f0 fs/super.c:1342  vfs_get_tree+0x88/0x270 fs/super.c:1547  do_new_mount fs/namespace.c:2875 [inline]  path_mount+0x179d/0x29e0 fs/namespace.c:3192  do_mount fs/namespace.c:3205 [inline]  __do_sys_mount fs/namespace.c:3413 [inline]  __se_sys_mount+0x126/0x180 fs/namespace.c:3390  do_syscall_64+0x31/0x70 arch/x86/entry/common.c:46  entry_SYSCALL_64_after_hwframe+0x44/0xa9  If exfat_read_root() returns an error, spinlock is used in exfat_evict_inode() without initialization. This patch combines exfat_cache_init_inode() with exfat_inode_init_once() to initialize spinlock by slab constructor.  ",8ff006e57ad3a25f909c456d053aa498b6673a39,1
KVM: VMX: Reject KVM_RUN if emulation is required with pending exception,"Reject KVM_RUN if emulation is required (because VMX is running without unrestricted guest) and an exception is pending, as KVM doesn't support emulating exceptions except when emulating real mode via vm86.  The vCPU is hosed either way, but letting KVM_RUN proceed triggers a WARN due to the impossible condition.  Alternatively, the WARN could be removed, but then userspace and/or KVM bugs would result in the vCPU silently running in a bad state, which isn't very friendly to users.  Originally, the bug was hit by syzkaller with a nested guest as that doesn't require kvm_intel.unrestricted_guest=0.  That particular flavor is likely fixed by commit cd0e615c49e5 (""KVM: nVMX: Synthesize TRIPLE_FAULT for L2 if emulation is required""), but it's trivial to trigger the WARN with a non-nested guest, and userspace can likely force bad state via ioctls() for a nested guest as well.  Checking for the impossible condition needs to be deferred until KVM_RUN because KVM can't force specific ordering between ioctls.  E.g. clearing exception.pending in KVM_SET_SREGS doesn't prevent userspace from setting it in KVM_SET_VCPU_EVENTS, and disallowing KVM_SET_VCPU_EVENTS with emulation_required would prevent userspace from queuing an exception and then stuffing sregs.  Note, if KVM were to try and detect/prevent the condition prior to KVM_RUN, handle_invalid_guest_state() and/or handle_emulation_failure() would need to be modified to clear the pending exception prior to exiting to userspace.   ",fc4fad79fc3d8841562e2a85808079da5b4835f6,1
ethtool: fix stack overflow in ethnl_parse_bitset(),"Syzbot reported a stack overflow in bitmap_from_arr32() called from ethnl_parse_bitset() when bitset from netlink message is longer than target bitmap length. While ethnl_compact_sanity_checks() makes sure that trailing part is all zeros (i.e. the request does not try to touch bits kernel does not recognize), we also need to cap change_bits to nbits so that we don't try to write past the prepared bitmaps.  ",a770bf515613c6e12ae904c3593e26016de99448,1
fbmem: pull fbcon_update_vcs() out of fb_set_var(),"syzbot is reporting OOB read bug in vc_do_resize() [1] caused by memcpy() based on outdated old_{rows,row_size} values, for resize_screen() can recurse into vc_do_resize() which changes vc->vc_{cols,rows} that outdates old_{rows,row_size} values which were saved before calling resize_screen().  Daniel Vetter explained that resize_screen() should not recurse into fbcon_update_vcs() path due to FBINFO_MISC_USEREVENT being still set when calling resize_screen().  Instead of masking FBINFO_MISC_USEREVENT before calling fbcon_update_vcs(), we can remove FBINFO_MISC_USEREVENT by calling fbcon_update_vcs() only if fb_set_var() returned 0. This change assumes that it is harmless to call fbcon_update_vcs() when fb_set_var() returned 0 without reaching fb_notifier_call_chain().  [1] https://syzkaller.appspot.com/bug?id=c70c88cfd16dcf6e1d3c7f0ab8648b3144b5b25e  ",d88ca7e1a27eb2df056bbf37ddef62e1c73d37ea,1
Bluetooth: add timeout sanity check to hci_inquiry,"Syzbot hit ""task hung"" bug in hci_req_sync(). The problem was in unreasonable huge inquiry timeout passed from userspace. Fix it by adding sanity check for timeout value to hci_inquiry().  Since hci_inquiry() is the only user of hci_req_sync() with user controlled timeout value, it makes sense to check timeout value in hci_inquiry() and don't touch hci_req_sync().  ",f41a4b2b5eb7872109723dab8ae1603bdd9d9ec1,1
bpf: fix NULL deref in btf_type_is_resolve_source_only,"Commit 1dc92851849c (""bpf: kernel side support for BTF Var and DataSec"") added invocations of btf_type_is_resolve_source_only before btf_type_nosize_or_null which checks for the NULL pointer. Swap the order of btf_type_nosize_or_null and btf_type_is_resolve_source_only to make sure the do the NULL pointer check first.  ",e4f07120210a1794c1f1ae64d209a2fbc7bd2682,0
"mm,thp: recheck each page before collapsing file THP","In collapse_file(), for !is_shmem case, current check cannot guarantee the locked page is up-to-date.  Specifically, xas_unlock_irq() should not be called before lock_page() and get_page(); and it is necessary to recheck PageUptodate() after locking the page.  With this bug and CONFIG_READ_ONLY_THP_FOR_FS=y, madvise(HUGE)'ed .text may contain corrupted data.  This is because khugepaged mistakenly collapses some not up-to-date sub pages into a huge page, and assumes the huge page is up-to-date.  This will NOT corrupt data in the disk, because the page is read-only and never written back.  Fix this by properly checking PageUptodate() after locking the page.  This check replaces ""VM_BUG_ON_PAGE(!PageUptodate(page), page);"".  Also, move PageDirty() check after locking the page.  Current khugepaged should not try to collapse dirty file THP, because it is limited to read-only .text.  The only case we hit a dirty page here is when the page hasn't been written since write.  Bail out and retry when this happens.  syzbot reported bug on previous version of this patch.  ",4655e5e5f387264fd22a835bcfbe4af6691ff774,1
ALSA: pcm: oss: Fix potential out-of-bounds shift,"syzbot spotted a potential out-of-bounds shift in the PCM OSS layer where it calculates the buffer size with the arbitrary shift value given via an ioctl.  Add a range check for avoiding the undefined behavior. As the value can be treated by a signed integer, the max shift should be 30.  ",175b8d89fe292796811fdee87fa39799a5b6b87a,1
RDMA/core: Don't infoleak GRH fields,"If dst->is_global field is not set, the GRH fields are not cleared and the following infoleak is reported.  ",b35a0f4dd544eaa6162b6d2f13a2557a121ae5fd,1
fuse: Fix use-after-free in fuse_dev_do_read(),"We may pick freed req in this way:  [cpu0]                                  [cpu1] fuse_dev_do_read()                      fuse_dev_do_write()    list_move_tail(&req->list, ...);     ...    spin_unlock(&fpq->lock);             ...    ...                                  request_end(fc, req);    ...                                    fuse_put_request(fc, req);    if (test_bit(FR_INTERRUPTED, ...))          queue_interrupt(fiq, req);  Fix that by keeping req alive until we finish all manipulations.  ",bc78abbd55dd28e2287ec6d6502b842321a17c87,1
ALSA: usb-audio: Fix UBSAN warnings for MIDI jacks,"The calculation of in_cables and out_cables bitmaps are done with the bit shift by the value from the descriptor, which is an arbitrary value, and can lead to UBSAN shift-out-of-bounds warnings.  Fix it by filtering the bad descriptor values with the check of the upper bound 0x10 (the cable bitmaps are 16 bits).  ",c06ccf3ebb7503706ea49fd248e709287ef385a3,1
isofs: Fix out of bound access for corrupted isofs image,When isofs image is suitably corrupted isofs_read_inode() can read data beyond the end of buffer. Sanity-check the directory entry length before using it.  ,e96a1866b40570b5950cda8602c2819189c62a48,1
"Revert ""ext4: fix superblock checksum calculation race""","This reverts commit acaa532687cdc3a03757defafece9c27aa667546 which can result in a ext4_superblock_csum_set() trying to sleep while a spinlock is being held.  For more discussion of this issue, please see:  https://lore.kernel.org/r/000000000000f50cb705b313ed70@google.com  ",d196e229a80c39254f4adbc312f55f5198e98941,1
vfs: Make fs_parse() handle fs_param_is_fd-type params better,Make fs_parse() handle fs_param_is_fd-type parameters that are passed a string by converting it to an integer (in addition to handling direct fd specification).  Also range check the integer.  [fix from  Yin Fengwei folded]  ,74983ac20aeafc88d9ceed64a8bf2a9024c488d5,1
ipc/shm: fix use-after-free of shm file via remap_file_pages(),"syzbot reported a use-after-free of shm_file_data(file)->file->f_op in shm_get_unmapped_area(), called via sys_remap_file_pages().  Unfortunately it couldn't generate a reproducer, but I found a bug which I think caused it.  When remap_file_pages() is passed a full System V shared memory segment, the memory is first unmapped, then a new map is created using the ->vm_file.  Between these steps, the shm ID can be removed and reused for a new shm segment.  But, shm_mmap() only checks whether the ID is currently valid before calling the underlying file's ->mmap(); it doesn't check whether it was reused.  Thus it can use the wrong underlying file, one that was already freed.  Fix this by making the ""outer"" shm file (the one that gets put in ->vm_file) hold a reference to the real shm file, and by making __shm_open() require that the file associated with the shm ID matches the one associated with the ""outer"" file.  Taking the reference to the real shm file is needed to fully solve the problem, since otherwise sfd->file could point to a freed file, which then could be reallocated for the reused shm ID, causing the wrong shm segment to be mapped (and without the required permission checks).  Commit 1ac0b6dec656 (""ipc/shm: handle removed segments gracefully in shm_mmap()"") almost fixed this bug, but it didn't go far enough because it didn't consider the case where the shm ID is reused.  The following program usually reproduces this bug:  	#include <stdlib.h> 	#include <sys/shm.h> 	#include <sys/syscall.h> 	#include <unistd.h>  	int main() 	{ 		int is_parent = (fork() != 0); 		srand(getpid()); 		for (;;) { 			int id = shmget(0xF00F, 4096, IPC_CREAT|0700); 			if (is_parent) { 				void *addr = shmat(id, NULL, 0); 				usleep(rand() % 50); 				while (!syscall(__NR_remap_file_pages, addr, 4096, 0, 0, 0)); 			} else { 				usleep(rand() % 50); 				shmctl(id, IPC_RMID, NULL); 			} 		} 	}  It causes the following NULL pointer dereference due to a 'struct file' being used while it's being freed.  (I couldn't actually get a KASAN use-after-free splat like in the syzbot report.  But I think it's possible with this bug; it would just take a more extraordinary race...)  	BUG: unable to handle kernel NULL pointer dereference at 0000000000000058 	PGD 0 P4D 0 	Oops: 0000 [#1] SMP NOPTI 	CPU: 9 PID: 258 Comm: syz_ipc Not tainted 4.16.0-05140-gf8cf2f16a7c95 #189 	Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS 1.11.0-20171110_100015-anatol 04/01/2014 	",3f05317d9889ab75c7190dcd39491d2a97921984,1
tcp: fix tcp_fastretrans_alert warning,This patch fixes the cause of an ,0eb96bf754d7fa6635aa0b0f6650c74b8a6b1cc9,0
staging: android: ion: Switch to pr_warn_once in ion_buffer_destroy,Syzbot reported yet another warning with Ion:  ,45ad559a29629cb1c64ee636563c69b71524f077,0
uprobes/x86: Remove incorrect WARN_ON() in uprobe_init_insn(),"insn_get_length() has the side-effect of processing the entire instruction but only if it was decoded successfully, otherwise insn_complete() can fail and in this case we need to just return an error without warning.  ",90718e32e1dcc2479acfa208ccfc6442850b594c,0
netfilter: nf_tables: fix use-after-free in nft_set_catchall_destroy(),We need to use list_for_each_entry_safe() iterator because we can not access @catchall after kfree_rcu() call.  ,0f7d9b31ce7abdbb29bf018131ac920c9f698518,1
hrtimer: Don't dereference the hrtimer pointer after the callback,"A hrtimer can be released in its callback, but lockdep_hrtimer_exit() dereferences the pointer after the callback returns, i.e. a potential use after free.  Retrieve the context in which the hrtimer expires before the callback is invoked and use it in lockdep_hrtimer_exit().  ",73d20564e0dcae003e0d79977f044d5e57496304,1
tipc: eliminate KASAN warning,"The following warning was reported by syzbot on Oct 24. 2017: KASAN: slab-out-of-bounds Read in tipc_nametbl_lookup_dst_nodes  This is a harmless bug, but we still want to get rid of the warning, so we swap the two conditions in question.  ",f65163fed0e7dc3c79be4f96a8fe97fc89328b93,1
netfilter: ctnetlink: memleak in filter initialization error path,Release the filter object in case of error.  ,6c2d2176a85eb2fd65eb7cfe94b3bad0acce99c0,0
KVM: fix memory leak in kvm_io_bus_unregister_dev(),"when kmalloc() fails in kvm_io_bus_unregister_dev(), before removing the bus, we should iterate over all other devices linked to it and call kvm_iodevice_destructor() for them  ",f65886606c2d3b562716de030706dfe1bea4ed5e,1
9p: Add refcount to p9_req_t,"To avoid use-after-free(s), use a refcount to keep track of the usable references to any instantiated struct p9_req_t.  This commit adds p9_req_put(), p9_req_get() and p9_req_try_get() as wrappers to kref_put(), kref_get() and kref_get_unless_zero(). These are used by the client and the transports to keep track of valid requests' references.  p9_free_req() is added back and used as callback by kref_put().  Add SLAB_TYPESAFE_BY_RCU as it ensures that the memory freed by kmem_cache_free() will not be reused for another type until the rcu synchronisation period is over, so an address gotten under rcu read lock is safe to inc_ref() without corrupting random memory while the lock is held.  Co-developed-by: Dominique Martinet <dominique.martinet@cea.fr> ",728356dedeff8ef999cb436c71333ef4ac51a81c,1
fix kcm_clone(),"1) it's fput() or sock_release(), not both 2) don't do fd_install() until the last failure exit. 3) not a bug per se, but... don't attach socket to struct file    until it's set up.  Take reserving descriptor into the caller, move fd_install() to the caller, sanitize failure exits and calling conventions.  ",a5739435b5a3b8c449f8844ecd71a3b1e89f0a33,0
gpu/drm: Fix lock held when returning to user space.,We need to call drm_modeset_acquire_fini() when drm_atomic_state_alloc() failed or call drm_modeset_acquire_init() after drm_atomic_state_alloc() succeeded.  ,4089e272ac61603931beb024d4d640de2cb390e0,0
geneve: fix an uninitialized value in geneve_changelink(),"geneve_nl2info() sets 'df' conditionally, so we have to initialize it by copying the value from existing geneve device in geneve_changelink().  ",32818c075c54bb0cae44dd6f7ab00b01c52b8372,1
net: propagate errors correctly in register_netdevice(),"If netdev_name_node_head_alloc() fails to allocate memory, we absolutely want register_netdevice() to return -ENOMEM instead of zero :/  One of the syzbot report looked like :  general protection fault: 0000 [#1] PREEMPT SMP KASAN CPU: 1 PID: 8760 Comm: syz-executor839 Not tainted 5.3.0+ #0 Hardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 01/01/2011 ",9077f052abd5391a866dd99e27212213648becef,1
net: xfrm: fix shift-out-of-bounds in xfrm_get_default,"Syzbot hit shift-out-of-bounds in xfrm_get_default. The problem was in missing validation check for user data.  up->dirmask comes from user-space, so we need to check if this value is less than XFRM_USERPOLICY_DIRMASK_MAX to avoid shift-out-of-bounds bugs.  ",3c10ffddc61f8a1a59e29a110ba70b47e679206a,1
ipv6: use fib6_info_hold_safe() when necessary,"In the code path where only rcu read lock is held, e.g. in the route lookup code path, it is not safe to directly call fib6_info_hold() because the fib6_info may already have been deleted but still exists in the rcu grace period. Holding reference to it could cause double free and crash the kernel.  This patch adds a new function fib6_info_hold_safe() and replace fib6_info_hold() in all necessary places.  Syzbot reported 3 crash traces because of this. One of them is: 8021q: adding VLAN 0 to HW filter on device team0 IPv6: ADDRCONF(NETDEV_CHANGE): team0: link becomes ready dst_release: dst:(____ptrval____) refcnt:-1 dst_release: dst:(____ptrval____) refcnt:-2 ",e873e4b9cc7e8ce79e5c5627b32b107035bb3f5d,1
userfaultfd: use RCU to free the task struct when fork fails,The task structure is freed while get_mem_cgroup_from_mm() holds rcu_read_lock() and dereferences mm->owner.    get_mem_cgroup_from_mm()                failing fork()   ,c3f3ce049f7d97cc7ec9c01cb51d9ec74e0f37c2,1
net: sched: fix police ext initialization,"When police action is created by cls API tcf_exts_validate() first conditional that calls tcf_action_init_1() directly, the action idr is not updated according to latest changes in action API that require caller to commit newly created action to idr with tcf_idr_insert_many(). This results such action not being accessible through act API and causes crash reported by syzbot:  ",396d7f23adf9e8c436dd81a69488b5b6a865acf8,1
net/smc: move sock lock in smc_ioctl(),When an SMC socket is connecting it is decided whether fallback to TCP is needed. To avoid races between connect and ioctl move the sock lock before the use_fallback check.  ,7311d665ca68907b9c43d6d1021f816f9a7bbd57,1
ANDROID: binder: remove WARN() for redundant txn error,"binder_send_failed_reply() is called when a synchronous transaction fails. It reports an error to the thread that is waiting for the completion. Given that the transaction is synchronous, there should never be more than 1 error response to that thread -- this was being asserted with a WARN().  However, when exercising the driver with syzbot tests, cases were observed where multiple ""synchronous"" requests were sent without waiting for responses, so it is possible that multiple errors would be reported to the thread. This testing was conducted with panic_on_warn set which forced the crash.  This is easily reproduced by sending back-to-back ""synchronous"" transactions without checking for any response (eg, set read_size to 0):      bwr.write_buffer = (uintptr_t)&bc1;     bwr.write_size = sizeof(bc1);     bwr.read_buffer = (uintptr_t)&br;     bwr.read_size = 0;     ioctl(fd, BINDER_WRITE_READ, &bwr);     sleep(1);     bwr2.write_buffer = (uintptr_t)&bc2;     bwr2.write_size = sizeof(bc2);     bwr2.read_buffer = (uintptr_t)&br;     bwr2.read_size = 0;     ioctl(fd, BINDER_WRITE_READ, &bwr2);     sleep(1);  The first transaction is sent to the servicemanager and the reply fails because no VMA is set up by this client. After binder_send_failed_reply() is called, the BINDER_WORK_RETURN_ERROR is sitting on the thread's todo list since the read_size was 0 and the client is not waiting for a response.  The 2nd transaction is sent and the BINDER_WORK_RETURN_ERROR has not been consumed, so the thread's reply_error.cmd is still set (normally cleared when the BINDER_WORK_RETURN_ERROR is handled). Therefore when the servicemanager attempts to reply to the 2nd failed transaction, the error is already set and it triggers this warning.  This is a user error since it is not waiting for the synchronous transaction to complete. If it ever does check, it will see an error.  Changed the WARN() to a pr_warn().  ",e46a3b3ba7509cb7fda0e07bc7c63a2cd90f579b,1
mm/filemap.c: remove bogus VM_BUG_ON,"It is not safe to check page->index without holding the page lock.  It can be changed if the page is moved between the swap cache and the page cache for a shmem file, for example.  There is a VM_BUG_ON below which checks page->index is correct after taking the page lock.  ",d417b49fff3e2f21043c834841e8623a6098741d,1
ext4: fix use-after-free race with debug_want_extra_isize,"When remounting with debug_want_extra_isize, we were not performing the same checks that we do during a normal mount.  That allowed us to set a value for s_want_extra_isize that reached outside the s_inode_size.  ",7bc04c5c2cc467c5b40f2b03ba08da174a0d5fa7,1
io_uring: allow conditional reschedule for intensive iterators,"If we have a lot of threads and rings, the tctx list can get quite big. This is especially true if we keep creating new threads and rings. Likewise for the provided buffers list. Be nice and insert a conditional reschedule point while iterating the nodes for deletion.  ",8bab4c09f24ec8d4a7a78ab343620f89d3a24804,0
block: ensure the bdi is freed after inode_detach_wb,"inode_detach_wb references the ""main"" bdi of the inode.  With the recent change to move the bdi from the request_queue to the gendisk this causes a guaranteed use after free when using certain cgroup configurations.  The big itself is older through as any non-default inode reference (e.g. an open file descriptor) could have injected this use after free even before that.  ",889c05cc5834a1eef2dbe1e639cfd7a81c4f4c6d,1
"mm,vmscan: Allow preallocating memory for register_shrinker().","syzbot is catching so many bugs triggered by commit 9ee332d99e4d5a97 (""sget(): handle failures of register_shrinker()""). That commit expected that calling kill_sb() from deactivate_locked_super() without successful fill_super() is safe, but the reality was different; some callers assign attributes which are needed for kill_sb() after sget() succeeds.  For example, [1] is a report where sb->s_mode (which seems to be either FMODE_READ | FMODE_EXCL | FMODE_WRITE or FMODE_READ | FMODE_EXCL) is not assigned unless sget() succeeds. But it does not worth complicate sget() so that register_shrinker() failure path can safely call kill_block_super() via kill_sb(). Making alloc_super() fail if memory allocation for register_shrinker() failed is much simpler. Let's avoid calling deactivate_locked_super() from sget_userns() by preallocating memory for the shrinker and making register_shrinker() in sget_userns() never fail.  [1] https://syzkaller.appspot.com/bug?id=588996a25a2587be2e3a54e8646728fb9cae44e7  ",8e04944f0ea8b838399049bdcda920ab36ae3b04,1
filemap: drop the mmap_sem for all blocking operations,"Currently we only drop the mmap_sem if there is contention on the page lock.  The idea is that we issue readahead and then go to lock the page while it is under IO and we want to not hold the mmap_sem during the IO.  The problem with this is the assumption that the readahead does anything. In the case that the box is under extreme memory or IO pressure we may end up not reading anything at all for readahead, which means we will end up reading in the page under the mmap_sem.  Even if the readahead does something, it could get throttled because of io pressure on the system and the process is in a lower priority cgroup.  Holding the mmap_sem while doing IO is problematic because it can cause system-wide priority inversions.  Consider some large company that does a lot of web traffic.  This large company has load balancing logic in it's core web server, cause some engineer thought this was a brilliant plan. This load balancing logic gets statistics from /proc about the system, which trip over processes mmap_sem for various reasons.  Now the web server application is in a protected cgroup, but these other processes may not be, and if they are being throttled while their mmap_sem is held we'll stall, and cause this nice death spiral.  Instead rework filemap fault path to drop the mmap sem at any point that we may do IO or block for an extended period of time.  This includes while issuing readahead, locking the page, or needing to call ->readpage because readahead did not occur.  Then once we have a fully uptodate page we can return with VM_FAULT_RETRY and come back again to find our nicely in-cache page that was gotten outside of the mmap_sem.  This patch also adds a new helper for locking the page with the mmap_sem dropped.  This doesn't make sense currently as generally speaking if the page is already locked it'll have been read in (unless there was an error) before it was unlocked.  However a forthcoming patchset will change this with the ability to abort read-ahead bio's if necessary, making it more likely that we could contend for a page lock and still have a not uptodate page.  This allows us to deal with this case by grabbing the lock and issuing the IO without the mmap_sem held, and then returning VM_FAULT_RETRY to come back around.  [josef@toxicpanda.com: v6]   [kirill@shutemov.name: fix race in filemap_fault()]   [akpm@linux-foundation.org: coding style fixes] ",6b4c9f4469819a0c1a38a0a4541337e0f9bf6c11,1
tipc: lock wakeup & inputq at tipc_link_reset(),"In tipc_link_reset() we copy the wakeup queue to input queue using skb_queue_splice_init(link->wakeupq, link->inputq). This is performed without holding any locks. The lists might be simultaneously be accessed by other cpu threads in tipc_sk_rcv(), something leading to to random missing packets.  ",3f32d0be6c16b902b687453c962d17eea5b8ea19,0
drm: limit to INT_MAX in create_blob ioctl,"The hardened usercpy code is too paranoid ever since commit 6a30afa8c1fb (""uaccess: disallow > INT_MAX copy sizes"")  Code itself should have been fine as-is.  ",5bf8bec3f4ce044a223c40cbce92590d938f0e9c,0
ALSA: seq: oss: Serialize ioctls,"Some ioctls via OSS sequencer API may race and lead to UAF when the port create and delete are performed concurrently, as spotted by a couple of syzkaller cases.  This patch is an attempt to address it by serializing the ioctls with the existing register_mutex.  Basically OSS sequencer API is an obsoleted interface and was designed without much consideration of the concurrency.  There are very few applications with it, and the concurrent performance isn't asked, hence this ""big hammer"" approach should be good enough.  ",80982c7e834e5d4e325b6ce33757012ecafdf0bb,1
mm/process_vm_access: Add missing #include <linux/compat.h>,With e.g. m68k/defconfig:      mm/process_vm_access.c: In function â€˜process_vm_rwâ€™:     mm/process_vm_access.c:277:5: error: implicit declaration of function â€˜in_compat_syscallâ€™ [-Werror=implicit-function-declaration]       277 |     in_compat_syscall()); 	  |     ^~~~~~~~~~~~~~~~~  Fix this by adding #include <linux/compat.h>.  ,f78f63da916e04e0b12a96010e2dd551954b1db4,0
binder: fix memory leak in error path,syzkallar found a 32-byte memory leak in a rarely executed error case. The transaction complete work item was not freed if put_user() failed when writing the BR_TRANSACTION_COMPLETE to the user command buffer. Fixed by freeing it before put_user() is called.  ,1909a671dbc3606685b1daf8b22a16f65ea7edda,1
bpf: fix use after free in prog symbol exposure,"syzkaller managed to trigger the warning in bpf_jit_free() which checks via bpf_prog_kallsyms_verify_off() for potentially unlinked JITed BPF progs in kallsyms, and subsequently trips over GPF when walking kallsyms entries:    [...]   8021q: adding VLAN 0 to HW filter on device batadv0   8021q: adding VLAN 0 to HW filter on device batadv0   ",c751798aa224fadc5124b49eeb38fb468c0fa039,1
bpf: fix sock hashmap kmalloc warning,syzbot reported a kernel warning below:   ,683d2ac3904c74a625ea62d7fcc6c1efd84be087,0
rxrpc: bad unlock balance in rxrpc_recvmsg,"When either ""goto wait_interrupted;"" or ""goto wait_error;"" paths are taken, socket lock has already been released.  This patch fixes following syzbot splat :  ",6dce3c20ac429e7a651d728e375853370c796e8d,0
udp: fix GRO packet of death,"syzbot was able to crash host by sending UDP packets with a 0 payload.  TCP does not have this issue since we do not aggregate packets without payload.  Since dev_gro_receive() sets gso_size based on skb_gro_len(skb) it seems not worth trying to cope with padded packets.  BUG: KASAN: slab-out-of-bounds in skb_gro_receive+0xf5f/0x10e0 net/core/skbuff.c:3826 Read of size 16 at addr ffff88808893fff0 by task syz-executor612/7889  CPU: 0 PID: 7889 Comm: syz-executor612 Not tainted 5.1.0-rc7+ #96 Hardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 01/01/2011 Call Trace:  __dump_stack lib/dump_stack.c:77 [inline]  dump_stack+0x172/0x1f0 lib/dump_stack.c:113  print_address_description.cold+0x7c/0x20d mm/kasan/report.c:187  kasan_report.cold+0x1b/0x40 mm/kasan/report.c:317  __asan_report_load16_noabort+0x14/0x20 mm/kasan/generic_report.c:133  skb_gro_receive+0xf5f/0x10e0 net/core/skbuff.c:3826  udp_gro_receive_segment net/ipv4/udp_offload.c:382 [inline]  call_gro_receive include/linux/netdevice.h:2349 [inline]  udp_gro_receive+0xb61/0xfd0 net/ipv4/udp_offload.c:414  udp4_gro_receive+0x763/0xeb0 net/ipv4/udp_offload.c:478  inet_gro_receive+0xe72/0x1110 net/ipv4/af_inet.c:1510  dev_gro_receive+0x1cd0/0x23c0 net/core/dev.c:5581  napi_gro_frags+0x36b/0xd10 net/core/dev.c:5843  tun_get_user+0x2f24/0x3fb0 drivers/net/tun.c:1981  tun_chr_write_iter+0xbd/0x156 drivers/net/tun.c:2027  call_write_iter include/linux/fs.h:1866 [inline]  do_iter_readv_writev+0x5e1/0x8e0 fs/read_write.c:681  do_iter_write fs/read_write.c:957 [inline]  do_iter_write+0x184/0x610 fs/read_write.c:938  vfs_writev+0x1b3/0x2f0 fs/read_write.c:1002  do_writev+0x15e/0x370 fs/read_write.c:1037  __do_sys_writev fs/read_write.c:1110 [inline]  __se_sys_writev fs/read_write.c:1107 [inline]  __x64_sys_writev+0x75/0xb0 fs/read_write.c:1107  do_syscall_64+0x103/0x610 arch/x86/entry/common.c:290  entry_SYSCALL_64_after_hwframe+0x49/0xbe ",4dd2b82d5adfbe0b1587ccad7a8f76d826120f37,1
USB: fix usbmon BUG trigger,"Automated tests triggered this by opening usbmon and accessing the mmap while simultaneously resizing the buffers. This bug was with us since 2006, because typically applications only size the buffers once and thus avoid racing. Reported by Kirill A. Shutemov.  ",46eb14a6e1585d99c1b9f58d0e7389082a5f466b,1
scsi: scsi_ioctl: Validate command size,Need to make sure the command size is valid before copying the command from user space.  ,20aaef52eb08f1d987d46ad26edb8f142f74d83a,0
net/tls: Only attach to sockets in ESTABLISHED state,"Calling accept on a TCP socket with a TLS ulp attached results in two sockets that share the same ulp context. The ulp context is freed while a socket is destroyed, so after one of the sockets is released, the second second will trigger a use after free when it tries to access the ulp context attached to it. We restrict the TLS ulp to sockets in ESTABLISHED state to prevent the scenario above.  ",d91c3e17f75f218022140dee18cf515292184a8f,1
KVM: lapic: Check for in-kernel LAPIC before deferencing apic pointer,...to avoid dereferencing a null pointer when querying the per-vCPU timer advance.  ,b904cb8dff824b79233e82c078837627ebd52717,0
tcp/dccp: fix ireq->opt races,"syzkaller found another bug in DCCP/TCP stacks [1]  For the reasons explained in commit ce1050089c96 (""tcp/dccp: fix ireq->pktopts race""), we need to make sure we do not access ireq->opt unless we own the request sock.  Note the opt field is renamed to ireq_opt to ease grep games.  [1] BUG: KASAN: use-after-free in ip_queue_xmit+0x1687/0x18e0 net/ipv4/ip_output.c:474 Read of size 1 at addr ffff8801c951039c by task syz-executor5/3295  CPU: 1 PID: 3295 Comm: syz-executor5 Not tainted 4.14.0-rc4+ #80 Hardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 01/01/2011 Call Trace:  __dump_stack lib/dump_stack.c:16 [inline]  dump_stack+0x194/0x257 lib/dump_stack.c:52  print_address_description+0x73/0x250 mm/kasan/report.c:252  kasan_report_error mm/kasan/report.c:351 [inline]  kasan_report+0x25b/0x340 mm/kasan/report.c:409  __asan_report_load1_noabort+0x14/0x20 mm/kasan/report.c:427  ip_queue_xmit+0x1687/0x18e0 net/ipv4/ip_output.c:474  tcp_transmit_skb+0x1ab7/0x3840 net/ipv4/tcp_output.c:1135  tcp_send_ack.part.37+0x3bb/0x650 net/ipv4/tcp_output.c:3587  tcp_send_ack+0x49/0x60 net/ipv4/tcp_output.c:3557  __tcp_ack_snd_check+0x2c6/0x4b0 net/ipv4/tcp_input.c:5072  tcp_ack_snd_check net/ipv4/tcp_input.c:5085 [inline]  tcp_rcv_state_process+0x2eff/0x4850 net/ipv4/tcp_input.c:6071  tcp_child_process+0x342/0x990 net/ipv4/tcp_minisocks.c:816  tcp_v4_rcv+0x1827/0x2f80 net/ipv4/tcp_ipv4.c:1682  ip_local_deliver_finish+0x2e2/0xba0 net/ipv4/ip_input.c:216  NF_HOOK include/linux/netfilter.h:249 [inline]  ip_local_deliver+0x1ce/0x6e0 net/ipv4/ip_input.c:257  dst_input include/net/dst.h:464 [inline]  ip_rcv_finish+0x887/0x19a0 net/ipv4/ip_input.c:397  NF_HOOK include/linux/netfilter.h:249 [inline]  ip_rcv+0xc3f/0x1820 net/ipv4/ip_input.c:493  __netif_receive_skb_core+0x1a3e/0x34b0 net/core/dev.c:4476  __netif_receive_skb+0x2c/0x1b0 net/core/dev.c:4514  netif_receive_skb_internal+0x10b/0x670 net/core/dev.c:4587  netif_receive_skb+0xae/0x390 net/core/dev.c:4611  tun_rx_batched.isra.50+0x5ed/0x860 drivers/net/tun.c:1372  tun_get_user+0x249c/0x36d0 drivers/net/tun.c:1766  tun_chr_write_iter+0xbf/0x160 drivers/net/tun.c:1792  call_write_iter include/linux/fs.h:1770 [inline]  new_sync_write fs/read_write.c:468 [inline]  __vfs_write+0x68a/0x970 fs/read_write.c:481  vfs_write+0x18f/0x510 fs/read_write.c:543  SYSC_write fs/read_write.c:588 [inline]  SyS_write+0xef/0x220 fs/read_write.c:580  entry_SYSCALL_64_fastpath+0x1f/0xbe ",c92e8c02fe664155ac4234516e32544bec0f113d,1
rtnetlink: ndo_dflt_fdb_dump() only work for ARPHRD_ETHER devices,"kmsan was able to trigger a kernel-infoleak using a gre device [1]  nlmsg_populate_fdb_fill() has a hard coded assumption that dev->addr_len is ETH_ALEN, as normally guaranteed for ARPHRD_ETHER devices.  A similar issue was fixed recently in commit da71577545a5 (""rtnetlink: Disallow FDB configuration for non-Ethernet device"")  [1] BUG: KMSAN: kernel-infoleak in copyout lib/iov_iter.c:143 [inline] BUG: KMSAN: kernel-infoleak in _copy_to_iter+0x4c0/0x2700 lib/iov_iter.c:576 CPU: 0 PID: 6697 Comm: syz-executor310 Not tainted 4.20.0-rc3+ #95 Hardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 01/01/2011 Call Trace:  __dump_stack lib/dump_stack.c:77 [inline]  dump_stack+0x32d/0x480 lib/dump_stack.c:113  kmsan_report+0x12c/0x290 mm/kmsan/kmsan.c:683  kmsan_internal_check_memory+0x32a/0xa50 mm/kmsan/kmsan.c:743  kmsan_copy_to_user+0x78/0xd0 mm/kmsan/kmsan_hooks.c:634  copyout lib/iov_iter.c:143 [inline]  _copy_to_iter+0x4c0/0x2700 lib/iov_iter.c:576  copy_to_iter include/linux/uio.h:143 [inline]  skb_copy_datagram_iter+0x4e2/0x1070 net/core/datagram.c:431  skb_copy_datagram_msg include/linux/skbuff.h:3316 [inline]  netlink_recvmsg+0x6f9/0x19d0 net/netlink/af_netlink.c:1975  sock_recvmsg_nosec net/socket.c:794 [inline]  sock_recvmsg+0x1d1/0x230 net/socket.c:801  ___sys_recvmsg+0x444/0xae0 net/socket.c:2278  __sys_recvmsg net/socket.c:2327 [inline]  __do_sys_recvmsg net/socket.c:2337 [inline]  __se_sys_recvmsg+0x2fa/0x450 net/socket.c:2334  __x64_sys_recvmsg+0x4a/0x70 net/socket.c:2334  do_syscall_64+0xcf/0x110 arch/x86/entry/common.c:291  entry_SYSCALL_64_after_hwframe+0x63/0xe7 ",688838934c231bb08f46db687e57f6d8bf82709c,1
KVM: X86: Fix async pf caused null-ptr-deref,"Syzbot reported that:    CPU: 1 PID: 6780 Comm: syz-executor153 Not tainted 5.7.0-syzkaller #0   Hardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 01/01/2011   ",9d3c447c72fb2337ca39f245c6ae89f2369de216,1
ipv6: fix kernel-infoleak in ipv6_local_error(),"This patch makes sure the flow label in the IPv6 header forged in ipv6_local_error() is initialized.  BUG: KMSAN: kernel-infoleak in _copy_to_user+0x16b/0x1f0 lib/usercopy.c:32 CPU: 1 PID: 24675 Comm: syz-executor1 Not tainted 4.20.0-rc7+ #4 Hardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 01/01/2011 Call Trace:  __dump_stack lib/dump_stack.c:77 [inline]  dump_stack+0x173/0x1d0 lib/dump_stack.c:113  kmsan_report+0x12e/0x2a0 mm/kmsan/kmsan.c:613  kmsan_internal_check_memory+0x455/0xb00 mm/kmsan/kmsan.c:675  kmsan_copy_to_user+0xab/0xc0 mm/kmsan/kmsan_hooks.c:601  _copy_to_user+0x16b/0x1f0 lib/usercopy.c:32  copy_to_user include/linux/uaccess.h:177 [inline]  move_addr_to_user+0x2e9/0x4f0 net/socket.c:227  ___sys_recvmsg+0x5d7/0x1140 net/socket.c:2284  __sys_recvmsg net/socket.c:2327 [inline]  __do_sys_recvmsg net/socket.c:2337 [inline]  __se_sys_recvmsg+0x2fa/0x450 net/socket.c:2334  __x64_sys_recvmsg+0x4a/0x70 net/socket.c:2334  do_syscall_64+0xbc/0xf0 arch/x86/entry/common.c:291  entry_SYSCALL_64_after_hwframe+0x63/0xe7 ",7d033c9f6a7fd3821af75620a0257db87c2b552a,1
block: assign correct tag before doing prefetch of request,Ensure that current tag is correctly assigned before attempting to prefetch the first cacheline of the request.  ,a22c00be90de188d36f4772ef7b268aa48d7010d,0
media: vim2m: use cancel_delayed_work_sync instead of flush_schedule_work,The use of flush_schedule_work() made no sense and caused a syzkaller error. Replace with the correct cancel_delayed_work_sync().  ,52117be68b82ee05c96da0a7beec319906ccf6cc,1
IMA: reject unknown hash algorithms in ima_get_hash_algo,"The new function validate_hash_algo() assumed that ima_get_hash_algo() always return a valid 'enum hash_algo', but it returned the user-supplied value present in the digital signature without any bounds checks.  Update ima_get_hash_algo() to always return a valid hash algorithm, defaulting on 'ima_hash_algo' when the user-supplied value inside the xattr is invalid.  ",cb181da161963eddc9de0000de6ab2c7942be219,0
sch_cake: do not call cake_destroy() from cake_init(),"qdiscs are not supposed to call their own destroy() method from init(), because core stack already does that.  syzbot was able to trigger use after free:  DEBUG_LOCKS_WARN_ON(lock->magic != lock) ",ab443c53916730862cec202078d36fd4008bea79,1
RDMA: Allow ib_client's to fail when add() is called,"When a client is added it isn't allowed to fail, but all the client's have various failure paths within their add routines.  This creates the very fringe condition where the client was added, failed during add and didn't set the client_data. The core code will then still call other client_data centric ops like remove(), rename(), get_nl_info(), and get_net_dev_by_params() with NULL client_data - which is confusing and unexpected.  If the add() callback fails, then do not call any more client ops for the device, even remove.  Remove all the now redundant checks for NULL client_data in ops callbacks.  Update all the add() callbacks to return error codes appropriately. EOPNOTSUPP is used for cases where the ULP does not support the ib_device - eg because it only works with IB.  ",11a0ae4c4bff9b2a471b54dbe910fc0f60e58e62,0
net: validate untrusted gso packets without csum offload,"Syzkaller again found a path to a kernel crash through bad gso input. By building an excessively large packet to cause an skb field to wrap.  If VIRTIO_NET_HDR_F_NEEDS_CSUM was set this would have been dropped in skb_partial_csum_set.  GSO packets that do not set checksum offload are suspicious and rare. Most callers of virtio_net_hdr_to_skb already pass them to skb_probe_transport_header.  Move that test forward, change it to detect parse failure and drop packets on failure as those cleary are not one of the legitimate VIRTIO_NET_HDR_GSO types.  ",d5be7f632bad0f489879eed0ff4b99bd7fe0b74c,1
drm/vkms: Fix plane duplicate_state,"We need to handle allocation failures and bail out. While at it, tune the allocation failures down to debug level.  syzbot injected an allocation failure and then hit this WARN_ON.  ",7cdf33ab02e01300e7e6289acbac9cd8759f8712,0
mfd: dln2: More sanity checking for endpoints,It is not enough to check for the number of endpoints. The types must also be correct.  ,2b8bd606b1e60ca28c765f69c1eedd7d2a2e9dca,1
bpf: fix verifier GPF in kmalloc failure path,syzbot reported the following panic in the verifier triggered by kmalloc error injection:  kasan: GPF could be caused by NULL-ptr deref or user memory access ,5896351ea9360072f8bdd9eee186861a9d13db6d,1
net: 6pack: fix slab-out-of-bounds in decode_data,"Syzbot reported slab-out-of bounds write in decode_data(). The problem was in missing validation checks.  Syzbot's reproducer generated malicious input, which caused decode_data() to be called a lot in sixpack_decode(). Since rx_count_cooked is only 400 bytes and noone reported before, that 400 bytes is not enough, let's just check if input is malicious and complain about buffer overrun.  Fail log: ",19d1532a187669ce86d5a2696eb7275310070793,1
media: vb2: add waiting_in_dqbuf flag,"Calling VIDIOC_DQBUF can release the core serialization lock pointed to by vb2_queue->lock if it has to wait for a new buffer to arrive.  However, if userspace dup()ped the video device filehandle, then it is possible to read or call DQBUF from two filehandles at the same time.  It is also possible to call REQBUFS from one filehandle while the other is waiting for a buffer. This will remove all the buffers and reallocate new ones. Removing all the buffers isn't the problem here (that's already handled correctly by DQBUF), but the reallocating part is: DQBUF isn't aware that the buffers have changed.  This is fixed by setting a flag whenever the lock is released while waiting for a buffer to arrive. And checking the flag where needed so we can return -EBUSY.  ",d65842f7126aa1a87fb44b7c9980c12630ed4f33,0
loop: don't hold lo_mutex during __loop_clr_fd(),"syzbot is reporting circular locking problem at __loop_clr_fd() [1], for commit 87579e9b7d8dc36e (""loop: use worker per cgroup instead of kworker"") is calling destroy_workqueue() with lo->lo_mutex held.  Since all functions where lo->lo_state matters are already checking lo->lo_state with lo->lo_mutex held (in order to avoid racing with e.g. ioctl(LOOP_CTL_REMOVE)), and __loop_clr_fd() can be called from either ioctl(LOOP_CLR_FD) xor close(), lo->lo_state == Lo_rundown is considered as an exclusive lock for __loop_clr_fd(). Therefore, hold lo->lo_mutex inside __loop_clr_fd() only when asserting/updating lo->lo_state.  Since ioctl(LOOP_CLR_FD) depends on lo->lo_state == Lo_bound, a valid lo->lo_backing_file must have been assigned by ioctl(LOOP_SET_FD) or ioctl(LOOP_CONFIGURE). Thus, we can remove lo->lo_backing_file test, and convert __loop_clr_fd() into a void function.  ",6050fa4c84cc93ae509f5105f585a429dffc5633,0
ipv6: sit: better validate user provided tunnel names,"Use dev_valid_name() to make sure user does not provide illegal device name.  syzbot caught the following bug :  BUG: KASAN: stack-out-of-bounds in strlcpy include/linux/string.h:300 [inline] BUG: KASAN: stack-out-of-bounds in ipip6_tunnel_locate+0x63b/0xaa0 net/ipv6/sit.c:254 Write of size 33 at addr ffff8801b64076d8 by task syzkaller932654/4453  CPU: 0 PID: 4453 Comm: syzkaller932654 Not tainted 4.16.0+ #1 Hardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 01/01/2011 Call Trace:  __dump_stack lib/dump_stack.c:17 [inline]  dump_stack+0x1b9/0x29f lib/dump_stack.c:53  print_address_description+0x6c/0x20b mm/kasan/report.c:256  kasan_report_error mm/kasan/report.c:354 [inline]  kasan_report.cold.7+0xac/0x2f5 mm/kasan/report.c:412  check_memory_region_inline mm/kasan/kasan.c:260 [inline]  check_memory_region+0x13e/0x1b0 mm/kasan/kasan.c:267  memcpy+0x37/0x50 mm/kasan/kasan.c:303  strlcpy include/linux/string.h:300 [inline]  ipip6_tunnel_locate+0x63b/0xaa0 net/ipv6/sit.c:254  ipip6_tunnel_ioctl+0xe71/0x241b net/ipv6/sit.c:1221  dev_ifsioc+0x43e/0xb90 net/core/dev_ioctl.c:334  dev_ioctl+0x69a/0xcc0 net/core/dev_ioctl.c:525  sock_ioctl+0x47e/0x680 net/socket.c:1015  vfs_ioctl fs/ioctl.c:46 [inline]  file_ioctl fs/ioctl.c:500 [inline]  do_vfs_ioctl+0x1cf/0x1650 fs/ioctl.c:684  ksys_ioctl+0xa9/0xd0 fs/ioctl.c:701  SYSC_ioctl fs/ioctl.c:708 [inline]  SyS_ioctl+0x24/0x30 fs/ioctl.c:706  do_syscall_64+0x29e/0x9d0 arch/x86/entry/common.c:287  entry_SYSCALL_64_after_hwframe+0x42/0xb7  ",b95211e066fc3494b7c115060b2297b4ba21f025,1
"Revert ""ALSA: seq: Protect in-kernel ioctl calls with mutex""","This reverts commit feb689025fbb6f0aa6297d3ddf97de945ea4ad32.  The fix attempt was incorrect, leading to the mutex deadlock through the close of OSS sequencer client.  The proper fix needs more consideration, so let's revert it now.  ",f0654ba94e33699b295ce4f3dc73094db6209035,0
xsk: Fix possible segfault at xskmap entry insertion,"Fix possible segfault when entry is inserted into xskmap. This can happen if the socket is in a state where the umem has been set up, the Rx ring created but it has yet to be bound to a device. In this case the pool has not yet been created and we cannot reference it for the existence of the fill ring. Fix this by removing the whole xsk_is_setup_for_bpf_map function. Once upon a time, it was used to make sure that the Rx and fill rings where set up before the driver could call xsk_rcv, since there are no tests for the existence of these rings in the data path. But these days, we have a state variable that we test instead. When it is XSK_BOUND, everything has been set up correctly and the socket has been bound. So no reason to have the xsk_is_setup_for_bpf_map function anymore.  ",968be23ceaca1f402dfad0a30a8da4649ee32940,0
pstore: Fix warning in pstore_kill_sb(),"syzbot is hitting WARN_ON(pstore_sb != sb) at pstore_kill_sb() [1], for the assumption that pstore_sb != NULL is wrong because pstore_fill_super() will not assign pstore_sb = sb when new_inode() for d_make_root() returned NULL (due to memory allocation fault injection).  Since mount_single() calls pstore_kill_sb() when pstore_fill_super() failed, pstore_kill_sb() needs to be aware of such failure path.  [1] https://syzkaller.appspot.com/bug?id=6abacb8da5137cb47a416f2bef95719ed60508a0  ",9c7d83ae6ba67d6c6199cce24573983db3b56332,1
loop: make autoclear operation asynchronous,"syzbot is reporting circular locking problem at __loop_clr_fd() [1], for commit 87579e9b7d8dc36e (""loop: use worker per cgroup instead of kworker"") is calling destroy_workqueue() with disk->open_mutex held.  This circular dependency cannot be broken unless we call __loop_clr_fd() without holding disk->open_mutex. Therefore, defer __loop_clr_fd() from lo_release() to a WQ context.  ",322c4293ecc58110227b49d7e47ae37b9b03566f,0
block: cleanup q->srcu,"srcu structure has to be cleanup via cleanup_srcu_struct(), so fix it.  ",850fd2abbe02eb2b52cbb1550adbcc89b36d65de,0
dma-buf: free dmabuf->name in dma_buf_release(),"dma-buf name can be set via DMA_BUF_SET_NAME ioctl, but once set it never gets freed.  Free it in dma_buf_release().  ",d1f37226431f5d9657aa144a40f2383adbcf27e1,0
net: ip6_gre: fix possible NULL pointer dereference in ip6erspan_set_version,"Fix a possible NULL pointer dereference in ip6erspan_set_version checking nlattr data pointer  kasan: CONFIG_KASAN_INLINE enabled kasan: GPF could be caused by NULL-ptr deref or user memory access general protection fault: 0000 [#1] PREEMPT SMP KASAN CPU: 1 PID: 7549 Comm: syz-executor432 Not tainted 5.0.0-rc6-next-20190218 #37 Hardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 01/01/2011 ",efcc9bcaf77c07df01371a7c34e50424c291f3ac,1
net/rds: restrict iovecs length for RDS_CMSG_RDMA_ARGS,syzbot found ,a11148e6fcce2ae53f47f0a442d098d860b4f7db,0
i2c: bail out early when RDWR parameters are wrong,"The buggy parameters currently get caught later, but emit a noisy WARN. Userspace should not be able to trigger this, so add similar checks much earlier. Also avoids some unneeded code paths, of course. Apply kernel coding stlye to a comment while here.  ",71581562ee36032d2d574a9b23ad4af6d6a64cf7,0
fuse: don't keep dead fuse_conn at fuse_fill_super().,"syzbot is reporting use-after-free at fuse_kill_sb_blk() [1]. Since sb->s_fs_info field is not cleared after fc was released by fuse_conn_put() when initialization failed, fuse_kill_sb_blk() finds already released fc and tries to hold the lock. Fix this by clearing sb->s_fs_info field after calling fuse_conn_put().  [1] https://syzkaller.appspot.com/bug?id=a07a680ed0a9290585ca424546860464dd9658db  ",543b8f8662fe6d21f19958b666ab0051af9db21a,1
ALSA: usb-audio: Fix gpf in snd_usb_pipe_sanity_check,syzbot found the following crash on:    general protection fault: 0000 [#1] SMP KASAN   ,5d78e1c2b7f4be00bbe62141603a631dc7812f35,1
perf: Fix sample_max_stack maximum check,The syzbot hit KASAN bug in perf_callchain_store having the entry stored behind the allocated bounds [1].  We miss the sample_max_stack check for the initial event that allocates callchain buffers. This missing check allows to create an event with sample_max_stack value bigger than the global sysctl maximum:    # sysctl -a | grep perf_event_max_stack   kernel.perf_event_max_stack = 127    # perf record -vv -C 1 -e cycles/max-stack=256/ kill   ...   perf_event_attr:     size                             112     ...     sample_max_stack                 256   ,5af44ca53d019de47efe6dbc4003dd518e5197ed,1
KVM: x86: remove bogus user-triggerable WARN_ON,"The WARN_ON is essentially comparing a user-provided value with 0.  It is trivial to trigger it just by passing garbage to KVM_SET_CLOCK.  Guests can break if you do so, but the same applies to every KVM_SET_* ioctl. So, if it hurts when you do like this, just do not do it.  ",d33294541889b023068522270cd4153ddd8e4635,0
hamradio: remove needs_free_netdev to avoid UAF,"The former patch ""defer 6pack kfree after unregister_netdev"" reorders the kfree of two buffer after the unregister_netdev to prevent the race condition. It also adds free_netdev() function in sixpack_close(), which is a direct copy from the similar code in mkiss_close().  However, in sixpack driver, the flag needs_free_netdev is set to true in sp_setup(), hence the unregister_netdev() will free the netdev automatically. Therefore, as the sp is netdev_priv, use-after-free occurs.  This patch removes the needs_free_netdev = true and just let the free_netdev to finish this deallocation task.  ",81b1d548d00bcd028303c4f3150fa753b9b8aa71,1
ext4: defer saving error info from atomic context,"When filesystem inconsistency is detected with group locked, we currently try to modify superblock to store error there without blocking. However this can cause superblock checksum failures (or DIF/DIX failure) when the superblock is just being written out.  Make error handling code just store error information in ext4_sb_info structure and copy it to on-disk superblock only in ext4_commit_super(). In case of error happening with group locked, we just postpone the superblock flushing to a workqueue.  ",c92dc856848f32781e37b88c1b7f875e274f5efb,1
vxlan: add missing rcu_read_lock() in neigh_reduce(),"syzbot complained in neigh_reduce(), because rcu_read_lock_bh() is treated differently than rcu_read_lock()  ",85e8b032d6ebb0f698a34dd22c2f13443d905888,0
mfd: da9063: Replace regmap_add_irq_chip with devm counterpart,"Use devm_regmap_add_irq_chip() instead of plain regmap_add_irq_chip(), which removes the need for da9063_irq_exit() altogether and also fixes a bug in da9063_device_init() where the da9063_irq_exit() was not called in a failpath.  ",7494de0454af50215bc46c93c83b88a32ca39fab,0
smackfs: Fix use-after-free in netlbl_catmap_walk(),Syzkaller reported use-after-free bug as described in [1]. The bug is triggered when smk_set_cipso() tries to free stale category bitmaps while there are concurrent reader(s) using the same bitmaps.  Wait for RCU grace period to finish before freeing the category bitmaps in smk_set_cipso(). This makes sure that there are no more readers using the stale bitmaps and freeing them should be safe.  [1] https://lore.kernel.org/netdev/000000000000a814c505ca657a4e@google.com/  ,0817534ff9ea809fac1322c5c8c574be8483ea57,1
media: ati_remote: sanity check for both endpoints,"If you do sanity checks, you should do them for both endpoints. Hence introduce checking for endpoint type for the output endpoint, too.  ",a8be80053ea74bd9c3f9a3810e93b802236d6498,1
io_uring: fix list corruption for splice file_get,"kernel BUG at lib/list_debug.c:29! Call Trace:  __list_add include/linux/list.h:67 [inline]  list_add include/linux/list.h:86 [inline]  io_file_get+0x8cc/0xdb0 fs/io_uring.c:6466  __io_splice_prep+0x1bc/0x530 fs/io_uring.c:3866  io_splice_prep fs/io_uring.c:3920 [inline]  io_req_prep+0x3546/0x4e80 fs/io_uring.c:6081  io_queue_sqe+0x609/0x10d0 fs/io_uring.c:6628  io_submit_sqe fs/io_uring.c:6705 [inline]  io_submit_sqes+0x1495/0x2720 fs/io_uring.c:6953  __do_sys_io_uring_enter+0x107d/0x1f30 fs/io_uring.c:9353  do_syscall_64+0x2d/0x70 arch/x86/entry/common.c:46  entry_SYSCALL_64_after_hwframe+0x44/0xa9  io_file_get() may be called from splice, and so REQ_F_INFLIGHT may already be set.  ",f609cbb8911e40e15f9055e8f945f926ac906924,1
hugetlb: don't pass page cache pages to restore_reserve_on_error,"syzbot hit kernel BUG at fs/hugetlbfs/inode.c:532 as described in [1]. This BUG triggers if the HPageRestoreReserve flag is set on a page in the page cache.  It should never be set, as the routine huge_add_to_page_cache explicitly clears the flag after adding a page to the cache.  The only code other than huge page allocation which sets the flag is restore_reserve_on_error.  It will potentially set the flag in rare out of memory conditions.  syzbot was injecting errors to cause memory allocation errors which exercised this specific path.  The code in restore_reserve_on_error is doing the right thing.  However, there are instances where pages in the page cache were being passed to restore_reserve_on_error.  This is incorrect, as once a page goes into the cache reservation information will not be modified for the page until it is removed from the cache.  Error paths do not remove pages from the cache, so even in the case of error, the page will remain in the cache and no reservation adjustment is needed.  Modify routines that potentially call restore_reserve_on_error with a page cache page to no longer do so.  Note on fixes tag: Prior to commit 846be08578ed (""mm/hugetlb: expand restore_reserve_on_error functionality"") the routine would not process page cache pages because the HPageRestoreReserve flag is not set on such pages.  Therefore, this issue could not be trigggered.  The code added by commit 846be08578ed (""mm/hugetlb: expand restore_reserve_on_error functionality"") is needed and correct.  It exposed incorrect calls to restore_reserve_on_error which is the root cause addressed by this commit.  [1] https://lore.kernel.org/linux-mm/00000000000050776d05c9b7c7f0@google.com/  ",c7b1850dfb41d0b4154aca8dbc04777fbd75616f,1
media: b2c2-flexcop-usb: add sanity checking,The driver needs an isochronous endpoint to be present. It will oops in its absence. Add checking for it.  ,1b976fc6d684e3282914cdbe7a8d68fdce19095c,1
memcg: fix use-after-free in uncharge_batch,"syzbot has reported an use-after-free in the uncharge_batch path    BUG: KASAN: use-after-free in instrument_atomic_write include/linux/instrumented.h:71 [inline]   BUG: KASAN: use-after-free in atomic64_sub_return include/asm-generic/atomic-instrumented.h:970 [inline]   BUG: KASAN: use-after-free in atomic_long_sub_return include/asm-generic/atomic-long.h:113 [inline]   BUG: KASAN: use-after-free in page_counter_cancel mm/page_counter.c:54 [inline]   BUG: KASAN: use-after-free in page_counter_uncharge+0x3d/0xc0 mm/page_counter.c:155   Write of size 8 at addr ffff8880371c0148 by task syz-executor.0/9304    CPU: 0 PID: 9304 Comm: syz-executor.0 Not tainted 5.8.0-syzkaller #0   Hardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 01/01/2011   Call Trace:     __dump_stack lib/dump_stack.c:77 [inline]     dump_stack+0x1f0/0x31e lib/dump_stack.c:118     print_address_description+0x66/0x620 mm/kasan/report.c:383     __kasan_report mm/kasan/report.c:513 [inline]     kasan_report+0x132/0x1d0 mm/kasan/report.c:530     check_memory_region_inline mm/kasan/generic.c:183 [inline]     check_memory_region+0x2b5/0x2f0 mm/kasan/generic.c:192     instrument_atomic_write include/linux/instrumented.h:71 [inline]     atomic64_sub_return include/asm-generic/atomic-instrumented.h:970 [inline]     atomic_long_sub_return include/asm-generic/atomic-long.h:113 [inline]     page_counter_cancel mm/page_counter.c:54 [inline]     page_counter_uncharge+0x3d/0xc0 mm/page_counter.c:155     uncharge_batch+0x6c/0x350 mm/memcontrol.c:6764     uncharge_page+0x115/0x430 mm/memcontrol.c:6796     uncharge_list mm/memcontrol.c:6835 [inline]     mem_cgroup_uncharge_list+0x70/0xe0 mm/memcontrol.c:6877     release_pages+0x13a2/0x1550 mm/swap.c:911     tlb_batch_pages_flush mm/mmu_gather.c:49 [inline]     tlb_flush_mmu_free mm/mmu_gather.c:242 [inline]     tlb_flush_mmu+0x780/0x910 mm/mmu_gather.c:249     tlb_finish_mmu+0xcb/0x200 mm/mmu_gather.c:328     exit_mmap+0x296/0x550 mm/mmap.c:3185     __mmput+0x113/0x370 kernel/fork.c:1076     exit_mm+0x4cd/0x550 kernel/exit.c:483     do_exit+0x576/0x1f20 kernel/exit.c:793     do_group_exit+0x161/0x2d0 kernel/exit.c:903     get_signal+0x139b/0x1d30 kernel/signal.c:2743     arch_do_signal+0x33/0x610 arch/x86/kernel/signal.c:811     exit_to_user_mode_loop kernel/entry/common.c:135 [inline]     exit_to_user_mode_prepare+0x8d/0x1b0 kernel/entry/common.c:166     syscall_exit_to_user_mode+0x5e/0x1a0 kernel/entry/common.c:241     entry_SYSCALL_64_after_hwframe+0x44/0xa9  Commit 1a3e1f40962c (""mm: memcontrol: decouple reference counting from page accounting"") reworked the memcg lifetime to be bound the the struct page rather than charges.  It also removed the css_put_many from uncharge_batch and that is causing the above splat.  uncharge_batch() is supposed to uncharge accumulated charges for all pages freed from the same memcg.  The queuing is done by uncharge_page which however drops the memcg reference after it adds charges to the batch.  If the current page happens to be the last one holding the reference for its memcg then the memcg is OK to go and the next page to be freed will trigger batched uncharge which needs to access the memcg which is gone already.  Fix the issue by taking a reference for the memcg in the current batch.  ",f1796544a0ca0f14386a679d3d05fbc69235015e,1
idr: fix invalid ptr dereference on item delete,"If the radix tree underlying the IDR happens to be full and we attempt to remove an id which is larger than any id in the IDR, we will call __radix_tree_delete() with an uninitialised 'slot' pointer, at which point anything could happen.  This was easiest to hit with a single entry at id 0 and attempting to remove a non-0 id, but it could have happened with 64 entries and attempting to remove an id >= 64.  Roman said:    The syzcaller test boils down to opening /dev/kvm, creating an   eventfd, and calling a couple of KVM ioctls. None of this requires   superuser. And the result is dereferencing an uninitialized pointer   which is likely a crash. The specific path caught by syzbot is via   KVM_HYPERV_EVENTD ioctl which is new in 4.17. But I guess there are   other user-triggerable paths, so cc:stable is probably justified.  Matthew added:    We have around 250 calls to idr_remove() in the kernel today. Many of   them pass an ID which is embedded in the object they're removing, so   they're safe. Picking a few likely candidates:    drivers/firewire/core-cdev.c looks unsafe; the ID comes from an ioctl.   drivers/gpu/drm/amd/amdgpu/amdgpu_ctx.c is similar   drivers/atm/nicstar.c could be taken down by a handcrafted packet  ",7a4deea1aa8bddfed4ef1b35fc2b6732563d8ad5,1
9p: fix multiple NULL-pointer-dereferences,Added checks to prevent GPFs from raising.  ,10aa14527f458e9867cf3d2cc6b8cb0f6704448b,1
block: loop: fix deadlock between open and remove,"Commit c76f48eb5c08 (""block: take bd_mutex around delete_partitions in del_gendisk"") adds disk->part0->bd_mutex in del_gendisk(), this way causes the following AB/BA deadlock between removing loop and opening loop:   1) loop_control_ioctl(LOOP_CTL_REMOVE)      -> mutex_lock(&loop_ctl_mutex)      -> del_gendisk          -> mutex_lock(&disk->part0->bd_mutex)   2) blkdev_get_by_dev      -> mutex_lock(&disk->part0->bd_mutex)      -> lo_open          -> mutex_lock(&loop_ctl_mutex)  Add a new Lo_deleting state to remove the need for clearing ->private_data and thus holding loop_ctl_mutex in the ioctl LOOP_CTL_REMOVE path.  Based on an analysis and earlier patch from Ming Lei <ming.lei@redhat.com>.  ",990e78116d38059c9306cf0560c1c4ed1cf358d3,0
rxrpc: Fix call ref leak,"When sendmsg() finds a call to continue on with, if the call is in an inappropriate state, it doesn't release the ref it just got on that call before returning an error.  This causes the following symptom to show up with kasan:  	BUG: KASAN: use-after-free in rxrpc_send_keepalive+0x8a2/0x940 	net/rxrpc/output.c:635 	Read of size 8 at addr ffff888064219698 by task kworker/0:3/11077  where line 635 is:  	whdr.epoch	= htonl(peer->local->rxnet->epoch);  The local endpoint (which cannot be pinned by the call) has been released, but not the peer (which is pinned by the call).  Fix this by releasing the call in the error path.  ",c48fc11b69e95007109206311b0187a3090591f3,1
sch_choke: avoid potential panic in choke_reset(),"If choke_init() could not allocate q->tab, we would crash later in choke_reset().  BUG: KASAN: null-ptr-deref in memset include/linux/string.h:366 [inline] BUG: KASAN: null-ptr-deref in choke_reset+0x208/0x340 net/sched/sch_choke.c:326 Write of size 8 at addr 0000000000000000 by task syz-executor822/7022  CPU: 1 PID: 7022 Comm: syz-executor822 Not tainted 5.7.0-rc1-syzkaller #0 Hardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 01/01/2011 Call Trace:  __dump_stack lib/dump_stack.c:77 [inline]  dump_stack+0x188/0x20d lib/dump_stack.c:118  __kasan_report.cold+0x5/0x4d mm/kasan/report.c:515  kasan_report+0x33/0x50 mm/kasan/common.c:625  check_memory_region_inline mm/kasan/generic.c:187 [inline]  check_memory_region+0x141/0x190 mm/kasan/generic.c:193  memset+0x20/0x40 mm/kasan/common.c:85  memset include/linux/string.h:366 [inline]  choke_reset+0x208/0x340 net/sched/sch_choke.c:326  qdisc_reset+0x6b/0x520 net/sched/sch_generic.c:910  dev_deactivate_queue.constprop.0+0x13c/0x240 net/sched/sch_generic.c:1138  netdev_for_each_tx_queue include/linux/netdevice.h:2197 [inline]  dev_deactivate_many+0xe2/0xba0 net/sched/sch_generic.c:1195  dev_deactivate+0xf8/0x1c0 net/sched/sch_generic.c:1233  qdisc_graft+0xd25/0x1120 net/sched/sch_api.c:1051  tc_modify_qdisc+0xbab/0x1a00 net/sched/sch_api.c:1670  rtnetlink_rcv_msg+0x44e/0xad0 net/core/rtnetlink.c:5454  netlink_rcv_skb+0x15a/0x410 net/netlink/af_netlink.c:2469  netlink_unicast_kernel net/netlink/af_netlink.c:1303 [inline]  netlink_unicast+0x537/0x740 net/netlink/af_netlink.c:1329  netlink_sendmsg+0x882/0xe10 net/netlink/af_netlink.c:1918  sock_sendmsg_nosec net/socket.c:652 [inline]  sock_sendmsg+0xcf/0x120 net/socket.c:672  ____sys_sendmsg+0x6bf/0x7e0 net/socket.c:2362  ___sys_sendmsg+0x100/0x170 net/socket.c:2416  __sys_sendmsg+0xec/0x1b0 net/socket.c:2449  do_syscall_64+0xf6/0x7d0 arch/x86/entry/common.c:295  ",8738c85c72b3108c9b9a369a39868ba5f8e10ae0,1
proc: s_fs_info may be NULL when proc_kill_sb is called,"syzbot found that proc_fill_super() fails before filling up sb->s_fs_info, deactivate_locked_super() will be called and sb->s_fs_info will be NULL. The proc_kill_sb() does not expect fs_info to be NULL which is wrong.  ",058f2e4da79b23afb56ce3d03d907d6cdd36f2b8,0
RDMA/cma: Fix deadlock on &lock in rdma_cma_listen_on_all() error unwind,"rdma_detroy_id() cannot be called under &lock - we must instead keep the error'd ID around until &lock can be released, then destroy it.  This is complicated by the usual way listen IDs are destroyed through cma_process_remove() which can run at any time and will asynchronously destroy the same ID.  Remove the ID from visiblity of cma_process_remove() before going down the destroy path outside the locking.  ",dd37d2f59eb839d51b988f6668ce5f0d533b23fd,0
kvm: debugfs: fix memory leak in kvm_create_vm_debugfs,"In commit bc9e9e672df9 (""KVM: debugfs: Reuse binary stats descriptors"") loop for filling debugfs_stat_data was copy-pasted 2 times, but in the second loop pointers are saved over pointers allocated in the first loop.  All this causes is a memory leak, fix it.  ",004d62eb4e57db3c391ed0df007cc11c93b6fbeb,1
ipv6: ip6_make_skb() needs to clear cork.base.dst,"In my last patch, I missed fact that cork.base.dst was not initialized in ip6_make_skb() :  If ip6_setup_cork() returns an error, we might attempt a dst_release() on some random pointer.  ",95ef498d977bf44ac094778fd448b98af158a3e6,0
nfc: llcp: fix NULL error pointer dereference on sendmsg() after failed bind(),"Syzbot detected a NULL pointer dereference of nfc_llcp_sock->dev pointer (which is a 'struct nfc_dev *') with calls to llcp_sock_sendmsg() after a failed llcp_sock_bind(). The message being sent is a SOCK_DGRAM.  KASAN report:    BUG: KASAN: null-ptr-deref in nfc_alloc_send_skb+0x2d/0xc0   Read of size 4 at addr 00000000000005c8 by task llcp_sock_nfc_a/899    CPU: 5 PID: 899 Comm: llcp_sock_nfc_a Not tainted 5.16.0-rc6-next-20211224-00001-gc6437fbf18b0 #125   Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS 1.14.0-2 04/01/2014   Call Trace:    <TASK>    dump_stack_lvl+0x45/0x59    ? nfc_alloc_send_skb+0x2d/0xc0    __kasan_report.cold+0x117/0x11c    ? mark_lock+0x480/0x4f0    ? nfc_alloc_send_skb+0x2d/0xc0    kasan_report+0x38/0x50    nfc_alloc_send_skb+0x2d/0xc0    nfc_llcp_send_ui_frame+0x18c/0x2a0    ? nfc_llcp_send_i_frame+0x230/0x230    ? __local_bh_enable_ip+0x86/0xe0    ? llcp_sock_connect+0x470/0x470    ? llcp_sock_connect+0x470/0x470    sock_sendmsg+0x8e/0xa0    ____sys_sendmsg+0x253/0x3f0    ...  The issue was visible only with multiple simultaneous calls to bind() and sendmsg(), which resulted in most of the bind() calls to fail.  The bind() was failing on checking if there is available WKS/SDP/SAP (respective bit in 'struct nfc_llcp_local' fields).  When there was no available WKS/SDP/SAP, the bind returned error but the sendmsg() to such socket was able to trigger mentioned NULL pointer dereference of nfc_llcp_sock->dev.  The code looks simply racy and currently it protects several paths against race with checks for (!nfc_llcp_sock->local) which is NULL-ified in error paths of bind().  The llcp_sock_sendmsg() did not have such check but called function nfc_llcp_send_ui_frame() had, although not protected with lock_sock().  Therefore the race could look like (same socket is used all the time):   CPU0                                     CPU1   ====                                     ====   llcp_sock_bind()   - lock_sock()     - success   - release_sock()   - return 0                                            llcp_sock_sendmsg()                                            - lock_sock()                                            - release_sock()   llcp_sock_bind(), same socket   - lock_sock()     - error                                            - nfc_llcp_send_ui_frame()                                              - if (!llcp_sock->local)     - llcp_sock->local = NULL     - nfc_put_device(dev)                                              - dereference llcp_sock->dev   - release_sock()   - return -ERRNO  The nfc_llcp_send_ui_frame() checked llcp_sock->local outside of the lock, which is racy and ineffective check.  Instead, its caller llcp_sock_sendmsg(), should perform the check inside lock_sock().  ",dded08927ca3c31a5c37f8e7f95fe98770475dd4,1
can: bcm/raw/isotp: use per module netdevice notifier,"syzbot is reporting hung task at register_netdevice_notifier() [1] and unregister_netdevice_notifier() [2], for cleanup_net() might perform time consuming operations while CAN driver's raw/bcm/isotp modules are calling {register,unregister}_netdevice_notifier() on each socket.  Change raw/bcm/isotp modules to call register_netdevice_notifier() from module's __init function and call unregister_netdevice_notifier() from module's __exit function, as with gw/j1939 modules are doing.  ",8d0caedb759683041d9db82069937525999ada53,0
Bluetooth: Fix memory leak in read_adv_mon_features(),read_adv_mon_features() is leaking memory. Free `rp` before returning.  ,cafd472a10ff3bccd8afd25a69f20a491cd8d7b8,1
bpf: Fix a buffer out-of-bound access when filling raw_tp link_info,"Commit f2e10bff16a0 (""bpf: Add support for BPF_OBJ_GET_INFO_BY_FD for bpf_link"") added link query for raw_tp. One of fields in link_info is to fill a user buffer with tp_name. The Scurrent checking only declares ""ulen && !ubuf"" as invalid. So ""!ulen && ubuf"" will be valid. Later on, we do ""copy_to_user(ubuf, tp_name, ulen - 1)"" which may overwrite user memory incorrectly.  This patch fixed the problem by disallowing ""!ulen && ubuf"" case as well.  ",b474959d5afda6e341a02c85f9595d85d39189ae,1
tipc: fix a dangling pointer,"tsk->group is set to grp earlier, but we forget to unset it after grp is freed.  ",e233df01576bba9f5bafacccd571353b72152bd5,0
netfilter: ebtables: CONFIG_COMPAT: don't trust userland offsets,"We need to make sure the offsets are not out of range of the total size. Also check that they are in ascending order.  The WARN_ON triggered by syzkaller (it sets panic_on_warn) is changed to also bail out, no point in continuing parsing.  Briefly tested with simple ruleset of -A INPUT --limit 1/s' --log plus jump to custom chains using 32bit ebtables binary.  ",b71812168571fa55e44cdd0254471331b9c4c4c6,1
net/smc: fix NULL pointer dereference on sock_create_kern() error path,"when sock_create_kern(..., a) returns an error, 'a' might not be a valid pointer, so it shouldn't be dereferenced to read a->sk->sk_sndbuf and and a->sk->sk_rcvbuf; not doing that caused the following crash:  general protection fault: 0000 [#1] SMP KASAN Dumping ftrace buffer:     (ftrace buffer empty) ",a5dcb73b96a9d21431048bdaac02d9e96f386da3,1
"seccomp, bpf: disable preemption before calling into bpf prog",All BPF programs must be called with preemption disabled.  ,e80d02dd763093f70c3000ef34253a6d426becf6,0
bdi: wake up concurrent wb_shutdown() callers.,"syzbot is reporting hung tasks at wait_on_bit(WB_shutting_down) in wb_shutdown() [1]. This seems to be because commit 5318ce7d46866e1d (""bdi: Shutdown writeback on all cgwbs in cgwb_bdi_destroy()"") forgot to call wake_up_bit(WB_shutting_down) after clear_bit(WB_shutting_down).  Introduce a helper function clear_and_wake_up_bit() and use it, in order to avoid similar errors in future.  [1] https://syzkaller.appspot.com/bug?id=b297474817af98d5796bc544e1bb806fc3da0e5e  ",8236b0ae31c837d2b3a2565c5f8d77f637e824cc,1
net: ieee802154: fix nl802154 del llsec devkey,This patch fixes a nullpointer dereference if NL802154_ATTR_SEC_DEVKEY is not set by the user. If this is the case nl802154 will return -EINVAL.  ,27c746869e1a135dffc2f2a80715bb7aa00445b4,1
sctp: fix error path in sctp_stream_init,"syzbot noticed a NULL pointer dereference panic in sctp_stream_free() which was caused by an incomplete error handling in sctp_stream_init(). By not clearing stream->outcnt, it made a for() in sctp_stream_free() think that it had elements to free, but not, leading to the panic.  As suggested by Xin Long, this patch also simplifies the error path by moving it to the only if() that uses it.  See-also: https://www.spinics.net/lists/netdev/msg473756.html See-also: https://www.spinics.net/lists/netdev/msg465024.html ",79d0895140e937ba111e6420b4cd83ee75efa788,1
exfat: fix shift-out-of-bounds in exfat_fill_super(),"syzbot reported a warning which could cause shift-out-of-bounds issue.  Call Trace:  __dump_stack lib/dump_stack.c:79 [inline]  dump_stack+0x183/0x22e lib/dump_stack.c:120  ubsan_epilogue lib/ubsan.c:148 [inline]  __ubsan_handle_shift_out_of_bounds+0x432/0x4d0 lib/ubsan.c:395  exfat_read_boot_sector fs/exfat/super.c:471 [inline]  __exfat_fill_super fs/exfat/super.c:556 [inline]  exfat_fill_super+0x2acb/0x2d00 fs/exfat/super.c:624  get_tree_bdev+0x406/0x630 fs/super.c:1291  vfs_get_tree+0x86/0x270 fs/super.c:1496  do_new_mount fs/namespace.c:2881 [inline]  path_mount+0x1937/0x2c50 fs/namespace.c:3211  do_mount fs/namespace.c:3224 [inline]  __do_sys_mount fs/namespace.c:3432 [inline]  __se_sys_mount+0x2f9/0x3b0 fs/namespace.c:3409  do_syscall_64+0x2d/0x70 arch/x86/entry/common.c:46  entry_SYSCALL_64_after_hwframe+0x44/0xa9  exfat specification describe sect_per_clus_bits field of boot sector could be at most 25 - sect_size_bits and at least 0. And sect_size_bits can also affect this calculation, It also needs validation. This patch add validation for sect_per_clus_bits and sect_size_bits field of boot sector.  ",78c276f5495aa53a8beebb627e5bf6a54f0af34f,1
sch_dsmark: fix potential NULL deref in dsmark_init(),"Make sure TCA_DSMARK_INDICES was provided by the user.  syzbot reported :  kasan: CONFIG_KASAN_INLINE enabled kasan: GPF could be caused by NULL-ptr deref or user memory access general protection fault: 0000 [#1] PREEMPT SMP KASAN CPU: 1 PID: 8799 Comm: syz-executor235 Not tainted 5.3.0+ #0 Hardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 01/01/2011 ",474f0813a3002cb299bb73a5a93aa1f537a80ca8,1
net: handle NULL ->poll gracefully,The big aio poll revert broke various network protocols that don't implement ->poll as a patch in the aio poll serie removed sock_no_poll and made the common code handle this case.  ,e88958e6369aeba48623afa18dd67fdf41c98d75,0
net: hsr: fix possible NULL deref in hsr_handle_frame(),"hsr_port_get_rcu() can return NULL, so we need to be careful.  general protection fault, probably for non-canonical address 0xdffffc0000000006: 0000 [#1] PREEMPT SMP KASAN KASAN: null-ptr-deref in range [0x0000000000000030-0x0000000000000037] CPU: 1 PID: 10249 Comm: syz-executor.5 Not tainted 5.5.0-syzkaller #0 Hardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 01/01/2011 ",2b5b8251bc9fe2f9118411f037862ee17cf81e97,1
io_uring: fail io_uring_register(2) on a dying io_uring instance,"If we have multiple threads doing io_uring_register(2) on an io_uring fd, then we can potentially try and kill the percpu reference while someone else has already killed it.  Prevent this race by failing io_uring_register(2) if the ref is marked dying. This is safe since we're inside the io_uring mutex.  ",35fa71a030caa50458a043560d4814ea9bcd639f,1
net: add READ_ONCE() annotation in __skb_wait_for_more_packets(),"__skb_wait_for_more_packets() can be called while other cpus can feed packets to the socket receive queue.  KCSAN reported :  BUG: KCSAN: data-race in __skb_wait_for_more_packets / __udp_enqueue_schedule_skb  write to 0xffff888102e40b58 of 8 bytes by interrupt on cpu 0:  __skb_insert include/linux/skbuff.h:1852 [inline]  __skb_queue_before include/linux/skbuff.h:1958 [inline]  __skb_queue_tail include/linux/skbuff.h:1991 [inline]  __udp_enqueue_schedule_skb+0x2d7/0x410 net/ipv4/udp.c:1470  __udp_queue_rcv_skb net/ipv4/udp.c:1940 [inline]  udp_queue_rcv_one_skb+0x7bd/0xc70 net/ipv4/udp.c:2057  udp_queue_rcv_skb+0xb5/0x400 net/ipv4/udp.c:2074  udp_unicast_rcv_skb.isra.0+0x7e/0x1c0 net/ipv4/udp.c:2233  __udp4_lib_rcv+0xa44/0x17c0 net/ipv4/udp.c:2300  udp_rcv+0x2b/0x40 net/ipv4/udp.c:2470  ip_protocol_deliver_rcu+0x4d/0x420 net/ipv4/ip_input.c:204  ip_local_deliver_finish+0x110/0x140 net/ipv4/ip_input.c:231  NF_HOOK include/linux/netfilter.h:305 [inline]  NF_HOOK include/linux/netfilter.h:299 [inline]  ip_local_deliver+0x133/0x210 net/ipv4/ip_input.c:252  dst_input include/net/dst.h:442 [inline]  ip_rcv_finish+0x121/0x160 net/ipv4/ip_input.c:413  NF_HOOK include/linux/netfilter.h:305 [inline]  NF_HOOK include/linux/netfilter.h:299 [inline]  ip_rcv+0x18f/0x1a0 net/ipv4/ip_input.c:523  __netif_receive_skb_one_core+0xa7/0xe0 net/core/dev.c:5010  __netif_receive_skb+0x37/0xf0 net/core/dev.c:5124  process_backlog+0x1d3/0x420 net/core/dev.c:5955  read to 0xffff888102e40b58 of 8 bytes by task 13035 on cpu 1:  __skb_wait_for_more_packets+0xfa/0x320 net/core/datagram.c:100  __skb_recv_udp+0x374/0x500 net/ipv4/udp.c:1683  udp_recvmsg+0xe1/0xb10 net/ipv4/udp.c:1712  inet_recvmsg+0xbb/0x250 net/ipv4/af_inet.c:838  sock_recvmsg_nosec+0x5c/0x70 net/socket.c:871  ___sys_recvmsg+0x1a0/0x3e0 net/socket.c:2480  do_recvmmsg+0x19a/0x5c0 net/socket.c:2601  __sys_recvmmsg+0x1ef/0x200 net/socket.c:2680  __do_sys_recvmmsg net/socket.c:2703 [inline]  __se_sys_recvmmsg net/socket.c:2696 [inline]  __x64_sys_recvmmsg+0x89/0xb0 net/socket.c:2696  do_syscall_64+0xcc/0x370 arch/x86/entry/common.c:290  entry_SYSCALL_64_after_hwframe+0x44/0xa9  Reported by Kernel Concurrency Sanitizer on: CPU: 1 PID: 13035 Comm: syz-executor.3 Not tainted 5.4.0-rc3+ #0 Hardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 01/01/2011  ",7c422d0ce97552dde4a97e6290de70ec6efb0fc6,1
ovl: fix oopses in ovl_fill_super() failure paths,ovl_free_fs() dereferences ofs->workbasedir and ofs->upper_mnt in cases when those might not have been initialized yet.  Fix the initialization order for these fields.  ,8c25741aaad8be6fbe51510e917c740e0059cf83,1
io_uring: fix poll requests leaking second poll entries,"For pure poll requests, it doesn't remove the second poll wait entry when it's done, neither after vfs_poll() or in the poll completion handler. We should remove the second poll wait entry. And we use io_poll_remove_double() rather than io_poll_remove_waitqs() since the latter has some redundant logic.  ",a890d01e4ee016978776e45340e521b3bbbdf41f,0
io_uring: Convert personality_idr to XArray,"You can't call idr_remove() from within a idr_for_each() callback, but you can call xa_erase() from an xa_for_each() loop, so switch the entire personality_idr from the IDR to the XArray.  This manifests as a use-after-free as idr_for_each() attempts to walk the rest of the node after removing the last entry from it.  ",61cf93700fe6359552848ed5e3becba6cd760efa,1
hugetlbfs: fix off-by-one error in hugetlb_vmdelete_list(),"Pass ""end - 1"" instead of ""end"" when walking the interval tree in hugetlb_vmdelete_list() to fix an inclusive vs.  exclusive bug.  The two callers that pass a non-zero ""end"" treat it as exclusive, whereas the interval tree iterator expects an inclusive ""last"".  E.g.  punching a hole in a file that precisely matches the size of a single hugepage, with a vma starting right on the boundary, will result in unmap_hugepage_range() being called twice, with the second call having start==end.  The off-by-one error doesn't cause functional problems as __unmap_hugepage_range() turns into a massive nop due to short-circuiting its for-loop on ""address < end"".  But, the mmu_notifier invocations to invalid_range_{start,end}() are passed a bogus zero-sized range, which may be unexpected behavior for secondary MMUs.  The bug was exposed by commit ed922739c919 (""KVM: Use interval tree to do fast hva lookup in memslots""), currently queued in the KVM tree for 5.17, which added a WARN to detect ranges with start==end.  ",d6aba4c8e20d4d2bf65d589953f6d891c178f3a3,0
io_uring: add missing finish_wait() in io_sq_thread(),Add it to pair with prepare_to_wait() in an attempt to avoid anything weird in the field.  ,10bea96dcc13ad841d53bdcc9d8e731e9e0ad58f,0
fat: fix memory allocation failure handling of match_strdup(),"In parse_options(), if match_strdup() failed, parse_options() leaves opts->iocharset in unexpected state (i.e.  still pointing the freed string).  And this can be the cause of double free.  To fix, this initialize opts->iocharset always when freeing.  ",35033ab988c396ad7bce3b6d24060c16a9066db8,1
io-wq: fix double put of 'wq' in error path,"We are already freeing the wq struct in both spots, so don't put it and get it freed twice.  ",470ec4ed8c91b4db398ad607c700e9ce88365202,0
KVM: x86: fix shift out of bounds reported by UBSAN,"Since we know that e >= s, we can reassociate the left shift, changing the shifted number from 1 to 2 in exchange for decreasing the right hand side by 1.  ",2f80d502d627f30257ba7e3655e71c373b7d1a5a,1
fat: don't allow to mount if the FAT length == 0,"If FAT length == 0, the image doesn't have any data. And it can be the cause of overlapping the root dir and FAT entries.  Also Windows treats it as invalid format.  ",b1b65750b8db67834482f758fc385bfa7560d228,0
bpf: fix panic due to oob in bpf_prog_test_run_skb,sykzaller triggered several panics similar to the below:    [...]   ,6e6fddc78323533be570873abb728b7e0ba7e024,0
rxrpc: Fix conn bundle leak in net-namespace exit,"When the network namespace exits, rxrpc_clean_up_local_conns() needs to unbundle each client connection it evicts.  Fix it to do this.  kernel BUG at net/rxrpc/conn_object.c:481! ",546a42410bf76075e157dbdd94c097b3bc44b25a,1
ipv6: drop incoming packets having a v4mapped source address,"This began with a syzbot report. syzkaller was injecting IPv6 TCP SYN packets having a v4mapped source address.  After an unsuccessful 4-tuple lookup, TCP creates a request socket (SYN_RECV) and calls reqsk_queue_hash_req()  reqsk_queue_hash_req() calls sk_ehashfn(sk)  At this point we have AF_INET6 sockets, and the heuristic used by sk_ehashfn() to either hash the IPv4 or IPv6 addresses is to use ipv6_addr_v4mapped(&sk->sk_v6_daddr)  For the particular spoofed packet, we end up hashing V4 addresses which were not initialized by the TCP IPv6 stack, so KMSAN fired a warning.  I first fixed sk_ehashfn() to test both source and destination addresses, but then faced various problems, including user-space programs like packetdrill that had similar assumptions.  Instead of trying to fix the whole ecosystem, it is better to admit that we have a dual stack behavior, and that we can not build linux kernels without V4 stack anyway.  The dual stack API automatically forces the traffic to be IPv4 if v4mapped addresses are used at bind() or connect(), so it makes no sense to allow IPv6 traffic to use the same v4mapped class.  ",6af1799aaf3f1bc8defedddfa00df3192445bbf3,1
xfs: fix inobt magic number check,"In commit a6a781a58befcbd467c (""xfs: have buffer verifier functions report failing address"") the bad magic number return was ported incorrectly.  ",2e050e648ad6c74a2f0a28f645155128be0626ca,0
rxrpc: Fix read-after-free in rxrpc_queue_local(),"rxrpc_queue_local() attempts to queue the local endpoint it is given and then, if successful, prints a trace line.  The trace line includes the current usage count - but we're not allowed to look at the local endpoint at this point as we passed our ref on it to the workqueue.  Fix this by reading the usage count before queuing the work item.  Also fix the reading of local->debug_id for trace lines, which must be done with the same consideration as reading the usage count.  ",06d9532fa6b34f12a6d75711162d47c17c1add72,0
virtio-gpu: fix possible memory allocation failure,"When kmem_cache_zalloc in virtio_gpu_get_vbuf fails, it will return an error code. But none of its callers checks this error code, and a core dump will take place.  Considering many of its callers can't handle such error, I add a __GFP_NOFAIL flag when calling kmem_cache_zalloc to make sure it won't fail, and delete those unused error handlings.  ",5bd4f20de8acad37dbb3154feb34dbc36d506c02,1
netem: fix zero division in tabledist,"Currently it is possible to craft a special netlink RTM_NEWQDISC command that can result in jitter being equal to 0x80000000. It is enough to set the 32 bit jitter to 0x02000000 (it will later be multiplied by 2^6) or just set the 64 bit jitter via TCA_NETEM_JITTER64. This causes an overflow during the generation of uniformly distributed numbers in tabledist(), which in turn leads to division by zero (sigma != 0, but sigma * 2 is 0).  The related fragment of code needs 32-bit division - see commit 9b0ed89 (""netem: remove unnecessary 64 bit modulus""), so switching to 64 bit is not an option.  Fix the issue by keeping the value of jitter within the range that can be adequately handled by tabledist() - [0;INT_MAX]. As negative std deviation makes no sense, take the absolute value of the passed value and cap it at INT_MAX. Inside tabledist(), switch to unsigned 32 bit arithmetic in order to prevent overflows.  ",eadd1befdd778a1eca57fad058782bd22b4db804,1
cfg80211: fix debugfs rename crash,"Removing the ""if (IS_ERR(dir)) dir = NULL;"" check only works if we adjust the remaining code to not rely on it being NULL. Check IS_ERR_OR_NULL() before attempting to dereference it.  I'm not actually entirely sure this fixes the syzbot crash as the kernel config indicates that they do have DEBUG_FS in the kernel, but this is what I found when looking there.  ",0bbab5f0301587cad4e923ccc49bb910db86162c,1
ax25: fix possible use-after-free,"syzbot found that ax25 routes where not properly protected against concurrent use [1].  In this particular report the bug happened while copying ax25->digipeat.  Fix this problem by making sure we call ax25_get_route() while ax25_route_lock is held, so that no modification could happen while using the route.  The current two ax25_get_route() callers do not sleep, so this change should be fine.  Once we do that, ax25_get_route() no longer needs to grab a reference on the found route.  [1] ax25_connect(): syz-executor0 uses autobind, please contact jreuter@yaina.de BUG: KASAN: use-after-free in memcpy include/linux/string.h:352 [inline] BUG: KASAN: use-after-free in kmemdup+0x42/0x60 mm/util.c:113 Read of size 66 at addr ffff888066641a80 by task syz-executor2/531  ax25_connect(): syz-executor0 uses autobind, please contact jreuter@yaina.de CPU: 1 PID: 531 Comm: syz-executor2 Not tainted 5.0.0-rc2+ #10 Hardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 01/01/2011 Call Trace:  __dump_stack lib/dump_stack.c:77 [inline]  dump_stack+0x1db/0x2d0 lib/dump_stack.c:113  print_address_description.cold+0x7c/0x20d mm/kasan/report.c:187  kasan_report.cold+0x1b/0x40 mm/kasan/report.c:317  check_memory_region_inline mm/kasan/generic.c:185 [inline]  check_memory_region+0x123/0x190 mm/kasan/generic.c:191  memcpy+0x24/0x50 mm/kasan/common.c:130  memcpy include/linux/string.h:352 [inline]  kmemdup+0x42/0x60 mm/util.c:113  kmemdup include/linux/string.h:425 [inline]  ax25_rt_autobind+0x25d/0x750 net/ax25/ax25_route.c:424  ax25_connect.cold+0x30/0xa4 net/ax25/af_ax25.c:1224  __sys_connect+0x357/0x490 net/socket.c:1664  __do_sys_connect net/socket.c:1675 [inline]  __se_sys_connect net/socket.c:1672 [inline]  __x64_sys_connect+0x73/0xb0 net/socket.c:1672  do_syscall_64+0x1a3/0x800 arch/x86/entry/common.c:290  entry_SYSCALL_64_after_hwframe+0x49/0xbe ",63530aba7826a0f8e129874df9c4d264f9db3f9e,1
namei: Fix use after free in kern_path_locked,"In 0ee50b47532a (""namei: change filename_parentat() calling conventions""), filename_parentat() was made to always call putname() on the  filename before returning, and kern_path_locked() was migrated to this calling convention.  However, kern_path_locked() uses the ""last"" parameter to lookup and potentially create a new dentry. The last parameter contains the last component of the path and points within the filename, which was recently freed at the end of filename_parentat(). Thus, when kern_path_locked() calls __lookup_hash(), it is using the filename after it has already been freed.  In other words, these calling conventions had been wrong for the only remaining caller of filename_parentat().  Everything else is using __filename_parentat(), which does not drop the reference; so should kern_path_locked().  Switch kern_path_locked() to use of __filename_parentat() and move getting/dropping struct filename into wrapper.  Remove filename_parentat(), now that we have no remaining callers.  ",0766ec82e5fb26fc5dc6d592bc61865608bdc651,1
net: pegasus: fix uninit-value in get_interrupt_interval,"Syzbot reported uninit value pegasus_probe(). The problem was in missing error handling.  get_interrupt_interval() internally calls read_eprom_word() which can fail in some cases. For example: failed to receive usb control message. These cases should be handled to prevent uninit value bug, since read_eprom_word() will not initialize passed stack variable in case of internal failure.  Fail log:  BUG: KMSAN: uninit-value in get_interrupt_interval drivers/net/usb/pegasus.c:746 [inline] BUG: KMSAN: uninit-value in pegasus_probe+0x10e7/0x4080 drivers/net/usb/pegasus.c:1152 CPU: 1 PID: 825 Comm: kworker/1:1 Not tainted 5.12.0-rc6-syzkaller #0 ... Workqueue: usb_hub_wq hub_event Call Trace:  __dump_stack lib/dump_stack.c:79 [inline]  dump_stack+0x24c/0x2e0 lib/dump_stack.c:120  kmsan_report+0xfb/0x1e0 mm/kmsan/kmsan_report.c:118  __msan_warning+0x5c/0xa0 mm/kmsan/kmsan_instr.c:197  get_interrupt_interval drivers/net/usb/pegasus.c:746 [inline]  pegasus_probe+0x10e7/0x4080 drivers/net/usb/pegasus.c:1152 ....  Local variable ",af35fc37354cda3c9c8cc4961b1d24bdc9d27903,1
tcp: fix TCP_REPAIR_QUEUE bound checking,"syzbot is able to produce a nasty WARN_ON() in tcp_verify_left_out() with following C-repro :  socket(PF_INET, SOCK_STREAM, IPPROTO_IP) = 3 setsockopt(3, SOL_TCP, TCP_REPAIR, [1], 4) = 0 setsockopt(3, SOL_TCP, TCP_REPAIR_QUEUE, [-1], 4) = 0 bind(3, {sa_family=AF_INET, sin_port=htons(20002), sin_addr=inet_addr(""0.0.0.0"")}, 16) = 0 sendto(3, ""\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0""..., 	1242, MSG_FASTOPEN, {sa_family=AF_INET, sin_port=htons(20002), sin_addr=inet_addr(""127.0.0.1"")}, 16) = 1242 setsockopt(3, SOL_TCP, TCP_REPAIR_WINDOW, ""\4\0\0@+\205\0\0\377\377\0\0\377\377\377\177\0\0\0\0"", 20) = 0 writev(3, [{""\270"", 1}], 1)             = 1 setsockopt(3, SOL_TCP, TCP_REPAIR_OPTIONS, ""\10\0\0\0\0\0\0\0\0\0\0\0|\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0""..., 386) = 0 writev(3, [{""\210v\r[\226\320t\231qwQ\204\264l\254\t\1\20\245\214p\350H\223\254;\\\37\345\307p$""..., 3144}], 1) = 3144  The 3rd system call looks odd : setsockopt(3, SOL_TCP, TCP_REPAIR_QUEUE, [-1], 4) = 0  This patch makes sure bound checking is using an unsigned compare.  ",bf2acc943a45d2b2e8a9f1a5ddff6b6e43cc69d9,0
"bpf, sockmap: Fix double bpf_prog_put on error case in map_link","sock_map_link() is called to update a sockmap entry with a sk. But, if the sock_map_init_proto() call fails then we return an error to the map_update op against the sockmap. In the error path though we need to cleanup psock and dec the refcnt on any programs associated with the map, because we refcnt them early in the update process to ensure they are pinned for the psock. (This avoids a race where user deletes programs while also updating the map with new socks.)  In current code we do the prog refcnt dec explicitely by calling bpf_prog_put() when the program was found in the map. But, after commit '38207a5e81230' in this error path we've already done the prog to psock assignment so the programs have a reference from the psock as well. This then causes the psock tear down logic, invoked by sk_psock_put() in the error path, to similarly call bpf_prog_put on the programs there.  To be explicit this logic does the prog->psock assignment:    if (msg_*)     psock_set_prog(...)  Then the error path under the out_progs label does a similar check and dec with:    if (msg_*)      bpf_prog_put(...)  And the teardown logic sk_psock_put() does ...    psock_set_prog(msg_*, NULL)  ... triggering another bpf_prog_put(...). Then KASAN gives us this splat, found by syzbot because we've created an inbalance between bpf_prog_inc and bpf_prog_put calling put twice on the program.    BUG: KASAN: vmalloc-out-of-bounds in __bpf_prog_put kernel/bpf/syscall.c:1812 [inline]   BUG: KASAN: vmalloc-out-of-bounds in __bpf_prog_put kernel/bpf/syscall.c:1812 [inline] kernel/bpf/syscall.c:1829   BUG: KASAN: vmalloc-out-of-bounds in bpf_prog_put+0x8c/0x4f0 kernel/bpf/syscall.c:1829 kernel/bpf/syscall.c:1829   Read of size 8 at addr ffffc90000e76038 by task syz-executor020/3641  To fix clean up error path so it doesn't try to do the bpf_prog_put in the error path once progs are assigned then it relies on the normal psock tear down logic to do complete cleanup.  For completness we also cover the case whereh sk_psock_init_strp() fails, but this is not expected because it indicates an incorrect socket type and should be caught earlier.  ",218d747a4142f281a256687bb513a135c905867b,1
block: tolerate tracing of NULL bio,__get_request() can call trace_block_getrq() with bio=NULL which causes block_get_rq::TP_fast_assign() to deref a NULL pointer and panic.  Syzkaller fuzzer panics with linux-next (1d53d908b79d7870d89063062584eead4cf83448):   kasan: GPF could be caused by NULL-ptr deref or user memory access   general protection fault: 0000 [#1] SMP KASAN   ,f8e9ec16611baa8db77a7d46facd2ba7aa525955,1
binder: prevent transactions to context manager from its own process.,"Currently, a transaction to context manager from its own process is prevented by checking if its binder_proc struct is the same as that of the sender. However, this would not catch cases where the process opens the binder device again and uses the new fd to send a transaction to the context manager.  ",49ed96943a8e0c62cc5a9b0a6cfc88be87d1fcec,0
net/smc: fix leak of kernel memory to user space,"As nlmsg_put() does not clear the memory that is reserved, it this the caller responsability to make sure all of this memory will be written, in order to not reveal prior content.  While we are at it, we can provide the socket cookie even if clsock is not set.  syzbot reported :  BUG: KMSAN: uninit-value in __arch_swab32 arch/x86/include/uapi/asm/swab.h:10 [inline] BUG: KMSAN: uninit-value in __fswab32 include/uapi/linux/swab.h:59 [inline] BUG: KMSAN: uninit-value in __swab32p include/uapi/linux/swab.h:179 [inline] BUG: KMSAN: uninit-value in __be32_to_cpup include/uapi/linux/byteorder/little_endian.h:82 [inline] BUG: KMSAN: uninit-value in get_unaligned_be32 include/linux/unaligned/access_ok.h:30 [inline] BUG: KMSAN: uninit-value in ____bpf_skb_load_helper_32 net/core/filter.c:240 [inline] BUG: KMSAN: uninit-value in ____bpf_skb_load_helper_32_no_cache net/core/filter.c:255 [inline] BUG: KMSAN: uninit-value in bpf_skb_load_helper_32_no_cache+0x14a/0x390 net/core/filter.c:252 CPU: 1 PID: 5262 Comm: syz-executor.5 Not tainted 5.5.0-rc5-syzkaller #0 Hardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 01/01/2011 Call Trace:  __dump_stack lib/dump_stack.c:77 [inline]  dump_stack+0x1c9/0x220 lib/dump_stack.c:118  kmsan_report+0xf7/0x1e0 mm/kmsan/kmsan_report.c:118  __msan_warning+0x58/0xa0 mm/kmsan/kmsan_instr.c:215  __arch_swab32 arch/x86/include/uapi/asm/swab.h:10 [inline]  __fswab32 include/uapi/linux/swab.h:59 [inline]  __swab32p include/uapi/linux/swab.h:179 [inline]  __be32_to_cpup include/uapi/linux/byteorder/little_endian.h:82 [inline]  get_unaligned_be32 include/linux/unaligned/access_ok.h:30 [inline]  ____bpf_skb_load_helper_32 net/core/filter.c:240 [inline]  ____bpf_skb_load_helper_32_no_cache net/core/filter.c:255 [inline]  bpf_skb_load_helper_32_no_cache+0x14a/0x390 net/core/filter.c:252  ",457fed775c97ac2c0cd1672aaf2ff2c8a6235e87,1
Bluetooth: Fix invalid-free in bcsp_close(),Syzbot reported an invalid-free that I introduced fixing a memleak.  bcsp_recv() also frees bcsp->rx_skb but never nullifies its value. Nullify bcsp->rx_skb every time it is freed.  ,cf94da6f502d8caecabd56b194541c873c8a7a3c,0
p54usb: Fix race between disconnect and firmware loading,"The syzbot fuzzer found a bug in the p54 USB wireless driver.  The issue involves a race between disconnect and the firmware-loader callback routine, and it has several aspects.  One big problem is that when the firmware can't be loaded, the callback routine tries to unbind the driver from the USB _device_ (by calling device_release_driver) instead of from the USB _interface_ to which it is actually bound (by calling usb_driver_release_interface).  The race involves access to the private data structure.  The driver's disconnect handler waits for a completion that is signalled by the firmware-loader callback routine.  As soon as the completion is signalled, you have to assume that the private data structure may have been deallocated by the disconnect handler -- even if the firmware was loaded without errors.  However, the callback routine does access the private data several times after that point.  Another problem is that, in order to ensure that the USB device structure hasn't been freed when the callback routine runs, the driver takes a reference to it.  This isn't good enough any more, because now that the callback routine calls usb_driver_release_interface, it has to ensure that the interface structure hasn't been freed.  Finally, the driver takes an unnecessary reference to the USB device structure in the probe function and drops the reference in the disconnect handler.  This extra reference doesn't accomplish anything, because the USB core already guarantees that a device structure won't be deallocated while a driver is still bound to any of its interfaces.  To fix these problems, this patch makes the following changes:  	Call usb_driver_release_interface() rather than 	device_release_driver().  	Don't signal the completion until after the important 	information has been copied out of the private data structure, 	and don't refer to the private data at all thereafter.  	Lock udev (the interface's parent) before unbinding the driver 	instead of locking udev->parent.  	During the firmware loading process, take a reference to the 	USB interface instead of the USB device.  	Don't take an unnecessary reference to the device during probe 	(and then don't drop it during disconnect).  ",6e41e2257f1094acc37618bf6c856115374c6922,1
net: batman-adv: fix error handling,"Syzbot reported ODEBUG warning in batadv_nc_mesh_free(). The problem was in wrong error handling in batadv_mesh_init().  Before this patch batadv_mesh_init() was calling batadv_mesh_free() in case of any batadv_*_init() calls failure. This approach may work well, when there is some kind of indicator, which can tell which parts of batadv are initialized; but there isn't any.  All written above lead to cleaning up uninitialized fields. Even if we hide ODEBUG warning by initializing bat_priv->nc.work, syzbot was able to hit GPF in batadv_nc_purge_paths(), because hash pointer in still NULL. [1]  To fix these bugs we can unwind batadv_*_init() calls one by one. It is good approach for 2 reasons: 1) It fixes bugs on error handling path 2) It improves the performance, since we won't call unneeded batadv_*_free() functions.  So, this patch makes all batadv_*_init() clean up all allocated memory before returning with an error to no call correspoing batadv_*_free() and open-codes batadv_mesh_free() with proper order to avoid touching uninitialized fields.  ",6f68cd634856f8ca93bafd623ba5357e0f648c68,1
tcp: fix zerocopy and notsent_lowat issues,"My recent patch had at least three problems :  1) TX zerocopy wants notification when skb is acknowledged,    thus we need to call skb_zcopy_clear() if the skb is    cached into sk->sk_tx_skb_cache  2) Some applications might expect precise EPOLLOUT    notifications, so we need to update sk->sk_wmem_queued    and call sk_mem_uncharge() from sk_wmem_free_skb()    in all cases. The SOCK_QUEUE_SHRUNK flag must also be set.  3) Reuse of saved skb should have used skb_cloned() instead   of simply checking if the fast clone has been freed.  ",4f661542a40217713f2cee0bb6678fbb30d9d367,0
drivers/misc/vmw_vmci: restrict too big queue size in qp_host_alloc_queue,syzbot found ,2fd10bcf0310b9525b2af9e1f7aa9ddd87c3772e,0
dma-buf: Move dma_buf_release() from fops to dentry_ops,"Charan Teja reported a 'use-after-free' in dmabuffs_dname [1], which happens if the dma_buf_release() is called while the userspace is accessing the dma_buf pseudo fs's dmabuffs_dname() in another process, and dma_buf_release() releases the dmabuf object when the last reference to the struct file goes away.  I discussed with Arnd Bergmann, and he suggested that rather than tying the dma_buf_release() to the file_operations' release(), we can tie it to the dentry_operations' d_release(), which will be called when the last ref to the dentry is removed.  The path exercised by __fput() calls f_op->release() first, and then calls dput, which eventually calls d_op->d_release().  In the 'normal' case, when no userspace access is happening via dma_buf pseudo fs, there should be exactly one fd, file, dentry and inode, so closing the fd will kill of everything right away.  In the presented case, the dentry's d_release() will be called only when the dentry's last ref is released.  Therefore, lets move dma_buf_release() from fops->release() to d_ops->d_release()  Many thanks to Arnd for his FS insights :)  [1]: https://lore.kernel.org/patchwork/patch/1238278/  ",4ab59c3c638c6c8952bf07739805d20eb6358a4d,1
ovl: fix recursive oi->lock in ovl_link(),"linking a non-copied-up file into a non-copied-up parent results in a nested call to mutex_lock_interruptible(&oi->lock). Fix this by copying up target parent before ovl_nlink_start(), same as done in ovl_rename().  ~/unionmount-testsuite$ ./run --ov -s ~/unionmount-testsuite$ ln /mnt/a/foo100 /mnt/a/dir100/   ",6cd078702f2f33cb6b19a682de3e9184112f1a46,0
crypto: user - fix use_after_free of struct xxx_request,"All crypto_stats functions use the struct xxx_request for feeding stats, but in some case this structure could already be freed.  For fixing this, the needed parameters (len and alg) will be stored before the request being executed. ",f7d76e05d058b832b373237566cc1af8251371b5,0
kasan: fix null pointer dereference in kasan_record_aux_stack,"Syzbot reported the following [1]:    BUG: kernel NULL pointer dereference, ",13384f6125ad7ebdcc8914fe1e03ded48ce76581,1
kcm: lock lower socket in kcm_attach,Need to lock lower socket in order to provide mutual exclusion with kcm_unattach.  v2: Add Reported-by for syzbot  ,2cc683e88c0c993ac3721d9b702cb0630abe2879,0
block: fix single bio async DIO error handling,"BUG: KASAN: use-after-free in io_submit_one+0x496/0x2fe0 fs/aio.c:1882 CPU: 2 PID: 15100 Comm: syz-executor873 Not tainted 5.16.0-rc1-syzk #1 Hardware name: Red Hat KVM, BIOS 1.13.0-2.module+el8.3.0+7860+a7792d29 04/01/2014 Call Trace:   [...]   refcount_dec_and_test include/linux/refcount.h:333 [inline]   iocb_put fs/aio.c:1161 [inline]   io_submit_one+0x496/0x2fe0 fs/aio.c:1882   __do_sys_io_submit fs/aio.c:1938 [inline]   __se_sys_io_submit fs/aio.c:1908 [inline]   __x64_sys_io_submit+0x1c7/0x4a0 fs/aio.c:1908   do_syscall_x64 arch/x86/entry/common.c:50 [inline]   do_syscall_64+0x3a/0x80 arch/x86/entry/common.c:80   entry_SYSCALL_64_after_hwframe+0x44/0xae  __blkdev_direct_IO_async() returns errors from bio_iov_iter_get_pages() directly, in which case upper layers won't be expecting ->ki_complete to be called by the block layer and will terminate the request. However, there is also bio_endio() leading to a second ->ki_complete and a double free.  ",75feae73a28020e492fbad2323245455ef69d687,1
bpf: don't leave partial mangled prog in jit_subprogs error path,syzkaller managed to trigger the following bug through fault injection:    [...]   ,c7a897843224a92209f306c984975b704969b89d,1
KVM: Fix stack-out-of-bounds read in write_mmio,"Reported by syzkaller:    BUG: KASAN: stack-out-of-bounds in write_mmio+0x11e/0x270 [kvm]   Read of size 8 at addr ffff8803259df7f8 by task syz-executor/32298    CPU: 6 PID: 32298 Comm: syz-executor Tainted: G           OE    4.15.0-rc2+ #18   Hardware name: LENOVO ThinkCentre M8500t-N000/SHARKBAY, BIOS FBKTC1AUS 02/16/2016   Call Trace:    dump_stack+0xab/0xe1    print_address_description+0x6b/0x290    kasan_report+0x28a/0x370    write_mmio+0x11e/0x270 [kvm]    emulator_read_write_onepage+0x311/0x600 [kvm]    emulator_read_write+0xef/0x240 [kvm]    emulator_fix_hypercall+0x105/0x150 [kvm]    em_hypercall+0x2b/0x80 [kvm]    x86_emulate_insn+0x2b1/0x1640 [kvm]    x86_emulate_instruction+0x39a/0xb90 [kvm]    handle_exception+0x1b4/0x4d0 [kvm_intel]    vcpu_enter_guest+0x15a0/0x2640 [kvm]    kvm_arch_vcpu_ioctl_run+0x549/0x7d0 [kvm]    kvm_vcpu_ioctl+0x479/0x880 [kvm]    do_vfs_ioctl+0x142/0x9a0    SyS_ioctl+0x74/0x80    entry_SYSCALL_64_fastpath+0x23/0x9a  The path of patched vmmcall will patch 3 bytes opcode 0F 01 C1(vmcall) to the guest memory, however, write_mmio tracepoint always prints 8 bytes through *(u64 *)val since kvm splits the mmio access into 8 bytes. This leaks 5 bytes from the kernel stack (CVE-2017-17741).  This patch fixes it by just accessing the bytes which we operate on.  Before patch:  syz-executor-5567  [007] .... 51370.561696: kvm_mmio: mmio write len 3 gpa 0x10 val 0x1ffff10077c1010f  After patch:  syz-executor-13416 [002] .... 51302.299573: kvm_mmio: mmio write len 3 gpa 0x10 val 0xc1010f  ",e39d200fa5bf5b94a0948db0dae44c1b73b84a56,1
KEYS: fix out-of-bounds read during ASN.1 parsing,"syzkaller with KASAN reported an out-of-bounds read in asn1_ber_decoder().  It can be reproduced by the following command, assuming CONFIG_X509_CERTIFICATE_PARSER=y and CONFIG_KASAN=y:      keyctl add asymmetric desc $'\x30\x30' @s  The bug is that the length of an ASN.1 data value isn't validated in the case where it is encoded using the short form, causing the decoder to read past the end of the input buffer.  Fix it by validating the length.  The bug report was:      BUG: KASAN: slab-out-of-bounds in asn1_ber_decoder+0x10cb/0x1730 lib/asn1_decoder.c:233     Read of size 1 at addr ffff88003cccfa02 by task syz-executor0/6818      CPU: 1 PID: 6818 Comm: syz-executor0 Not tainted 4.14.0-rc7-00008-g5f479447d983 #2     Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS Bochs 01/01/2011     Call Trace:      __dump_stack lib/dump_stack.c:16 [inline]      dump_stack+0xb3/0x10b lib/dump_stack.c:52      print_address_description+0x79/0x2a0 mm/kasan/report.c:252      kasan_report_error mm/kasan/report.c:351 [inline]      kasan_report+0x236/0x340 mm/kasan/report.c:409      __asan_report_load1_noabort+0x14/0x20 mm/kasan/report.c:427      asn1_ber_decoder+0x10cb/0x1730 lib/asn1_decoder.c:233      x509_cert_parse+0x1db/0x650 crypto/asymmetric_keys/x509_cert_parser.c:89      x509_key_preparse+0x64/0x7a0 crypto/asymmetric_keys/x509_public_key.c:174      asymmetric_key_preparse+0xcb/0x1a0 crypto/asymmetric_keys/asymmetric_type.c:388      key_create_or_update+0x347/0xb20 security/keys/key.c:855      SYSC_add_key security/keys/keyctl.c:122 [inline]      SyS_add_key+0x1cd/0x340 security/keys/keyctl.c:62      entry_SYSCALL_64_fastpath+0x1f/0xbe     ",2eb9eabf1e868fda15808954fb29b0f105ed65f1,1
io_uring: don't recurse on tsk->sighand->siglock with signalfd,"If an application is doing reads on signalfd, and we arm the poll handler because there's no data available, then the wakeup can recurse on the tasks sighand->siglock as the signal delivery from task_work_add() will use TWA_SIGNAL and that attempts to lock it again.  We can detect the signalfd case pretty easily by comparing the poll->head wait_queue_head_t with the target task signalfd wait queue. Just use normal task wakeup for this case.  ",fd7d6de2241453fc7d042336d366a939a25bc5a9,0
net: fix use-after-free in kfree_skb_list,"syzbot reported nasty use-after-free [1]  Lets remove frag_list field from structs ip_fraglist_iter and ip6_fraglist_iter. This seens not needed anyway.  [1] : BUG: KASAN: use-after-free in kfree_skb_list+0x5d/0x60 net/core/skbuff.c:706 Read of size 8 at addr ffff888085a3cbc0 by task syz-executor303/8947  CPU: 0 PID: 8947 Comm: syz-executor303 Not tainted 5.2.0-rc2+ #12 Hardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 01/01/2011 Call Trace:  __dump_stack lib/dump_stack.c:77 [inline]  dump_stack+0x172/0x1f0 lib/dump_stack.c:113  print_address_description.cold+0x7c/0x20d mm/kasan/report.c:188  __kasan_report.cold+0x1b/0x40 mm/kasan/report.c:317  kasan_report+0x12/0x20 mm/kasan/common.c:614  __asan_report_load8_noabort+0x14/0x20 mm/kasan/generic_report.c:132  kfree_skb_list+0x5d/0x60 net/core/skbuff.c:706  ip6_fragment+0x1ef4/0x2680 net/ipv6/ip6_output.c:882  __ip6_finish_output+0x577/0xaa0 net/ipv6/ip6_output.c:144  ip6_finish_output+0x38/0x1f0 net/ipv6/ip6_output.c:156  NF_HOOK_COND include/linux/netfilter.h:294 [inline]  ip6_output+0x235/0x7f0 net/ipv6/ip6_output.c:179  dst_output include/net/dst.h:433 [inline]  ip6_local_out+0xbb/0x1b0 net/ipv6/output_core.c:179  ip6_send_skb+0xbb/0x350 net/ipv6/ip6_output.c:1796  ip6_push_pending_frames+0xc8/0xf0 net/ipv6/ip6_output.c:1816  rawv6_push_pending_frames net/ipv6/raw.c:617 [inline]  rawv6_sendmsg+0x2993/0x35e0 net/ipv6/raw.c:947  inet_sendmsg+0x141/0x5d0 net/ipv4/af_inet.c:802  sock_sendmsg_nosec net/socket.c:652 [inline]  sock_sendmsg+0xd7/0x130 net/socket.c:671  ___sys_sendmsg+0x803/0x920 net/socket.c:2292  __sys_sendmsg+0x105/0x1d0 net/socket.c:2330  __do_sys_sendmsg net/socket.c:2339 [inline]  __se_sys_sendmsg net/socket.c:2337 [inline]  __x64_sys_sendmsg+0x78/0xb0 net/socket.c:2337  do_syscall_64+0xfd/0x680 arch/x86/entry/common.c:301  entry_SYSCALL_64_after_hwframe+0x49/0xbe ",b7034146756b9e91cc059b19df7fe4defd4d7de7,1
media: zr364xx: fix memory leaks in probe(),"Syzbot discovered that the probe error handling doesn't clean up the resources allocated in zr364xx_board_init().  There are several related bugs in this code so I have re-written the error handling.  1)  Introduce a new function zr364xx_board_uninit() which cleans up     the resources in zr364xx_board_init(). 2)  In zr364xx_board_init() if the call to zr364xx_start_readpipe()     fails then release the ""cam->buffer.frame[i].lpvbits"" memory     before returning.  This way every function either allocates     everything successfully or it cleans up after itself. 3)  Re-write the probe function so that each failure path goto frees     the most recent allocation.  That way we don't free anything     before it has been allocated and we can also verify that     everything is freed. 4)  Originally, in the probe function the ""cam->v4l2_dev.release""     pointer was set to ""zr364xx_release"" near the start but I moved     that assignment to the end, after everything had succeeded.  The     release function was never actually called during the probe cleanup     process, but with this change I wanted to make it clear that we     don't want to call zr364xx_release() until everything is     allocated successfully.  Next I re-wrote the zr364xx_release() function.  Ideally this would have been a simple matter of copy and pasting the cleanup code from probe and adding an additional call to video_unregister_device().  But there are a couple quirks to note.  1)  The probe function does not call videobuf_mmap_free() and I don't     know where the videobuf_mmap is allocated.  I left the code as-is to     avoid introducing a bug in code I don't understand. 2)  The zr364xx_board_uninit() has a call to zr364xx_stop_readpipe()     which is a change from the original behavior with regards to     unloading the driver.  Calling zr364xx_stop_readpipe() on a stopped     pipe is not a problem so this is safe and is potentially a bugfix.  ",ea354b6ddd6f09be29424f41fa75a3e637fea234,1
net/packet: rx_owner_map depends on pg_vec,"Packet sockets may switch ring versions. Avoid misinterpreting state between versions, whose fields share a union. rx_owner_map is only allocated with a packet ring (pg_vec) and both are swapped together. If pg_vec is NULL, meaning no packet ring was allocated, then neither was rx_owner_map. And the field may be old state from a tpacket_v3.  ",ec6af094ea28f0f2dda1a6a33b14cd57e36a9755,0
USB: usbtmc: Fix RCU stall warning,"rcu: INFO: rcu_preempt self-detected stall on CPU rcu:    1-...!: (2 ticks this GP) idle=d92/1/0x4000000000000000         softirq=25390/25392 fqs=3         (t=12164 jiffies g=31645 q=43226) rcu: rcu_preempt kthread starved for 12162 jiffies! g31645 f0x0      RCU_GP_WAIT_FQS(5) ->state=0x0 ->cpu=0 rcu:    Unless rcu_preempt kthread gets sufficient CPU time,         OOM is now expected behavior. rcu: RCU grace-period kthread stack dump: ",30fad76ce4e98263edfa8f885c81d5426c1bf169,0
USB: Fix invalid-free bug in port_over_current_notify(),Syzbot and KASAN found the following invalid-free bug in port_over_current_notify():  ,d81bb019d7bb30091e3c796102c00935d6dd7ca9,1
block: pre-initialize struct block_device in bdev_alloc_inode,"bdev_evict_inode and bdev_free_inode are also called for the root inode of bdevfs, for which bdev_alloc is never called.  Move the zeroing o f struct block_device and the initialization of the bd_bdi field into bdev_alloc_inode to make sure they are initialized for the root inode as well.  ",2d2f6f1b4799428d160c021dd652bc3e3593945e,0
ALSA: control led: fix memory leak in snd_ctl_led_register,"The snd_ctl_led_sysfs_add and snd_ctl_led_sysfs_remove should contain the refcount operations in pair. However, snd_ctl_led_sysfs_remove fails to decrease the refcount to zero, which causes device_release never to be invoked. This leads to memory leak to some resources, like struct device_private. In addition, we also free some other similar memory leaks in snd_ctl_led_init/snd_ctl_led_exit.  Fix this by replacing device_del to device_unregister in snd_ctl_led_sysfs_remove/snd_ctl_led_init/snd_ctl_led_exit.  Note that, when CONFIG_DEBUG_KOBJECT_RELEASE is enabled, put_device will call kobject_release and delay the release of kobject, which will cause use-after-free when the memory backing the kobject is freed at once.  ",3ae72f6ab9c1f688bd578cdc252dabce65fdaf57,1
sctp: allocate sctp_sockaddr_entry with kzalloc,"The similar issue as fixed in Commit 4a2eb0c37b47 (""sctp: initialize sin6_flowinfo for ipv6 addrs in sctp_inet6addr_event"") also exists in sctp_inetaddr_event, as Alexander noticed.  To fix it, allocate sctp_sockaddr_entry with kzalloc for both sctp ipv4 and ipv6 addresses, as does in sctp_v4/6_copy_addrlist().  ",400b8b9a2a17918f8ce00786f596f530e7f30d50,0
netfilter: ipset: fix suspicious RCU usage in find_set_and_id,"find_set_and_id() is called when the NFNL_SUBSYS_IPSET mutex is held. However, in the error path there can be a follow-up recvmsg() without the mutex held. Use the start() function of struct netlink_dump_control instead of dump() to verify and report if the specified set does not exist.  ",5038517119d50ed0240059b1d7fc2faa92371c08,0
delayacct: fix crash in delayacct_blkio_end() after delayacct init failure,"While forking, if delayacct init fails due to memory shortage, it continues expecting all delayacct users to check task->delays pointer against NULL before dereferencing it, which all of them used to do.  Commit c96f5471ce7d (""delayacct: Account blkio completion on the correct task""), while updating delayacct_blkio_end() to take the target task instead of always using %current, made the function test NULL on %current->delays and then continue to operated on @p->delays.  If %current succeeded init while @p didn't, it leads to the following crash.   BUG: unable to handle kernel NULL pointer dereference at 0000000000000004  IP: __delayacct_blkio_end+0xc/0x40  PGD 8000001fd07e1067 P4D 8000001fd07e1067 PUD 1fcffbb067 PMD 0  Oops: 0000 [#1] SMP PTI  CPU: 4 PID: 25774 Comm: QIOThread0 Not tainted 4.16.0-9_fbk1_rc2_1180_g6b593215b4d7 #9  ",b512719f771a82180211c9a315b8a7f628832b3d,1
mm: khugepaged: skip huge page collapse for special files,"The read-only THP for filesystems will collapse THP for files opened readonly and mapped with VM_EXEC.  The intended usecase is to avoid TLB misses for large text segments.  But it doesn't restrict the file types so a THP could be collapsed for a non-regular file, for example, block device, if it is opened readonly and mapped with EXEC permission.  This may cause bugs, like [1] and [2].  This is definitely not the intended usecase, so just collapse THP for regular files in order to close the attack surface.  [shy828301@gmail.com: fix vm_file check [3]]  ",a4aeaa06d45e90f9b279f0b09de84bd00006e733,0
vsock: always call vsock_init_tables(),"Although CONFIG_VSOCKETS_DIAG depends on CONFIG_VSOCKETS, vsock_init_tables() is not always called, it is called only if other modules call its caller. Therefore if we only enable CONFIG_VSOCKETS_DIAG, it would crash kernel on uninitialized vsock_bind_table.  This patch fixes it by moving vsock_init_tables() to its own module_init().  ",c1eef220c1760762753b602c382127bfccee226d,1
media: iguanair: add sanity checks,"The driver needs to check the endpoint types, too, as opposed to the number of endpoints. This also requires moving the check earlier.  ",ab1cbdf159beba7395a13ab70bc71180929ca064,1
smc: move unhash as early as possible in smc_release(),"In smc_release() we release smc->clcsock before unhash the smc sock, but a parallel smc_diag_dump() may be still reading smc->clcsock, therefore this could cause a use-after-free as reported by syzbot.  ",26d92e951fe0a44ee4aec157cabb65a818cc8151,1
RDMA/cm: Add min length checks to user structure copies,"These are missing throughout ucma, it harmlessly copies garbage from userspace, but in this new code which uses min to compute the copy length it can result in uninitialized stack memory. Check for minimum length at the very start.    BUG: KMSAN: uninit-value in ucma_connect+0x2aa/0xab0 drivers/infiniband/core/ucma.c:1091   CPU: 0 PID: 8457 Comm: syz-executor069 Not tainted 5.8.0-rc5-syzkaller #0   Hardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 01/01/2011   Call Trace:    __dump_stack lib/dump_stack.c:77 [inline]    dump_stack+0x1df/0x240 lib/dump_stack.c:118    kmsan_report+0xf7/0x1e0 mm/kmsan/kmsan_report.c:121    __msan_warning+0x58/0xa0 mm/kmsan/kmsan_instr.c:215    ucma_connect+0x2aa/0xab0 drivers/infiniband/core/ucma.c:1091    ucma_write+0x5c5/0x630 drivers/infiniband/core/ucma.c:1764    do_loop_readv_writev fs/read_write.c:737 [inline]    do_iter_write+0x710/0xdc0 fs/read_write.c:1020    vfs_writev fs/read_write.c:1091 [inline]    do_writev+0x42d/0x8f0 fs/read_write.c:1134    __do_sys_writev fs/read_write.c:1207 [inline]    __se_sys_writev+0x9b/0xb0 fs/read_write.c:1204    __x64_sys_writev+0x4a/0x70 fs/read_write.c:1204    do_syscall_64+0xb0/0x150 arch/x86/entry/common.c:386    entry_SYSCALL_64_after_hwframe+0x44/0xa9  ",31142a4ba617f5aa8aefdf1c65561ca30d43f360,1
9p: only copy valid iattrs in 9P2000.L setattr implementation,"The 9P2000.L setattr method v9fs_vfs_setattr_dotl() copies struct iattr values without checking whether they are valid causing unitialized values to be copied. The 9P2000 setattr method v9fs_vfs_setattr() method gets this right. Check whether struct iattr fields are valid first before copying in v9fs_vfs_setattr_dotl() too and make sure that all other fields are set to 0 apart from {g,u}id which should be set to INVALID_{G,U}ID. This ensure that they can be safely sent over the wire or printed for debugging later on.  ",3cb6ee991496b67ee284c6895a0ba007e2d7bac3,0
io_uring: ensure that SQPOLL thread is started for exit,"If we create it in a disabled state because IORING_SETUP_R_DISABLED is set on ring creation, we need to ensure that we've kicked the thread if we're exiting before it's been explicitly disabled. Otherwise we can run into a deadlock where exit is waiting go park the SQPOLL thread, but the SQPOLL thread itself is waiting to get a signal to start.  That results in the below trace of both tasks hung, waiting on each other:  INFO: task syz-executor458:8401 blocked for more than 143 seconds.       Not tainted 5.11.0-next-20210226-syzkaller #0 ""echo 0 > /proc/sys/kernel/hung_task_timeout_secs"" disables this message. ",3ebba796fa251d042be42b929a2d916ee5c34a49,1
vt_ioctl: make VT_RESIZEX behave like VT_RESIZE,"syzbot is reporting UAF/OOB read at bit_putcs()/soft_cursor() [1][2], for vt_resizex() from ioctl(VT_RESIZEX) allows setting font height larger than actual font height calculated by con_font_set() from ioctl(PIO_FONT). Since fbcon_set_font() from con_font_set() allocates minimal amount of memory based on actual font height calculated by con_font_set(), use of vt_resizex() can cause UAF/OOB read for font data.  VT_RESIZEX was introduced in Linux 1.3.3, but it is unclear that what comes to the ""+ more"" part, and I couldn't find a user of VT_RESIZEX.    ",988d0763361bb65690d60e2bc53a6b72777040c3,1
ipv6: set msg_control_is_user in do_ipv6_getsockopt,"While do_ipv6_getsockopt does not call the high-level recvmsg helper, the msghdr eventually ends up being passed to put_cmsg anyway, and thus needs msg_control_is_user set to the proper value.  ",1b2f08df0a886e0565c71821d5230cba395f5c18,0
bpf: fix integer overflow in queue_stack_map,Fix the following issues:  - allow queue_stack_map for root only - fix u32 max_entries overflow - disallow value_size == 0  ,813961de3ee6474dd5703e883471fd941d6c8f69,1
bpf: add tests for direct packet access from CGROUP_SKB,"Tests are added to make sure CGROUP_SKB cannot access:   tc_classid, data_meta, flow_keys  and can read and write:   mark, prority, and cb[0-4]  and can read other fields.  To make selftest with skb->sk work, a dummy sk is added in bpf_prog_test_run_skb().  ",2cb494a36c98279c5c6ce8e99cf9776f15449ade,0
bpf: fix a return in sockmap_get_from_fd(),"""map"" is a valid pointer.  We wanted to return ""err"" instead.  Also let's return a zero literal at the end.  ",ae2b27b859a144f503d382580320873c0beb09c7,0
staging: android: ashmem: Fix lockdep warning for write operation,syzbot report [1] describes a deadlock when write operation against an ashmem fd executed at the time when ashmem is shrinking its cache results in the following lock sequence:  Possible unsafe locking scenario:          CPU0                    CPU1         ,3e338d3c95c735dc3265a86016bb4c022ec7cadc,0
netfilter: drop template ct when conntrack is skipped.,"The ipv4 nf_ct code currently skips the nf_conntrak_in() call for fragmented packets. As a results later matches/target can end up manipulating template ct entry instead of 'real' ones.  Exploiting the above, syzbot found a way to trigger the following splat:  ",aebfa52a925d701114afd6af0def35bab16d4f47,0
tun: avoid double free in tun_free_netdev,"Avoid double free in tun_free_netdev() by moving the dev->tstats and tun->security allocs to a new ndo_init routine (tun_net_init()) that will be called by register_netdevice(). ndo_init is paired with the desctructor (tun_free_netdev()), so if there's an error in register_netdevice() the destructor will handle the frees.  BUG: KASAN: double-free or invalid-free in selinux_tun_dev_free_security+0x1a/0x20 security/selinux/hooks.c:5605  CPU: 0 PID: 25750 Comm: syz-executor416 Not tainted 5.16.0-rc2-syzk #1 Hardware name: Red Hat KVM, BIOS Call Trace: <TASK> __dump_stack lib/dump_stack.c:88 [inline] dump_stack_lvl+0x89/0xb5 lib/dump_stack.c:106 print_address_description.constprop.9+0x28/0x160 mm/kasan/report.c:247 kasan_report_invalid_free+0x55/0x80 mm/kasan/report.c:372 ____kasan_slab_free mm/kasan/common.c:346 [inline] __kasan_slab_free+0x107/0x120 mm/kasan/common.c:374 kasan_slab_free include/linux/kasan.h:235 [inline] slab_free_hook mm/slub.c:1723 [inline] slab_free_freelist_hook mm/slub.c:1749 [inline] slab_free mm/slub.c:3513 [inline] kfree+0xac/0x2d0 mm/slub.c:4561 selinux_tun_dev_free_security+0x1a/0x20 security/selinux/hooks.c:5605 security_tun_dev_free_security+0x4f/0x90 security/security.c:2342 tun_free_netdev+0xe6/0x150 drivers/net/tun.c:2215 netdev_run_todo+0x4df/0x840 net/core/dev.c:10627 rtnl_unlock+0x13/0x20 net/core/rtnetlink.c:112 __tun_chr_ioctl+0x80c/0x2870 drivers/net/tun.c:3302 tun_chr_ioctl+0x2f/0x40 drivers/net/tun.c:3311 vfs_ioctl fs/ioctl.c:51 [inline] __do_sys_ioctl fs/ioctl.c:874 [inline] __se_sys_ioctl fs/ioctl.c:860 [inline] __x64_sys_ioctl+0x19d/0x220 fs/ioctl.c:860 do_syscall_x64 arch/x86/entry/common.c:50 [inline] do_syscall_64+0x3a/0x80 arch/x86/entry/common.c:80 entry_SYSCALL_64_after_hwframe+0x44/0xae  ",158b515f703e75e7d68289bf4d98c664e1d632df,1
btrfs: dev-replace: fail mount if we don't have replace item with target device,"If there is a device BTRFS_DEV_REPLACE_DEVID without the device replace item, then it means the filesystem is inconsistent state. This is either corruption or a crafted image.  Fail the mount as this needs a closer look what is actually wrong.  As of now if BTRFS_DEV_REPLACE_DEVID is present without the replace item, in __btrfs_free_extra_devids() we determine that there is an extra device, and free those extra devices but continue to mount the device. However, we were wrong in keeping tack of the rw_devices so the syzbot testcase failed:    ",cf89af146b7e62af55470cf5f3ec3c56ec144a5e,1
kasan: fix per-page tags for non-page_alloc pages,"To allow performing tag checks on page_alloc addresses obtained via page_address(), tag-based KASAN modes store tags for page_alloc allocations in page->flags.  Currently, the default tag value stored in page->flags is 0x00. Therefore, page_address() returns a 0x00ffff...  address for pages that were not allocated via page_alloc.  This might cause problems.  A particular case we encountered is a conflict with KFENCE.  If a KFENCE-allocated slab object is being freed via kfree(page_address(page) + offset), the address passed to kfree() will get tagged with 0x00 (as slab pages keep the default per-page tags).  This leads to is_kfence_address() check failing, and a KFENCE object ending up in normal slab freelist, which causes memory corruptions.  This patch changes the way KASAN stores tag in page-flags: they are now stored xor'ed with 0xff.  This way, KASAN doesn't need to initialize per-page flags for every created page, which might be slow.  With this change, page_address() returns natively-tagged (with 0xff) pointers for pages that didn't have tags set explicitly.  This patch fixes the encountered conflict with KFENCE and prevents more similar issues that can occur in the future.  ",cf10bd4c4aff8dd64d1aa7f2a529d0c672bc16af,1
net/qrtr: fix __netdev_alloc_skb call,syzbot found ,093b036aa94e01a0bea31a38d7f0ee28a2749023,0
net: xfrm: fix memory leak in xfrm_user_rcv_msg,"Syzbot reported memory leak in xfrm_user_rcv_msg(). The problem was is non-freed skb's frag_list.  In skb_release_all() skb_release_data() will be called only in case of skb->head != NULL, but netlink_skb_destructor() sets head to NULL. So, allocated frag_list skb should be freed manualy, since consume_skb() won't take care of it  ",7c1a80e80cde008f271bae630d28cf684351e807,1
ALSA: pcm: oss: Fix a few more UBSAN fixes,"There are a few places that call round{up|down}_pow_of_two() with the value zero, and this causes undefined behavior warnings.  Avoid calling those macros if such a nonsense value is passed; it's a minor optimization as well, as we handle it as either an error or a value to be skipped, instead.  ",11cb881bf075cea41092a20236ba708b18e1dbb2,0
io_uring: no need to call xa_destroy() on empty xarray,"The kernel test robot reports this lockdep issue:  [child1:659] mbind (274) returned ENOSYS, marking as inactive. [child1:659] mq_timedsend (279) returned ENOSYS, marking as inactive. [main] 10175 iterations. [F:7781 S:2344 HI:2397] ",ca6484cd308a671811bf39f3119e81966eb476e3,0
can: isotp: isotp_release(): omit unintended hrtimer restart on socket release,"When closing the isotp socket, the potentially running hrtimers are canceled before removing the subscription for CAN identifiers via can_rx_unregister().  This may lead to an unintended (re)start of a hrtimer in isotp_rcv_cf() and isotp_rcv_fc() in the case that a CAN frame is received by isotp_rcv() while the subscription removal is processed.  However, isotp_rcv() is called under RCU protection, so after calling can_rx_unregister, we may call synchronize_rcu in order to wait for any RCU read-side critical sections to finish. This prevents the reception of CAN frames after hrtimer_cancel() and therefore the unintended (re)start of the hrtimers.  ",14a4696bc3118ba49da28f79280e1d55603aa737,0
genhd: Fix use after free in __blkdev_get(),"When two blkdev_open() calls race with device removal and recreation, __blkdev_get() can use looked up gendisk after it is freed:  CPU0				CPU1			CPU2 							del_gendisk(disk); 							  bdev_unhash_inode(inode); blkdev_open()			blkdev_open()   bdev = bd_acquire(inode);     - creates and returns new inode 				  bdev = bd_acquire(inode); 				    - returns the same inode   __blkdev_get(devt)		  __blkdev_get(devt)     disk = get_gendisk(devt);       - got structure of device going away 							<finish device removal> 							<new device gets 							 created under the same 							 device number> 				  disk = get_gendisk(devt); 				    - got new device structure 				  if (!bdev->bd_openers) { 				    does the first open 				  }     if (!bdev->bd_openers)       - false     } else {       put_disk_and_module(disk)         - remember this was old device - this was last ref and disk is           now freed     }     disk_unblock_events(disk); -> oops  Fix the problem by making sure we drop reference to disk in __blkdev_get() only after we are really done with it.  ",897366537fb65e87755b822360c230354c3fc73b,1
tls: convert to generic sk_msg interface,"Convert kTLS over to make use of sk_msg interface for plaintext and encrypted scattergather data, so it reuses all the sk_msg helpers and data structure which later on in a second step enables to glue this to BPF.  This also allows to remove quite a bit of open coded helpers which are covered by the sk_msg API. Recent changes in kTLs 80ece6a03aaf (""tls: Remove redundant vars from tls record structure"") and 4e6d47206c32 (""tls: Add support for inplace records encryption"") changed the data path handling a bit; while we've kept the latter optimization intact, we had to undo the former change to better fit the sk_msg model, hence the sg_aead_in and sg_aead_out have been brought back and are linked into the sk_msg sgs. Now the kTLS record contains a msg_plaintext and msg_encrypted sk_msg each.  In the original code, the zerocopy_from_iter() has been used out of TX but also RX path. For the strparser skb-based RX path, we've left the zerocopy_from_iter() in decrypt_internal() mostly untouched, meaning it has been moved into tls_setup_from_iter() with charging logic removed (as not used from RX). Given RX path is not based on sk_msg objects, we haven't pursued setting up a dummy sk_msg to call into sk_msg_zerocopy_from_iter(), but it could be an option to prusue in a later step.  Joint work with John.  ",d829e9c4112b52f4f00195900fd4c685f61365ab,1
KVM: x86/mmu: Don't advance iterator after restart due to yielding,"After dropping mmu_lock in the TDP MMU, restart the iterator during tdp_iter_next() and do not advance the iterator.  Advancing the iterator results in skipping the top-level SPTE and all its children, which is fatal if any of the skipped SPTEs were not visited before yielding.  When zapping all SPTEs, i.e. when min_level == root_level, restarting the iter and then invoking tdp_iter_next() is always fatal if the current gfn has as a valid SPTE, as advancing the iterator results in try_step_side() skipping the current gfn, which wasn't visited before yielding.  Sprinkle WARNs on iter->yielded being true in various helpers that are often used in conjunction with yielding, and tag the helper with __must_check to reduce the probabily of improper usage.  Failing to zap a top-level SPTE manifests in one of two ways.  If a valid SPTE is skipped by both kvm_tdp_mmu_zap_all() and kvm_tdp_mmu_put_root(), the shadow page will be leaked and KVM will WARN accordingly.    ",3a0f64de479cae75effb630a2e0a237ca0d0623c,0
ext4: force revalidation of directory pointer after seekdir(2),A malicious user could force the directory pointer to be in an invalid spot by using seekdir(2).  Use the mechanism we already have to notice if the directory has changed since the last time we called ext4_readdir() to force a revalidation of the pointer.  ,e40ff213898502d299351cc2fe1e350cd186f0d3,0
"rxrpc: Fix send on a connected, but unbound socket","If sendmsg() or sendmmsg() is called on a connected socket that hasn't had bind() called on it, then an oops will occur when the kernel tries to connect the call because no local endpoint has been allocated.  Fix this by implicitly binding the socket if it is in the RXRPC_CLIENT_UNBOUND state, just like it does for the RXRPC_UNBOUND state.  Further, the state should be transitioned to RXRPC_CLIENT_BOUND after this to prevent further attempts to bind it.  This can be tested with:  	#include <stdio.h> 	#include <stdlib.h> 	#include <string.h> 	#include <sys/socket.h> 	#include <arpa/inet.h> 	#include <linux/rxrpc.h> 	static const unsigned char inet6_addr[16] = { 		0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -1, -1, 0xac, 0x14, 0x14, 0xaa 	}; 	int main(void) 	{ 		struct sockaddr_rxrpc srx; 		struct cmsghdr *cm; 		struct msghdr msg; 		unsigned char control[16]; 		int fd; 		memset(&srx, 0, sizeof(srx)); 		srx.srx_family = 0x21; 		srx.srx_service = 0; 		srx.transport_type = AF_INET; 		srx.transport_len = 0x1c; 		srx.transport.sin6.sin6_family = AF_INET6; 		srx.transport.sin6.sin6_port = htons(0x4e22); 		srx.transport.sin6.sin6_flowinfo = htons(0x4e22); 		srx.transport.sin6.sin6_scope_id = htons(0xaa3b); 		memcpy(&srx.transport.sin6.sin6_addr, inet6_addr, 16); 		cm = (struct cmsghdr *)control; 		cm->cmsg_len	= CMSG_LEN(sizeof(unsigned long)); 		cm->cmsg_level	= SOL_RXRPC; 		cm->cmsg_type	= RXRPC_USER_CALL_ID; 		*(unsigned long *)CMSG_DATA(cm) = 0; 		msg.msg_name = NULL; 		msg.msg_namelen = 0; 		msg.msg_iov = NULL; 		msg.msg_iovlen = 0; 		msg.msg_control = control; 		msg.msg_controllen = cm->cmsg_len; 		msg.msg_flags = 0; 		fd = socket(AF_RXRPC, SOCK_DGRAM, AF_INET); 		connect(fd, (struct sockaddr *)&srx, sizeof(srx)); 		sendmsg(fd, &msg, 0); 		return 0; 	}  Leading to the following oops:  	BUG: kernel NULL pointer dereference, ",e835ada07091f40dcfb1bc735082bd0a7c005e59,1
net/ipv6: Fix gfp_flags arg to addrconf_prefix_route,"Eric noticed that __ipv6_ifa_notify is called under rcu_read_lock, so the gfp argument to addrconf_prefix_route can not be GFP_KERNEL.  While scrubbing other calls I noticed addrconf_addr_gen has one place with GFP_ATOMIC that can be GFP_KERNEL.  ",27b10608a2fe3dd91c9ae1f8f8489bf547c12f08,0
usbip: fix stub_dev usbip_sockfd_store() races leading to gpf,"usbip_sockfd_store() is invoked when user requests attach (import) detach (unimport) usb device from usbip host. vhci_hcd sends import request and usbip_sockfd_store() exports the device if it is free for export.  Export and unexport are governed by local state and shared state - Shared state (usbip device status, sockfd) - sockfd and Device   status are used to determine if stub should be brought up or shut   down. - Local state (tcp_socket, rx and tx thread task_struct ptrs)   A valid tcp_socket controls rx and tx thread operations while the   device is in exported state. - While the device is exported, device status is marked used and socket,   sockfd, and thread pointers are valid.  Export sequence (stub-up) includes validating the socket and creating receive (rx) and transmit (tx) threads to talk to the client to provide access to the exported device. rx and tx threads depends on local and shared state to be correct and in sync.  Unexport (stub-down) sequence shuts the socket down and stops the rx and tx threads. Stub-down sequence relies on local and shared states to be in sync.  There are races in updating the local and shared status in the current stub-up sequence resulting in crashes. These stem from starting rx and tx threads before local and global state is updated correctly to be in sync.  1. Doesn't handle kthread_create() error and saves invalid ptr in local    state that drives rx and tx threads. 2. Updates tcp_socket and sockfd,  starts stub_rx and stub_tx threads    before updating usbip_device status to SDEV_ST_USED. This opens up a    race condition between the threads and usbip_sockfd_store() stub up    and down handling.  Fix the above problems: - Stop using kthread_get_run() macro to create/start threads. - Create threads and get task struct reference. - Add kthread_create() failure handling and bail out. - Hold usbip_device lock to update local and shared states after   creating rx and tx threads. - Update usbip_device status to SDEV_ST_USED. - Update usbip_device tcp_socket, sockfd, tcp_rx, and tcp_tx - Start threads after usbip_device (tcp_socket, sockfd, tcp_rx, tcp_tx,   and status) is complete.  Credit goes to syzbot and Tetsuo Handa for finding and root-causing the kthread_get_run() improper error handling problem and others. This is a hard problem to find and debug since the races aren't seen in a normal case. Fuzzing forces the race window to be small enough for the kthread_get_run() error path bug and starting threads before updating the local and shared state bug in the stub-up sequence.  Tested with syzbot reproducer: - https://syzkaller.appspot.com/text?tag=ReproC&x=14801034d00000  ",9380afd6df70e24eacbdbde33afc6a3950965d22,1
sctp: fix the handling of ICMP Frag Needed for too small MTUs,"syzbot reported a hang involving SCTP, on which it kept flooding dmesg with the message: ",b6c5734db07079c9410147b32407f2366d584e6c,1
usb: core: fix slab-out-of-bounds Read in read_descriptors,"The USB device descriptor may get changed between two consecutive enumerations on the same device for some reason, such as DFU or malicius device. In that case, we may access the changing descriptor if we don't take the device lock here.  The issue is reported: https://syzkaller.appspot.com/bug?id=901a0d9e6519ef8dc7acab25344bd287dd3c7be9  ",a18cd6c9b6bc73dc17e8b7e9bd07decaa8833c97,1
ath10k: Change the warning message string,"The """,265df32eae5845212ad9f55f5ae6b6dcb68b187b,0
netfilter: ecache: don't look for ecache extension on dying/unconfirmed conntracks,"syzbot reported following splat: BUG: KASAN: use-after-free in __nf_ct_ext_exist include/net/netfilter/nf_conntrack_extend.h:53 [inline] BUG: KASAN: use-after-free in nf_ct_deliver_cached_events+0x5c3/0x6d0 net/netfilter/nf_conntrack_ecache.c:205 nf_conntrack_confirm include/net/netfilter/nf_conntrack_core.h:65 [inline] nf_confirm+0x3d8/0x4d0 net/netfilter/nf_conntrack_proto.c:154 [..]  While there is no reproducer yet, the syzbot report contains one interesting bit of information:  Freed by task 27585: [..]  kfree+0x10a/0x2c0 mm/slab.c:3757  nf_ct_ext_destroy+0x2ab/0x2e0 net/netfilter/nf_conntrack_extend.c:38  nf_conntrack_free+0x8f/0xe0 net/netfilter/nf_conntrack_core.c:1418  destroy_conntrack+0x1a2/0x270 net/netfilter/nf_conntrack_core.c:626  nf_conntrack_put include/linux/netfilter/nf_conntrack_common.h:31 [inline]  nf_ct_resolve_clash net/netfilter/nf_conntrack_core.c:915 [inline]  ^^^^^^^^^^^^^^^^^^^  __nf_conntrack_confirm+0x21ca/0x2830 net/netfilter/nf_conntrack_core.c:1038  nf_conntrack_confirm include/net/netfilter/nf_conntrack_core.h:63 [inline]  nf_confirm+0x3e7/0x4d0 net/netfilter/nf_conntrack_proto.c:154  This is whats happening:  1. a conntrack entry is about to be confirmed (added to hash table). 2. a clash with existing entry is detected. 3. nf_ct_resolve_clash() puts skb->nfct (the ""losing"" entry). 4. this entry now has a refcount of 0 and is freed to SLAB_TYPESAFE_BY_RCU    kmem cache.  skb->nfct has been replaced by the one found in the hash. Problem is that nf_conntrack_confirm() uses the old ct:  static inline int nf_conntrack_confirm(struct sk_buff *skb) {  struct nf_conn *ct = (struct nf_conn *)skb_nfct(skb);  int ret = NF_ACCEPT;    if (ct) {     if (!nf_ct_is_confirmed(ct))        ret = __nf_conntrack_confirm(skb);     if (likely(ret == NF_ACCEPT)) 	nf_ct_deliver_cached_events(ct); ",ad88b7a6aa3e6ac94589fc1aaf7c99fe9211cff2,1
commoncap: Handle memory allocation failure.,"syzbot is reporting NULL pointer dereference at xattr_getsecurity() [1], for cap_inode_getsecurity() is returning sizeof(struct vfs_cap_data) when memory allocation failed. Return -ENOMEM if memory allocation failed.  [1] https://syzkaller.appspot.com/bug?id=a55ba438506fe68649a5f50d2d82d56b365e0107  ",1f5781725dcbb026438e77091c91a94f678c3522,1
io_uring: always delete double poll wait entry on match,"syzbot reports a crash with tty polling, which is using the double poll handling:  general protection fault, probably for non-canonical address 0xdffffc0000000009: 0000 [#1] PREEMPT SMP KASAN KASAN: null-ptr-deref in range [0x0000000000000048-0x000000000000004f] CPU: 0 PID: 6874 Comm: syz-executor749 Not tainted 5.9.0-rc6-next-20200924-syzkaller #0 Hardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 01/01/2011 ",8706e04ed7d6c95004d42b22a4db97d5b2eb73b2,1
lib/mpi: Fix karactx leak in mpi_powm,Sometimes mpi_powm will leak karactx because a memory allocation failure causes a bail-out that skips the freeing of karactx.  This patch moves the freeing of karactx to the end of the function like everything else so that it can't be skipped.  ,c8ea9fce2baf7b643384f36f29e4194fa40d33a6,0
net-tun: fix panics at dismantle time,"syzkaller got crashes at dismantle time [1]  It is not correct to test (tun->flags & IFF_NAPI) in tun_napi_disable() and tun_napi_del() : Each tun_file can have different mode, depending on how they were created.  Similarly I have changed tun_get_user() and tun_poll_controller() to use the new tfile->napi_enabled boolean.  ",aec72f3392b1d598a979e89c4fdb131965ae0ab3,1
io_uring: fix cancellation taking mutex while TASK_UNINTERRUPTIBLE,do not call blocking ops when !TASK_RUNNING; state=2 set at 	[<00000000ced9dbfc>] prepare_to_wait+0x1f4/0x3b0 	kernel/sched/wait.c:262 ,ca70f00bed6cb255b7a9b91aa18a2717c9217f70,0
net: kcm: fix memory leak in kcm_sendmsg,"Syzbot reported memory leak in kcm_sendmsg()[1]. The problem was in non-freed frag_list in case of error.  In the while loop:  	if (head == skb) 		skb_shinfo(head)->frag_list = tskb; 	else 		skb->next = tskb;  frag_list filled with skbs, but nothing was freeing them.  backtrace:   [<0000000094c02615>] __alloc_skb+0x5e/0x250 net/core/skbuff.c:198   [<00000000e5386cbd>] alloc_skb include/linux/skbuff.h:1083 [inline]   [<00000000e5386cbd>] kcm_sendmsg+0x3b6/0xa50 net/kcm/kcmsock.c:967 [1]   [<00000000f1613a8a>] sock_sendmsg_nosec net/socket.c:652 [inline]   [<00000000f1613a8a>] sock_sendmsg+0x4c/0x60 net/socket.c:672  ",c47cc304990a2813995b1a92bbc11d0bb9a19ea9,1
sctp: fully initialize v4 addr in some functions,"Syzbot found a crash:    BUG: KMSAN: uninit-value in crc32_body lib/crc32.c:112 [inline]   BUG: KMSAN: uninit-value in crc32_le_generic lib/crc32.c:179 [inline]   BUG: KMSAN: uninit-value in __crc32c_le_base+0x4fa/0xd30 lib/crc32.c:202   Call Trace:     crc32_body lib/crc32.c:112 [inline]     crc32_le_generic lib/crc32.c:179 [inline]     __crc32c_le_base+0x4fa/0xd30 lib/crc32.c:202     chksum_update+0xb2/0x110 crypto/crc32c_generic.c:90     crypto_shash_update+0x4c5/0x530 crypto/shash.c:107     crc32c+0x150/0x220 lib/libcrc32c.c:47     sctp_csum_update+0x89/0xa0 include/net/sctp/checksum.h:36     __skb_checksum+0x1297/0x12a0 net/core/skbuff.c:2640     sctp_compute_cksum include/net/sctp/checksum.h:59 [inline]     sctp_packet_pack net/sctp/output.c:528 [inline]     sctp_packet_transmit+0x40fb/0x4250 net/sctp/output.c:597     sctp_outq_flush_transports net/sctp/outqueue.c:1146 [inline]     sctp_outq_flush+0x1823/0x5d80 net/sctp/outqueue.c:1194     sctp_outq_uncork+0xd0/0xf0 net/sctp/outqueue.c:757     sctp_cmd_interpreter net/sctp/sm_sideeffect.c:1781 [inline]     sctp_side_effects net/sctp/sm_sideeffect.c:1184 [inline]     sctp_do_sm+0x8fe1/0x9720 net/sctp/sm_sideeffect.c:1155     sctp_primitive_REQUESTHEARTBEAT+0x175/0x1a0 net/sctp/primitive.c:185     sctp_apply_peer_addr_params+0x212/0x1d40 net/sctp/socket.c:2433     sctp_setsockopt_peer_addr_params net/sctp/socket.c:2686 [inline]     sctp_setsockopt+0x189bb/0x19090 net/sctp/socket.c:4672  The issue was caused by transport->ipaddr set with uninit addr param, which was passed by:    sctp_transport_init net/sctp/transport.c:47 [inline]   sctp_transport_new+0x248/0xa00 net/sctp/transport.c:100   sctp_assoc_add_peer+0x5ba/0x2030 net/sctp/associola.c:611   sctp_process_param net/sctp/sm_make_chunk.c:2524 [inline]  where 'addr' is set by sctp_v4_from_addr_param(), and it doesn't initialize the padding of addr->v4.  Later when calling sctp_make_heartbeat(), hbinfo.daddr(=transport->ipaddr) will become the part of skb, and the issue occurs.  This patch is to fix it by initializing the padding of addr->v4 in sctp_v4_from_addr_param(), as well as other functions that do the similar thing, and these functions shouldn't trust that the caller initializes the memory, as Marcelo suggested.  ",b6f3320b1d5267e7b583a6d0c88dda518101740c,1
USB: iowarrior: fix use-after-free on disconnect,"A recent fix addressing a deadlock on disconnect introduced a new bug by moving the present flag out of the critical section protected by the driver-data mutex. This could lead to a racing release() freeing the driver data before disconnect() is done with it.  Due to insufficient locking a related use-after-free could be triggered also before the above mentioned commit. Specifically, the driver needs to hold the driver-data mutex also while checking the opened flag at disconnect().  ",edc4746f253d907d048de680a621e121517f484b,1
udp: fix jump label misuse,"The commit 60fb9567bf30 (""udp: implement complete book-keeping for encap_needed"") introduced a severe misuse of jump label APIs, which syzbot, as reported by Eric, was able to exploit.  When multiple sockets/process can concurrently request (and than disable) the udp encap, we need to track the activation counter with *_inc()",9c48060141bd937497774546e4bb89b8992be383,0
proc: Handle umounts cleanly,syzbot writes: > KASAN: use-after-free Read in dput (2) > > proc_fill_super: allocate dentry failed > ,4fa3b1c417377c352208ee9f487e17cfcee32348,1
tun: initialize napi_mutex unconditionally,"This is the first part to fix following syzbot report :  console output: https://syzkaller.appspot.com/x/log.txt?x=145378e6400000 kernel config:  https://syzkaller.appspot.com/x/.config?x=443816db871edd66 dashboard link: https://syzkaller.appspot.com/bug?extid=e662df0ac1d753b57e80  Following patch is fixing the race condition, but it seems safer to initialize this mutex at tfile creation anyway.  ",c7256f579f8302ce2c038181c30060d0b40017b2,1
bpf: fix precision tracking of stack slots,"The problem can be seen in the following two tests: 0: (bf) r3 = r10 1: (55) if r3 != 0x7b goto pc+0 2: (7a) *(u64 *)(r3 -8) = 0 3: (79) r4 = *(u64 *)(r10 -8) .. 0: (85) call bpf_get_prandom_u32#7 1: (bf) r3 = r10 2: (55) if r3 != 0x7b goto pc+0 3: (7b) *(u64 *)(r3 -8) = r0 4: (79) r4 = *(u64 *)(r10 -8)  When backtracking need to mark R4 it will mark slot fp-8. But ST or STX into fp-8 could belong to the same block of instructions. When backtracing is done the parent state may have fp-8 slot as ""unallocated stack"". Which will cause verifier to warn and incorrectly reject such programs.  Writes into stack via non-R10 register are rare. llvm always generates canonical stack spill/fill. For such pathological case fall back to conservative precision tracking instead of rejecting.  ",2339cd6cd0b5401fa3fe886bf1c0cb8822041957,0
Bluetooth: check for zapped sk before connecting,"There is a possibility of receiving a zapped sock on l2cap_sock_connect(). This could lead to interesting crashes, one such case is tearing down an already tore l2cap_sock as is happened with this call trace:  __dump_stack lib/dump_stack.c:15 [inline] dump_stack+0xc4/0x118 lib/dump_stack.c:56 register_lock_class kernel/locking/lockdep.c:792 [inline] register_lock_class+0x239/0x6f6 kernel/locking/lockdep.c:742 __lock_acquire+0x209/0x1e27 kernel/locking/lockdep.c:3105 lock_acquire+0x29c/0x2fb kernel/locking/lockdep.c:3599 __raw_spin_lock_bh include/linux/spinlock_api_smp.h:137 [inline] _raw_spin_lock_bh+0x38/0x47 kernel/locking/spinlock.c:175 spin_lock_bh include/linux/spinlock.h:307 [inline] lock_sock_nested+0x44/0xfa net/core/sock.c:2518 l2cap_sock_teardown_cb+0x88/0x2fb net/bluetooth/l2cap_sock.c:1345 l2cap_chan_del+0xa3/0x383 net/bluetooth/l2cap_core.c:598 l2cap_chan_close+0x537/0x5dd net/bluetooth/l2cap_core.c:756 l2cap_chan_timeout+0x104/0x17e net/bluetooth/l2cap_core.c:429 process_one_work+0x7e3/0xcb0 kernel/workqueue.c:2064 worker_thread+0x5a5/0x773 kernel/workqueue.c:2196 kthread+0x291/0x2a6 kernel/kthread.c:211 ret_from_fork+0x4e/0x80 arch/x86/entry/entry_64.S:604  ",3af70b39fa2d415dc86c370e5b24ddb9fdacbd6f,1
ucounts: Fix race condition between alloc_ucounts and put_ucounts,The race happens because put_ucounts() doesn't use spinlock and get_ucounts is not under spinlock:  CPU0                    CPU1 ,345daff2e994ee844d6a609c37f085695fbb4c4d,1
USB: usbcore: Fix slab-out-of-bounds bug during device reset,"The syzbot fuzzer provoked a slab-out-of-bounds error in the USB core:  BUG: KASAN: slab-out-of-bounds in memcmp+0xa6/0xb0 lib/string.c:904 Read of size 1 at addr ffff8881d175bed6 by task kworker/0:3/2746  CPU: 0 PID: 2746 Comm: kworker/0:3 Not tainted 5.3.0-rc5+ #28 Hardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 01/01/2011 Workqueue: usb_hub_wq hub_event Call Trace:   __dump_stack lib/dump_stack.c:77 [inline]   dump_stack+0xca/0x13e lib/dump_stack.c:113   print_address_description+0x6a/0x32c mm/kasan/report.c:351   __kasan_report.cold+0x1a/0x33 mm/kasan/report.c:482   kasan_report+0xe/0x12 mm/kasan/common.c:612   memcmp+0xa6/0xb0 lib/string.c:904   memcmp include/linux/string.h:400 [inline]   descriptors_changed drivers/usb/core/hub.c:5579 [inline]   usb_reset_and_verify_device+0x564/0x1300 drivers/usb/core/hub.c:5729   usb_reset_device+0x4c1/0x920 drivers/usb/core/hub.c:5898   rt2x00usb_probe+0x53/0x7af drivers/net/wireless/ralink/rt2x00/rt2x00usb.c:806  The error occurs when the descriptors_changed() routine (called during a device reset) attempts to compare the old and new BOS and capability descriptors.  The length it uses for the comparison is the wTotalLength value stored in BOS descriptor, but this value is not necessarily the same as the length actually allocated for the descriptors.  If it is larger the routine will call memcmp() with a length that is too big, thus reading beyond the end of the allocated region and leading to this fault.  The kernel reads the BOS descriptor twice: first to get the total length of all the capability descriptors, and second to read it along with all those other descriptors.  A malicious (or very faulty) device may send different values for the BOS descriptor fields each time. The memory area will be allocated using the wTotalLength value read the first time, but stored within it will be the value read the second time.  To prevent this possibility from causing any errors, this patch modifies the BOS descriptor after it has been read the second time: It sets the wTotalLength field to the actual length of the descriptors that were read in and validated.  Then the memcpy() call, or any other code using these descriptors, will be able to rely on wTotalLength being valid.  ",3dd550a2d36596a1b0ee7955da3b611c031d3873,1
bpf: Fix use after free in subprog's jited symbol removal,syzkaller managed to trigger the following crash:    [...]   BUG: unable to handle page fault for ,cd7455f1013ef96d5cbf5c05d2b7c06f273810a6,1
ext4: do not try to set xattr into ea_inode if value is empty,Syzbot report a warning that ext4 may create an empty ea_inode if set an empty extent attribute to a file on the file system which is no free blocks left.    ,6b22489911b726eebbf169caee52fea52013fbdd,0
usbip: give back URBs for unsent unlink requests during cleanup,"In vhci_device_unlink_cleanup(), the URBs for unsent unlink requests are not given back. This sometimes causes usb_kill_urb to wait indefinitely for that urb to be given back. syzbot has reported a hung task issue [1] for this.  To fix this, give back the urbs corresponding to unsent unlink requests (unlink_tx list) similar to how urbs corresponding to unanswered unlink requests (unlink_rx list) are given back.  [1]: https://syzkaller.appspot.com/bug?id=08f12df95ae7da69814e64eb5515d5a85ed06b76  ",258c81b341c8025d79073ce2d6ce19dcdc7d10d2,1
net: Fix double free and memory corruption in get_net_ns_by_id(),"(I can trivially verify that that idr_remove in cleanup_net happens  after the network namespace count has dropped to zero --EWB)  Function get_net_ns_by_id() does not check for net::count after it has found a peer in netns_ids idr.  It may dereference a peer, after its count has already been finaly decremented. This leads to double free and memory corruption:  put_net(peer)                                   rtnl_lock() atomic_dec_and_test(&peer->count) [count=0]     ... __put_net(peer)                                 get_net_ns_by_id(net, id)   spin_lock(&cleanup_list_lock)   list_add(&net->cleanup_list, &cleanup_list)   spin_unlock(&cleanup_list_lock) queue_work()                                      peer = idr_find(&net->netns_ids, id)   |                                               get_net(peer) [count=1]   |                                               ...   |                                               (use after final put)   v                                               ...   cleanup_net()                                   ...     spin_lock(&cleanup_list_lock)                 ...     list_replace_init(&cleanup_list, ..)          ...     spin_unlock(&cleanup_list_lock)               ...     ...                                           ...     ...                                           put_net(peer)     ...                                             atomic_dec_and_test(&peer->count) [count=0]     ...                                               spin_lock(&cleanup_list_lock)     ...                                               list_add(&net->cleanup_list, &cleanup_list)     ...                                               spin_unlock(&cleanup_list_lock)     ...                                             queue_work()     ...                                           rtnl_unlock()     rtnl_lock()                                   ...     for_each_net(tmp) {                           ...       id = __peernet2id(tmp, peer)                ...       spin_lock_irq(&tmp->nsid_lock)              ...       idr_remove(&tmp->netns_ids, id)             ...       ...                                         ...       net_drop_ns()                               ... 	net_free(peer)                            ...     }                                             ...   |   v   cleanup_net()     ...     (Second free of peer)  Also, put_net() on the right cpu may reorder with left's cpu list_replace_init(&cleanup_list, ..), and then cleanup_list will be corrupted.  Since cleanup_net() is executed in worker thread, while put_net(peer) can happen everywhere, there should be enough time for concurrent get_net_ns_by_id() to pick the peer up, and the race does not seem to be unlikely. The patch fixes the problem in standard way.  (Also, there is possible problem in peernet2id_alloc(), which requires check for net::count under nsid_lock and maybe_get_net(peer), but in current stable kernel it's used under rtnl_lock() and it has to be safe. Openswitch begun to use peernet2id_alloc(), and possibly it should be fixed too. While this is not in stable kernel yet, so I'll send a separate message to netdev@ later).  ",21b5944350052d2583e82dd59b19a9ba94a007f0,1
posix-timers: Fix division by zero bug,The signal delivery path of posix-timers can try to rearm the timer even if the interval is zero. That's handled for the common case (hrtimer) but not for alarm timers. In that case the forwarding function raises a division by zero exception.  The handling for hrtimer based posix timers is wrong because it marks the timer as active despite the fact that it is stopped.  Move the check from common_hrtimer_rearm() to posixtimer_rearm() to cure both issues.  ,0e334db6bb4b1fd1e2d72c1f3d8f004313cd9f94,1
net/smc: keep clcsock reference in smc_tcp_listen_work(),"The internal CLC socket should exist till the SMC-socket is released. Function tcp_listen_worker() releases the internal CLC socket of a listen socket, if an smc_close_active() is called. This function is called for the final release(), but it is called for shutdown SHUT_RDWR as well. This opens a door for protection faults, if socket calls using the internal CLC socket are called for a shutdown listen socket.  With the changes of commit 3d502067599f (""net/smc: simplify wait when closing listen socket"") there is no need anymore to release the internal CLC socket in function tcp_listen_worker((). It is sufficient to release it in smc_release().  ",070204a34884110ac5e19c1e2e036fcfd033f8e3,0
tty: n_hdlc: make n_hdlc_tty_wakeup() asynchronous,"syzbot is reporting that an unprivileged user who logged in from tty console can crash the system using a reproducer shown below [1], for n_hdlc_tty_wakeup() is synchronously calling n_hdlc_send_frames().  ",1ee33b1ca2b8dabfcc17198ffd049a6b55674a86,1
net: icmp: fix data-race in cmp_global_allow(),"This code reads two global variables without protection of a lock. We need READ_ONCE()/WRITE_ONCE() pairs to avoid load/store-tearing and better document the intent.  KCSAN reported : BUG: KCSAN: data-race in icmp_global_allow / icmp_global_allow  read to 0xffffffff861a8014 of 4 bytes by task 11201 on cpu 0:  icmp_global_allow+0x36/0x1b0 net/ipv4/icmp.c:254  icmpv6_global_allow net/ipv6/icmp.c:184 [inline]  icmpv6_global_allow net/ipv6/icmp.c:179 [inline]  icmp6_send+0x493/0x1140 net/ipv6/icmp.c:514  icmpv6_send+0x71/0xb0 net/ipv6/ip6_icmp.c:43  ip6_link_failure+0x43/0x180 net/ipv6/route.c:2640  dst_link_failure include/net/dst.h:419 [inline]  vti_xmit net/ipv4/ip_vti.c:243 [inline]  vti_tunnel_xmit+0x27f/0xa50 net/ipv4/ip_vti.c:279  __netdev_start_xmit include/linux/netdevice.h:4420 [inline]  netdev_start_xmit include/linux/netdevice.h:4434 [inline]  xmit_one net/core/dev.c:3280 [inline]  dev_hard_start_xmit+0xef/0x430 net/core/dev.c:3296  __dev_queue_xmit+0x14c9/0x1b60 net/core/dev.c:3873  dev_queue_xmit+0x21/0x30 net/core/dev.c:3906  neigh_direct_output+0x1f/0x30 net/core/neighbour.c:1530  neigh_output include/net/neighbour.h:511 [inline]  ip6_finish_output2+0x7a6/0xec0 net/ipv6/ip6_output.c:116  __ip6_finish_output net/ipv6/ip6_output.c:142 [inline]  __ip6_finish_output+0x2d7/0x330 net/ipv6/ip6_output.c:127  ip6_finish_output+0x41/0x160 net/ipv6/ip6_output.c:152  NF_HOOK_COND include/linux/netfilter.h:294 [inline]  ip6_output+0xf2/0x280 net/ipv6/ip6_output.c:175  dst_output include/net/dst.h:436 [inline]  ip6_local_out+0x74/0x90 net/ipv6/output_core.c:179  write to 0xffffffff861a8014 of 4 bytes by task 11183 on cpu 1:  icmp_global_allow+0x174/0x1b0 net/ipv4/icmp.c:272  icmpv6_global_allow net/ipv6/icmp.c:184 [inline]  icmpv6_global_allow net/ipv6/icmp.c:179 [inline]  icmp6_send+0x493/0x1140 net/ipv6/icmp.c:514  icmpv6_send+0x71/0xb0 net/ipv6/ip6_icmp.c:43  ip6_link_failure+0x43/0x180 net/ipv6/route.c:2640  dst_link_failure include/net/dst.h:419 [inline]  vti_xmit net/ipv4/ip_vti.c:243 [inline]  vti_tunnel_xmit+0x27f/0xa50 net/ipv4/ip_vti.c:279  __netdev_start_xmit include/linux/netdevice.h:4420 [inline]  netdev_start_xmit include/linux/netdevice.h:4434 [inline]  xmit_one net/core/dev.c:3280 [inline]  dev_hard_start_xmit+0xef/0x430 net/core/dev.c:3296  __dev_queue_xmit+0x14c9/0x1b60 net/core/dev.c:3873  dev_queue_xmit+0x21/0x30 net/core/dev.c:3906  neigh_direct_output+0x1f/0x30 net/core/neighbour.c:1530  neigh_output include/net/neighbour.h:511 [inline]  ip6_finish_output2+0x7a6/0xec0 net/ipv6/ip6_output.c:116  __ip6_finish_output net/ipv6/ip6_output.c:142 [inline]  __ip6_finish_output+0x2d7/0x330 net/ipv6/ip6_output.c:127  ip6_finish_output+0x41/0x160 net/ipv6/ip6_output.c:152  NF_HOOK_COND include/linux/netfilter.h:294 [inline]  ip6_output+0xf2/0x280 net/ipv6/ip6_output.c:175  Reported by Kernel Concurrency Sanitizer on: CPU: 1 PID: 11183 Comm: syz-executor.2 Not tainted 5.4.0-rc3+ #0 Hardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 01/01/2011  ",bbab7ef235031f6733b5429ae7877bfa22339712,1
net: avoid potential false sharing in neighbor related code,There are common instances of the following construct :  	if (n->confirmed != now) 		n->confirmed = now;  A C compiler could legally remove the conditional.  Use READ_ONCE()/WRITE_ONCE() to avoid this problem.  ,25c7a6d1f90e208ec27ca854b1381ed39842ec57,0
bpf: sockhash fix omitted bucket lock in sock_close,"First the sk_callback_lock() was being used to protect both the sock callback hooks and the psock->maps list. This got overly convoluted after the addition of sockhash (in sockmap it made some sense because masp and callbacks were tightly coupled) so lets split out a specific lock for maps and only use the callback lock for its intended purpose. This fixes a couple cases where we missed using maps lock when it was in fact needed. Also this makes it easier to follow the code because now we can put the locking closer to the actual code its serializing.  Next, in sock_hash_delete_elem() the pattern was as follows,    sock_hash_delete_elem()      [...]      spin_lock(bucket_lock)      l = lookup_elem_raw()      if (l)         hlist_del_rcu()         write_lock(sk_callback_lock)          .... destroy psock ...         write_unlock(sk_callback_lock)      spin_unlock(bucket_lock)  The ordering is necessary because we only know the {p}sock after dereferencing the hash table which we can't do unless we have the bucket lock held. Once we have the bucket lock and the psock element it is deleted from the hashmap to ensure any other path doing a lookup will fail. Finally, the refcnt is decremented and if zero the psock is destroyed.  In parallel with the above (or free'ing the map) a tcp close event may trigger tcp_close(). Which at the moment omits the bucket lock altogether (oops!) where the flow looks like this,    bpf_tcp_close()      [...]      write_lock(sk_callback_lock)      for each psock->maps // list of maps this sock is part of          hlist_del_rcu(ref_hash_node);          .... destroy psock ...      write_unlock(sk_callback_lock)  Obviously, and demonstrated by syzbot, this is broken because we can have multiple threads deleting entries via hlist_del_rcu().  To fix this we might be tempted to wrap the hlist operation in a bucket lock but that would create a lock inversion problem. In summary to follow locking rules the psocks maps list needs the sk_callback_lock (after this patch maps_lock) but we need the bucket lock to do the hlist_del_rcu.  To resolve the lock inversion problem pop the head of the maps list repeatedly and remove the reference until no more are left. If a delete happens in parallel from the BPF API that is OK as well because it will do a similar action, lookup the lock in the map/hash, delete it from the map/hash, and dec the refcnt. We check for this case before doing a destroy on the psock to ensure we don't have two threads tearing down a psock. The new logic is as follows,    bpf_tcp_close()   e = psock_map_pop(psock->maps) // done with map lock   bucket_lock() // lock hash list bucket   l = lookup_elem_raw(head, hash, key, key_size);   if (l) {      //only get here if elmnt was not already removed      hlist_del_rcu()      ... destroy psock...   }   bucket_unlock()  And finally for all the above to work add missing locking around  map operations per above. Then add RCU annotations and use rcu_dereference/rcu_assign_pointer to manage values relying on RCU so that the object is not free'd from sock_hash_free() while it is being referenced in bpf_tcp_close().  ",e9db4ef6bf4ca9894bb324c76e01b8f1a16b2650,1
nsh: fix infinite loop,"syzbot caught an infinite recursion in nsh_gso_segment().  Problem here is that we need to make sure the NSH header is of reasonable length.  BUG: MAX_LOCK_DEPTH too low! turning off the locking correctness validator. depth: 48  max: 48! 48 locks held by syz-executor0/10189:  #0:         (ptrval) (rcu_read_lock_bh){....}, at: __dev_queue_xmit+0x30f/0x34c0 net/core/dev.c:3517  #1:         (ptrval) (rcu_read_lock){....}, at: __skb_pull include/linux/skbuff.h:2080 [inline]  #1:         (ptrval) (rcu_read_lock){....}, at: skb_mac_gso_segment+0x221/0x720 net/core/dev.c:2787  #2:         (ptrval) (rcu_read_lock){....}, at: __skb_pull include/linux/skbuff.h:2080 [inline]  #2:         (ptrval) (rcu_read_lock){....}, at: skb_mac_gso_segment+0x221/0x720 net/core/dev.c:2787  #3:         (ptrval) (rcu_read_lock){....}, at: __skb_pull include/linux/skbuff.h:2080 [inline]  #3:         (ptrval) (rcu_read_lock){....}, at: skb_mac_gso_segment+0x221/0x720 net/core/dev.c:2787  #4:         (ptrval) (rcu_read_lock){....}, at: __skb_pull include/linux/skbuff.h:2080 [inline]  #4:         (ptrval) (rcu_read_lock){....}, at: skb_mac_gso_segment+0x221/0x720 net/core/dev.c:2787  #5:         (ptrval) (rcu_read_lock){....}, at: __skb_pull include/linux/skbuff.h:2080 [inline]  #5:         (ptrval) (rcu_read_lock){....}, at: skb_mac_gso_segment+0x221/0x720 net/core/dev.c:2787  #6:         (ptrval) (rcu_read_lock){....}, at: __skb_pull include/linux/skbuff.h:2080 [inline]  #6:         (ptrval) (rcu_read_lock){....}, at: skb_mac_gso_segment+0x221/0x720 net/core/dev.c:2787  #7:         (ptrval) (rcu_read_lock){....}, at: __skb_pull include/linux/skbuff.h:2080 [inline]  #7:         (ptrval) (rcu_read_lock){....}, at: skb_mac_gso_segment+0x221/0x720 net/core/dev.c:2787  #8:         (ptrval) (rcu_read_lock){....}, at: __skb_pull include/linux/skbuff.h:2080 [inline]  #8:         (ptrval) (rcu_read_lock){....}, at: skb_mac_gso_segment+0x221/0x720 net/core/dev.c:2787  #9:         (ptrval) (rcu_read_lock){....}, at: __skb_pull include/linux/skbuff.h:2080 [inline]  #9:         (ptrval) (rcu_read_lock){....}, at: skb_mac_gso_segment+0x221/0x720 net/core/dev.c:2787  #10:         (ptrval) (rcu_read_lock){....}, at: __skb_pull include/linux/skbuff.h:2080 [inline]  #10:         (ptrval) (rcu_read_lock){....}, at: skb_mac_gso_segment+0x221/0x720 net/core/dev.c:2787  #11:         (ptrval) (rcu_read_lock){....}, at: __skb_pull include/linux/skbuff.h:2080 [inline]  #11:         (ptrval) (rcu_read_lock){....}, at: skb_mac_gso_segment+0x221/0x720 net/core/dev.c:2787  #12:         (ptrval) (rcu_read_lock){....}, at: __skb_pull include/linux/skbuff.h:2080 [inline]  #12:         (ptrval) (rcu_read_lock){....}, at: skb_mac_gso_segment+0x221/0x720 net/core/dev.c:2787  #13:         (ptrval) (rcu_read_lock){....}, at: __skb_pull include/linux/skbuff.h:2080 [inline]  #13:         (ptrval) (rcu_read_lock){....}, at: skb_mac_gso_segment+0x221/0x720 net/core/dev.c:2787  #14:         (ptrval) (rcu_read_lock){....}, at: __skb_pull include/linux/skbuff.h:2080 [inline]  #14:         (ptrval) (rcu_read_lock){....}, at: skb_mac_gso_segment+0x221/0x720 net/core/dev.c:2787  #15:         (ptrval) (rcu_read_lock){....}, at: __skb_pull include/linux/skbuff.h:2080 [inline]  #15:         (ptrval) (rcu_read_lock){....}, at: skb_mac_gso_segment+0x221/0x720 net/core/dev.c:2787  #16:         (ptrval) (rcu_read_lock){....}, at: __skb_pull include/linux/skbuff.h:2080 [inline]  #16:         (ptrval) (rcu_read_lock){....}, at: skb_mac_gso_segment+0x221/0x720 net/core/dev.c:2787  #17:         (ptrval) (rcu_read_lock){....}, at: __skb_pull include/linux/skbuff.h:2080 [inline]  #17:         (ptrval) (rcu_read_lock){....}, at: skb_mac_gso_segment+0x221/0x720 net/core/dev.c:2787  #18:         (ptrval) (rcu_read_lock){....}, at: __skb_pull include/linux/skbuff.h:2080 [inline]  #18:         (ptrval) (rcu_read_lock){....}, at: skb_mac_gso_segment+0x221/0x720 net/core/dev.c:2787  #19:         (ptrval) (rcu_read_lock){....}, at: __skb_pull include/linux/skbuff.h:2080 [inline]  #19:         (ptrval) (rcu_read_lock){....}, at: skb_mac_gso_segment+0x221/0x720 net/core/dev.c:2787  #20:         (ptrval) (rcu_read_lock){....}, at: __skb_pull include/linux/skbuff.h:2080 [inline]  #20:         (ptrval) (rcu_read_lock){....}, at: skb_mac_gso_segment+0x221/0x720 net/core/dev.c:2787  #21:         (ptrval) (rcu_read_lock){....}, at: __skb_pull include/linux/skbuff.h:2080 [inline]  #21:         (ptrval) (rcu_read_lock){....}, at: skb_mac_gso_segment+0x221/0x720 net/core/dev.c:2787  #22:         (ptrval) (rcu_read_lock){....}, at: __skb_pull include/linux/skbuff.h:2080 [inline]  #22:         (ptrval) (rcu_read_lock){....}, at: skb_mac_gso_segment+0x221/0x720 net/core/dev.c:2787  #23:         (ptrval) (rcu_read_lock){....}, at: __skb_pull include/linux/skbuff.h:2080 [inline]  #23:         (ptrval) (rcu_read_lock){....}, at: skb_mac_gso_segment+0x221/0x720 net/core/dev.c:2787  #24:         (ptrval) (rcu_read_lock){....}, at: __skb_pull include/linux/skbuff.h:2080 [inline]  #24:         (ptrval) (rcu_read_lock){....}, at: skb_mac_gso_segment+0x221/0x720 net/core/dev.c:2787  #25:         (ptrval) (rcu_read_lock){....}, at: __skb_pull include/linux/skbuff.h:2080 [inline]  #25:         (ptrval) (rcu_read_lock){....}, at: skb_mac_gso_segment+0x221/0x720 net/core/dev.c:2787  #26:         (ptrval) (rcu_read_lock){....}, at: __skb_pull include/linux/skbuff.h:2080 [inline]  #26:         (ptrval) (rcu_read_lock){....}, at: skb_mac_gso_segment+0x221/0x720 net/core/dev.c:2787  #27:         (ptrval) (rcu_read_lock){....}, at: __skb_pull include/linux/skbuff.h:2080 [inline]  #27:         (ptrval) (rcu_read_lock){....}, at: skb_mac_gso_segment+0x221/0x720 net/core/dev.c:2787  #28:         (ptrval) (rcu_read_lock){....}, at: __skb_pull include/linux/skbuff.h:2080 [inline]  #28:         (ptrval) (rcu_read_lock){....}, at: skb_mac_gso_segment+0x221/0x720 net/core/dev.c:2787  #29:         (ptrval) (rcu_read_lock){....}, at: __skb_pull include/linux/skbuff.h:2080 [inline]  #29:         (ptrval) (rcu_read_lock){....}, at: skb_mac_gso_segment+0x221/0x720 net/core/dev.c:2787  #30:         (ptrval) (rcu_read_lock){....}, at: __skb_pull include/linux/skbuff.h:2080 [inline]  #30:         (ptrval) (rcu_read_lock){....}, at: skb_mac_gso_segment+0x221/0x720 net/core/dev.c:2787  #31:         (ptrval) (rcu_read_lock){....}, at: __skb_pull include/linux/skbuff.h:2080 [inline]  #31:         (ptrval) (rcu_read_lock){....}, at: skb_mac_gso_segment+0x221/0x720 net/core/dev.c:2787 dccp_close: ABORT with 65423 bytes unread  #32:         (ptrval) (rcu_read_lock){....}, at: __skb_pull include/linux/skbuff.h:2080 [inline]  #32:         (ptrval) (rcu_read_lock){....}, at: skb_mac_gso_segment+0x221/0x720 net/core/dev.c:2787  #33:         (ptrval) (rcu_read_lock){....}, at: __skb_pull include/linux/skbuff.h:2080 [inline]  #33:         (ptrval) (rcu_read_lock){....}, at: skb_mac_gso_segment+0x221/0x720 net/core/dev.c:2787  #34:         (ptrval) (rcu_read_lock){....}, at: __skb_pull include/linux/skbuff.h:2080 [inline]  #34:         (ptrval) (rcu_read_lock){....}, at: skb_mac_gso_segment+0x221/0x720 net/core/dev.c:2787  #35:         (ptrval) (rcu_read_lock){....}, at: __skb_pull include/linux/skbuff.h:2080 [inline]  #35:         (ptrval) (rcu_read_lock){....}, at: skb_mac_gso_segment+0x221/0x720 net/core/dev.c:2787  #36:         (ptrval) (rcu_read_lock){....}, at: __skb_pull include/linux/skbuff.h:2080 [inline]  #36:         (ptrval) (rcu_read_lock){....}, at: skb_mac_gso_segment+0x221/0x720 net/core/dev.c:2787  #37:         (ptrval) (rcu_read_lock){....}, at: __skb_pull include/linux/skbuff.h:2080 [inline]  #37:         (ptrval) (rcu_read_lock){....}, at: skb_mac_gso_segment+0x221/0x720 net/core/dev.c:2787  #38:         (ptrval) (rcu_read_lock){....}, at: __skb_pull include/linux/skbuff.h:2080 [inline]  #38:         (ptrval) (rcu_read_lock){....}, at: skb_mac_gso_segment+0x221/0x720 net/core/dev.c:2787  #39:         (ptrval) (rcu_read_lock){....}, at: __skb_pull include/linux/skbuff.h:2080 [inline]  #39:         (ptrval) (rcu_read_lock){....}, at: skb_mac_gso_segment+0x221/0x720 net/core/dev.c:2787  #40:         (ptrval) (rcu_read_lock){....}, at: __skb_pull include/linux/skbuff.h:2080 [inline]  #40:         (ptrval) (rcu_read_lock){....}, at: skb_mac_gso_segment+0x221/0x720 net/core/dev.c:2787  #41:         (ptrval) (rcu_read_lock){....}, at: __skb_pull include/linux/skbuff.h:2080 [inline]  #41:         (ptrval) (rcu_read_lock){....}, at: skb_mac_gso_segment+0x221/0x720 net/core/dev.c:2787  #42:         (ptrval) (rcu_read_lock){....}, at: __skb_pull include/linux/skbuff.h:2080 [inline]  #42:         (ptrval) (rcu_read_lock){....}, at: skb_mac_gso_segment+0x221/0x720 net/core/dev.c:2787  #43:         (ptrval) (rcu_read_lock){....}, at: __skb_pull include/linux/skbuff.h:2080 [inline]  #43:         (ptrval) (rcu_read_lock){....}, at: skb_mac_gso_segment+0x221/0x720 net/core/dev.c:2787  #44:         (ptrval) (rcu_read_lock){....}, at: __skb_pull include/linux/skbuff.h:2080 [inline]  #44:         (ptrval) (rcu_read_lock){....}, at: skb_mac_gso_segment+0x221/0x720 net/core/dev.c:2787  #45:         (ptrval) (rcu_read_lock){....}, at: __skb_pull include/linux/skbuff.h:2080 [inline]  #45:         (ptrval) (rcu_read_lock){....}, at: skb_mac_gso_segment+0x221/0x720 net/core/dev.c:2787  #46:         (ptrval) (rcu_read_lock){....}, at: __skb_pull include/linux/skbuff.h:2080 [inline]  #46:         (ptrval) (rcu_read_lock){....}, at: skb_mac_gso_segment+0x221/0x720 net/core/dev.c:2787  #47:         (ptrval) (rcu_read_lock){....}, at: __skb_pull include/linux/skbuff.h:2080 [inline]  #47:         (ptrval) (rcu_read_lock){....}, at: skb_mac_gso_segment+0x221/0x720 net/core/dev.c:2787 INFO: lockdep is turned off. CPU: 1 PID: 10189 Comm: syz-executor0 Not tainted 4.17.0-rc2+ #26 Hardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 01/01/2011 Call Trace:  __dump_stack lib/dump_stack.c:77 [inline]  dump_stack+0x1b9/0x294 lib/dump_stack.c:113  __lock_acquire+0x1788/0x5140 kernel/locking/lockdep.c:3449  lock_acquire+0x1dc/0x520 kernel/locking/lockdep.c:3920  rcu_lock_acquire include/linux/rcupdate.h:246 [inline]  rcu_read_lock include/linux/rcupdate.h:632 [inline]  skb_mac_gso_segment+0x25b/0x720 net/core/dev.c:2789  nsh_gso_segment+0x405/0xb60 net/nsh/nsh.c:107  skb_mac_gso_segment+0x3ad/0x720 net/core/dev.c:2792  nsh_gso_segment+0x405/0xb60 net/nsh/nsh.c:107  skb_mac_gso_segment+0x3ad/0x720 net/core/dev.c:2792  nsh_gso_segment+0x405/0xb60 net/nsh/nsh.c:107  skb_mac_gso_segment+0x3ad/0x720 net/core/dev.c:2792  nsh_gso_segment+0x405/0xb60 net/nsh/nsh.c:107  skb_mac_gso_segment+0x3ad/0x720 net/core/dev.c:2792  nsh_gso_segment+0x405/0xb60 net/nsh/nsh.c:107  skb_mac_gso_segment+0x3ad/0x720 net/core/dev.c:2792  nsh_gso_segment+0x405/0xb60 net/nsh/nsh.c:107  skb_mac_gso_segment+0x3ad/0x720 net/core/dev.c:2792  nsh_gso_segment+0x405/0xb60 net/nsh/nsh.c:107  skb_mac_gso_segment+0x3ad/0x720 net/core/dev.c:2792  nsh_gso_segment+0x405/0xb60 net/nsh/nsh.c:107  skb_mac_gso_segment+0x3ad/0x720 net/core/dev.c:2792  nsh_gso_segment+0x405/0xb60 net/nsh/nsh.c:107  skb_mac_gso_segment+0x3ad/0x720 net/core/dev.c:2792  nsh_gso_segment+0x405/0xb60 net/nsh/nsh.c:107  skb_mac_gso_segment+0x3ad/0x720 net/core/dev.c:2792  nsh_gso_segment+0x405/0xb60 net/nsh/nsh.c:107  skb_mac_gso_segment+0x3ad/0x720 net/core/dev.c:2792  nsh_gso_segment+0x405/0xb60 net/nsh/nsh.c:107  skb_mac_gso_segment+0x3ad/0x720 net/core/dev.c:2792  nsh_gso_segment+0x405/0xb60 net/nsh/nsh.c:107  skb_mac_gso_segment+0x3ad/0x720 net/core/dev.c:2792  nsh_gso_segment+0x405/0xb60 net/nsh/nsh.c:107  skb_mac_gso_segment+0x3ad/0x720 net/core/dev.c:2792  nsh_gso_segment+0x405/0xb60 net/nsh/nsh.c:107  skb_mac_gso_segment+0x3ad/0x720 net/core/dev.c:2792  nsh_gso_segment+0x405/0xb60 net/nsh/nsh.c:107  skb_mac_gso_segment+0x3ad/0x720 net/core/dev.c:2792  nsh_gso_segment+0x405/0xb60 net/nsh/nsh.c:107  skb_mac_gso_segment+0x3ad/0x720 net/core/dev.c:2792  nsh_gso_segment+0x405/0xb60 net/nsh/nsh.c:107  skb_mac_gso_segment+0x3ad/0x720 net/core/dev.c:2792  nsh_gso_segment+0x405/0xb60 net/nsh/nsh.c:107  skb_mac_gso_segment+0x3ad/0x720 net/core/dev.c:2792  nsh_gso_segment+0x405/0xb60 net/nsh/nsh.c:107  skb_mac_gso_segment+0x3ad/0x720 net/core/dev.c:2792  nsh_gso_segment+0x405/0xb60 net/nsh/nsh.c:107  skb_mac_gso_segment+0x3ad/0x720 net/core/dev.c:2792  nsh_gso_segment+0x405/0xb60 net/nsh/nsh.c:107  skb_mac_gso_segment+0x3ad/0x720 net/core/dev.c:2792  nsh_gso_segment+0x405/0xb60 net/nsh/nsh.c:107  skb_mac_gso_segment+0x3ad/0x720 net/core/dev.c:2792  nsh_gso_segment+0x405/0xb60 net/nsh/nsh.c:107  skb_mac_gso_segment+0x3ad/0x720 net/core/dev.c:2792  nsh_gso_segment+0x405/0xb60 net/nsh/nsh.c:107  skb_mac_gso_segment+0x3ad/0x720 net/core/dev.c:2792  nsh_gso_segment+0x405/0xb60 net/nsh/nsh.c:107  skb_mac_gso_segment+0x3ad/0x720 net/core/dev.c:2792  nsh_gso_segment+0x405/0xb60 net/nsh/nsh.c:107  skb_mac_gso_segment+0x3ad/0x720 net/core/dev.c:2792  nsh_gso_segment+0x405/0xb60 net/nsh/nsh.c:107  skb_mac_gso_segment+0x3ad/0x720 net/core/dev.c:2792  nsh_gso_segment+0x405/0xb60 net/nsh/nsh.c:107  skb_mac_gso_segment+0x3ad/0x720 net/core/dev.c:2792  nsh_gso_segment+0x405/0xb60 net/nsh/nsh.c:107  skb_mac_gso_segment+0x3ad/0x720 net/core/dev.c:2792  nsh_gso_segment+0x405/0xb60 net/nsh/nsh.c:107  skb_mac_gso_segment+0x3ad/0x720 net/core/dev.c:2792  nsh_gso_segment+0x405/0xb60 net/nsh/nsh.c:107  skb_mac_gso_segment+0x3ad/0x720 net/core/dev.c:2792  nsh_gso_segment+0x405/0xb60 net/nsh/nsh.c:107  skb_mac_gso_segment+0x3ad/0x720 net/core/dev.c:2792  nsh_gso_segment+0x405/0xb60 net/nsh/nsh.c:107  skb_mac_gso_segment+0x3ad/0x720 net/core/dev.c:2792  nsh_gso_segment+0x405/0xb60 net/nsh/nsh.c:107  skb_mac_gso_segment+0x3ad/0x720 net/core/dev.c:2792  nsh_gso_segment+0x405/0xb60 net/nsh/nsh.c:107  skb_mac_gso_segment+0x3ad/0x720 net/core/dev.c:2792  nsh_gso_segment+0x405/0xb60 net/nsh/nsh.c:107  skb_mac_gso_segment+0x3ad/0x720 net/core/dev.c:2792  nsh_gso_segment+0x405/0xb60 net/nsh/nsh.c:107  skb_mac_gso_segment+0x3ad/0x720 net/core/dev.c:2792  nsh_gso_segment+0x405/0xb60 net/nsh/nsh.c:107  skb_mac_gso_segment+0x3ad/0x720 net/core/dev.c:2792  nsh_gso_segment+0x405/0xb60 net/nsh/nsh.c:107  skb_mac_gso_segment+0x3ad/0x720 net/core/dev.c:2792  nsh_gso_segment+0x405/0xb60 net/nsh/nsh.c:107  skb_mac_gso_segment+0x3ad/0x720 net/core/dev.c:2792  nsh_gso_segment+0x405/0xb60 net/nsh/nsh.c:107  skb_mac_gso_segment+0x3ad/0x720 net/core/dev.c:2792  nsh_gso_segment+0x405/0xb60 net/nsh/nsh.c:107  skb_mac_gso_segment+0x3ad/0x720 net/core/dev.c:2792  nsh_gso_segment+0x405/0xb60 net/nsh/nsh.c:107  skb_mac_gso_segment+0x3ad/0x720 net/core/dev.c:2792  nsh_gso_segment+0x405/0xb60 net/nsh/nsh.c:107  skb_mac_gso_segment+0x3ad/0x720 net/core/dev.c:2792  nsh_gso_segment+0x405/0xb60 net/nsh/nsh.c:107  skb_mac_gso_segment+0x3ad/0x720 net/core/dev.c:2792  __skb_gso_segment+0x3bb/0x870 net/core/dev.c:2865  skb_gso_segment include/linux/netdevice.h:4025 [inline]  validate_xmit_skb+0x54d/0xd90 net/core/dev.c:3118  validate_xmit_skb_list+0xbf/0x120 net/core/dev.c:3168  sch_direct_xmit+0x354/0x11e0 net/sched/sch_generic.c:312  qdisc_restart net/sched/sch_generic.c:399 [inline]  __qdisc_run+0x741/0x1af0 net/sched/sch_generic.c:410  __dev_xmit_skb net/core/dev.c:3243 [inline]  __dev_queue_xmit+0x28ea/0x34c0 net/core/dev.c:3551  dev_queue_xmit+0x17/0x20 net/core/dev.c:3616  packet_snd net/packet/af_packet.c:2951 [inline]  packet_sendmsg+0x40f8/0x6070 net/packet/af_packet.c:2976  sock_sendmsg_nosec net/socket.c:629 [inline]  sock_sendmsg+0xd5/0x120 net/socket.c:639  __sys_sendto+0x3d7/0x670 net/socket.c:1789  __do_sys_sendto net/socket.c:1801 [inline]  __se_sys_sendto net/socket.c:1797 [inline]  __x64_sys_sendto+0xe1/0x1a0 net/socket.c:1797  do_syscall_64+0x1b1/0x800 arch/x86/entry/common.c:287  entry_SYSCALL_64_after_hwframe+0x49/0xbe  ",af50e4ba34f4c45e92535364133d4deb5931c1c5,1
block: fix error unwinding in device_add_disk,"One device_add is called disk->ev will be freed by disk_release, so we should free it twice.  Fix this by allocating disk->ev after device_add so that the extra local unwinding can be removed entirely.  Based on an earlier patch from Tetsuo Handa.  ",99d8690aae4b2f0d1d90075de355ac087f820a66,0
net_sched: add max len check for TCA_KIND,The TCA_KIND attribute is of NLA_STRING which does not check the NUL char. KMSAN reported an uninit-value of TCA_KIND which is likely caused by the lack of NUL.  Change it to NLA_NUL_STRING and add a max len too.  ,62794fc4fbf52f2209dc094ea255eaef760e7d01,0
netfilter: ipset: Missing nfnl_lock()/nfnl_unlock() is added to ip_set_net_exit(),"Patch ""netfilter: ipset: use nfnl_mutex_is_locked"" is added the real mutex locking check, which revealed the missing locking in ip_set_net_exit().  ",f998b6b10144cd9809da6af02758615f789e8aa1,0
ALSA: timer: Add missing mutex lock for compat ioctls,"The races among ioctl and other operations were protected by the commit af368027a49a (""ALSA: timer: Fix race among timer ioctls"") and later fixes, but one code path was forgotten in the scenario: the 32bit compat ioctl.  As syzkaller recently spotted, a very similar use-after-free may happen with the combination of compat ioctls.  The fix is simply to apply the same ioctl_lock to the compat_ioctl callback, too.  ",79fb0518fec8c8b4ea7f1729f54f293724b3dbb0,1
smack: use GFP_NOFS while holding inode_smack::smk_lock,"inode_smack::smk_lock is taken during smack_d_instantiate(), which is called during a filesystem transaction when creating a file on ext4. Therefore to avoid a deadlock, all code that takes this lock must use GFP_NOFS, to prevent memory reclaim from waiting for the filesystem transaction to complete.  ",e5bfad3d7acc5702f32aafeb388362994f4d7bd0,0
rtnetlink: Disallow FDB configuration for non-Ethernet device,"When an FDB entry is configured, the address is validated to have the length of an Ethernet address, but the device for which the address is configured can be of any type.  The above can result in the use of uninitialized memory when the address is later compared against existing addresses since 'dev->addr_len' is used and it may be greater than ETH_ALEN, as with ip6tnl devices.  Fix this by making sure that FDB entries are only configured for Ethernet devices.  BUG: KMSAN: uninit-value in memcmp+0x11d/0x180 lib/string.c:863 CPU: 1 PID: 4318 Comm: syz-executor998 Not tainted 4.19.0-rc3+ #49 Hardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 01/01/2011 Call Trace:   __dump_stack lib/dump_stack.c:77 [inline]   dump_stack+0x14b/0x190 lib/dump_stack.c:113   kmsan_report+0x183/0x2b0 mm/kmsan/kmsan.c:956   __msan_warning+0x70/0xc0 mm/kmsan/kmsan_instr.c:645   memcmp+0x11d/0x180 lib/string.c:863   dev_uc_add_excl+0x165/0x7b0 net/core/dev_addr_lists.c:464   ndo_dflt_fdb_add net/core/rtnetlink.c:3463 [inline]   rtnl_fdb_add+0x1081/0x1270 net/core/rtnetlink.c:3558   rtnetlink_rcv_msg+0xa0b/0x1530 net/core/rtnetlink.c:4715   netlink_rcv_skb+0x36e/0x5f0 net/netlink/af_netlink.c:2454   rtnetlink_rcv+0x50/0x60 net/core/rtnetlink.c:4733   netlink_unicast_kernel net/netlink/af_netlink.c:1317 [inline]   netlink_unicast+0x1638/0x1720 net/netlink/af_netlink.c:1343   netlink_sendmsg+0x1205/0x1290 net/netlink/af_netlink.c:1908   sock_sendmsg_nosec net/socket.c:621 [inline]   sock_sendmsg net/socket.c:631 [inline]   ___sys_sendmsg+0xe70/0x1290 net/socket.c:2114   __sys_sendmsg net/socket.c:2152 [inline]   __do_sys_sendmsg net/socket.c:2161 [inline]   __se_sys_sendmsg+0x2a3/0x3d0 net/socket.c:2159   __x64_sys_sendmsg+0x4a/0x70 net/socket.c:2159   do_syscall_64+0xb8/0x100 arch/x86/entry/common.c:291   entry_SYSCALL_64_after_hwframe+0x63/0xe7 ",da71577545a52be3e0e9225a946e5fd79cfab015,1
gpio: fix NULL-deref-on-deregistration regression,"Fix a NULL-pointer deference when deregistering the gpio character device that was introduced by the recent stub-driver hack. When the new ""driver"" is unbound as part of deregistration, driver core clears the driver-data pointer which is used to retrieve the struct gpio_device in its release callback.  Fix this by using container_of() in the release callback as should have been done all along.  ",a6112998ee45514def58200a7914706c0703f3d7,0
bpf: fix a rcu usage warning in bpf_prog_array_copy_core(),"Commit 394e40a29788 (""bpf: extend bpf_prog_array to store pointers to the cgroup storage"") refactored the bpf_prog_array_copy_core() to accommodate new structure bpf_prog_array_item which contains bpf_prog array itself.  In the old code, we had    perf_event_query_prog_array():      mutex_lock(...)      bpf_prog_array_copy_call():        prog = rcu_dereference_check(array, 1)->progs        bpf_prog_array_copy_core(prog, ...)      mutex_unlock(...)  With the above commit, we had    perf_event_query_prog_array():      mutex_lock(...)      bpf_prog_array_copy_call():        bpf_prog_array_copy_core(array, ...):          item = rcu_dereference(array)->items;          ...      mutex_unlock(...)  The new code will trigger a lockdep rcu checking warning. The fix is to change rcu_dereference() to rcu_dereference_check() to prevent such a warning.  ",965931e3a803a506482616f89239eff6901c17b8,1
ipv6: fix uninit-value in ip6_multipath_l3_keys(),"syzbot/KMSAN reported an uninit-value in ip6_multipath_l3_keys(), root caused to a bad assumption of ICMP header being already pulled in skb->head  ip_multipath_l3_keys() does the correct thing, so it is an IPv6 only bug.  BUG: KMSAN: uninit-value in ip6_multipath_l3_keys net/ipv6/route.c:1830 [inline] BUG: KMSAN: uninit-value in rt6_multipath_hash+0x5c4/0x640 net/ipv6/route.c:1858 CPU: 0 PID: 4507 Comm: syz-executor661 Not tainted 4.16.0+ #87 Hardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 01/01/2011 Call Trace:  __dump_stack lib/dump_stack.c:17 [inline]  dump_stack+0x185/0x1d0 lib/dump_stack.c:53  kmsan_report+0x142/0x240 mm/kmsan/kmsan.c:1067  __msan_warning_32+0x6c/0xb0 mm/kmsan/kmsan_instr.c:683  ip6_multipath_l3_keys net/ipv6/route.c:1830 [inline]  rt6_multipath_hash+0x5c4/0x640 net/ipv6/route.c:1858  ip6_route_input+0x65a/0x920 net/ipv6/route.c:1884  ip6_rcv_finish+0x413/0x6e0 net/ipv6/ip6_input.c:69  NF_HOOK include/linux/netfilter.h:288 [inline]  ipv6_rcv+0x1e16/0x2340 net/ipv6/ip6_input.c:208  __netif_receive_skb_core+0x47df/0x4a90 net/core/dev.c:4562  __netif_receive_skb net/core/dev.c:4627 [inline]  netif_receive_skb_internal+0x49d/0x630 net/core/dev.c:4701  netif_receive_skb+0x230/0x240 net/core/dev.c:4725  tun_rx_batched drivers/net/tun.c:1555 [inline]  tun_get_user+0x740f/0x7c60 drivers/net/tun.c:1962  tun_chr_write_iter+0x1d4/0x330 drivers/net/tun.c:1990  call_write_iter include/linux/fs.h:1782 [inline]  new_sync_write fs/read_write.c:469 [inline]  __vfs_write+0x7fb/0x9f0 fs/read_write.c:482  vfs_write+0x463/0x8d0 fs/read_write.c:544  SYSC_write+0x172/0x360 fs/read_write.c:589  SyS_write+0x55/0x80 fs/read_write.c:581  do_syscall_64+0x309/0x430 arch/x86/entry/common.c:287  entry_SYSCALL_64_after_hwframe+0x3d/0xa2  ",cea67a2dd6b2419dcc13a39309b9a79a1f773193,1
fs/minix: don't allow getting deleted inodes,"If an inode has no links, we need to mark it bad rather than allowing it to be accessed.  This avoids ",facb03dddec04e4aac1bb2139accdceb04deb1f3,0
KEYS: fix parsing invalid pkey info string,We need to check the return value of match_token() for Opt_err before doing anything with it.  ,57b0e31453209d746c99e513d80b3d0c44a80891,0
skbuff: fix a data race in skb_queue_len(),"sk_buff.qlen can be accessed concurrently as noticed by KCSAN,   BUG: KCSAN: data-race in __skb_try_recv_from_queue / unix_dgram_sendmsg   read to 0xffff8a1b1d8a81c0 of 4 bytes by task 5371 on cpu 96:   unix_dgram_sendmsg+0x9a9/0xb70 include/linux/skbuff.h:1821 				 net/unix/af_unix.c:1761   ____sys_sendmsg+0x33e/0x370   ___sys_sendmsg+0xa6/0xf0   __sys_sendmsg+0x69/0xf0   __x64_sys_sendmsg+0x51/0x70   do_syscall_64+0x91/0xb47   entry_SYSCALL_64_after_hwframe+0x49/0xbe   write to 0xffff8a1b1d8a81c0 of 4 bytes by task 1 on cpu 99:   __skb_try_recv_from_queue+0x327/0x410 include/linux/skbuff.h:2029   __skb_try_recv_datagram+0xbe/0x220   unix_dgram_recvmsg+0xee/0x850   ____sys_recvmsg+0x1fb/0x210   ___sys_recvmsg+0xa2/0xf0   __sys_recvmsg+0x66/0xf0   __x64_sys_recvmsg+0x51/0x70   do_syscall_64+0x91/0xb47   entry_SYSCALL_64_after_hwframe+0x49/0xbe  Since only the read is operating as lockless, it could introduce a logic bug in unix_recvq_full() due to the load tearing. Fix it by adding a lockless variant of skb_queue_len() and unix_recvq_full() where READ_ONCE() is on the read while WRITE_ONCE() is on the write similar to the commit d7d16a89350a (""net: add skb_queue_empty_lockless()"").  ",86b18aaa2b5b5bb48e609cd591b3d2d0fdbe0442,1
net-sysfs: Fix reference count leak,"Netdev_register_kobject is calling device_initialize. In case of error reference taken by device_initialize is not given up.  Drivers are supposed to call free_netdev in case of error. In non-error case the last reference is given up there and device release sequence is triggered. In error case this reference is kept and the release sequence is never started.  Fix this by setting reg_state as NETREG_UNREGISTERED if registering fails.  This is the rootcause for couple of memory leaks reported by Syzkaller:  BUG: memory leak unreferenced object 0xffff8880675ca008 (size 256):   comm ""netdev_register"", pid 281, jiffies 4294696663 (age 6.808s)   ",cb626bf566eb4433318d35681286c494f04fedcc,1
"bpf, test, cgroup: Use sk_{alloc,free} for test cases","BPF test infra has some hacks in place which kzalloc() a socket and perform minimum init via sock_net_set() and sock_init_data(). As a result, the sk's skcd->cgroup is NULL since it didn't go through proper initialization as it would have been the case from sk_alloc(). Rather than re-adding a NULL test in sock_cgroup_ptr() just for this, use sk_{alloc,free}() pair for the test socket. The latter also allows to get rid of the bpf_sk_storage_free() special case.  ",435b08ec0094ac1e128afe6cfd0d9311a8c617a7,0
net/rds: fix warn in rds_message_alloc_sgs,redundant copy_from_user in rds_sendmsg system call expose rds to issue where rds_rdma_extra_size walk the rds iovec and and calculate the number pf pages (sgs) it need to add to the tail of rds message and later rds_cmsg_rdma_args copy the rds iovec again and re calculate the same number and get different result causing WARN_ON in rds_message_alloc_sgs.  fix this by doing the copy_from_user only once per rds_sendmsg system call.  When issue occur the below dump is seen:  ,ea010070d0a7497253d5a6f919f6dd107450b31a,0
net/smc: init conn.tx_work & conn.send_lock sooner,"syzkaller found that following program crashes the host :  {   int fd = socket(AF_SMC, SOCK_STREAM, 0);   int val = 1;    listen(fd, 0);   shutdown(fd, SHUT_RDWR);   setsockopt(fd, 6, TCP_NODELAY, &val, 4); }  Simply initialize conn.tx_work & conn.send_lock at socket creation, rather than deeper in the stack.  ODEBUG: assert_init not available (active state 0) object type: timer_list hint:           (null) ",be7f3e59997b7744e8be153b76fca28ac5b71354,1
kernel/smp: Provide CSD lock timeout diagnostics,This commit causes csd_lock_wait() to emit diagnostics when a CPU fails to respond quickly enough to one of the smp_call_function() family of function calls.  These diagnostics are enabled by a new CSD_LOCK_WAIT_DEBUG Kconfig option that depends on DEBUG_KERNEL.  This commit was inspired by an earlier patch by Josef Bacik.  ,35feb60474bf4f7fa7840e14fc7fd344996b919d,1
crypto: af_alg - fix NULL pointer dereference in,"af_alg_free_areq_sgls()  If allocating the ->tsgl member of 'struct af_alg_async_req' failed, during cleanup we dereferenced the NULL ->tsgl pointer in af_alg_free_areq_sgls(), because ->tsgl_entries was nonzero.  Fix it by only freeing the ->tsgl list if it is non-NULL.  This affected both algif_skcipher and algif_aead.  ",887207ed9e5812ed9239b6d07185a2d35dda91db,1
HID: magicmouse: Fix an error handling path in magicmouse_probe(),"If the timer introduced by the commit below is started, then it must be deleted in the error handling of the probe. Otherwise it would trigger once the driver is no more.  ",33812fc7c8d77a43b7e2bf36a0d5a57c277a4b0c,1
"fbdev: Detect integer underflow at ""struct fbcon_ops""->clear_margins.","syzbot is reporting general protection fault in bitfill_aligned() [1] caused by integer underflow in bit_clear_margins(). The cause of this problem is when and how do_vc_resize() updates vc->vc_{cols,rows}.  If vc_do_resize() fails (e.g. kzalloc() fails) when var.xres or var.yres is going to shrink, vc->vc_{cols,rows} will not be updated. This allows bit_clear_margins() to see info->var.xres < (vc->vc_cols * cw) or info->var.yres < (vc->vc_rows * ch). Unexpectedly large rw or bh will try to overrun the __iomem region and causes general protection fault.  Also, vc_resize(vc, 0, 0) does not set vc->vc_{cols,rows} = 0 due to    new_cols = (cols ? cols : vc->vc_cols);   new_rows = (lines ? lines : vc->vc_rows);  exception. Since cols and lines are calculated as    cols = FBCON_SWAP(ops->rotate, info->var.xres, info->var.yres);   rows = FBCON_SWAP(ops->rotate, info->var.yres, info->var.xres);   cols /= vc->vc_font.width;   rows /= vc->vc_font.height;   vc_resize(vc, cols, rows);  in fbcon_modechanged(), var.xres < vc->vc_font.width makes cols = 0 and var.yres < vc->vc_font.height makes rows = 0. This means that    const int fd = open(""/dev/fb0"", O_ACCMODE);   struct fb_var_screeninfo var = { };   ioctl(fd, FBIOGET_VSCREENINFO, &var);   var.xres = var.yres = 1;   ioctl(fd, FBIOPUT_VSCREENINFO, &var);  easily reproduces integer underflow bug explained above.  Of course, callers of vc_resize() are not handling vc_do_resize() failure is bad. But we can't avoid vc_resize(vc, 0, 0) which returns 0. Therefore, as a band-aid workaround, this patch checks integer underflow in ""struct fbcon_ops""->clear_margins call, assuming that vc->vc_cols * vc->vc_font.width and vc->vc_rows * vc->vc_font.heigh do not cause integer overflow.  [1] https://syzkaller.appspot.com/bug?id=a565882df74fa76f10d3a6fec4be31098dbb37c6  ",033724d6864245a11f8e04c066002e6ad22b3fd0,1
udp: harden copy_linear_skb(),"syzkaller got crashes with CONFIG_HARDENED_USERCOPY=y configs.  Issue here is that recvfrom() can be used with user buffer of Z bytes, and SO_PEEK_OFF of X bytes, from a skb with Y bytes, and following condition :  Z < X < Y  kernel BUG at mm/usercopy.c:72! invalid opcode: 0000 [#1] SMP KASAN Dumping ftrace buffer:    (ftrace buffer empty) ",fd851ba9caa9a63fdbb72a2e6ed5560c0989e999,1
nbd: remove nbd->destroy_complete,"The nbd->destroy_complete pointer is not really needed.  For creating a device without a specific index we now simplify skip devices marked NBD_DESTROY_ON_DISCONNECT as there is not much point to reuse them. For device creation with a specific index there is no real need to treat the case of a requested but not finished disconnect different than any other device that is being shutdown, i.e. we can just return an error, as a slightly different race window would anyway.  ",7ee656c3ac3d047b4cf1269f83ac9d6c0bba916b,1
ovl: fix out of bounds access warning in ovl_check_fb_len(),"syzbot reported out of bounds memory access from open_by_handle_at() with a crafted file handle that looks like this:    { .handle_bytes = 2, .handle_type = OVL_FILEID_V1 }  handle_bytes gets rounded down to 0 and we end up calling:   ovl_check_fh_len(fh, 0) => ovl_check_fb_len(fh + 3, -3)  But fh buffer is only 2 bytes long, so accessing struct ovl_fb at fh + 3 is illegal.  ",522f6e6cba6880a038e2bd88e10390b84cd3febd,1
vfs: move_mount: reject moving kernel internal mounts,"sys_move_mount() crashes by dereferencing the pointer MNT_NS_INTERNAL, a.k.a. ERR_PTR(-EINVAL), if the old mount is specified by fd for a kernel object with an internal mount, such as a pipe or memfd.  Fix it by checking for this case and returning -EINVAL.  [AV: what we want is is_mounted(); use that instead of making the condition even more convoluted]  Reproducer:      #include <unistd.h>      ",570d7a98e7d6d5d8706d94ffd2d40adeaa318332,1
geneve: move debug check after netdev unregister,The debug check must be done after unregister_netdevice_many() call -- the list_del() for this is done inside .ndo_stop.  ,0fda7600c2e174fe27e9cf02e78e345226e441fa,0
ipv6/addrconf: fix potential NULL deref in inet6_set_link_af(),"__in6_dev_get(dev) called from inet6_set_link_af() can return NULL.  The needed check has been recently removed, let's add it back.  While do_setlink() does call validate_linkmsg() : ... err = validate_linkmsg(dev, tb); ",db3fa271022dacb9f741b96ea4714461a8911bb9,0
mISDN: fix a race in dev_expire_timer(),"Since mISDN_close() uses dev->pending to iterate over active timers, there is a chance that one timer got removed from the ->pending list in dev_expire_timer() but that the thread has not called yet wake_up_interruptible()  So mISDN_close() could miss this and free dev before completion of at least one dev_expire_timer()  syzbot was able to catch this race :  BUG: KASAN: use-after-free in register_lock_class+0x140c/0x1bf0 kernel/locking/lockdep.c:827 Write of size 8 at addr ffff88809fc18948 by task syz-executor1/24769  CPU: 1 PID: 24769 Comm: syz-executor1 Not tainted 5.0.0-rc5 #60 Hardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 01/01/2011 Call Trace:  <IRQ>  __dump_stack lib/dump_stack.c:77 [inline]  dump_stack+0x172/0x1f0 lib/dump_stack.c:113  print_address_description.cold+0x7c/0x20d mm/kasan/report.c:187  kasan_report.cold+0x1b/0x40 mm/kasan/report.c:317  __asan_report_store8_noabort+0x17/0x20 mm/kasan/generic_report.c:140  register_lock_class+0x140c/0x1bf0 kernel/locking/lockdep.c:827  __lock_acquire+0x11f/0x4700 kernel/locking/lockdep.c:3224  lock_acquire+0x16f/0x3f0 kernel/locking/lockdep.c:3841  __raw_spin_lock_irqsave include/linux/spinlock_api_smp.h:110 [inline]  _raw_spin_lock_irqsave+0x95/0xcd kernel/locking/spinlock.c:152  __wake_up_common_lock+0xc7/0x190 kernel/sched/wait.c:120  __wake_up+0xe/0x10 kernel/sched/wait.c:145  dev_expire_timer+0xe4/0x3b0 drivers/isdn/mISDN/timerdev.c:174  call_timer_fn+0x190/0x720 kernel/time/timer.c:1325 protocol 88fb is buggy, dev hsr_slave_0 protocol 88fb is buggy, dev hsr_slave_1  expire_timers kernel/time/timer.c:1362 [inline]  __run_timers kernel/time/timer.c:1681 [inline]  __run_timers kernel/time/timer.c:1649 [inline]  run_timer_softirq+0x652/0x1700 kernel/time/timer.c:1694  __do_softirq+0x266/0x95a kernel/softirq.c:292  invoke_softirq kernel/softirq.c:373 [inline]  irq_exit+0x180/0x1d0 kernel/softirq.c:413  exiting_irq arch/x86/include/asm/apic.h:536 [inline]  smp_apic_timer_interrupt+0x14a/0x570 arch/x86/kernel/apic/apic.c:1062  apic_timer_interrupt+0xf/0x20 arch/x86/entry/entry_64.S:807  </IRQ> ",bdcc5bc25548ef6b08e2e43937148f907c212292,1
net: vlan: fix a UAF in vlan_dev_real_dev(),The real_dev of a vlan net_device may be freed after unregister_vlan_dev(). Access the real_dev continually by vlan_dev_real_dev() will trigger the UAF problem for the real_dev like following:  ,563bcbae3ba233c275c244bfce2efe12938f5363,0
ipv6: make icmp6_send() robust against null skb->dev,syzbot was able to crash one host with the following stack trace :  kasan: GPF could be caused by NULL-ptr deref or user memory access general protection fault: 0000 [#1] PREEMPT SMP KASAN CPU: 0 PID: 8625 Comm: syz-executor4 Not tainted 4.20.0+ #8 ,8d933670452107e41165bea70a30dffbd281bef1,1
vhost: use mutex_lock_nested() in vhost_dev_lock_vqs(),We used to call mutex_lock() in vhost_dev_lock_vqs() which tries to hold mutexes of all virtqueues. This may confuse lockdep to report a possible deadlock because of trying to hold locks belong to same class. Switch to use mutex_lock_nested() to avoid false positive.  ,e9cb4239134c860e5f92c75bf5321bd377bb505b,0
bpf: Fix error path in htab_map_alloc(),"syzbot was able to trigger a use-after-free in htab_map_alloc() [1]  htab_map_alloc() lacks a call to lockdep_unregister_key() in its error path.  lockdep_register_key() and lockdep_unregister_key() can not fail, it seems better to use them right after htab allocation and before htab freeing, avoiding more goto/labels in htab_map_alloc()  [1] BUG: KASAN: use-after-free in lockdep_register_key+0x356/0x3e0 kernel/locking/lockdep.c:1182 Read of size 8 at addr ffff88805fa67ad8 by task syz-executor.3/2356  CPU: 1 PID: 2356 Comm: syz-executor.3 Not tainted 5.9.0-syzkaller #0 Hardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 01/01/2011 Call Trace:  __dump_stack lib/dump_stack.c:77 [inline]  dump_stack+0x107/0x163 lib/dump_stack.c:118  print_address_description.constprop.0.cold+0xae/0x4c8 mm/kasan/report.c:385  __kasan_report mm/kasan/report.c:545 [inline]  kasan_report.cold+0x1f/0x37 mm/kasan/report.c:562  lockdep_register_key+0x356/0x3e0 kernel/locking/lockdep.c:1182  htab_init_buckets kernel/bpf/hashtab.c:144 [inline]  htab_map_alloc+0x6c5/0x14a0 kernel/bpf/hashtab.c:521  find_and_alloc_map kernel/bpf/syscall.c:122 [inline]  map_create kernel/bpf/syscall.c:825 [inline]  __do_sys_bpf+0xa80/0x5180 kernel/bpf/syscall.c:4381  do_syscall_64+0x2d/0x70 arch/x86/entry/common.c:46  entry_SYSCALL_64_after_hwframe+0x44/0xa9 ",8aaeed81fcb917b5cf4976932c5baefa1471128b,1
ip6_tunnel: better validate user provided tunnel names,Use valid_name() to make sure user does not provide illegal device name.  ,db7a65e3ab78e5b1c4b17c0870ebee35a4ee3257,0
ip_gre: set dev->hard_header_len and dev->needed_headroom properly,"GRE tunnel has its own header_ops, ipgre_header_ops, and sets it conditionally. When it is set, it assumes the outer IP header is already created before ipgre_xmit().  This is not true when we send packets through a raw packet socket, where L2 headers are supposed to be constructed by user. Packet socket calls dev_validate_header() to validate the header. But GRE tunnel does not set dev->hard_header_len, so that check can be simply bypassed, therefore uninit memory could be passed down to ipgre_xmit(). Similar for dev->needed_headroom.  dev->hard_header_len is supposed to be the length of the header created by dev->header_ops->create(), so it should be used whenever header_ops is set, and dev->needed_headroom should be used when it is not set.  ",fdafed459998e2be0e877e6189b24cb7a0183224,0
tipc: call start and done ops directly in __tipc_nl_compat_dumpit(),"__tipc_nl_compat_dumpit() uses a netlink_callback on stack, so the only way to align it with other ->dumpit() call path is calling tipc_dump_start() and tipc_dump_done() directly inside it. Otherwise ->dumpit() would always get NULL from cb->args[].  But tipc_dump_start() uses sock_net(cb->skb->sk) to retrieve net pointer, the cb->skb here doesn't set skb->sk, the net pointer is saved in msg->net instead, so introduce a helper function __tipc_dump_start() to pass in msg->net.  Ying pointed out cb->args[0...3] are already used by other callbacks on this call path, so we can't use cb->args[0] any more, use cb->args[4] instead.  ",8f5c5fcf353302374b36232d6885c1a3b579e5ca,0
go7007: add sanity checking for endpoints,A malicious USB device may lack endpoints the driver assumes to exist Accessing them leads to NULL pointer accesses. This patch introduces sanity checking.  ,137641287eb40260783a4413847a0aef06023a6c,1
tty: vt: always invoke vc->vc_sw->con_resize callback,"syzbot is reporting OOB write at vga16fb_imageblit() [1], for resize_screen() from ioctl(VT_RESIZE) returns 0 without checking whether requested rows/columns fit the amount of memory reserved for the graphical screen if current mode is KD_GRAPHICS.  ",ffb324e6f874121f7dce5bdae5e05d02baae7269,1
fuse: annotate lock in fuse_reverse_inval_entry(),Add missing inode lock annotatation; found by syzbot.  ,bda9a71980e083699a0360963c0135657b73f47a,0
net: fix a concurrency bug in l2tp_tunnel_register(),"l2tp_tunnel_register() registers a tunnel without fully initializing its attribute. This can allow another kernel thread running l2tp_xmit_core() to access the uninitialized data and then cause a kernel NULL pointer dereference error, as shown below.  Thread 1    Thread 2 //l2tp_tunnel_register() list_add_rcu(&tunnel->list, &pn->l2tp_tunnel_list);            //pppol2tp_connect()            tunnel = l2tp_tunnel_get(sock_net(sk), info.tunnel_id);            // Fetch the new tunnel            ...            //l2tp_xmit_core()            struct sock *sk = tunnel->sock;            ...            bh_lock_sock(sk);            //Null pointer error happens tunnel->sock = sk;  Fix this bug by initializing tunnel->sock before adding the tunnel into l2tp_tunnel_list.  ",69e16d01d1de4f1249869de342915f608feb55d5,1
Bluetooth: skip invalid hci_sync_conn_complete_evt,"Syzbot reported a corrupted list in kobject_add_internal [1]. This happens when multiple HCI_EV_SYNC_CONN_COMPLETE event packets with status 0 are sent for the same HCI connection. This causes us to register the device more than once which corrupts the kset list.  As this is forbidden behavior, we add a check for whether we're trying to process the same HCI_EV_SYNC_CONN_COMPLETE event multiple times for one connection. If that's the case, the event is invalid, so we report an error that the device is misbehaving, and ignore the packet.  ",92fe24a7db751b80925214ede43f8d2be792ea7b,0
fork: annotate data race in copy_process(),"KCSAN reported data race reading and writing nr_threads and max_threads. The data race is intentional and benign. This is obvious from the comment above it and based on general consensus when discussing this issue. So there's no need for any heavy atomic or *_ONCE() machinery here.  In accordance with the newly introduced data_race() annotation consensus, mark the offending line with data_race(). Here it's actually useful not just to silence KCSAN but to also clearly communicate that the race is intentional. This is especially helpful since nr_threads is otherwise protected by tasklist_lock.  BUG: KCSAN: data-race in copy_process / copy_process  write to 0xffffffff86205cf8 of 4 bytes by task 14779 on cpu 1:   copy_process+0x2eba/0x3c40 kernel/fork.c:2273   _do_fork+0xfe/0x7a0 kernel/fork.c:2421   __do_sys_clone kernel/fork.c:2576 [inline]   __se_sys_clone kernel/fork.c:2557 [inline]   __x64_sys_clone+0x130/0x170 kernel/fork.c:2557   do_syscall_64+0xcc/0x3a0 arch/x86/entry/common.c:294   entry_SYSCALL_64_after_hwframe+0x44/0xa9  read to 0xffffffff86205cf8 of 4 bytes by task 6944 on cpu 0:   copy_process+0x94d/0x3c40 kernel/fork.c:1954   _do_fork+0xfe/0x7a0 kernel/fork.c:2421   __do_sys_clone kernel/fork.c:2576 [inline]   __se_sys_clone kernel/fork.c:2557 [inline]   __x64_sys_clone+0x130/0x170 kernel/fork.c:2557   do_syscall_64+0xcc/0x3a0 arch/x86/entry/common.c:294   entry_SYSCALL_64_after_hwframe+0x44/0xa9 deration/thvp7AHs5Ew/aPdYLXfYBQAJ  ",c17d1a3a8ee4dac7539d5c976b45d9300f6f10bc,1
net/ipv6: respect rcu grace period before freeing fib6_info,"syzbot reported use after free that is caused by fib6_info being freed without a proper RCU grace period.  CPU: 0 PID: 1407 Comm: udevd Not tainted 4.17.0+ #39 Hardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 01/01/2011 Call Trace:  <IRQ>  __dump_stack lib/dump_stack.c:77 [inline]  dump_stack+0x1b9/0x294 lib/dump_stack.c:113  print_address_description+0x6c/0x20b mm/kasan/report.c:256  kasan_report_error mm/kasan/report.c:354 [inline]  kasan_report.cold.7+0x242/0x2fe mm/kasan/report.c:412  __asan_report_load8_noabort+0x14/0x20 mm/kasan/report.c:433  __read_once_size include/linux/compiler.h:188 [inline]  find_rr_leaf net/ipv6/route.c:705 [inline]  rt6_select net/ipv6/route.c:761 [inline]  fib6_table_lookup+0x12b7/0x14d0 net/ipv6/route.c:1823  ip6_pol_route+0x1c2/0x1020 net/ipv6/route.c:1856  ip6_pol_route_output+0x54/0x70 net/ipv6/route.c:2082  fib6_rule_lookup+0x211/0x6d0 net/ipv6/fib6_rules.c:122  ip6_route_output_flags+0x2c5/0x350 net/ipv6/route.c:2110  ip6_route_output include/net/ip6_route.h:82 [inline]  icmpv6_xrlim_allow net/ipv6/icmp.c:211 [inline]  icmp6_send+0x147c/0x2da0 net/ipv6/icmp.c:535  icmpv6_send+0x17a/0x300 net/ipv6/ip6_icmp.c:43  ip6_link_failure+0xa5/0x790 net/ipv6/route.c:2244  dst_link_failure include/net/dst.h:427 [inline]  ndisc_error_report+0xd1/0x1c0 net/ipv6/ndisc.c:695  neigh_invalidate+0x246/0x550 net/core/neighbour.c:892  neigh_timer_handler+0xaf9/0xde0 net/core/neighbour.c:978  call_timer_fn+0x230/0x940 kernel/time/timer.c:1326  expire_timers kernel/time/timer.c:1363 [inline]  __run_timers+0x79e/0xc50 kernel/time/timer.c:1666  run_timer_softirq+0x4c/0x70 kernel/time/timer.c:1692  __do_softirq+0x2e0/0xaf5 kernel/softirq.c:284  invoke_softirq kernel/softirq.c:364 [inline]  irq_exit+0x1d1/0x200 kernel/softirq.c:404  exiting_irq arch/x86/include/asm/apic.h:527 [inline]  smp_apic_timer_interrupt+0x17e/0x710 arch/x86/kernel/apic/apic.c:1052  apic_timer_interrupt+0xf/0x20 arch/x86/entry/entry_64.S:863  </IRQ> ",9b0a8da8c4c6e91012ab03a801acc5d8011c7c2f,1
sit: proper dev_{hold|put} in ndo_[un]init methods,"After adopting CONFIG_PCPU_DEV_REFCNT=n option, syzbot was able to trigger a warning [1]  Issue here is that:  - all dev_put() should be paired with a corresponding prior dev_hold().  - A driver doing a dev_put() in its ndo_uninit() MUST also   do a dev_hold() in its ndo_init(), only when ndo_init()   is returning 0.  Otherwise, register_netdevice() would call ndo_uninit() in its error path and release a refcount too soon.  ",6289a98f0817a4a457750d6345e754838eae9439,0
media: dvb-usb: fix ununit-value in az6027_rc_query,Syzbot reported ununit-value bug in az6027_rc_query(). The problem was in missing state pointer initialization. Since this function does nothing we can simply initialize state to REMOTE_NO_KEY_PRESSED.  ,afae4ef7d5ad913cab1316137854a36bea6268a5,0
reiserfs: Initialize inode keys properly,reiserfs_read_locked_inode() didn't initialize key length properly. Use _make_cpu_key() macro for key initialization so that all key member are properly initialized.  CC: stable@vger.kernel.org ,4443390e08d34d5771ab444f601cf71b3c9634a4,0
can: j1939: j1939_sk_init(): set SOCK_RCU_FREE to call sk_destruct() after RCU is done,"Set SOCK_RCU_FREE to let RCU to call sk_destruct() on completion. Without this patch, we will run in to j1939_can_recv() after priv was freed by j1939_sk_release()->j1939_sk_sock_destruct()  ",22c696fed25c63c7f67508309820358b94a96b6d,0
net: qrtr: fix usage of idr in port assignment to socket,"Passing large uint32 sockaddr_qrtr.port numbers for port allocation triggers a warning within idr_alloc() since the port number is cast to int, and thus interpreted as a negative number. This leads to the rejection of such valid port numbers in qrtr_port_assign() as idr_alloc() fails.  To avoid the problem, switch to idr_alloc_u32() instead.  ",8dfddfb79653df7c38a9c8c4c034f242a36acee9,0
io_uring: don't touch ctx in setup after ring fd install,syzkaller reported an issue where it looks like a malicious app can trigger a use-after-free of reading the ctx ->sq_array and ->rings value right after having installed the ring fd in the process file table.  Defer ring fd installation until after we're done reading those values.  ,044c1ab399afbe9f2ebef49a3204ef1509826dc7,1
drm/vgem: fix use-after-free when drm_gem_handle_create() fails,"If drm_gem_handle_create() fails in vgem_gem_create(), then the drm_vgem_gem_object is freed twice: once when the reference is dropped by drm_gem_object_put_unlocked(), and again by __vgem_gem_destroy().  This was hit by syzkaller using fault injection.  Fix it by skipping the second free.  ",21d2b122732318b48c10b7262e15595ce54511d3,1
hsr: fix general protection fault in hsr_addr_is_self(),"The port->hsr is used in the hsr_handle_frame(), which is a callback of rx_handler. hsr master and slaves are initialized in hsr_add_port(). This function initializes several pointers, which includes port->hsr after registering rx_handler. So, in the rx_handler routine, un-initialized pointer would be used. In order to fix this, pointers should be initialized before registering rx_handler.  Test commands:     ip netns del left     ip netns del right     modprobe -rv veth     modprobe -rv hsr     killall ping     modprobe hsr     ip netns add left     ip netns add right     ip link add veth0 type veth peer name veth1     ip link add veth2 type veth peer name veth3     ip link add veth4 type veth peer name veth5     ip link set veth1 netns left     ip link set veth3 netns right     ip link set veth4 netns left     ip link set veth5 netns right     ip link set veth0 up     ip link set veth2 up     ip link set veth0 address fc:00:00:00:00:01     ip link set veth2 address fc:00:00:00:00:02     ip netns exec left ip link set veth1 up     ip netns exec left ip link set veth4 up     ip netns exec right ip link set veth3 up     ip netns exec right ip link set veth5 up     ip link add hsr0 type hsr slave1 veth0 slave2 veth2     ip a a 192.168.100.1/24 dev hsr0     ip link set hsr0 up     ip netns exec left ip link add hsr1 type hsr slave1 veth1 slave2 veth4     ip netns exec left ip a a 192.168.100.2/24 dev hsr1     ip netns exec left ip link set hsr1 up     ip netns exec left ip n a 192.168.100.1 dev hsr1 lladdr \ 	    fc:00:00:00:00:01 nud permanent     ip netns exec left ip n r 192.168.100.1 dev hsr1 lladdr \ 	    fc:00:00:00:00:01 nud permanent     for i in {1..100}     do         ip netns exec left ping 192.168.100.1 &     done     ip netns exec left hping3 192.168.100.1 -2 --flood &     ip netns exec right ip link add hsr2 type hsr slave1 veth3 slave2 veth5     ip netns exec right ip a a 192.168.100.3/24 dev hsr2     ip netns exec right ip link set hsr2 up     ip netns exec right ip n a 192.168.100.1 dev hsr2 lladdr \ 	    fc:00:00:00:00:02 nud permanent     ip netns exec right ip n r 192.168.100.1 dev hsr2 lladdr \ 	    fc:00:00:00:00:02 nud permanent     for i in {1..100}     do         ip netns exec right ping 192.168.100.1 &     done     ip netns exec right hping3 192.168.100.1 -2 --flood &     while :     do         ip link add hsr0 type hsr slave1 veth0 slave2 veth2 	ip a a 192.168.100.1/24 dev hsr0 	ip link set hsr0 up 	ip link del hsr0     done  Splat looks like: ",3a303cfdd28d5f930a307c82e8a9d996394d5ebd,0
sctp: cache netns in sctp_ep_common,"This patch is to fix a data-race reported by syzbot:    BUG: KCSAN: data-race in sctp_assoc_migrate / sctp_hash_obj    write to 0xffff8880b67c0020 of 8 bytes by task 18908 on cpu 1:     sctp_assoc_migrate+0x1a6/0x290 net/sctp/associola.c:1091     sctp_sock_migrate+0x8aa/0x9b0 net/sctp/socket.c:9465     sctp_accept+0x3c8/0x470 net/sctp/socket.c:4916     inet_accept+0x7f/0x360 net/ipv4/af_inet.c:734     __sys_accept4+0x224/0x430 net/socket.c:1754     __do_sys_accept net/socket.c:1795 [inline]     __se_sys_accept net/socket.c:1792 [inline]     __x64_sys_accept+0x4e/0x60 net/socket.c:1792     do_syscall_64+0xcc/0x370 arch/x86/entry/common.c:290     entry_SYSCALL_64_after_hwframe+0x44/0xa9    read to 0xffff8880b67c0020 of 8 bytes by task 12003 on cpu 0:     sctp_hash_obj+0x4f/0x2d0 net/sctp/input.c:894     rht_key_get_hash include/linux/rhashtable.h:133 [inline]     rht_key_hashfn include/linux/rhashtable.h:159 [inline]     rht_head_hashfn include/linux/rhashtable.h:174 [inline]     head_hashfn lib/rhashtable.c:41 [inline]     rhashtable_rehash_one lib/rhashtable.c:245 [inline]     rhashtable_rehash_chain lib/rhashtable.c:276 [inline]     rhashtable_rehash_table lib/rhashtable.c:316 [inline]     rht_deferred_worker+0x468/0xab0 lib/rhashtable.c:420     process_one_work+0x3d4/0x890 kernel/workqueue.c:2269     worker_thread+0xa0/0x800 kernel/workqueue.c:2415     kthread+0x1d4/0x200 drivers/block/aoe/aoecmd.c:1253     ret_from_fork+0x1f/0x30 arch/x86/entry/entry_64.S:352  It was caused by rhashtable access asoc->base.sk when sctp_assoc_migrate is changing its value. However, what rhashtable wants is netns from asoc base.sk, and for an asoc, its netns won't change once set. So we can simply fix it by caching netns since created.  ",312434617cb16be5166316cf9d08ba760b1042a1,1
mptcp: fix infinite loop on recvmsg()/worker() race.,"If recvmsg() and the workqueue race to dequeue the data pending on some subflow, the current mapping for such subflow covers several skbs and some of them have not reached yet the received, either the worker or recvmsg() can find a subflow with the data_avail flag set - since the current mapping is valid and in sequence - but no skbs in the receive queue - since the other entity just processed them.  The above will lead to an unbounded loop in __mptcp_move_skbs() and a subsequent hang of any task trying to acquiring the msk socket lock.  This change addresses the issue stopping the __mptcp_move_skbs() loop as soon as we detect the above race (empty receive queue with data_avail set).  ",d9fb8c507d42256034b457ec59347855bec9e569,1
l2tp: check sockaddr length in pppol2tp_connect(),"Check sockaddr_len before dereferencing sp->sa_protocol, to ensure that it actually points to valid data.  ",eb1c28c05894a4b1f6b56c5bf072205e64cfa280,0
kernel/signal.c: remove the no longer needed SIGNAL_UNKILLABLE check in complete_signal(),"complete_signal() checks SIGNAL_UNKILLABLE before it starts to destroy the thread group, today this is wrong in many ways.  If nothing else, fatal_signal_pending() should always imply that the whole thread group (except ->group_exit_task if it is not NULL) is killed, this check breaks the rule.  After the previous changes we can rely on sig_task_ignored(); sig_fatal(sig) && SIGNAL_UNKILLABLE can only be true if we actually want to kill this task and sig == SIGKILL OR it is traced and debugger can intercept the signal.  This should hopefully fix the problem reported by Dmitry.  This test-case  	static int init(void *arg) 	{ 		for (;;) 			pause(); 	}  	int main(void) 	{ 		char stack[16 * 1024];  		for (;;) { 			int pid = clone(init, stack + sizeof(stack)/2, 					CLONE_NEWPID | SIGCHLD, NULL); 			assert(pid > 0);  			assert(ptrace(PTRACE_ATTACH, pid, 0, 0) == 0); 			assert(waitpid(-1, NULL, WSTOPPED) == pid);  			assert(ptrace(PTRACE_DETACH, pid, 0, SIGSTOP) == 0); 			assert(syscall(__NR_tkill, pid, SIGKILL) == 0); 			assert(pid == wait(NULL)); 		} 	}  triggers the WARN_ON_ONCE(!(task->jobctl & JOBCTL_STOP_PENDING)) in task_participate_group_stop().  do_signal_stop()->signal_group_exit() checks SIGNAL_GROUP_EXIT and return false, but task_set_jobctl_pending() checks fatal_signal_pending() and does not set JOBCTL_STOP_PENDING.  And his should fix the minor security problem reported by Kyle, SECCOMP_RET_TRACE can miss fatal_signal_pending() the same way if the task is the root of a pid namespace.  ",426915796ccaf9c2bd9bb06dc5702225957bc2e5,0
af_unix: fix potential NULL deref in unix_dgram_connect(),"syzbot was able to trigger NULL deref in unix_dgram_connect() [1]  This happens in  	if (unix_peer(sk)) 		sk->sk_state = other->sk_state = TCP_ESTABLISHED; // crash because @other is NULL  Because locks have been dropped, unix_peer() might be non NULL, while @other is NULL (AF_UNSPEC case)  We need to move code around, so that we no longer access unix_peer() and sk_state while locks have been released.  [1] general protection fault, probably for non-canonical address 0xdffffc0000000002: 0000 [#1] PREEMPT SMP KASAN KASAN: null-ptr-deref in range [0x0000000000000010-0x0000000000000017] CPU: 0 PID: 10341 Comm: syz-executor239 Not tainted 5.14.0-rc7-syzkaller #0 Hardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 01/01/2011 ",dc56ad7028c5f559b3ce90d5cca2e6b7b839f1d5,1
net: qrtr: check skb_put_padto() return value,"If skb_put_padto() returns an error, skb has been freed. Better not touch it anymore, as reported by syzbot [1]  Note to qrtr maintainers : this suggests qrtr_sendmsg() should adjust sock_alloc_send_skb() second parameter to account for the potential added alignment to avoid reallocation.  [1]  BUG: KASAN: use-after-free in __skb_insert include/linux/skbuff.h:1907 [inline] BUG: KASAN: use-after-free in __skb_queue_before include/linux/skbuff.h:2016 [inline] BUG: KASAN: use-after-free in __skb_queue_tail include/linux/skbuff.h:2049 [inline] BUG: KASAN: use-after-free in skb_queue_tail+0x6b/0x120 net/core/skbuff.c:3146 Write of size 8 at addr ffff88804d8ab3c0 by task syz-executor.4/4316  CPU: 1 PID: 4316 Comm: syz-executor.4 Not tainted 5.9.0-rc4-syzkaller #0 Hardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 01/01/2011 Call Trace:  __dump_stack lib/dump_stack.c:77 [inline]  dump_stack+0x1d6/0x29e lib/dump_stack.c:118  print_address_description+0x66/0x620 mm/kasan/report.c:383  __kasan_report mm/kasan/report.c:513 [inline]  kasan_report+0x132/0x1d0 mm/kasan/report.c:530  __skb_insert include/linux/skbuff.h:1907 [inline]  __skb_queue_before include/linux/skbuff.h:2016 [inline]  __skb_queue_tail include/linux/skbuff.h:2049 [inline]  skb_queue_tail+0x6b/0x120 net/core/skbuff.c:3146  qrtr_tun_send+0x1a/0x40 net/qrtr/tun.c:23  qrtr_node_enqueue+0x44f/0xc00 net/qrtr/qrtr.c:364  qrtr_bcast_enqueue+0xbe/0x140 net/qrtr/qrtr.c:861  qrtr_sendmsg+0x680/0x9c0 net/qrtr/qrtr.c:960  sock_sendmsg_nosec net/socket.c:651 [inline]  sock_sendmsg net/socket.c:671 [inline]  sock_write_iter+0x317/0x470 net/socket.c:998  call_write_iter include/linux/fs.h:1882 [inline]  new_sync_write fs/read_write.c:503 [inline]  vfs_write+0xa96/0xd10 fs/read_write.c:578  ksys_write+0x11b/0x220 fs/read_write.c:631  do_syscall_64+0x31/0x70 arch/x86/entry/common.c:46  entry_SYSCALL_64_after_hwframe+0x44/0xa9 ",3ca1a42a52ca4b4f02061683851692ad65fefac8,1
HID: Fix assumption that devices have inputs,"The syzbot fuzzer found a slab-out-of-bounds write bug in the hid-gaff driver.  The problem is caused by the driver's assumption that the device must have an input report.  While this will be true for all normal HID input devices, a suitably malicious device can violate the assumption.  The same assumption is present in over a dozen other HID drivers. This patch fixes them by checking that the list of hid_inputs for the hid_device is nonempty before allowing it to be used.  ",d9d4b1e46d9543a82c23f6df03f4ad697dab361b,1
net: bridge: deny dev_set_mac_address() when unregistering,"We have an interesting memory leak in the bridge when it is being unregistered and is a slave to a master device which would change the mac of its slaves on unregister (e.g. bond, team). This is a very unusual setup but we do end up leaking 1 fdb entry because dev_set_mac_address() would cause the bridge to insert the new mac address into its table after all fdbs are flushed, i.e. after dellink() on the bridge has finished and we call NETDEV_UNREGISTER the bond/team would release it and will call dev_set_mac_address() to restore its original address and that in turn will add an fdb in the bridge. One fix is to check for the bridge dev's reg_state in its ndo_set_mac_address callback and return an error if the bridge is not in NETREG_REGISTERED.  Easy steps to reproduce:  1. add bond in mode != A/B  2. add any slave to the bond  3. add bridge dev as a slave to the bond  4. destroy the bridge device  Trace:  unreferenced object 0xffff888035c4d080 (size 128):    comm ""ip"", pid 4068, jiffies 4296209429 (age 1413.753s)    ",c4b4c421857dc7b1cf0dccbd738472360ff2cd70,1
net: annotate accesses to sk->sk_incoming_cpu,"This socket field can be read and written by concurrent cpus.  Use READ_ONCE() and WRITE_ONCE() annotations to document this, and avoid some compiler 'optimizations'.  KCSAN reported :  BUG: KCSAN: data-race in tcp_v4_rcv / tcp_v4_rcv  write to 0xffff88812220763c of 4 bytes by interrupt on cpu 0:  sk_incoming_cpu_update include/net/sock.h:953 [inline]  tcp_v4_rcv+0x1b3c/0x1bb0 net/ipv4/tcp_ipv4.c:1934  ip_protocol_deliver_rcu+0x4d/0x420 net/ipv4/ip_input.c:204  ip_local_deliver_finish+0x110/0x140 net/ipv4/ip_input.c:231  NF_HOOK include/linux/netfilter.h:305 [inline]  NF_HOOK include/linux/netfilter.h:299 [inline]  ip_local_deliver+0x133/0x210 net/ipv4/ip_input.c:252  dst_input include/net/dst.h:442 [inline]  ip_rcv_finish+0x121/0x160 net/ipv4/ip_input.c:413  NF_HOOK include/linux/netfilter.h:305 [inline]  NF_HOOK include/linux/netfilter.h:299 [inline]  ip_rcv+0x18f/0x1a0 net/ipv4/ip_input.c:523  __netif_receive_skb_one_core+0xa7/0xe0 net/core/dev.c:5010  __netif_receive_skb+0x37/0xf0 net/core/dev.c:5124  process_backlog+0x1d3/0x420 net/core/dev.c:5955  napi_poll net/core/dev.c:6392 [inline]  net_rx_action+0x3ae/0xa90 net/core/dev.c:6460  __do_softirq+0x115/0x33f kernel/softirq.c:292  do_softirq_own_stack+0x2a/0x40 arch/x86/entry/entry_64.S:1082  do_softirq.part.0+0x6b/0x80 kernel/softirq.c:337  do_softirq kernel/softirq.c:329 [inline]  __local_bh_enable_ip+0x76/0x80 kernel/softirq.c:189  read to 0xffff88812220763c of 4 bytes by interrupt on cpu 1:  sk_incoming_cpu_update include/net/sock.h:952 [inline]  tcp_v4_rcv+0x181a/0x1bb0 net/ipv4/tcp_ipv4.c:1934  ip_protocol_deliver_rcu+0x4d/0x420 net/ipv4/ip_input.c:204  ip_local_deliver_finish+0x110/0x140 net/ipv4/ip_input.c:231  NF_HOOK include/linux/netfilter.h:305 [inline]  NF_HOOK include/linux/netfilter.h:299 [inline]  ip_local_deliver+0x133/0x210 net/ipv4/ip_input.c:252  dst_input include/net/dst.h:442 [inline]  ip_rcv_finish+0x121/0x160 net/ipv4/ip_input.c:413  NF_HOOK include/linux/netfilter.h:305 [inline]  NF_HOOK include/linux/netfilter.h:299 [inline]  ip_rcv+0x18f/0x1a0 net/ipv4/ip_input.c:523  __netif_receive_skb_one_core+0xa7/0xe0 net/core/dev.c:5010  __netif_receive_skb+0x37/0xf0 net/core/dev.c:5124  process_backlog+0x1d3/0x420 net/core/dev.c:5955  napi_poll net/core/dev.c:6392 [inline]  net_rx_action+0x3ae/0xa90 net/core/dev.c:6460  __do_softirq+0x115/0x33f kernel/softirq.c:292  run_ksoftirqd+0x46/0x60 kernel/softirq.c:603  smpboot_thread_fn+0x37d/0x4a0 kernel/smpboot.c:165  Reported by Kernel Concurrency Sanitizer on: CPU: 1 PID: 16 Comm: ksoftirqd/1 Not tainted 5.4.0-rc3+ #0 Hardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 01/01/2011  ",7170a977743b72cf3eb46ef6ef89885dc7ad3621,1
xfrm_user: uncoditionally validate esn replay attribute struct,"The sanity test added in ecd7918745234 can be bypassed, validation only occurs if XFRM_STATE_ESN flag is set, but rest of code doesn't care and just checks if the attribute itself is present.  So always validate.  Alternative is to reject if we have the attribute without the flag but that would change abi.  ",d97ca5d714a5334aecadadf696875da40f1fbf3e,0
net: qrtr: fix a kernel-infoleak in qrtr_recvmsg(),"struct sockaddr_qrtr has a 2-byte hole, and qrtr_recvmsg() currently does not clear it before copying kernel data to user space.  It might be too late to name the hole since sockaddr_qrtr structure is uapi.  BUG: KMSAN: kernel-infoleak in kmsan_copy_to_user+0x9c/0xb0 mm/kmsan/kmsan_hooks.c:249 CPU: 0 PID: 29705 Comm: syz-executor.3 Not tainted 5.11.0-rc7-syzkaller #0 Hardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 01/01/2011 Call Trace:  __dump_stack lib/dump_stack.c:79 [inline]  dump_stack+0x21c/0x280 lib/dump_stack.c:120  kmsan_report+0xfb/0x1e0 mm/kmsan/kmsan_report.c:118  kmsan_internal_check_memory+0x202/0x520 mm/kmsan/kmsan.c:402  kmsan_copy_to_user+0x9c/0xb0 mm/kmsan/kmsan_hooks.c:249  instrument_copy_to_user include/linux/instrumented.h:121 [inline]  _copy_to_user+0x1ac/0x270 lib/usercopy.c:33  copy_to_user include/linux/uaccess.h:209 [inline]  move_addr_to_user+0x3a2/0x640 net/socket.c:237  ____sys_recvmsg+0x696/0xd50 net/socket.c:2575  ___sys_recvmsg net/socket.c:2610 [inline]  do_recvmmsg+0xa97/0x22d0 net/socket.c:2710  __sys_recvmmsg net/socket.c:2789 [inline]  __do_sys_recvmmsg net/socket.c:2812 [inline]  __se_sys_recvmmsg+0x24a/0x410 net/socket.c:2805  __x64_sys_recvmmsg+0x62/0x80 net/socket.c:2805  do_syscall_64+0x9f/0x140 arch/x86/entry/common.c:48  entry_SYSCALL_64_after_hwframe+0x44/0xa9 ",50535249f624d0072cd885bcdce4e4b6fb770160,1
netfilter: x_tables: add and use xt_check_proc_name,"recent and hashlimit both create /proc files, but only check that name is 0 terminated.  This can trigger WARN() from procfs when name is """" or ""/"". Add helper for this and then use it for both.  ",b1d0a5d0cba4597c0394997b2d5fced3e3841b4e,0
lockdep: Optimize the memory usage of circular queue,"Qian Cai reported a BFS_EQUEUEFULL warning [1] after read recursive deadlock detection merged into tip tree recently. Unlike the previous lockep graph searching, which iterate every lock class (every node in the graph) exactly once, the graph searching for read recurisve deadlock detection needs to iterate every lock dependency (every edge in the graph) once, as a result, the maximum memory cost of the circular queue changes from O(V), where V is the number of lock classes (nodes or vertices) in the graph, to O(E), where E is the number of lock dependencies (edges), because every lock class or dependency gets enqueued once in the BFS. Therefore we hit the BFS_EQUEUEFULL case.  However, actually we don't need to enqueue all dependencies for the BFS, because every time we enqueue a dependency, we almostly enqueue all other dependencies in the same dependency list (""almostly"" is because we currently check before enqueue, so if a dependency doesn't pass the check stage we won't enqueue it, however, we can always do in reverse ordering), based on this, we can only enqueue the first dependency from a dependency list and every time we want to fetch a new dependency to work, we can either:    1)	fetch the dependency next to the current dependency in the 	dependency list or    2)	if the dependency in 1) doesn't exist, fetch the dependency from 	the queue.  With this approach, the ""max bfs queue depth"" for a x86_64_defconfig + lockdep and selftest config kernel can get descreased from:          max bfs queue depth:                   201  to (after apply this patch)          max bfs queue depth:                   61  While I'm at it, clean up the code logic a little (e.g. directly return other than set a ""ret"" value and goto the ""exit"" label).  [1]: https://lore.kernel.org/lkml/17343f6f7f2438fc376125384133c5ba70c2a681.camel@redhat.com/  ",6d1823ccc480866e571ab1206665d693aeb600cf,0
cgroup: Prevent double killing of css when enabling threaded cgroup,The test_cgcore_no_internal_process_constraint_on_threads selftest when running with subsystem controlling noise triggers two warnings:  > ,3bc0bb36fa30e95ca829e9cf480e1ef7f7638333,0
ALSA: timer: Remove kernel warning at compat ioctl error paths,"Some timer compat ioctls have NULL checks of timer instance with snd_BUG_ON() that bring up WARN_ON() when the debug option is set. Actually the condition can be met in the normal situation and it's confusing and bad to spew kernel warnings with stack trace there. Let's remove snd_BUG_ON() invocation and replace with the simple checks.  Also, correct the error code to EBADFD to follow the native ioctl error handling.  ",3d4e8303f2c747c8540a0a0126d0151514f6468b,1
gfs2_meta: ->mount() can get NULL dev_name,get in sync with mount_bdev() handling of the same  ,3df629d873f8683af6f0d34dfc743f637966d483,1
batman-adv: fix uninit-value in batadv_netlink_get_ifindex(),"batadv_netlink_get_ifindex() needs to make sure user passed a correct u32 attribute.  syzbot reported : BUG: KMSAN: uninit-value in batadv_netlink_dump_hardif+0x70d/0x880 net/batman-adv/netlink.c:968 CPU: 1 PID: 11705 Comm: syz-executor888 Not tainted 5.1.0+ #1 Hardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 01/01/2011 Call Trace:  __dump_stack lib/dump_stack.c:77 [inline]  dump_stack+0x191/0x1f0 lib/dump_stack.c:113  kmsan_report+0x130/0x2a0 mm/kmsan/kmsan.c:622  __msan_warning+0x75/0xe0 mm/kmsan/kmsan_instr.c:310  batadv_netlink_dump_hardif+0x70d/0x880 net/batman-adv/netlink.c:968  genl_lock_dumpit+0xc6/0x130 net/netlink/genetlink.c:482  netlink_dump+0xa84/0x1ab0 net/netlink/af_netlink.c:2253  __netlink_dump_start+0xa3a/0xb30 net/netlink/af_netlink.c:2361  genl_family_rcv_msg net/netlink/genetlink.c:550 [inline]  genl_rcv_msg+0xfc1/0x1a40 net/netlink/genetlink.c:627  netlink_rcv_skb+0x431/0x620 net/netlink/af_netlink.c:2486  genl_rcv+0x63/0x80 net/netlink/genetlink.c:638  netlink_unicast_kernel net/netlink/af_netlink.c:1311 [inline]  netlink_unicast+0xf3e/0x1020 net/netlink/af_netlink.c:1337  netlink_sendmsg+0x127e/0x12f0 net/netlink/af_netlink.c:1926  sock_sendmsg_nosec net/socket.c:651 [inline]  sock_sendmsg net/socket.c:661 [inline]  ___sys_sendmsg+0xcc6/0x1200 net/socket.c:2260  __sys_sendmsg net/socket.c:2298 [inline]  __do_sys_sendmsg net/socket.c:2307 [inline]  __se_sys_sendmsg+0x305/0x460 net/socket.c:2305  __x64_sys_sendmsg+0x4a/0x70 net/socket.c:2305  do_syscall_64+0xbc/0xf0 arch/x86/entry/common.c:291  entry_SYSCALL_64_after_hwframe+0x63/0xe7 ",3ee1bb7aae97324ec9078da1f00cb2176919563f,1
udmabuf: fix general protection fault in udmabuf_create,"Syzbot reported general protection fault in udmabuf_create. The problem was in wrong error handling.  In commit 16c243e99d33 (""udmabuf: Add support for mapping hugepages (v4)"") shmem_read_mapping_page() call was replaced with find_get_page_flags(), but find_get_page_flags() returns NULL on failure instead PTR_ERR().  Wrong error checking was causing GPF in get_page(), since passed page was equal to NULL. Fix it by changing if (IS_ER(!hpage)) to if (!hpage)  ",b9770b0b6eac2be3772b6f4748e6b899a9ab2870,1
usb: usbip: Fix BUG: KASAN: slab-out-of-bounds in vhci_hub_control(),vhci_hub_control() accesses port_status array with out of bounds port value. Fix it to reference port_status[] only with a valid rhport value when invalid_rhport flag is true.  The invalid_rhport flag is set early on after detecting in port value is within the bounds or not.  The following is used reproduce the problem and verify the fix: C reproducer:   https://syzkaller.appspot.com/x/repro.c?x=14ed8ab6400000  ,81f7567c51ad97668d1c3a48e8ecc482e64d4161,1
ALSA: aloop: Fix racy hw constraints adjustment,"The aloop driver tries to update the hw constraints of the connected target on the cable of the opened PCM substream.  This is done by adding the extra hw constraints rules referring to the substream runtime->hw fields, while the other substream may update the runtime hw of another side on the fly.  This is, however, racy and may result in the inconsistent values when both PCM streams perform the prepare concurrently.  One of the reason is that it overwrites the other's runtime->hw field; which is not only racy but also broken when it's called before the open of another side finishes.  And, since the reference to runtime->hw isn't protected, the concurrent write may give the partial value update and become inconsistent.  This patch is an attempt to fix and clean up: - The prepare doesn't change the runtime->hw of other side any longer,   but only update the cable->hw that is referred commonly. - The extra rules refer to the loopback_pcm object instead of the   runtime->hw.  The actual hw is deduced from cable->hw. - The extra rules take the cable_lock to protect against the race.  ",898dfe4687f460ba337a01c11549f87269a13fa2,1
net_sched: validate TCA_KIND attribute in tc_chain_tmplt_add(),"Use the new tcf_proto_check_kind() helper to make sure user provided value is well formed.  BUG: KMSAN: uninit-value in string_nocheck lib/vsprintf.c:606 [inline] BUG: KMSAN: uninit-value in string+0x4be/0x600 lib/vsprintf.c:668 CPU: 0 PID: 12358 Comm: syz-executor.1 Not tainted 5.4.0-rc8-syzkaller #0 Hardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 01/01/2011 Call Trace:  __dump_stack lib/dump_stack.c:77 [inline]  dump_stack+0x1c9/0x220 lib/dump_stack.c:118  kmsan_report+0x128/0x220 mm/kmsan/kmsan_report.c:108  __msan_warning+0x64/0xc0 mm/kmsan/kmsan_instr.c:245  string_nocheck lib/vsprintf.c:606 [inline]  string+0x4be/0x600 lib/vsprintf.c:668  vsnprintf+0x218f/0x3210 lib/vsprintf.c:2510  __request_module+0x2b1/0x11c0 kernel/kmod.c:143  tcf_proto_lookup_ops+0x171/0x700 net/sched/cls_api.c:139  tc_chain_tmplt_add net/sched/cls_api.c:2730 [inline]  tc_ctl_chain+0x1904/0x38a0 net/sched/cls_api.c:2850  rtnetlink_rcv_msg+0x115a/0x1580 net/core/rtnetlink.c:5224  netlink_rcv_skb+0x431/0x620 net/netlink/af_netlink.c:2477  rtnetlink_rcv+0x50/0x60 net/core/rtnetlink.c:5242  netlink_unicast_kernel net/netlink/af_netlink.c:1302 [inline]  netlink_unicast+0xf3e/0x1020 net/netlink/af_netlink.c:1328  netlink_sendmsg+0x110f/0x1330 net/netlink/af_netlink.c:1917  sock_sendmsg_nosec net/socket.c:637 [inline]  sock_sendmsg net/socket.c:657 [inline]  ___sys_sendmsg+0x14ff/0x1590 net/socket.c:2311  __sys_sendmsg net/socket.c:2356 [inline]  __do_sys_sendmsg net/socket.c:2365 [inline]  __se_sys_sendmsg+0x305/0x460 net/socket.c:2363  __x64_sys_sendmsg+0x4a/0x70 net/socket.c:2363  do_syscall_64+0xb6/0x160 arch/x86/entry/common.c:291  entry_SYSCALL_64_after_hwframe+0x44/0xa9 ",2dd5616ecdcebdf5a8d007af64e040d4e9214efe,1
kcm: Check if sk_user_data already set in kcm_attach,This is needed to prevent sk_user_data being overwritten. The check is done under the callback lock. This should prevent a socket from being attached twice to a KCM mux. It also prevents a socket from being attached for other use cases of sk_user_data as long as the other cases set sk_user_data under the lock. Followup work is needed to unify all the use cases of sk_user_data to use the same locking.  ,e5571240236c5652f3e079b1d5866716a7ad819c,0
Bluetooth: Prevent out-of-bounds read in hci_inquiry_result_with_rssi_evt(),Check `num_rsp` before using it as for-loop counter. Add `unlock` label.  ,629b49c848ee71244203934347bd7730b0ddee8d,1
KVM: x86: fix em_fxstor() sleeping while in atomic,"Commit 9d643f63128b (""KVM: x86: avoid large stack allocations in em_fxrstor"") optimize the stack size, but introduced a guest memory access which might sleep while in atomic.  Fix it by introducing, again, a second fxregs_state. Try to avoid large stacks by using noinline. Add some helpful comments.  Reported by syzbot:  in_atomic(): 1, irqs_disabled(): 0, pid: 2909, name: syzkaller879109 2 locks held by syzkaller879109/2909:   #0:  (&vcpu->mutex){+.+.}, at: [<ffffffff8106222c>] vcpu_load+0x1c/0x70 arch/x86/kvm/../../../virt/kvm/kvm_main.c:154   #1:  (&kvm->srcu){....}, at: [<ffffffff810dd162>] vcpu_enter_guest arch/x86/kvm/x86.c:6983 [inline]   #1:  (&kvm->srcu){....}, at: [<ffffffff810dd162>] vcpu_run arch/x86/kvm/x86.c:7061 [inline]   #1:  (&kvm->srcu){....}, at: [<ffffffff810dd162>] kvm_arch_vcpu_ioctl_run+0x1bc2/0x58b0 arch/x86/kvm/x86.c:7222 CPU: 1 PID: 2909 Comm: syzkaller879109 Not tainted 4.13.0-rc4-next-20170811 Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS Bochs 01/01/2011 Call Trace:   __dump_stack lib/dump_stack.c:16 [inline]   dump_stack+0x194/0x257 lib/dump_stack.c:52   ___might_sleep+0x2b2/0x470 kernel/sched/core.c:6014   __might_sleep+0x95/0x190 kernel/sched/core.c:5967   __might_fault+0xab/0x1d0 mm/memory.c:4383   __copy_from_user include/linux/uaccess.h:71 [inline]   __kvm_read_guest_page+0x58/0xa0 arch/x86/kvm/../../../virt/kvm/kvm_main.c:1771   kvm_vcpu_read_guest_page+0x44/0x60 arch/x86/kvm/../../../virt/kvm/kvm_main.c:1791   kvm_read_guest_virt_helper+0x76/0x140 arch/x86/kvm/x86.c:4407   kvm_read_guest_virt_system+0x3c/0x50 arch/x86/kvm/x86.c:4466   segmented_read_std+0x10c/0x180 arch/x86/kvm/emulate.c:819   em_fxrstor+0x27b/0x410 arch/x86/kvm/emulate.c:4022   x86_emulate_insn+0x55d/0x3c50 arch/x86/kvm/emulate.c:5471   x86_emulate_instruction+0x411/0x1ca0 arch/x86/kvm/x86.c:5698   kvm_mmu_page_fault+0x18b/0x2c0 arch/x86/kvm/mmu.c:4854   handle_ept_violation+0x1fc/0x5e0 arch/x86/kvm/vmx.c:6400   vmx_handle_exit+0x281/0x1ab0 arch/x86/kvm/vmx.c:8718   vcpu_enter_guest arch/x86/kvm/x86.c:6999 [inline]   vcpu_run arch/x86/kvm/x86.c:7061 [inline]   kvm_arch_vcpu_ioctl_run+0x1cee/0x58b0 arch/x86/kvm/x86.c:7222   kvm_vcpu_ioctl+0x64c/0x1010 arch/x86/kvm/../../../virt/kvm/kvm_main.c:2591   vfs_ioctl fs/ioctl.c:45 [inline]   do_vfs_ioctl+0x1b1/0x1520 fs/ioctl.c:685   SYSC_ioctl fs/ioctl.c:700 [inline]   SyS_ioctl+0x8f/0xc0 fs/ioctl.c:691   entry_SYSCALL_64_fastpath+0x1f/0xbe ",4d772cb85f64c16eca00177089ecb3cd5d292120,1
rxrpc: Fix deadlock around release of dst cached on udp tunnel,"AF_RXRPC sockets use UDP ports in encap mode.  This causes socket and dst from an incoming packet to get stolen and attached to the UDP socket from whence it is leaked when that socket is closed.  When a network namespace is removed, the wait for dst records to be cleaned up happens before the cleanup of the rxrpc and UDP socket, meaning that the wait never finishes.  Fix this by moving the rxrpc (and, by dependence, the afs) private per-network namespace registrations to the device group rather than subsys group.  This allows cached rxrpc local endpoints to be cleared and their UDP sockets closed before we try waiting for the dst records.  The symptom is that lines looking like the following:  	unregister_netdevice: waiting for lo to become free  get emitted at regular intervals after running something like the referenced syzbot test.  ",5399d52233c47905bbf97dcbaa2d7a9cc31670ba,0
Bluetooth: Fix auto-creation of hci_conn at Conn Complete event,"Currently the code auto-creates hci_conn only if the remote address has been discovered before. This may not be the case. For example, the remote device may trigger connection after reboot at already-paired state so there is no inquiry result found, but it is still correct to create the hci_conn when Connection Complete event is received.  A better guard is to check against bredr allowlist. Devices in the allowlist have been given permission to auto-connect.  ",a46b7ed4d52d09bd6c7ab53b2217d04fc2f02c65,0
media: vivid: Fix global-out-of-bounds read in precalculate_color(),"vivid_meta_out_process() is setting `brightness`, `contrast`, `saturation` and `hue` using tpg_s_*(). This is wrong, since tpg_s_*() do not provide range checks. Using tpg_s_*() here also makes the control framework out-of-sync with the actual values. Use v4l2_ctrl_s_ctrl() instead.  This issue has been reported by syzbot as an out-of-bounds read bug in precalculate_color().  ",e3158a5e7e661786b3ab650c7e4d21024e8eff0f,1
tcp: repair: fix TCP_QUEUE_SEQ implementation,"When application uses TCP_QUEUE_SEQ socket option to change tp->rcv_next, we must also update tp->copied_seq.  Otherwise, stuff relying on tcp_inq() being precise can eventually be confused.  For example, tcp_zerocopy_receive() might crash because it does not expect tcp_recv_skb() to return NULL.  We could add tests in various places to fix the issue, or simply make sure tcp_inq() wont return a random value, and leave fast path as it is.  Note that this fixes ioctl(fd, SIOCINQ, &val) at the same time.  ",6cd6cbf593bfa3ae6fc3ed34ac21da4d35045425,1
soreuseport: initialise timewait reuseport field,"syzbot reported an uninit-value in inet_csk_bind_conflict() [1]  It turns out we never propagated sk->sk_reuseport into timewait socket.  [1] BUG: KMSAN: uninit-value in inet_csk_bind_conflict+0x5f9/0x990 net/ipv4/inet_connection_sock.c:151 CPU: 1 PID: 3589 Comm: syzkaller008242 Not tainted 4.16.0+ #82 Hardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 01/01/2011 Call Trace:  __dump_stack lib/dump_stack.c:17 [inline]  dump_stack+0x185/0x1d0 lib/dump_stack.c:53  kmsan_report+0x142/0x240 mm/kmsan/kmsan.c:1067  __msan_warning_32+0x6c/0xb0 mm/kmsan/kmsan_instr.c:676  inet_csk_bind_conflict+0x5f9/0x990 net/ipv4/inet_connection_sock.c:151  inet_csk_get_port+0x1d28/0x1e40 net/ipv4/inet_connection_sock.c:320  inet6_bind+0x121c/0x1820 net/ipv6/af_inet6.c:399  SYSC_bind+0x3f2/0x4b0 net/socket.c:1474  SyS_bind+0x54/0x80 net/socket.c:1460  do_syscall_64+0x309/0x430 arch/x86/entry/common.c:287  entry_SYSCALL_64_after_hwframe+0x3d/0xa2 ",3099a52918937ab86ec47038ad80d377ba16c531,1
ALSA: mixer: fix deadlock in snd_mixer_oss_set_volume,"In commit 411cef6adfb3 (""ALSA: mixer: oss: Fix racy access to slots"") added mutex protection in snd_mixer_oss_set_volume(). Second mutex_lock() in same function looks like typo, fix it.  ",3ab7992018455ac63c33e9b3eaa7264e293e40f4,0
sctp: not allow transport timeout value less than HZ/5 for hb_timer,"syzbot reported a rcu_sched self-detected stall on CPU which is caused by too small value set on rto_min with SCTP_RTOINFO sockopt. With this value, hb_timer will get stuck there, as in its timer handler it starts this timer again with this value, then goes to the timer handler again.  This problem is there since very beginning, and thanks to Eric for the reproducer shared from a syzbot mail.  This patch fixes it by not allowing sctp_transport_timeout to return a smaller value than HZ/5 for hb_timer, which is based on TCP's min rto.  Note that it doesn't fix this issue by limiting rto_min, as some users are still using small rto and no proper value was found for it yet.  ",1d88ba1ebb2763aa86172cd7ca05dedbeccc0d35,0
mm/memory.c: recheck page table entry with page table lock held,"We clear the pte temporarily during read/modify/write update of the pte. If we take a page fault while the pte is cleared, the application can get SIGBUS.  One such case is with remap_pfn_range without a backing vm_ops->fault callback.  do_fault will return SIGBUS in that case.  cpu 0		 				cpu1 mprotect() ptep_modify_prot_start()/pte cleared. . .						page fault. . . prep_modify_prot_commit()  Fix this by taking page table lock and rechecking for pte_none.  [aneesh.kumar@linux.ibm.com: fix crash observed with syzkaller run]   ",ff09d7ec9786be4ad7589aa987d7dc66e2dd9160,1
ALSA: pcm: Check PCM state at xfern compat ioctl,"Since snd_pcm_ioctl_xfern_compat() has no PCM state check, it may go further and hit the sanity check pcm_sanity_check() when the ioctl is called right after open.  It may eventually spew a kernel warning, as triggered by syzbot, depending on kconfig.  The lack of PCM state check there was just an oversight.  Although it's no real crash, the spurious kernel warning is annoying, so let's add the proper check.  ",f13876e2c33a657a71bcbb10f767c0951b165020,1
net_sched: gen_estimator: support large ewma log,"syzbot report reminded us that very big ewma_log were supported in the past, even if they made litle sense.  tc qdisc replace dev xxx root est 1sec 131072sec ...  While fixing the bug, also add boundary checks for ewma_log, in line with range supported by iproute2.  UBSAN: shift-out-of-bounds in net/core/gen_estimator.c:83:38 shift exponent -1 is negative CPU: 0 PID: 0 Comm: swapper/0 Not tainted 5.10.0-syzkaller #0 Hardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 01/01/2011 Call Trace:  <IRQ>  __dump_stack lib/dump_stack.c:79 [inline]  dump_stack+0x107/0x163 lib/dump_stack.c:120  ubsan_epilogue+0xb/0x5a lib/ubsan.c:148  __ubsan_handle_shift_out_of_bounds.cold+0xb1/0x181 lib/ubsan.c:395  est_timer.cold+0xbb/0x12d net/core/gen_estimator.c:83  call_timer_fn+0x1a5/0x710 kernel/time/timer.c:1417  expire_timers kernel/time/timer.c:1462 [inline]  __run_timers.part.0+0x692/0xa80 kernel/time/timer.c:1731  __run_timers kernel/time/timer.c:1712 [inline]  run_timer_softirq+0xb3/0x1d0 kernel/time/timer.c:1744  __do_softirq+0x2bc/0xa77 kernel/softirq.c:343  asm_call_irq_on_stack+0xf/0x20  </IRQ>  __run_on_irqstack arch/x86/include/asm/irq_stack.h:26 [inline]  run_on_irqstack_cond arch/x86/include/asm/irq_stack.h:77 [inline]  do_softirq_own_stack+0xaa/0xd0 arch/x86/kernel/irq_64.c:77  invoke_softirq kernel/softirq.c:226 [inline]  __irq_exit_rcu+0x17f/0x200 kernel/softirq.c:420  irq_exit_rcu+0x5/0x20 kernel/softirq.c:432  sysvec_apic_timer_interrupt+0x4d/0x100 arch/x86/kernel/apic/apic.c:1096  asm_sysvec_apic_timer_interrupt+0x12/0x20 arch/x86/include/asm/idtentry.h:628 ",dd5e073381f2ada3630f36be42833c6e9c78b75e,1
netlink: policy: correct validation type check,"In the policy export for binary attributes I erroneously used a != NLA_VALIDATE_NONE comparison instead of checking for the two possible values, which meant that if a validation function pointer ended up aliasing the min/max as negatives, we'd hit a warning in nla_get_range_unsigned().  Fix this to correctly check for only the two types that should be handled here, i.e. range with or without warn-too-long.  ",c30a3c957c885e618ddffc065f888be4f8d5a9bd,0
btrfs: fix rw device counting in __btrfs_free_extra_devids,"When removing a writeable device in __btrfs_free_extra_devids, the rw device count should be decremented.  This error was caught by Syzbot which reported a warning in close_fs_devices:    ",b2a616676839e2a6b02c8e40be7f886f882ed194,0
io_uring: only test SQPOLL cpu after we've verified it,"We currently call cpu_possible() even if we don't use the CPU. Move the test under the SQ_AFF branch, which is the only place where we'll use the value. Do the cpu_possible() test AFTER we've limited it to a max of NR_CPUS. This avoids triggering the following warning:  ",917257daa0fea7a007102691c0e27d9216a96768,0
fs: don't scan the inode cache before SB_BORN is set,"We recently had an oops reported on a 4.14 kernel in xfs_reclaim_inodes_count() where sb->s_fs_info pointed to garbage and so the m_perag_tree lookup walked into lala land.  It produces an oops down this path during the failed mount:    radix_tree_gang_lookup_tag+0xc4/0x130   xfs_perag_get_tag+0x37/0xf0   xfs_reclaim_inodes_count+0x32/0x40   xfs_fs_nr_cached_objects+0x11/0x20   super_cache_count+0x35/0xc0   shrink_slab.part.66+0xb1/0x370   shrink_node+0x7e/0x1a0   try_to_free_pages+0x199/0x470   __alloc_pages_slowpath+0x3a1/0xd20   __alloc_pages_nodemask+0x1c3/0x200   cache_grow_begin+0x20b/0x2e0   fallback_alloc+0x160/0x200   kmem_cache_alloc+0x111/0x4e0  The problem is that the superblock shrinker is running before the filesystem structures it depends on have been fully set up. i.e. the shrinker is registered in sget(), before ->fill_super() has been called, and the shrinker can call into the filesystem before fill_super() does it's setup work. Essentially we are exposed to both use-after-free and use-before-initialisation bugs here.  To fix this, add a check for the SB_BORN flag in super_cache_count. In general, this flag is not set until ->fs_mount() completes successfully, so we know that it is set after the filesystem setup has completed. This matches the trylock_super() behaviour which will not let super_cache_scan() run if SB_BORN is not set, and hence will not allow the superblock shrinker from entering the filesystem while it is being set up or after it has failed setup and is being torn down.  ",79f546a696bff2590169fb5684e23d65f4d9f591,1
ipmr: properly check rhltable_init() return value,"commit 8fb472c09b9d (""ipmr: improve hash scalability"") added a call to rhltable_init() without checking its return value.  This problem was then later copied to IPv6 and factorized in commit 0bbbf0e7d0e7 (""ipmr, ip6mr: Unite creation of new mr_table"")  kasan: CONFIG_KASAN_INLINE enabled kasan: GPF could be caused by NULL-ptr deref or user memory access general protection fault: 0000 [#1] SMP KASAN Dumping ftrace buffer:    (ftrace buffer empty) ",66fb33254f45df4b049f487aff1cbde1ef919390,1
net/packet: fix a race in packet_bind() and packet_notifier(),"syzbot reported crashes [1] and provided a C repro easing bug hunting.  When/if packet_do_bind() calls __unregister_prot_hook() and releases po->bind_lock, another thread can run packet_notifier() and process an NETDEV_UP event.  This calls register_prot_hook() and hooks again the socket right before first thread is able to grab again po->bind_lock.  Fixes this issue by temporarily setting po->num to 0, as suggested by David Miller.  [1] dev_remove_pack: ffff8801bf16fa80 not found ",15fe076edea787807a7cdc168df832544b58eba6,1
"Revert ""devlink: Remove not-executed trap group notifications""",This reverts commit 8bbeed4858239ac956a78e5cbaf778bd6f3baef8 as it revealed that mlxsw and netdevsim (copy/paste from mlxsw) reregisters devlink objects during another devlink user triggered command.  ,fb9d19c2d844c415d612bb93c231abf2ccf2a821,0
net/smc: fix refcounting for non-blocking connect(),"If a nonblocking socket is immediately closed after connect(), the connect worker may not have started. This results in a refcount problem, since sock_hold() is called from the connect worker. This patch moves the sock_hold in front of the connect worker scheduling.  ",301428ea3708188dc4a243e6e6b46c03b46a0fbc,0
ALSA: pcm: oss: Avoid potential buffer overflows,"syzkaller reported an invalid access in PCM OSS read, and this seems to be an overflow of the internal buffer allocated for a plugin. Since the rate plugin adjusts its transfer size dynamically, the calculation for the chained plugin might be bigger than the given buffer size in some extreme cases, which lead to such an buffer overflow as caught by KASAN.  Fix it by limiting the max transfer size properly by checking against the destination size in each plugin transfer callback.  ",4cc8d6505ab82db3357613d36e6c58a297f57f7c,1
"can: j1939: fix Use-after-Free, hold skb ref while in use","This patch fixes a Use-after-Free found by the syzbot.  The problem is that a skb is taken from the per-session skb queue, without incrementing the ref count. This leads to a Use-after-Free if the skb is taken concurrently from the session queue due to a CTS.  ",2030043e616cab40f510299f09b636285e0a3678,0
bpf: remove tracepoints from bpf core,"tracepoints to bpf core were added as a way to provide introspection to bpf programs and maps, but after some time it became clear that this approach is inadequate, so prog_id, map_id and corresponding get_next_id, get_fd_by_id, get_info_by_fd, prog_query APIs were introduced and fully adopted by bpftool and other applications. The tracepoints in bpf core started to rot and causing syzbot warnings: ",4d220ed0f8140c478ab7b0a14d96821da639b646,0
io-wq: fix use-after-free in io_wq_worker_running,The smart syzbot has found a reproducer for the following issue:   ,c4068bf898ddaef791049a366828d9b84b467bda,1
arm64: Do not pass tagged addresses to __is_lm_address(),"Commit 519ea6f1c82f (""arm64: Fix kernel address detection of __is_lm_address()"") fixed the incorrect validation of addresses below PAGE_OFFSET. However, it no longer allowed tagged addresses to be passed to virt_addr_valid().  Fix this by explicitly resetting the pointer tag prior to invoking __is_lm_address(). This is consistent with the __lm_to_phys() macro.  ",91cb2c8b072e00632adf463b78b44f123d46a0fa,0
xdp: check prog type before updating BPF link,"The bpf_xdp_link_update() function didn't check the program type before updating the program, which made it possible to install any program type as an XDP program, which is obviously not good. Syzbot managed to trigger this by swapping in an LWT program on the XDP hook which would crash in a helper call.  Fix this by adding a check and bailing out if the types don't match.  ",382778edc8262b7535f00523e9eb22edba1b9816,1
l2tp: do not use inet_hash()/inet_unhash(),"syzbot recently found a way to crash the kernel [1]  Issue here is that inet_hash() & inet_unhash() are currently only meant to be used by TCP & DCCP, since only these protocols provide the needed hashinfo pointer.  L2TP uses a single list (instead of a hash table)  This old bug became an issue after commit 610236587600 (""bpf: Add new cgroup attach type to enable sock modifications"") since after this commit, sk_common_release() can be called while the L2TP socket is still considered 'hashed'.  general protection fault, probably for non-canonical address 0xdffffc0000000001: 0000 [#1] PREEMPT SMP KASAN KASAN: null-ptr-deref in range [0x0000000000000008-0x000000000000000f] CPU: 0 PID: 7063 Comm: syz-executor654 Not tainted 5.7.0-rc6-syzkaller #0 Hardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 01/01/2011 ",02c71b144c811bcdd865e0a1226d0407d11357e8,1
io_uring: sanitize double poll handling,"There's a bit of confusion on the matching pairs of poll vs double poll, depending on if the request is a pure poll (IORING_OP_POLL_ADD) or poll driven retry.  Add io_poll_get_double() that returns the double poll waitqueue, if any, and io_poll_get_single() that returns the original poll waitqueue. With that, remove the argument to io_poll_remove_double().  Finally ensure that wait->private is cleared once the double poll handler has run, so that remove knows it's already been seen.  ",d4e7cd36a90e38e0276d6ce0c20f5ccef17ec38c,1
KVM: VMX: Properly handle kvm_read/write_guest_virt*() result,Syzbot reports the following issue:  ,7a35e515a7055f483f87d12041c41db11b36c9ee,0
xfrm: fix missing dst_release() after policy blocking lbcast and multicast,Fix missing dst_release() when local broadcast or multicast traffic is xfrm policy blocked.  For IPv4 this results to dst leak: ip_route_output_flow() allocates dst_entry via __ip_route_output_key() and passes it to xfrm_lookup_route(). xfrm_lookup returns ERR_PTR(-EPERM) that is propagated. The dst that was allocated is never released.  IPv4 local broadcast testcase:  ping -b 192.168.1.255 &  sleep 1  ip xfrm policy add src 0.0.0.0/0 dst 192.168.1.255/32 dir out action block  IPv4 multicast testcase:  ping 224.0.0.1 &  sleep 1  ip xfrm policy add src 0.0.0.0/0 dst 224.0.0.1/32 dir out action block  For IPv6 the missing dst_release() causes trouble e.g. when used in netns:  ip netns add TEST  ip netns exec TEST ip link set lo up  ip link add dummy0 type dummy  ip link set dev dummy0 netns TEST  ip netns exec TEST ip addr add fd00::1111 dev dummy0  ip netns exec TEST ip link set dummy0 up  ip netns exec TEST ping -6 -c 5 ff02::1%dummy0 &  sleep 1  ip netns exec TEST ip xfrm policy add src ::/0 dst ff02::1 dir out action block  wait  ip netns del TEST  After netns deletion we see: ,8cc88773855f988d6a3bbf102bbd9dd9c828eb81,0
net: use skb_queue_empty_lockless() in busy poll contexts,Busy polling usually runs without locks. Let's use skb_queue_empty_lockless() instead of skb_queue_empty()  Also uses READ_ONCE() in __skb_try_recv_datagram() to address a similar potential problem.  ,3f926af3f4d688e2e11e7f8ed04e277a14d4d4a4,0
net: validate attribute sizes in neigh_dump_table(),"Since neigh_dump_table() calls nlmsg_parse() without giving policy constraints, attributes can have arbirary size that we must validate  Reported by syzbot/KMSAN :  BUG: KMSAN: uninit-value in neigh_master_filtered net/core/neighbour.c:2292 [inline] BUG: KMSAN: uninit-value in neigh_dump_table net/core/neighbour.c:2348 [inline] BUG: KMSAN: uninit-value in neigh_dump_info+0x1af0/0x2250 net/core/neighbour.c:2438 CPU: 1 PID: 3575 Comm: syzkaller268891 Not tainted 4.16.0+ #83 Hardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 01/01/2011 Call Trace:  __dump_stack lib/dump_stack.c:17 [inline]  dump_stack+0x185/0x1d0 lib/dump_stack.c:53  kmsan_report+0x142/0x240 mm/kmsan/kmsan.c:1067  __msan_warning_32+0x6c/0xb0 mm/kmsan/kmsan_instr.c:676  neigh_master_filtered net/core/neighbour.c:2292 [inline]  neigh_dump_table net/core/neighbour.c:2348 [inline]  neigh_dump_info+0x1af0/0x2250 net/core/neighbour.c:2438  netlink_dump+0x9ad/0x1540 net/netlink/af_netlink.c:2225  __netlink_dump_start+0x1167/0x12a0 net/netlink/af_netlink.c:2322  netlink_dump_start include/linux/netlink.h:214 [inline]  rtnetlink_rcv_msg+0x1435/0x1560 net/core/rtnetlink.c:4598  netlink_rcv_skb+0x355/0x5f0 net/netlink/af_netlink.c:2447  rtnetlink_rcv+0x50/0x60 net/core/rtnetlink.c:4653  netlink_unicast_kernel net/netlink/af_netlink.c:1311 [inline]  netlink_unicast+0x1672/0x1750 net/netlink/af_netlink.c:1337  netlink_sendmsg+0x1048/0x1310 net/netlink/af_netlink.c:1900  sock_sendmsg_nosec net/socket.c:630 [inline]  sock_sendmsg net/socket.c:640 [inline]  ___sys_sendmsg+0xec0/0x1310 net/socket.c:2046  __sys_sendmsg net/socket.c:2080 [inline]  SYSC_sendmsg+0x2a3/0x3d0 net/socket.c:2091  SyS_sendmsg+0x54/0x80 net/socket.c:2087  do_syscall_64+0x309/0x430 arch/x86/entry/common.c:287  entry_SYSCALL_64_after_hwframe+0x3d/0xa2 ",7dd07c143a4b54d050e748bee4b4b9e94a7b1744,1
net/sched: sch_taprio: reset child qdiscs before freeing them,syzkaller shows that packets can still be dequeued while taprio_destroy() is running. Let sch_taprio use the reset() function to cancel the advance timer and drop all skbs from the child qdiscs.  ,44d4775ca51805b376a8db5b34f650434a08e556,1
KEYS: reject NULL restriction string when type is specified,"keyctl_restrict_keyring() allows through a NULL restriction when the ""type"" is non-NULL, which causes a NULL pointer dereference in asymmetric_lookup_restriction() when it calls strcmp() on the restriction string.  But no key types actually use a ""NULL restriction"" to mean anything, so update keyctl_restrict_keyring() to reject it with EINVAL.  ",18026d866801d0c52e5550210563222bd6c7191d,1
ath9k: Fix general protection fault in ath9k_hif_usb_rx_cb,"In ath9k_hif_usb_rx_cb interface number is assumed to be 0. usb_ifnum_to_if(urb->dev, 0) But it isn't always true.  The case reported by syzbot: https://lore.kernel.org/linux-usb/000000000000666c9c05a1c05d12@google.com usb 2-1: new high-speed USB device number 2 using dummy_hcd usb 2-1: config 1 has an invalid interface number: 2 but max is 0 usb 2-1: config 1 has no interface number 0 usb 2-1: New USB device found, idVendor=0cf3, idProduct=9271, bcdDevice= 1.08 usb 2-1: New USB device strings: Mfr=1, Product=2, SerialNumber=3 general protection fault, probably for non-canonical address 0xdffffc0000000015: 0000 [#1] SMP KASAN KASAN: null-ptr-deref in range [0x00000000000000a8-0x00000000000000af] CPU: 0 PID: 0 Comm: swapper/0 Not tainted 5.6.0-rc5-syzkaller #0  Call Trace __usb_hcd_giveback_urb+0x29a/0x550 drivers/usb/core/hcd.c:1650 usb_hcd_giveback_urb+0x368/0x420 drivers/usb/core/hcd.c:1716 dummy_timer+0x1258/0x32ae drivers/usb/gadget/udc/dummy_hcd.c:1966 call_timer_fn+0x195/0x6f0 kernel/time/timer.c:1404 expire_timers kernel/time/timer.c:1449 [inline] __run_timers kernel/time/timer.c:1773 [inline] __run_timers kernel/time/timer.c:1740 [inline] run_timer_softirq+0x5f9/0x1500 kernel/time/timer.c:1786 __do_softirq+0x21e/0x950 kernel/softirq.c:292 invoke_softirq kernel/softirq.c:373 [inline] irq_exit+0x178/0x1a0 kernel/softirq.c:413 exiting_irq arch/x86/include/asm/apic.h:546 [inline] smp_apic_timer_interrupt+0x141/0x540 arch/x86/kernel/apic/apic.c:1146 apic_timer_interrupt+0xf/0x20 arch/x86/entry/entry_64.S:829  ",2bbcaaee1fcbd83272e29f31e2bb7e70d8c49e05,1
tun: add mutex_unlock() call and napi.skb clearing in tun_get_user(),"If both IFF_NAPI_FRAGS mode and XDP are enabled, and the XDP program consumes the skb, we need to clear the napi.skb (or risk a use-after-free) and release the mutex (or risk a deadlock)  ",1efba987c48629c0c64703bb4ea76ca1a3771d17,1
packet: reset network header if packet shorter than ll reserved space,"If variable length link layer headers result in a packet shorter than dev->hard_header_len, reset the network header offset. Else skb->mac_len may exceed skb->len after skb_mac_reset_len.  packet_sendmsg_spkt already has similar logic.  ",993675a3100b16a4c80dfd70cbcde8ea7127b31d,0
posix-cpu-timers: Always clear head pointer on dequeue,The head pointer in struct cpu_timer is checked to be NULL in posix_cpu_timer_del() when the delete raced with the exit cleanup. The works correctly as long as the timer is actually dequeued via posix_cpu_timers_exit*().  But if the timer was dequeued due to expiry the head pointer is still set and triggers the warning.  In fact keeping the head pointer around after any dequeue is pointless as is has no meaning at all after that.  Clear the head pointer always on dequeue and remove the unused requeue function while at it.  ,00d9e47f8ec2a293db9ebed86aab0583d9a49533,1
drm/virtio: fix OOB in virtio_gpu_object_create,"After commit f651c8b05542 (""drm/virtio: factor out the sg_table from virtio_gpu_object""), virtio_gpu_create_object allocates too small space to fit everything in. It is because it allocates struct virtio_gpu_object, but should allocate a newly added struct virtio_gpu_object_shmem which has 2 more members.  So fix that by using correct type in virtio_gpu_create_object.  ",b513b0d4563ab70a0a25e7a0ed94afaf88ac28bf,1
ip: validate header length on virtual device xmit,"KMSAN detected read beyond end of buffer in vti and sit devices when passing truncated packets with PF_PACKET. The issue affects additional ip tunnel devices.  Extend commit 76c0ddd8c3a6 (""ip6_tunnel: be careful when accessing the inner header"") and commit ccfec9e5cb2d (""ip_tunnel: be careful when accessing the inner header"").  Move the check to a separate helper and call at the start of each ndo_start_xmit function in net/ipv4 and net/ipv6.  Minor changes: - convert dev_kfree_skb to kfree_skb on error path,   as dev_kfree_skb calls consume_skb which is not for error paths. - use pskb_network_may_pull even though that is pedantic here,   as the same as pskb_may_pull for devices without llheaders. - do not cache ipv6 hdrs if used only once   (unsafe across pskb_may_pull, was more relevant to earlier patch)  ",cb9f1b783850b14cbd7f87d061d784a666dfba1f,0
ALSA: rawmidi: Avoid bit fields for state flags,"The rawmidi state flags (opened, append, active_sensing) are stored in bit fields that can be potentially racy when concurrently accessed without any locks.  Although the current code should be fine, there is also no any real benefit by keeping the bitfields for this kind of short number of members.  This patch changes those bit fields flags to the simple bool fields. There should be no size increase of the snd_rawmidi_substream by this change.  ",dfa9a5efe8b932a84b3b319250aa3ac60c20f876,0
xfrm: policy: fix infinite loop when merging src-nodes,"With very small change to test script we can trigger softlockup due to bogus assignment of 'p' (policy to be examined) on restart.  Previously the two to-be-merged nodes had same address/prefixlength pair, so no erase/reinsert was necessary, we only had to append the list from node a to b.  If prefix lengths are different, the node has to be deleted and re-inserted into the tree, with the updated prefix length.  This was broken; due to bogus update to 'p' this loops forever.  Add a 'restart' label and use that instead.  While at it, don't perform the unneeded reinserts of the policies that are already sorted into the 'new' node.  A previous patch in this series made xfrm_policy_inexact_list_reinsert() use the relative position indicator to sort policies according to age in case priorities are identical.  ",12750abad517a991c4568969bc748db302ab52cd,1
Bluetooth: verify AMP hci_chan before amp_destroy,"hci_chan can be created in 2 places: hci_loglink_complete_evt() if it is an AMP hci_chan, or l2cap_conn_add() otherwise. In theory, Only AMP hci_chan should be removed by a call to hci_disconn_loglink_complete_evt(). However, the controller might mess up, call that function, and destroy an hci_chan which is not initiated by hci_loglink_complete_evt().  This patch adds a verification that the destroyed hci_chan must have been init'd by hci_loglink_complete_evt().  Example crash call trace: Call Trace:  __dump_stack lib/dump_stack.c:77 [inline]  dump_stack+0xe3/0x144 lib/dump_stack.c:118  print_address_description+0x67/0x22a mm/kasan/report.c:256  kasan_report_error mm/kasan/report.c:354 [inline]  kasan_report mm/kasan/report.c:412 [inline]  kasan_report+0x251/0x28f mm/kasan/report.c:396  hci_send_acl+0x3b/0x56e net/bluetooth/hci_core.c:4072  l2cap_send_cmd+0x5af/0x5c2 net/bluetooth/l2cap_core.c:877  l2cap_send_move_chan_cfm_icid+0x8e/0xb1 net/bluetooth/l2cap_core.c:4661  l2cap_move_fail net/bluetooth/l2cap_core.c:5146 [inline]  l2cap_move_channel_rsp net/bluetooth/l2cap_core.c:5185 [inline]  l2cap_bredr_sig_cmd net/bluetooth/l2cap_core.c:5464 [inline]  l2cap_sig_channel net/bluetooth/l2cap_core.c:5799 [inline]  l2cap_recv_frame+0x1d12/0x51aa net/bluetooth/l2cap_core.c:7023  l2cap_recv_acldata+0x2ea/0x693 net/bluetooth/l2cap_core.c:7596  hci_acldata_packet net/bluetooth/hci_core.c:4606 [inline]  hci_rx_work+0x2bd/0x45e net/bluetooth/hci_core.c:4796  process_one_work+0x6f8/0xb50 kernel/workqueue.c:2175  worker_thread+0x4fc/0x670 kernel/workqueue.c:2321  kthread+0x2f0/0x304 kernel/kthread.c:253  ret_from_fork+0x3a/0x50 arch/x86/entry/entry_64.S:415  Allocated by task 38:  set_track mm/kasan/kasan.c:460 [inline]  kasan_kmalloc+0x8d/0x9a mm/kasan/kasan.c:553  kmem_cache_alloc_trace+0x102/0x129 mm/slub.c:2787  kmalloc include/linux/slab.h:515 [inline]  kzalloc include/linux/slab.h:709 [inline]  hci_chan_create+0x86/0x26d net/bluetooth/hci_conn.c:1674  l2cap_conn_add.part.0+0x1c/0x814 net/bluetooth/l2cap_core.c:7062  l2cap_conn_add net/bluetooth/l2cap_core.c:7059 [inline]  l2cap_connect_cfm+0x134/0x852 net/bluetooth/l2cap_core.c:7381  hci_connect_cfm+0x9d/0x122 include/net/bluetooth/hci_core.h:1404  hci_remote_ext_features_evt net/bluetooth/hci_event.c:4161 [inline]  hci_event_packet+0x463f/0x72fa net/bluetooth/hci_event.c:5981  hci_rx_work+0x197/0x45e net/bluetooth/hci_core.c:4791  process_one_work+0x6f8/0xb50 kernel/workqueue.c:2175  worker_thread+0x4fc/0x670 kernel/workqueue.c:2321  kthread+0x2f0/0x304 kernel/kthread.c:253  ret_from_fork+0x3a/0x50 arch/x86/entry/entry_64.S:415  Freed by task 1732:  set_track mm/kasan/kasan.c:460 [inline]  __kasan_slab_free mm/kasan/kasan.c:521 [inline]  __kasan_slab_free+0x106/0x128 mm/kasan/kasan.c:493  slab_free_hook mm/slub.c:1409 [inline]  slab_free_freelist_hook+0xaa/0xf6 mm/slub.c:1436  slab_free mm/slub.c:3009 [inline]  kfree+0x182/0x21e mm/slub.c:3972  hci_disconn_loglink_complete_evt net/bluetooth/hci_event.c:4891 [inline]  hci_event_packet+0x6a1c/0x72fa net/bluetooth/hci_event.c:6050  hci_rx_work+0x197/0x45e net/bluetooth/hci_core.c:4791  process_one_work+0x6f8/0xb50 kernel/workqueue.c:2175  worker_thread+0x4fc/0x670 kernel/workqueue.c:2321  kthread+0x2f0/0x304 kernel/kthread.c:253  ret_from_fork+0x3a/0x50 arch/x86/entry/entry_64.S:415  The buggy address belongs to the object at ffff8881d7af9180  which belongs to the cache kmalloc-128 of size 128 The buggy address is located 24 bytes inside of  128-byte region [ffff8881d7af9180, ffff8881d7af9200) The buggy address belongs to the page: page:ffffea00075ebe40 count:1 mapcount:0 mapping:ffff8881da403200 index:0x0 flags: 0x8000000000000200(slab) raw: 8000000000000200 dead000000000100 dead000000000200 ffff8881da403200 raw: 0000000000000000 0000000080150015 00000001ffffffff 0000000000000000 page dumped because: kasan: bad access detected  Memory state around the buggy ",5c4c8c9544099bb9043a10a5318130a943e32fc3,1
clk: hisilicon: hi3559a: Drop __init markings everywhere,"This driver is a platform driver. The probe function can be called after kernel init, and try to reference kernel memory that has been freed. Drop the __init markings everywhere here to avoid referencing initdata from non-init code. Fixes modpost warnings.  ",498cc50b3fa99b545532dc433d53d3c0b889cc98,0
pkt_sched: sch_qfq: fix qfq_change_class() error path,"If qfq_change_class() is unable to allocate memory for qfq_aggregate, it frees the class that has been inserted in the class hash table, but does not unhash it.  Defer the insertion after the problematic allocation.  BUG: KASAN: use-after-free in hlist_add_head include/linux/list.h:884 [inline] BUG: KASAN: use-after-free in qdisc_class_hash_insert+0x200/0x210 net/sched/sch_api.c:731 Write of size 8 at addr ffff88814a534f10 by task syz-executor.4/31478  CPU: 0 PID: 31478 Comm: syz-executor.4 Not tainted 5.13.0-rc6-syzkaller #0 Hardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 01/01/2011 Call Trace:  __dump_stack lib/dump_stack.c:79 [inline]  dump_stack+0x141/0x1d7 lib/dump_stack.c:120  print_address_description.constprop.0.cold+0x5b/0x2f8 mm/kasan/report.c:233  __kasan_report mm/kasan/report.c:419 [inline]  kasan_report.cold+0x7c/0xd8 mm/kasan/report.c:436  hlist_add_head include/linux/list.h:884 [inline]  qdisc_class_hash_insert+0x200/0x210 net/sched/sch_api.c:731  qfq_change_class+0x96c/0x1990 net/sched/sch_qfq.c:489  tc_ctl_tclass+0x514/0xe50 net/sched/sch_api.c:2113  rtnetlink_rcv_msg+0x44e/0xad0 net/core/rtnetlink.c:5564  netlink_rcv_skb+0x153/0x420 net/netlink/af_netlink.c:2504  netlink_unicast_kernel net/netlink/af_netlink.c:1314 [inline]  netlink_unicast+0x533/0x7d0 net/netlink/af_netlink.c:1340  netlink_sendmsg+0x856/0xd90 net/netlink/af_netlink.c:1929  sock_sendmsg_nosec net/socket.c:654 [inline]  sock_sendmsg+0xcf/0x120 net/socket.c:674  ____sys_sendmsg+0x6e8/0x810 net/socket.c:2350  ___sys_sendmsg+0xf3/0x170 net/socket.c:2404  __sys_sendmsg+0xe5/0x1b0 net/socket.c:2433  do_syscall_64+0x3a/0xb0 arch/x86/entry/common.c:47  entry_SYSCALL_64_after_hwframe+0x44/0xae ",0cd58e5c53babb9237b741dbef711f0a9eb6d3fd,1
crypto: vmac - separate tfm and request context,"syzbot reported a crash in vmac_final() when multiple threads concurrently use the same ""vmac(aes)"" transform through AF_ALG.  The bug is pretty fundamental: the VMAC template doesn't separate per-request state from per-tfm (per-key) state like the other hash algorithms do, but rather stores it all in the tfm context.  That's wrong.  Also, vmac_final() incorrectly zeroes most of the state including the derived keys and cached pseudorandom pad.  Therefore, only the first VMAC invocation with a given key calculates the correct digest.  Fix these bugs by splitting the per-tfm state from the per-request state and using the proper init/update/final sequencing for requests.  Reproducer for the crash:      #include <linux/if_alg.h>     #include <sys/socket.h>     #include <unistd.h>      int main()     {             int fd;             struct sockaddr_alg addr = {                     .salg_type = ""hash"",                     .salg_name = ""vmac(aes)"",             };             char buf[256] = { 0 };              fd = socket(AF_ALG, SOCK_SEQPACKET, 0);             bind(fd, (void *)&addr, sizeof(addr));             setsockopt(fd, SOL_ALG, ALG_SET_KEY, buf, 16);             fork();             fd = accept(fd, NULL, NULL);             for (;;)                     write(fd, buf, 256);     }  The immediate cause of the crash is that vmac_ctx_t.partial_size exceeds VMAC_NHBYTES, causing vmac_final() to memset() a negative length.  ",bb29648102335586e9a66289a1d98a0cb392b6e5,1
cfg80211: call cfg80211_stop_ap when switch from P2P_GO type,"If the userspace tools switch from NL80211_IFTYPE_P2P_GO to NL80211_IFTYPE_ADHOC via send_msg(NL80211_CMD_SET_INTERFACE), it does not call the cleanup cfg80211_stop_ap(), this leads to the initialization of in-use data. For example, this path re-init the sdata->assigned_chanctx_list while it is still an element of assigned_vifs list, and makes that linked list corrupt.  ",563fbefed46ae4c1f70cffb8eb54c02df480b2c2,0
quota: Fix memory leak when handling corrupted quota file,When checking corrupted quota file we can bail out and leak allocated info structure. Properly free info structure on error return.  ,a4db1072e1a3bd7a8d9c356e1902b13ac5deb8ef,1
vhost_net: add missing lock nesting notation,We try to hold TX virtqueue mutex in vhost_net_rx_peek_head_len() after RX virtqueue mutex is held in handle_rx(). This requires an appropriate lock nesting notation to calm down deadlock detector.  ,aaa3149bbee9ba9b4e6f0bd6e3e7d191edeae942,0
bfs: add sanity check at bfs_fill_super(),"syzbot is reporting too large memory allocation at bfs_fill_super() [1]. Since file system image is corrupted such that bfs_sb->s_start == 0, bfs_fill_super() is trying to allocate 8MB of continuous memory. Fix this by adding a sanity check on bfs_sb->s_start, __GFP_NOWARN and printf().  [1] https://syzkaller.appspot.com/bug?id=16a87c236b951351374a84c8a32f40edbc034e96  ",9f2df09a33aa2c76ce6385d382693f98d7f2f07e,1
crypto: sha512-mb - initialize pending lengths correctly,"The SHA-512 multibuffer code keeps track of the number of blocks pending in each lane.  The minimum of these values is used to identify the next lane that will be completed.  Unused lanes are set to a large number (0xFFFFFFFF) so that they don't affect this calculation.  However, it was forgotten to set the lengths to this value in the initial state, where all lanes are unused.  As a result it was possible for sha512_mb_mgr_get_comp_job_avx2() to select an unused lane, causing a NULL pointer dereference.  Specifically this could happen in the case where ->update() was passed fewer than SHA512_BLOCK_SIZE bytes of data, so it then called sha_complete_job() without having actually submitted any blocks to the multi-buffer code.  This hit a NULL pointer dereference if another task happened to have submitted blocks concurrently to the same CPU and the flush timer had not yet expired.  Fix this by initializing sha512_mb_mgr->lens correctly.  As usual, this bug was found by syzkaller.  ",eff84b379089cd8b4e83599639c1f5f6e34ef7bf,1
act_ife: load meta modules before tcf_idr_check_alloc(),"The following deadlock scenario is triggered by syzbot:  Thread A:				Thread B: tcf_idr_check_alloc() ... populate_metalist()   rtnl_unlock() 					rtnl_lock() 					...   request_module()			tcf_idr_check_alloc()   rtnl_lock()  At this point, thread A is waiting for thread B to release RTNL lock, while thread B is waiting for thread A to commit the IDR change with tcf_idr_insert() later.  Break this deadlock situation by preloading ife modules earlier, before tcf_idr_check_alloc(), this is fine because we only need to load modules we need potentially.  ",cc8e58f8325cdf14b9516b61c384cdfd02a4f408,0
usb: mon: Fix a deadlock in usbmon between mmap and read,"The problem arises because our read() function grabs a lock of the circular buffer, finds something of interest, then invokes copy_to_user() straight from the buffer, which in turn takes mm->mmap_sem. In the same time, the callback mon_bin_vma_fault() is invoked under mm->mmap_sem. It attempts to take the fetch lock and deadlocks.  This patch does away with protecting of our page list with any semaphores, and instead relies on the kernel not close the device while mmap is active in a process.  In addition, we prohibit re-sizing of a buffer while mmap is active. This way, when (now unlocked) fault is processed, it works with the page that is intended to be mapped-in, and not some other random page. Note that this may have an ABI impact, but hopefully no legitimate program is this wrong.  ",19e6317d24c25ee737c65d1ffb7483bdda4bb54a,0
io_uring: remove double poll entry on arm failure,"__io_queue_proc() can enqueue both poll entries and still fail afterwards, so the callers trying to cancel it should also try to remove the second poll entry (if any).  For example, it may leave the request alive referencing a io_uring context but not accessible for cancellation:  ",46fee9ab02cb24979bbe07631fc3ae95ae08aa3e,0
ath9x: Fix stack-out-of-bounds Write in ath9k_hif_usb_rx_cb,Add barrier to accessing the stack array skb_pool.  The case reported by syzbot: https://lore.kernel.org/linux-usb/0000000000003d7c1505a2168418@google.com BUG: KASAN: stack-out-of-bounds in ath9k_hif_usb_rx_stream drivers/net/wireless/ath/ath9k/hif_usb.c:626 [inline] BUG: KASAN: stack-out-of-bounds in ath9k_hif_usb_rx_cb+0xdf6/0xf70 drivers/net/wireless/ath/ath9k/hif_usb.c:666 Write of size 8 at addr ffff8881db309a28 by task swapper/1/0  Call Trace: ath9k_hif_usb_rx_stream drivers/net/wireless/ath/ath9k/hif_usb.c:626 [inline] ath9k_hif_usb_rx_cb+0xdf6/0xf70 drivers/net/wireless/ath/ath9k/hif_usb.c:666 __usb_hcd_giveback_urb+0x1f2/0x470 drivers/usb/core/hcd.c:1648 usb_hcd_giveback_urb+0x368/0x420 drivers/usb/core/hcd.c:1713 dummy_timer+0x1258/0x32ae drivers/usb/gadget/udc/dummy_hcd.c:1966 call_timer_fn+0x195/0x6f0 kernel/time/timer.c:1404 expire_timers kernel/time/timer.c:1449 [inline] __run_timers kernel/time/timer.c:1773 [inline] __run_timers kernel/time/timer.c:1740 [inline] run_timer_softirq+0x5f9/0x1500 kernel/time/timer.c:1786  ,19d6c375d671ce9949a864fb9a03e19f5487b4d3,1
"Revert ""net/ipv6: fix metrics leak""",This reverts commit df18b50448fab1dff093731dfd0e25e77e1afcd1.  This change causes other problems and use-after-free situations as found by syzbot.  ,e6aed040eafb4ce1881bbc59a225f6b27d250396,1
ubi: check kthread_should_stop() after the setting of task state,"A detach hung is possible when a race occurs between the detach process and the ubi background thread. The following sequences outline the race:    ubi thread: if (list_empty(&ubi->works)...    ubi detach: set_bit(KTHREAD_SHOULD_STOP, &kthread->flags)               => by kthread_stop()               wake_up_process()               => ubi thread is still running, so 0 is returned    ubi thread: set_current_state(TASK_INTERRUPTIBLE)               schedule()               => ubi thread will never be scheduled again    ubi detach: wait_for_completion()               => hung task!  To fix that, we need to check kthread_should_stop() after we set the task state, so the ubi thread will either see the stop bit and exit or the task state is reset to runnable such that it isn't scheduled out indefinitely.  ",d005f8c6588efcfbe88099b6edafc6f58c84a9c1,1
tcp: annotate tp->snd_nxt lockless reads,"There are few places where we fetch tp->snd_nxt while this field can change from IRQ or other cpu.  We need to add READ_ONCE() annotations, and also make sure write sides use corresponding WRITE_ONCE() to avoid store-tearing.  ",e0d694d638dba768b47be31c22e1a9b4f862f561,0
gfs2: add validation checks for size of superblock,"In gfs2_check_sb(), no validation checks are performed with regards to the size of the superblock. syzkaller detected a slab-out-of-bounds bug that was primarily caused because the block size for a superblock was set to zero. A valid size for a superblock is a power of 2 between 512 and PAGE_SIZE. Performing validation checks and ensuring that the size of the superblock is valid fixes this bug.  ",0ddc5154b24c96f20e94d653b0a814438de6032b,1
Abort file_remove_privs() for non-reg. files,"file_remove_privs() might be called for non-regular files, e.g. blkdev inode. There is no reason to do its job on things like blkdev inodes, pipes, or cdevs. Hence, abort if file does not refer to a regular inode.  AV: more to the point, for devices there might be any number of inodes refering to given device.  Which one to strip the permissions from, even if that made any sense in the first place?  All of them will be observed with contents modified, after all.  Found by LockDoc (Alexander Lochmann, Horst Schirmeier and Olaf Spinczyk)  ",f69e749a49353d96af1a293f56b5b56de59c668a,0
rtnetlink: validate attributes in do_setlink(),"It seems that rtnl_group_changelink() can call do_setlink while a prior call to validate_linkmsg(dev = NULL, ...) could not validate IFLA_ADDRESS / IFLA_BROADCAST  Make sure do_setlink() calls validate_linkmsg() instead of letting its callers having this responsibility.  With help from Dmitry Vyukov, thanks a lot !  BUG: KMSAN: uninit-value in is_valid_ether_addr include/linux/etherdevice.h:199 [inline] BUG: KMSAN: uninit-value in eth_prepare_mac_addr_change net/ethernet/eth.c:275 [inline] BUG: KMSAN: uninit-value in eth_mac_addr+0x203/0x2b0 net/ethernet/eth.c:308 CPU: 1 PID: 8695 Comm: syz-executor3 Not tainted 4.17.0-rc5+ #103 Hardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 01/01/2011 Call Trace:  __dump_stack lib/dump_stack.c:77 [inline]  dump_stack+0x185/0x1d0 lib/dump_stack.c:113  kmsan_report+0x149/0x260 mm/kmsan/kmsan.c:1084  __msan_warning_32+0x6e/0xc0 mm/kmsan/kmsan_instr.c:686  is_valid_ether_addr include/linux/etherdevice.h:199 [inline]  eth_prepare_mac_addr_change net/ethernet/eth.c:275 [inline]  eth_mac_addr+0x203/0x2b0 net/ethernet/eth.c:308  dev_set_mac_address+0x261/0x530 net/core/dev.c:7157  do_setlink+0xbc3/0x5fc0 net/core/rtnetlink.c:2317  rtnl_group_changelink net/core/rtnetlink.c:2824 [inline]  rtnl_newlink+0x1fe9/0x37a0 net/core/rtnetlink.c:2976  rtnetlink_rcv_msg+0xa32/0x1560 net/core/rtnetlink.c:4646  netlink_rcv_skb+0x378/0x600 net/netlink/af_netlink.c:2448  rtnetlink_rcv+0x50/0x60 net/core/rtnetlink.c:4664  netlink_unicast_kernel net/netlink/af_netlink.c:1310 [inline]  netlink_unicast+0x1678/0x1750 net/netlink/af_netlink.c:1336  netlink_sendmsg+0x104f/0x1350 net/netlink/af_netlink.c:1901  sock_sendmsg_nosec net/socket.c:629 [inline]  sock_sendmsg net/socket.c:639 [inline]  ___sys_sendmsg+0xec0/0x1310 net/socket.c:2117  __sys_sendmsg net/socket.c:2155 [inline]  __do_sys_sendmsg net/socket.c:2164 [inline]  __se_sys_sendmsg net/socket.c:2162 [inline]  __x64_sys_sendmsg+0x331/0x460 net/socket.c:2162  do_syscall_64+0x152/0x230 arch/x86/entry/common.c:287  entry_SYSCALL_64_after_hwframe+0x44/0xa9 ",644c7eebbfd59e72982d11ec6cc7d39af12450ae,1
bpf: fix check of allowed specifiers in bpf_trace_printk,"A format string consisting of ""%p"" or ""%s"" followed by an invalid specifier (e.g. ""%p%\n"" or ""%s%"") could pass the check which would make format_decode (lib/vsprintf.c) to warn.  ",1efb6ee3edea57f57f9fb05dba8dcb3f7333f61f,0
netfilter: nft_tunnel: fix null-attribute check,"else we get null deref when one of the attributes is missing, both must be non-null.  ",1c702bf902bd37349f6d91cd7f4b372b1e46d0ed,0
packet: in packet_snd start writing at link layer allocation,"Packet sockets allow construction of packets shorter than dev->hard_header_len to accommodate protocols with variable length link layer headers. These packets are padded to dev->hard_header_len, because some device drivers interpret that as a minimum packet size.  packet_snd reserves dev->hard_header_len bytes on allocation. SOCK_DGRAM sockets call skb_push in dev_hard_header() to ensure that link layer headers are stored in the reserved range. SOCK_RAW sockets do the same in tpacket_snd, but not in packet_snd.  Syzbot was able to send a zero byte packet to a device with massive 116B link layer header, causing padding to cross over into skb_shinfo. Fix this by writing from the start of the llheader reserved range also in the case of packet_snd/SOCK_RAW.  Update skb_set_network_header to the new offset. This also corrects it for SOCK_DGRAM, where it incorrectly double counted reserve due to the skb_push in dev_hard_header.  ",b84bbaf7a6c8cca24f8acf25a2c8e46913a947ba,0
l2tp: do not accept arbitrary sockets,"syzkaller found an issue caused by lack of sufficient checks in l2tp_tunnel_create()  RAW sockets can not be considered as UDP ones for instance.  In another patch, we shall replace all pr_err() by less intrusive pr_debug() so that syzkaller can find other bugs faster. ",17cfe79a65f98abe535261856c5aef14f306dff7,1
bonding: avoid possible dead-lock,Syzkaller reported this on a slightly older kernel but it's still applicable to the current kernel -  ,d4859d749aa7090ffb743d15648adb962a1baeae,0
ipvs: defer hook registration to avoid leaks,"syzkaller reports for memory leak when registering hooks [1]  As we moved the nf_unregister_net_hooks() call into __ip_vs_dev_cleanup(), defer the nf_register_net_hooks() call, so that hooks are allocated and freed from same pernet_operations (ipvs_core_dev_ops).  [1] BUG: memory leak unreferenced object 0xffff88810acd8a80 (size 96):  comm ""syz-executor073"", pid 7254, jiffies 4294950560 (age 22.250s)  ",cf47a0b882a4e5f6b34c7949d7b293e9287f1972,1
rxrpc: Fix call crypto state cleanup,"Fix the cleanup of the crypto state on a call after the call has been disconnected.  As the call has been disconnected, its connection ref has been discarded and so we can't go through that to get to the security ops table.  Fix this by caching the security ops pointer in the rxrpc_call struct and using that when freeing the call security state.  Also use this in other places we're dealing with call-specific security.  The symptoms look like:      BUG: KASAN: use-after-free in rxrpc_release_call+0xb2d/0xb60     net/rxrpc/call_object.c:481     Read of size 8 at addr ffff888062ffeb50 by task syz-executor.5/4764  ",91fcfbe8852edb929ff8702534525031a15d0aa6,1
bonding: don't need RTNL for ipsec helpers,"The bond_ipsec_* helpers don't need RTNL, and can potentially get called without it being held, so switch from rtnl_dereference() to rcu_dereference() to access bond struct data.  Lightly tested with xfrm bonding, no problems found, should address the syzkaller bug referenced below.  ",f548a476268d621846bb0146af861bb56250ae37,1
proc: Use new infrastructure to fix deadlocks in execve,"This changes lock_trace to use the new exec_update_mutex instead of cred_guard_mutex.  This fixes possible deadlocks when the trace is accessing /proc/$pid/stack for instance.  This should be safe, as the credentials are only used for reading, and task->mm is updated on execve under the new exec_update_mutex.  ",2db9dbf71bf98d02a0bf33e798e5bfd2a9944696,0
RDS: null pointer dereference in rds_atomic_free_op,"set rm->atomic.op_active to 0 when rds_pin_pages() fails or the user supplied address is invalid, this prevents a NULL pointer usage in rds_atomic_free_op()  ",7d11f77f84b27cef452cee332f4e469503084737,1
ovl: avoid deadlock on directory ioctl,"The function ovl_dir_real_file() currently uses the inode lock to serialize writes to the od->upperfile field.  However, this function will get called by ovl_ioctl_set_flags(), which utilizes the inode lock too.  In this case ovl_dir_real_file() will try to claim a lock that is owned by a function in its call stack, which won't get released before ovl_dir_real_file() returns.  Fix by replacing the open coded compare and exchange by an explicit atomic op.  ",b854cc659dcb80f172cb35dbedc15d39d49c383f,0
media: msi2500: assign SPI bus number dynamically,"SPI bus number must be assigned dynamically for each device, otherwise it will crash when multiple devices are plugged to system.  ",9c60cc797cf72e95bb39f32316e9f0e5f85435f9,1
fuse: fix unlocked access to processing queue,"fuse_dev_release() assumes that it's the only one referencing the fpq->processing list, but that's not true, since fuse_abort_conn() can be doing the same without any serialization between the two.  ",45ff350bbd9d0f0977ff270a0d427c71520c0c37,0
af_unix: fix holding spinlock in oob handling,syzkaller found that OOB code was holding spinlock while calling a function in which it could sleep.  ,876c14ad014d0e39c57cbfde53e13d17cdb6d645,1
fbmem: don't allow too huge resolutions,"syzbot is reporting page fault at vga16fb_fillrect() [1], for vga16fb_check_var() is failing to detect multiplication overflow.    if (vxres * vyres > maxmem) {     vyres = maxmem / vxres;     if (vyres < yres)       return -ENOMEM;   }  Since no module would accept too huge resolutions where multiplication overflow happens, let's reject in the common path.  ",8c28051cdcbe9dfcec6bd0a4709d67a09df6edae,1
tcp: do not release socket ownership in tcp_close(),"syzkaller was able to hit the WARN_ON(sock_owned_by_user(sk)); in tcp_close()  While a socket is being closed, it is very possible other threads find it in rtnetlink dump.  tcp_get_info() will acquire the socket lock for a short amount of time (slow = lock_sock_fast(sk)/unlock_sock_fast(sk, slow);), enough to trigger the warning.  ",8873c064d1de579ea23412a6d3eee972593f142b,1
timers: Move clearing of base::timer_running under base:: Lock,"syzbot reported KCSAN data races vs. timer_base::timer_running being set to NULL without holding base::lock in expire_timers().  This looks innocent and most reads are clearly not problematic, but Frederic identified an issue which is:   int data = 0;   void timer_func(struct timer_list *t)  {     data = 1;  }   CPU 0                                            CPU 1  ",bb7262b295472eb6858b5c49893954794027cd84,1
net/qrtr: restrict user-controlled length in qrtr_tun_write_iter(),syzbot found ,2a80c15812372e554474b1dba0b1d8e467af295d,0
USB: cdc-wdm: Make wdm_flush() interruptible and add wdm_fsync().,"syzbot is reporting hung task at wdm_flush() [1], for there is a circular dependency that wdm_flush() from flip_close() for /dev/cdc-wdm0 forever waits for /dev/raw-gadget to be closed while close() for /dev/raw-gadget cannot be called unless close() for /dev/cdc-wdm0 completes.  Tetsuo Handa considered that such circular dependency is an usage error [2] which corresponds to an unresponding broken hardware [3]. But Alan Stern responded that we should be prepared for such hardware [4]. Therefore, this patch changes wdm_flush() to use wait_event_interruptible_timeout() which gives up after 30 seconds, for hardware that remains silent must be ignored. The 30 seconds are coming out of thin air.  Changing wait_event() to wait_event_interruptible_timeout() makes error reporting from close() syscall less reliable. To compensate it, this patch also implements wdm_fsync() which does not use timeout. Those who want to be very sure that data has gone out to the device are now advised to call fsync(), with a caveat that fsync() can return -EINVAL when running on older kernels which do not implement wdm_fsync().  This patch also fixes three more problems (listed below) found during exhaustive discussion and testing.    Since multiple threads can concurrently call wdm_write()/wdm_flush(),   we need to use wake_up_all() whenever clearing WDM_IN_USE in order to   make sure that all waiters are woken up. Also, error reporting needs   to use fetch-and-clear approach in order not to report same error for   multiple times.    Since wdm_flush() checks WDM_DISCONNECTING, wdm_write() should as well   check WDM_DISCONNECTING.    In wdm_flush(), since locks are not held, it is not safe to dereference   desc->intf after checking that WDM_DISCONNECTING is not set [5]. Thus,   remove dev_err() from wdm_flush().  [1] https://syzkaller.appspot.com/bug?id=e7b761593b23eb50855b9ea31e3be5472b711186 [2] https://lkml.kernel.org/r/27b7545e-8f41-10b8-7c02-e35a08eb1611@i-love.sakura.ne.jp [3] https://lkml.kernel.org/r/79ba410f-e0ef-2465-b94f-6b9a4a82adf5@i-love.sakura.ne.jp [4] https://lkml.kernel.org/r/20200530011040.GB12419@rowland.harvard.edu [5] https://lkml.kernel.org/r/c85331fc-874c-6e46-a77f-0ef1dc075308@i-love.sakura.ne.jp  ",37d2a36394d954413a495da61da1b2a51ecd28ab,1
net: Properly unlink GRO packets on overflow.,"Just like with normal GRO processing, we have to initialize skb->next to NULL when we unlink overflow packets from the GRO hash lists.  ",ece23711dd956cd5053c9cb03e9fe0668f9c8894,1
net: skb_segment() should not return NULL,"syzbot caught a NULL deref [1], caused by skb_segment()  skb_segment() has many ""goto err;"" that assume the @err variable contains -ENOMEM.  A successful call to __skb_linearize() should not clear @err, otherwise a subsequent memory allocation error could return NULL.  While we are at it, we might use -EINVAL instead of -ENOMEM when MAX_SKB_FRAGS limit is reached.  [1] kasan: CONFIG_KASAN_INLINE enabled kasan: GPF could be caused by NULL-ptr deref or user memory access general protection fault: 0000 [#1] SMP KASAN CPU: 0 PID: 13285 Comm: syz-executor3 Not tainted 4.18.0-rc4+ #146 Hardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 01/01/2011 ",ff907a11a0d68a749ce1a321f4505c03bf72190c,1
"NFS: Fix a double unlock from nfs_match,get_client","Now that nfs_match_client drops the nfs_client_lock, we should be careful to always return it in the same condition: locked.  ",c260121a97a3e4df6536edbc2f26e166eff370ce,0
ALSA: usb-audio: Validate MS endpoint descriptors,"snd_usbmidi_get_ms_info() may access beyond the border when a malformed descriptor is passed.  This patch adds the sanity checks of the given MS endpoint descriptors, and skips invalid ones.  ",e84749a78dc82bc545f12ce009e3dbcc2c5a8a91,1
HID: hiddev: Fix race in in hiddev_disconnect(),"Syzbot reports that ""hiddev"" is used after it's free in hiddev_disconnect(). The hiddev_disconnect() function sets ""hiddev->exist = 0;"" so hiddev_release() can free it as soon as we drop the ""existancelock"" lock.  This patch moves the mutex_unlock(&hiddev->existancelock) until after we have finished using it.  ",5c02c447eaeda29d3da121a2e17b97ccaf579b51,1
rds: fix refcount bug in rds_sock_addref,syzbot was able to catch a bug in rds [1]  The issue here is that the socket might be found in a hash table but that its refcount has already be set to 0 by another cpu.  We need to use refcount_inc_not_zero() to be safe here.  [1]  refcount_t: increment on 0; use-after-free. ,6fa19f5637a6c22bc0999596bcc83bdcac8a4fa6,1
io_uring: harder fdinfo sq/cq ring iterating,"The ring iteration is racy, which isn't necessarily a problem except it can cause us to iterate the whole thing. That isn't desired or ideal, and it can lead to excessive runtimes of reading fdinfo.  Cap the iteration at tail - head OR the ring size. While in there, clean up the ring masking and just dump the raw values along with the masks. That provides more useful debug info.  ",f75d118349be055d47407b4ba4ceb98e6437e472,0
xsk: Fix umem cleanup bug at socket destruct,"Fix a bug that is triggered when a partially setup socket is destroyed. For a fully setup socket, a socket that has been bound to a device, the cleanup of the umem is performed at the end of the buffer pool's cleanup work queue item. This has to be performed in a work queue, and not in RCU cleanup, as it is doing a vunmap that cannot execute in interrupt context. However, when a socket has only been partially set up so that a umem has been created but the buffer pool has not, the code erroneously directly calls the umem cleanup function instead of using a work queue, and this leads to a BUG_ON() in vunmap().  As there in this case is no buffer pool, we cannot use its work queue, so we need to introduce a work queue for the umem and schedule this for the cleanup. So in the case there is no pool, we are going to use the umem's own work queue to schedule the cleanup. But if there is a pool, the cleanup of the umem is still being performed by the pool's work queue, as it is important that the umem is cleaned up after the pool.  ",537cf4e3cc2f6cc9088dcd6162de573f603adc29,1
media: vivid: set min width/height to a value > 0,The capture DV timings capabilities allowed for a minimum width and height of 0. So passing a timings struct with 0 values is allowed and will later cause a division by zero.  Ensure that the width and height must be >= 16 to avoid this.  ,9729d6d282a6d7ce88e64c9119cecdf79edf4e88,0
cdc_ncm: fix divide-by-zero caused by invalid wMaxPacketSize,"Endpoints with zero wMaxPacketSize are not usable for transferring data. Ignore such endpoints when looking for valid in, out and status pipes, to make the driver more robust against invalid and meaningless descriptors.  The wMaxPacketSize of the out pipe is used as divisor. So this change fixes a divide-by-zero bug.  ",3fe4b3351301660653a2bc73f2226da0ebd2b95e,0
xfrm: fix a warning in xfrm_policy_insert_list,This waring can be triggered simply by:    # ip xfrm policy update src 192.168.1.1/24 dst 192.168.1.2/24 dir in \     priority 1 mark 0 mask 0x10  #[1]   # ip xfrm policy update src 192.168.1.1/24 dst 192.168.1.2/24 dir in \     priority 2 mark 0 mask 0x1   #[2]   # ip xfrm policy update src 192.168.1.1/24 dst 192.168.1.2/24 dir in \     priority 2 mark 0 mask 0x10  #[3]  Then dmesg shows:    ,ed17b8d377eaf6b4a01d46942b4c647378a79bdd,0
llc: set SOCK_RCU_FREE in llc_sap_add_socket(),"WHen an llc sock is added into the sk_laddr_hash of an llc_sap, it is not marked with SOCK_RCU_FREE.  This causes that the sock could be freed while it is still being read by __llc_lookup_established() with RCU read lock. sock is refcounted, but with RCU read lock, nothing prevents the readers getting a zero refcnt.  Fix it by setting SOCK_RCU_FREE in llc_sap_add_socket().  ",5a8e7aea953bdb6d4da13aff6f1e7f9c62023499,0
mac80211-hwsim: fix late beacon hrtimer handling,"Thomas explained in https://lore.kernel.org/r/87mtoeb4hb.ffs@tglx that our handling of the hrtimer here is wrong: If the timer fires late (e.g. due to vCPU scheduling, as reported by Dmitry/syzbot) then it tries to actually rearm the timer at the next deadline, which might be in the past already:   1          2          3          N          N+1  |          |          |   ...    |          |   ^ intended to fire here (1)             ^ next deadline here (2)                                       ^ actually fired here  The next time it fires, it's later, but will still try to schedule for the next deadline (now 3), etc. until it catches up with N, but that might take a long time, causing stalls etc.  Now, all of this is simulation, so we just have to fix it, but note that the behaviour is wrong even per spec, since there's no value then in sending all those beacons unaligned - they should be aligned to the TBTT (1, 2, 3, ... in the picture), and if we're a bit (or a lot) late, then just resume at that point.  Therefore, change the code to use hrtimer_forward_now() which will ensure that the next firing of the timer would be at N+1 (in the picture), i.e. the next interval point after the current time.  Suggested-by: Thomas Gleixner <tglx@linutronix.de> ",313bbd1990b6ddfdaa7da098d0c56b098a833572,1
rtc: mc146818: Dont test for bit 0-5 in Register D,The recent change to validate the RTC turned out to be overly tight.  While it cures the problem on the reporters machine it breaks machines with Intel chipsets which use bit 0-5 of the D register. So check only for bit 6 being 0 which is the case on these Intel machines as well.  ,ebb22a05943666155e6da04407cc6e913974c78c,0
ALSA: hda - Downgrade error message for single-cmd fallback,"We made the error message for the CORB/RIRB communication clearer by upgrading to dev_WARN() so that user can notice better.  But this struck us like a boomerang: now it caught syzbot and reported back as a fatal issue although it's not really any too serious bug that worth for stopping the whole system.  OK, OK, let's be softy, downgrade it to the standard dev_err() again.  ",475feec0c41ad71cb7d02f0310e56256606b57c5,0
net/smc: reduce sock_put() for fallback sockets,smc_release() calls a sock_put() for smc fallback sockets to cover the passive closing sock_hold() in __smc_connect() and smc_tcp_listen_work(). This does not make sense for sockets in state SMC_LISTEN and SMC_INIT. An SMC socket stays in state SMC_INIT if connect fails. The sock_put in smc_connect_abort() does not cover all failures. Move it into smc_connect_decline_fallback().  ,e1bbdd57047454dad068dc36612dd60a57f4c58f,0
afs: Fix characters allowed into cell names,"The afs filesystem needs to prohibit certain characters from cell names, such as '/', as these are used to form filenames in procfs, leading to the following warning being generated:  	",a45ea48e2bcd92c1f678b794f488ca0bda9835b8,0
media: v4l2-core: ignore native time32 ioctls on 64-bit,"Syzbot found that passing ioctl command 0xc0505609 into a 64-bit kernel from a 32-bit process causes uninitialized kernel memory to get passed to drivers instead of the user space data:  BUG: KMSAN: uninit-value in check_array_args drivers/media/v4l2-core/v4l2-ioctl.c:3041 [inline] BUG: KMSAN: uninit-value in video_usercopy+0x1631/0x3d30 drivers/media/v4l2-core/v4l2-ioctl.c:3315 CPU: 0 PID: 19595 Comm: syz-executor.4 Not tainted 5.11.0-rc7-syzkaller #0 Hardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 01/01/2011 Call Trace:  __dump_stack lib/dump_stack.c:79 [inline]  dump_stack+0x21c/0x280 lib/dump_stack.c:120  kmsan_report+0xfb/0x1e0 mm/kmsan/kmsan_report.c:118  __msan_warning+0x5f/0xa0 mm/kmsan/kmsan_instr.c:197  check_array_args drivers/media/v4l2-core/v4l2-ioctl.c:3041 [inline]  video_usercopy+0x1631/0x3d30 drivers/media/v4l2-core/v4l2-ioctl.c:3315  video_ioctl2+0x9f/0xb0 drivers/media/v4l2-core/v4l2-ioctl.c:3391  v4l2_ioctl+0x255/0x290 drivers/media/v4l2-core/v4l2-dev.c:360  v4l2_compat_ioctl32+0x2c6/0x370 drivers/media/v4l2-core/v4l2-compat-ioctl32.c:1248  __do_compat_sys_ioctl fs/ioctl.c:842 [inline]  __se_compat_sys_ioctl+0x53d/0x1100 fs/ioctl.c:793  __ia32_compat_sys_ioctl+0x4a/0x70 fs/ioctl.c:793  do_syscall_32_irqs_on arch/x86/entry/common.c:79 [inline]  __do_fast_syscall_32+0x102/0x160 arch/x86/entry/common.c:141  do_fast_syscall_32+0x6a/0xc0 arch/x86/entry/common.c:166  do_SYSENTER_32+0x73/0x90 arch/x86/entry/common.c:209  entry_SYSENTER_compat_after_hwframe+0x4d/0x5c  The time32 commands are defined but were never meant to be called on 64-bit machines, as those have always used time64 interfaces.  I missed this in my patch that introduced the time64 handling on 32-bit platforms.  The problem in this case is the mismatch of one function checking for the numeric value of the command and another function checking for the type of process (native vs compat) instead, with the result being that for this combination, nothing gets copied into the buffer at all.  Avoid this by only trying to convert the time32 commands when running on a 32-bit kernel where these are defined in a meaningful way.  [hverkuil: fix 3 warnings: switch with no cases]  ",c344f07aa1b4ba38ca8fabe407a2afe2f436323c,1
tipc: fix uninit-value in tipc_nl_compat_doit,"BUG: KMSAN: uninit-value in tipc_nl_compat_doit+0x404/0xa10 net/tipc/netlink_compat.c:335 CPU: 0 PID: 4514 Comm: syz-executor485 Not tainted 4.16.0+ #87 Hardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 01/01/2011 Call Trace:  __dump_stack lib/dump_stack.c:17 [inline]  dump_stack+0x185/0x1d0 lib/dump_stack.c:53  kmsan_report+0x142/0x240 mm/kmsan/kmsan.c:1067  __msan_warning_32+0x6c/0xb0 mm/kmsan/kmsan_instr.c:683  tipc_nl_compat_doit+0x404/0xa10 net/tipc/netlink_compat.c:335  tipc_nl_compat_recv+0x164b/0x2700 net/tipc/netlink_compat.c:1153  genl_family_rcv_msg net/netlink/genetlink.c:599 [inline]  genl_rcv_msg+0x1686/0x1810 net/netlink/genetlink.c:624  netlink_rcv_skb+0x378/0x600 net/netlink/af_netlink.c:2447  genl_rcv+0x63/0x80 net/netlink/genetlink.c:635  netlink_unicast_kernel net/netlink/af_netlink.c:1311 [inline]  netlink_unicast+0x166b/0x1740 net/netlink/af_netlink.c:1337  netlink_sendmsg+0x1048/0x1310 net/netlink/af_netlink.c:1900  sock_sendmsg_nosec net/socket.c:630 [inline]  sock_sendmsg net/socket.c:640 [inline]  ___sys_sendmsg+0xec0/0x1310 net/socket.c:2046  __sys_sendmsg net/socket.c:2080 [inline]  SYSC_sendmsg+0x2a3/0x3d0 net/socket.c:2091  SyS_sendmsg+0x54/0x80 net/socket.c:2087  do_syscall_64+0x309/0x430 arch/x86/entry/common.c:287  entry_SYSCALL_64_after_hwframe+0x3d/0xa2 ",2753ca5d9009c180dbfd4c802c80983b4b6108d1,1
loop: use worker per cgroup instead of kworker,"Patch series ""Charge loop device i/o to issuing cgroup"", v14.  The loop device runs all i/o to the backing file on a separate kworker thread which results in all i/o being charged to the root cgroup.  This allows a loop device to be used to trivially bypass resource limits and other policy.  This patch series fixes this gap in accounting.  A simple script to demonstrate this behavior on cgroupv2 machine:  ''' #!/bin/bash set -e  CGROUP=/sys/fs/cgroup/test.slice LOOP_DEV=/dev/loop0  if [",87579e9b7d8dc36e7cfc40c03f1ae5634e16e2c5,0
net: bridge: mcast: add and enforce startup query interval minimum,As reported[1] if startup query interval is set too low in combination with large number of startup queries and we have multiple bridges or even a single bridge with multiple querier vlans configured we can crash the machine. Add a 1 second minimum which must be enforced by overwriting the value if set lower (i.e. without returning an error) to avoid breaking user-space. If that happens a log message is emitted to let the admin know that the startup interval has been set to the minimum. It doesn't make sense to make the startup interval lower than the normal query interval so use the same value of 1 second. The issue has been present since these intervals could be user-controlled.  [1] https://lore.kernel.org/netdev/e8b9ce41-57b9-b6e2-a46a-ff9c791cf0ba@gmail.com/  ,f83a112bd91a494cdee671aec74e777470fb4a07,1
KVM: fix unregistering coalesced mmio zone from wrong bus,"If you register a kvm_coalesced_mmio_zone with '.pio = 0' but then unregister it with '.pio = 1', KVM_UNREGISTER_COALESCED_MMIO will try to unregister it from KVM_PIO_BUS rather than KVM_MMIO_BUS, which is a no-op.  But it frees the kvm_coalesced_mmio_dev anyway, causing a use-after-free.  Fix it by only unregistering and freeing the zone if the correct value of 'pio' is provided.  ",987d1149be7ddcc1380ff946cf236874421a7e1b,1
mm: make wait_on_page_writeback() wait for multiple pending writebacks,"Ever since commit 2a9127fcf229 (""mm: rewrite wait_on_page_bit_common() logic"") we've had some very occasional reports of BUG_ON(PageWriteback) in write_cache_pages(), which we thought we already fixed in commit 073861ed77b6 (""mm: fix VM_BUG_ON(PageTail) and BUG_ON(PageWriteback)"").  But syzbot just reported another one, even with that commit in place.  And it turns out that there's a simpler way to trigger the BUG_ON() than the one Hugh found with page re-use.  It all boils down to the fact that the page writeback is ostensibly serialized by the page lock, but that isn't actually really true.  Yes, the people _setting_ writeback all do so under the page lock, but the actual clearing of the bit - and waking up any waiters - happens without any page lock.  This gives us this fairly simple race condition:    CPU1 = end previous writeback   CPU2 = start new writeback under page lock   CPU3 = write_cache_pages()    CPU1          CPU2            CPU3   ",c2407cf7d22d0c0d94cf20342b3b8f06f1d904e7,1
inet_diag: fix kernel-infoleak for UDP sockets,"KMSAN reported a kernel-infoleak [1], that can exploited by unpriv users.  After analysis it turned out UDP was not initializing r->idiag_expires. Other users of inet_sk_diag_fill() might make the same mistake in the future, so fix this in inet_sk_diag_fill().  [1] BUG: KMSAN: kernel-infoleak in instrument_copy_to_user include/linux/instrumented.h:121 [inline] BUG: KMSAN: kernel-infoleak in copyout lib/iov_iter.c:156 [inline] BUG: KMSAN: kernel-infoleak in _copy_to_iter+0x69d/0x25c0 lib/iov_iter.c:670  instrument_copy_to_user include/linux/instrumented.h:121 [inline]  copyout lib/iov_iter.c:156 [inline]  _copy_to_iter+0x69d/0x25c0 lib/iov_iter.c:670  copy_to_iter include/linux/uio.h:155 [inline]  simple_copy_to_iter+0xf3/0x140 net/core/datagram.c:519  __skb_datagram_iter+0x2cb/0x1280 net/core/datagram.c:425  skb_copy_datagram_iter+0xdc/0x270 net/core/datagram.c:533  skb_copy_datagram_msg include/linux/skbuff.h:3657 [inline]  netlink_recvmsg+0x660/0x1c60 net/netlink/af_netlink.c:1974  sock_recvmsg_nosec net/socket.c:944 [inline]  sock_recvmsg net/socket.c:962 [inline]  sock_read_iter+0x5a9/0x630 net/socket.c:1035  call_read_iter include/linux/fs.h:2156 [inline]  new_sync_read fs/read_write.c:400 [inline]  vfs_read+0x1631/0x1980 fs/read_write.c:481  ksys_read+0x28c/0x520 fs/read_write.c:619  __do_sys_read fs/read_write.c:629 [inline]  __se_sys_read fs/read_write.c:627 [inline]  __x64_sys_read+0xdb/0x120 fs/read_write.c:627  do_syscall_x64 arch/x86/entry/common.c:51 [inline]  do_syscall_64+0x54/0xd0 arch/x86/entry/common.c:82  entry_SYSCALL_64_after_hwframe+0x44/0xae  ",71ddeac8cd1d217744a0e060ff520e147c9328d1,1
"hugetlbfs: revert ""Use i_mmap_rwsem to fix page fault/truncate race""","This reverts c86aa7bbfd5568ba8a82d3635d8f7b8a8e06fe54  The reverted commit caused ABBA deadlocks when file migration raced with file eviction for specific hugetlbfs files.  This was discovered with a modified version of the LTP move_pages12 test.  The purpose of the reverted patch was to close a long existing race between hugetlbfs file truncation and page faults.  After more analysis of the patch and impacted code, it was determined that i_mmap_rwsem can not be used for all required synchronization.  Therefore, revert this patch while working an another approach to the underlying issue.  ",e7c58097793ef15d58fadf190ee58738fbf447cd,1
shmem: fix possible deadlocks on shmlock_user_lock,"Recent commit 71725ed10c40 (""mm: huge tmpfs: try to split_huge_page() when punching hole"") has allowed syzkaller to probe deeper, uncovering a long-standing lockdep issue between the irq-unsafe shmlock_user_lock, the irq-safe xa_lock on mapping->i_pages, and shmem inode's info->lock which nests inside xa_lock (or tree_lock) since 4.8's shmem_uncharge().  user_shm_lock(), servicing SysV shmctl(SHM_LOCK), wants shmlock_user_lock while its caller shmem_lock() holds info->lock with interrupts disabled; but hugetlbfs_file_setup() calls user_shm_lock() with interrupts enabled, and might be interrupted by a writeback endio wanting xa_lock on i_pages.  This may not risk an actual deadlock, since shmem inodes do not take part in writeback accounting, but there are several easy ways to avoid it.  Requiring interrupts disabled for shmlock_user_lock would be easy, but it's a high-level global lock for which that seems inappropriate. Instead, recall that the use of info->lock to guard info->flags in shmem_lock() dates from pre-3.1 days, when races with SHMEM_PAGEIN and SHMEM_TRUNCATE could occur: nowadays it serves no purpose, the only flag added or removed is VM_LOCKED itself, and calls to shmem_lock() an inode are already serialized by the caller.  Take info->lock out of the chain and the possibility of deadlock or lockdep warning goes away.  ",ea0dfeb4209b4eab954d6e00ed136bc6b48b380d,1
crypto: af_alg - fix race accessing cipher request,"When invoking an asynchronous cipher operation, the invocation of the callback may be performed before the subsequent operations in the initial code path are invoked. The callback deletes the cipher request data structure which implies that after the invocation of the asynchronous cipher operation, this data structure must not be accessed any more.  The setting of the return code size with the request data structure must therefore be moved before the invocation of the asynchronous cipher operation.  ",d53c5135792319e095bb126bc43b2ee98586f7fe,1
xfs: fix iclog allocation size,Properly allocate the space for the bio_vecs instead of just one byte per bio_vec.  ,89b171acb222dc5283c66a1e99f2ac835eab0a3c,0
net: fix a leak in register_netdevice(),"We have to free ""dev->name_node"" on this error path.  ",42c17fa69f9866a3f80ac196ce70b4fda1242717,0
HID: usbhid: Fix warning caused by 0-length input reports,"Syzbot found a warning caused by hid_submit_ctrl() submitting a control request to transfer a 0-length input report:  	usb 1-1: BOGUS control dir, pipe 80000280 doesn't match bRequestType a1  (The warning message is a little difficult to understand.  It means that the control request claims to be for an IN transfer but this contradicts the USB spec, which requires 0-length control transfers always to be in the OUT direction.)  Now, a zero-length report isn't good for anything and there's no reason for a device to have one, but the fuzzer likes to pick out these weird edge cases.  In the future, perhaps we will decide to reject 0-length reports at probe time.  For now, the simplest approach for avoiding these warnings is to pretend that the report actually has length 1.  ",0a824efdb724e07574bafcd2c2486b2a3de35ff6,0
sch_qfq: prevent shift-out-of-bounds in qfq_init_qdisc,"tx_queue_len can be set to ~0U, we need to be more careful about overflows.  __fls(0) is undefined, as this report shows:  UBSAN: shift-out-of-bounds in net/sched/sch_qfq.c:1430:24 shift exponent 51770272 is too large for 32-bit type 'int' CPU: 0 PID: 25574 Comm: syz-executor.0 Not tainted 5.16.0-rc7-syzkaller #0 Hardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 01/01/2011 Call Trace:  <TASK>  __dump_stack lib/dump_stack.c:88 [inline]  dump_stack_lvl+0x201/0x2d8 lib/dump_stack.c:106  ubsan_epilogue lib/ubsan.c:151 [inline]  __ubsan_handle_shift_out_of_bounds+0x494/0x530 lib/ubsan.c:330  qfq_init_qdisc+0x43f/0x450 net/sched/sch_qfq.c:1430  qdisc_create+0x895/0x1430 net/sched/sch_api.c:1253  tc_modify_qdisc+0x9d9/0x1e20 net/sched/sch_api.c:1660  rtnetlink_rcv_msg+0x934/0xe60 net/core/rtnetlink.c:5571  netlink_rcv_skb+0x200/0x470 net/netlink/af_netlink.c:2496  netlink_unicast_kernel net/netlink/af_netlink.c:1319 [inline]  netlink_unicast+0x814/0x9f0 net/netlink/af_netlink.c:1345  netlink_sendmsg+0xaea/0xe60 net/netlink/af_netlink.c:1921  sock_sendmsg_nosec net/socket.c:704 [inline]  sock_sendmsg net/socket.c:724 [inline]  ____sys_sendmsg+0x5b9/0x910 net/socket.c:2409  ___sys_sendmsg net/socket.c:2463 [inline]  __sys_sendmsg+0x280/0x370 net/socket.c:2492  do_syscall_x64 arch/x86/entry/common.c:50 [inline]  do_syscall_64+0x44/0xd0 arch/x86/entry/common.c:80  entry_SYSCALL_64_after_hwframe+0x44/0xae  ",7d18a07897d07495ee140dd319b0e9265c0f68ba,1
netfilter: add back stackpointer size checks,"The rationale for removing the check is only correct for rulesets generated by ip(6)tables.  In iptables, a jump can only occur to a user-defined chain, i.e. because we size the stack based on number of user-defined chains we cannot exceed stack size.  However, the underlying binary format has no such restriction, and the validation step only ensures that the jump target is a valid rule start point.  IOW, its possible to build a rule blob that has no user-defined chains but does contain a jump.  If this happens, no jump stack gets allocated and crash occurs because no jumpstack was allocated.  ",57ebd808a97d7c5b1e1afb937c2db22beba3c1f8,1
netfilter: nf_tables: fix potential NULL-ptr deref in nf_tables_dump_obj_done(),"If there is no NFTA_OBJ_TABLE and NFTA_OBJ_TYPE, the c.data will be NULL in nf_tables_getobj(). So before free filter->table in nf_tables_dump_obj_done(), we need to check if filter is NULL first.  ",8bea728dce8972e534e6b99fd550f7b5cc3864e8,0
xfrm: Reset secpath in xfrm failure,"In esp4_gro_receive() and esp6_gro_receive(), secpath can be allocated without adding xfrm state to xvec. Then, sp->xvec[sp->len - 1] would fail and result in dereferencing invalid pointer in esp4_gso_segment() and esp6_gso_segment(). Reset secpath if xfrm function returns error.  ",6ed69184ed9c43873b8a1ee721e3bf3c08c2c6be,0
net: sched: act_ctinfo: fix memory leak,"Implement a cleanup method to properly free ci->params  BUG: memory leak unreferenced object 0xffff88811746e2c0 (size 64):   comm ""syz-executor617"", pid 7106, jiffies 4294943055 (age 14.250s)   ",09d4f10a5e78d76a53e3e584f1e6a701b6d24108,1
net/sched: cbs: Set default link speed to 10 Mbps in cbs_set_port_rate,"The discussion to be made is absolutely the same as in the case of previous patch (""taprio: Set default link speed to 10 Mbps in taprio_set_picos_per_byte""). Nothing is lost when setting a default.  ",1c6c09a0ae62fa3ea8f8ead2ac3920e6fff2de64,0
HID: prodikeys: Fix general protection fault during probe,"The syzbot fuzzer provoked a general protection fault in the hid-prodikeys driver:  kasan: CONFIG_KASAN_INLINE enabled kasan: GPF could be caused by NULL-ptr deref or user memory access general protection fault: 0000 [#1] SMP KASAN CPU: 0 PID: 12 Comm: kworker/0:1 Not tainted 5.3.0-rc5+ #28 Hardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 01/01/2011 Workqueue: usb_hub_wq hub_event ",98375b86c79137416e9fd354177b85e768c16e56,1
gfs2: check for empty rgrp tree in gfs2_ri_update,"If gfs2 tries to mount a (corrupt) file system that has no resource groups it still tries to set preferences on the first one, which causes a kernel null pointer dereference. This patch adds a check to function gfs2_ri_update so this condition is detected and reported back as an error.  ",778721510e84209f78e31e2ccb296ae36d623f5e,1
ALSA: pcm: Abort properly at pending signal in OSS read/write loops,"The loops for read and write in PCM OSS emulation have no proper check of pending signals, and they keep processing even after user tries to break.  This results in a very long delay, often seen as RCU stall when a huge unprocessed bytes remain queued.  The bug could be easily triggered by syzkaller.  As a simple workaround, this patch adds the proper check of pending signals and aborts the loop appropriately.  ",29159a4ed7044c52e3e2cf1a9fb55cec4745c60b,1
rcu: Use *_ONCE() to protect lockless ->expmask accesses,The rcu_node structure's ->expmask field is accessed locklessly when starting a new expedited grace period and when reporting an expedited RCU CPU stall warning.  This commit therefore handles the former by taking a snapshot of ->expmask while the lock is held and the latter by applying READ_ONCE() to lockless reads and WRITE_ONCE() to the corresponding updates.  ,15c7c972cd26d89a26788e609c53b5a465324a6c,0
mac80211: pause TX while changing interface type,"syzbot reported a crash that happened when changing the interface type around a lot, and while it might have been easy to fix just the symptom there, a little deeper investigation found that really the reason is that we allowed packets to be transmitted while in the middle of changing the interface type.  Disallow TX by stopping the queues while changing the type.  ",054c9939b4800a91475d8d89905827bf9e1ad97a,1
slip: Fix use-after-free Read in slip_open,Slip_open doesn't clean-up device which registration failed from the slip_devs device list. On next open after failure this list is iterated and freed device is accessed. Fix this by calling sl_free_netdev in error path.  Here is the trace from the Syzbot:  __dump_stack lib/dump_stack.c:77 [inline] dump_stack+0x197/0x210 lib/dump_stack.c:118 print_address_description.constprop.0.cold+0xd4/0x30b mm/kasan/report.c:374 __kasan_report.cold+0x1b/0x41 mm/kasan/report.c:506 kasan_report+0x12/0x20 mm/kasan/common.c:634 __asan_report_load8_noabort+0x14/0x20 mm/kasan/generic_report.c:132 sl_sync drivers/net/slip/slip.c:725 [inline] slip_open+0xecd/0x11b7 drivers/net/slip/slip.c:801 tty_ldisc_open.isra.0+0xa3/0x110 drivers/tty/tty_ldisc.c:469 tty_set_ldisc+0x30e/0x6b0 drivers/tty/tty_ldisc.c:596 tiocsetd drivers/tty/tty_io.c:2334 [inline] tty_ioctl+0xe8d/0x14f0 drivers/tty/tty_io.c:2594 vfs_ioctl fs/ioctl.c:46 [inline] file_ioctl fs/ioctl.c:509 [inline] do_vfs_ioctl+0xdb6/0x13e0 fs/ioctl.c:696 ksys_ioctl+0xab/0xd0 fs/ioctl.c:713 __do_sys_ioctl fs/ioctl.c:720 [inline] __se_sys_ioctl fs/ioctl.c:718 [inline] __x64_sys_ioctl+0x73/0xb0 fs/ioctl.c:718 do_syscall_64+0xfa/0x760 arch/x86/entry/common.c:290 entry_SYSCALL_64_after_hwframe+0x49/0xbe  ,e58c1912418980f57ba2060017583067f5f71e52,1
net: fix possible NULL deref in sock_reserve_memory,"Sanity check in sock_reserve_memory() was not enough to prevent malicious user to trigger a NULL deref.  In this case, the isse is that sk_prot->memory_allocated is NULL.  Use standard sk_has_account() helper to deal with this.  BUG: KASAN: null-ptr-deref in instrument_atomic_read_write include/linux/instrumented.h:101 [inline] BUG: KASAN: null-ptr-deref in atomic_long_add_return include/linux/atomic/atomic-instrumented.h:1218 [inline] BUG: KASAN: null-ptr-deref in sk_memory_allocated_add include/net/sock.h:1371 [inline] BUG: KASAN: null-ptr-deref in sock_reserve_memory net/core/sock.c:994 [inline] BUG: KASAN: null-ptr-deref in sock_setsockopt+0x22ab/0x2b30 net/core/sock.c:1443 Write of size 8 at addr 0000000000000000 by task syz-executor.0/11270  CPU: 1 PID: 11270 Comm: syz-executor.0 Not tainted 5.15.0-syzkaller #0 Hardware name: QEMU Standard PC (Q35 + ICH9, 2009), BIOS 1.14.0-2 04/01/2014 Call Trace:  <TASK>  __dump_stack lib/dump_stack.c:88 [inline]  dump_stack_lvl+0xcd/0x134 lib/dump_stack.c:106  __kasan_report mm/kasan/report.c:446 [inline]  kasan_report.cold+0x66/0xdf mm/kasan/report.c:459  check_region_inline mm/kasan/generic.c:183 [inline]  kasan_check_range+0x13d/0x180 mm/kasan/generic.c:189  instrument_atomic_read_write include/linux/instrumented.h:101 [inline]  atomic_long_add_return include/linux/atomic/atomic-instrumented.h:1218 [inline]  sk_memory_allocated_add include/net/sock.h:1371 [inline]  sock_reserve_memory net/core/sock.c:994 [inline]  sock_setsockopt+0x22ab/0x2b30 net/core/sock.c:1443  __sys_setsockopt+0x4f8/0x610 net/socket.c:2172  __do_sys_setsockopt net/socket.c:2187 [inline]  __se_sys_setsockopt net/socket.c:2184 [inline]  __x64_sys_setsockopt+0xba/0x150 net/socket.c:2184  do_syscall_x64 arch/x86/entry/common.c:50 [inline]  do_syscall_64+0x35/0xb0 arch/x86/entry/common.c:80  entry_SYSCALL_64_after_hwframe+0x44/0xae ",d00c8ee31729248ba40b4ab25cd3b3b580c6f87c,1
SUNRPC: fix use-after-free in rpc_free_client_work(),"Parts of rpc_free_client() were recently moved to a separate rpc_free_clent_work().  This introduced a use-after-free as rpc_clnt_remove_pipedir() calls rpc_net_ns(), and that uses clnt->cl_xprt which has already been freed. So move the call to xprt_put() after the call to rpc_clnt_remove_pipedir().  ",31e9a7f353526bbe53165a292f8ea9695ead3168,1
xsk: fix potential crash in xsk_diag_put_umem(),"Fixes two typos in xsk_diag_put_umem()  syzbot reported the following crash :  kasan: CONFIG_KASAN_INLINE enabled kasan: GPF could be caused by NULL-ptr deref or user memory access general protection fault: 0000 [#1] PREEMPT SMP KASAN CPU: 1 PID: 7641 Comm: syz-executor946 Not tainted 5.0.0-rc7+ #95 Hardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 01/01/2011 ",915905f8b1d452e70ee6d8637c3f0fb55a39691d,1
Bluetooth: RFCOMM: fix ODEBUG bug in rfcomm_dev_ioctl,"Needn't call 'rfcomm_dlc_put' here, because 'rfcomm_dlc_exists' didn't increase dlc->refcnt.  ",71811cac8532b2387b3414f7cd8fe9e497482864,1
"NFS: Forbid setting AF_INET6 to ""struct sockaddr_in""->sin_family.","syzbot is reporting uninitialized value at rpc_sockaddr2uaddr() [1]. This is because syzbot is setting AF_INET6 to ""struct sockaddr_in""->sin_family (which is embedded into user-visible ""struct nfs_mount_data"" structure) despite nfs23_validate_mount_data() cannot pass sizeof(struct sockaddr_in6) bytes of AF_INET6 address to rpc_sockaddr2uaddr().  Since ""struct nfs_mount_data"" structure is user-visible, we can't change ""struct nfs_mount_data"" to use ""struct sockaddr_storage"". Therefore, assuming that everybody is using AF_INET family when passing address via ""struct nfs_mount_data""->addr, reject if its sin_family is not AF_INET.  [1] https://syzkaller.appspot.com/bug?id=599993614e7cbbf66bc2656a919ab2a95fb5d75c  ",7c2bd9a39845bfb6d72ddb55ce737650271f6f96,1
net: avoid updating qdisc_xmit_lock_key in netdev_update_lockdep_key(),"syzbot reported some bogus lockdep warnings, for example bad unlock balance in sch_direct_xmit(). They are due to a race condition between slow path and fast path, that is qdisc_xmit_lock_key gets re-registered in netdev_update_lockdep_key() on slow path, while we could still acquire the queue->_xmit_lock on fast path in this small window:  CPU A						CPU B 						__netif_tx_lock(); lockdep_unregister_key(qdisc_xmit_lock_key); 						__netif_tx_unlock(); lockdep_register_key(qdisc_xmit_lock_key);  In fact, unlike the addr_list_lock which has to be reordered when the master/slave device relationship changes, queue->_xmit_lock is only acquired on fast path and only when NETIF_F_LLTX is not set, so there is likely no nested locking for it.  Therefore, we can just get rid of re-registration of qdisc_xmit_lock_key.  ",53d374979ef147ab51f5d632dfe20b14aebeccd0,1
nbd: replace kill_bdev() with __invalidate_device() again,"Commit abbbdf12497d (""replace kill_bdev() with __invalidate_device()"") once did this, but 29eaadc03649 (""nbd: stop using the bdev everywhere"") resurrected kill_bdev() and it has been there since then. So buffer_head mappings still get killed on a server disconnection, and we can still hit the BUG_ON on a filesystem on the top of the nbd device.    EXT4-fs (nbd0): mounted filesystem with ordered data mode. Opts: (null)   block nbd0: Receive control failed (result -32)   block nbd0: shutting down sockets   print_req_error: I/O error, dev nbd0, sector 66264 flags 3000   EXT4-fs warning (device nbd0): htree_dirblock_to_tree:979: inode #2: lblock 0: comm ls: error -5 reading directory block   print_req_error: I/O error, dev nbd0, sector 2264 flags 3000   EXT4-fs error (device nbd0): __ext4_get_inode_loc:4690: inode #2: block 283: comm ls: unable to read itable block   EXT4-fs error (device nbd0) in ext4_reserve_inode_write:5894: IO failure   ",2b5c8f0063e4b263cf2de82029798183cf85c320,1
RDMA/rxe: Clear all QP fields if creation failed,"rxe_qp_do_cleanup() relies on valid pointer values in QP for the properly created ones, but in case rxe_qp_from_init() failed it was filled with garbage and caused tot the following error.    refcount_t: underflow; use-after-free.   ",67f29896fdc83298eed5a6576ff8f9873f709228,1
sctp: bring inet(6)_skb_parm back to sctp_input_cb,"inet(6)_skb_parm was removed from sctp_input_cb by Commit a1dd2cf2f1ae (""sctp: allow changing transport encap_port by peer packets""), as it thought sctp_input_cb->header is not used any more in SCTP.  syzbot reported a crash:    ",0356010d825eb18d9157408e8ca4ec4613d61398,1
vt: defer kfree() of vc_screenbuf in vc_do_resize(),"syzbot is reporting UAF bug in set_origin() from vc_do_resize() [1], for vc_do_resize() calls kfree(vc->vc_screenbuf) before calling set_origin().  Unfortunately, in set_origin(), vc->vc_sw->con_set_origin() might access vc->vc_pos when scroll is involved in order to manipulate cursor, but vc->vc_pos refers already released vc->vc_screenbuf until vc->vc_pos gets updated based on the result of vc->vc_sw->con_set_origin().  Preserving old buffer and tolerating outdated vc members until set_origin() completes would be easier than preventing vc->vc_sw->con_set_origin() from accessing outdated vc members.  [1] https://syzkaller.appspot.com/bug?id=6649da2081e2ebdc65c0642c214b27fe91099db3  ",f8d1653daec02315e06d30246cff4af72e76e54e,1
kbuild: lto: fix module versioning,"With CONFIG_MODVERSIONS, version information is linked into each compilation unit that exports symbols. With LTO, we cannot use this method as all C code is compiled into LLVM bitcode instead. This change collects symbol versions into .symversions files and merges them in link-vmlinux.sh where they are all linked into vmlinux.o at the same time.  ",38e89184900385b0dad1ee55c35ae8abcfee6ece,0
bonding: fix null dereference in bond_ipsec_add_sa(),"If bond doesn't have real device, bond->curr_active_slave is null. But bond_ipsec_add_sa() dereferences bond->curr_active_slave without null checking. So, null-ptr-deref would occur.  Test commands:     ip link add bond0 type bond     ip link set bond0 up     ip x s add proto esp dst 14.1.1.1 src 15.1.1.1 spi \ 0x07 mode transport reqid 0x07 replay-window 32 aead 'rfc4106(gcm(aes))' \ 0x44434241343332312423222114131211f4f3f2f1 128 sel src 14.0.0.52/24 \ dst 14.0.0.70/24 proto tcp offload dev bond0 dir in  Splat looks like: KASAN: null-ptr-deref in range [0x0000000000000000-0x0000000000000007] CPU: 4 PID: 680 Comm: ip Not tainted 5.13.0-rc3+ #1168 ",105cd17a866017b45f3c45901b394c711c97bf40,1
"perf/core: Fix lock inversion between perf,trace,cpuhp",Lockdep gifted us with noticing the following 4-way lockup scenario:          perf_trace_init()  #0       mutex_lock(&event_mutex)           perf_trace_event_init()             perf_trace_event_reg()               tp_event->class->reg() := tracepoint_probe_register  #1             mutex_lock(&tracepoints_mutex)                   trace_point_add_func()  #2                 static_key_enable()   #2     do_cpu_up()           perf_event_init_cpu()  #3         mutex_lock(&pmus_lock)  #4         mutex_lock(&ctx->mutex)          perf_event_task_disable()           mutex_lock(&current->perf_event_mutex)  #4       ctx = perf_event_ctx_lock()  #5       perf_event_for_each_child()          do_exit()           task_work_run()             __fput()               perf_release()                 perf_event_release_kernel()  #4               mutex_lock(&ctx->mutex)  #5               mutex_lock(&event->child_mutex)                   free_event()                     _free_event()                       event->destroy() := perf_trace_destroy  #0                     mutex_lock(&event_mutex);  Fix that by moving the free_event() out from under the locks.  ,82d94856fa221b5173eefd56bcd1057c037e9b07,0
af_unix: annote lockless accesses to unix_tot_inflight & gc_in_progress,"wait_for_unix_gc() reads unix_tot_inflight & gc_in_progress without synchronization.  Adds READ_ONCE()/WRITE_ONCE() and their associated comments to better document the intent.  BUG: KCSAN: data-race in unix_inflight / wait_for_unix_gc  write to 0xffffffff86e2b7c0 of 4 bytes by task 9380 on cpu 0:  unix_inflight+0x1e8/0x260 net/unix/scm.c:63  unix_attach_fds+0x10c/0x1e0 net/unix/scm.c:121  unix_scm_to_skb net/unix/af_unix.c:1674 [inline]  unix_dgram_sendmsg+0x679/0x16b0 net/unix/af_unix.c:1817  unix_seqpacket_sendmsg+0xcc/0x110 net/unix/af_unix.c:2258  sock_sendmsg_nosec net/socket.c:704 [inline]  sock_sendmsg net/socket.c:724 [inline]  ____sys_sendmsg+0x39a/0x510 net/socket.c:2409  ___sys_sendmsg net/socket.c:2463 [inline]  __sys_sendmmsg+0x267/0x4c0 net/socket.c:2549  __do_sys_sendmmsg net/socket.c:2578 [inline]  __se_sys_sendmmsg net/socket.c:2575 [inline]  __x64_sys_sendmmsg+0x53/0x60 net/socket.c:2575  do_syscall_x64 arch/x86/entry/common.c:50 [inline]  do_syscall_64+0x44/0xd0 arch/x86/entry/common.c:80  entry_SYSCALL_64_after_hwframe+0x44/0xae  read to 0xffffffff86e2b7c0 of 4 bytes by task 9375 on cpu 1:  wait_for_unix_gc+0x24/0x160 net/unix/garbage.c:196  unix_dgram_sendmsg+0x8e/0x16b0 net/unix/af_unix.c:1772  unix_seqpacket_sendmsg+0xcc/0x110 net/unix/af_unix.c:2258  sock_sendmsg_nosec net/socket.c:704 [inline]  sock_sendmsg net/socket.c:724 [inline]  ____sys_sendmsg+0x39a/0x510 net/socket.c:2409  ___sys_sendmsg net/socket.c:2463 [inline]  __sys_sendmmsg+0x267/0x4c0 net/socket.c:2549  __do_sys_sendmmsg net/socket.c:2578 [inline]  __se_sys_sendmmsg net/socket.c:2575 [inline]  __x64_sys_sendmmsg+0x53/0x60 net/socket.c:2575  do_syscall_x64 arch/x86/entry/common.c:50 [inline]  do_syscall_64+0x44/0xd0 arch/x86/entry/common.c:80  entry_SYSCALL_64_after_hwframe+0x44/0xae  value changed: 0x00000002 -> 0x00000004  Reported by Kernel Concurrency Sanitizer on: CPU: 1 PID: 9375 Comm: syz-executor.1 Not tainted 5.16.0-rc7-syzkaller #0 Hardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 01/01/2011  ",9d6d7f1cb67cdee15f1a0e85aacfb924e0e02435,1
9p/net: put a lower bound on msize,"If the requested msize is too small (either from command line argument or from the server version reply), we won't get any work done. If it's *really* too small, nothing will work, and this got caught by syzbot recently (on a new kmem_cache_create_usercopy() call)  Just set a minimum msize to 4k in both code paths, until someone complains they have a use-case for a smaller msize.  We need to check in both mount option and server reply individually because the msize for the first version request would be unchecked with just a global check on clnt->msize.  ",574d356b7a02c7e1b01a1d9cba8a26b3c2888f45,0
bonding: init notify_work earlier to avoid uninitialized use,"If bond_kobj_init() or later kzalloc() in bond_alloc_slave() fail, then we call kobject_put() on the slave->kobj. This in turn calls the release function slave_kobj_release() which will always try to cancel_delayed_work_sync(&slave->notify_work), which shouldn't be done on an uninitialized work struct.  Always initialize the work struct earlier to avoid problems here.  Syzbot bisected this down to a completely pointless commit, some fault injection may have been at work here that caused the alloc failure in the first place, which may interact badly with bisect.  ",35d96e631860226d5dc4de0fad0a415362ec2457,1
ipv6: fix suspicious RCU usage in rt6_dump_route(),"syzbot reminded us that rt6_nh_dump_exceptions() needs to be called with rcu_read_lock()  net/ipv6/route.c:1593 suspicious rcu_dereference_check() usage!  other info that might help us debug this:  rcu_scheduler_active = 2, debug_locks = 1 2 locks held by syz-executor609/8966:  #0: 00000000b7dbe288 (rtnl_mutex){+.+.}, at: netlink_dump+0xe7/0xfb0 net/netlink/af_netlink.c:2199  #1: 00000000f2d87c21 (&(&tb->tb6_lock)->rlock){+...}, at: spin_lock_bh include/linux/spinlock.h:343 [inline]  #1: 00000000f2d87c21 (&(&tb->tb6_lock)->rlock){+...}, at: fib6_dump_table.isra.0+0x37e/0x570 net/ipv6/ip6_fib.c:533  stack backtrace: CPU: 0 PID: 8966 Comm: syz-executor609 Not tainted 5.2.0-rc5+ #43 Hardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 01/01/2011 Call Trace:  __dump_stack lib/dump_stack.c:77 [inline]  dump_stack+0x172/0x1f0 lib/dump_stack.c:113  lockdep_rcu_suspicious+0x153/0x15d kernel/locking/lockdep.c:5250  fib6_nh_get_excptn_bucket+0x18e/0x1b0 net/ipv6/route.c:1593  rt6_nh_dump_exceptions+0x45/0x4d0 net/ipv6/route.c:5541  rt6_dump_route+0x904/0xc50 net/ipv6/route.c:5640  fib6_dump_node+0x168/0x280 net/ipv6/ip6_fib.c:467  fib6_walk_continue+0x4a9/0x8e0 net/ipv6/ip6_fib.c:1986  fib6_walk+0x9d/0x100 net/ipv6/ip6_fib.c:2034  fib6_dump_table.isra.0+0x38a/0x570 net/ipv6/ip6_fib.c:534  inet6_dump_fib+0x93c/0xb00 net/ipv6/ip6_fib.c:624  rtnl_dump_all+0x295/0x490 net/core/rtnetlink.c:3445  netlink_dump+0x558/0xfb0 net/netlink/af_netlink.c:2244  __netlink_dump_start+0x5b1/0x7d0 net/netlink/af_netlink.c:2352  netlink_dump_start include/linux/netlink.h:226 [inline]  rtnetlink_rcv_msg+0x73d/0xb00 net/core/rtnetlink.c:5182  netlink_rcv_skb+0x177/0x450 net/netlink/af_netlink.c:2477  rtnetlink_rcv+0x1d/0x30 net/core/rtnetlink.c:5237  netlink_unicast_kernel net/netlink/af_netlink.c:1302 [inline]  netlink_unicast+0x531/0x710 net/netlink/af_netlink.c:1328  netlink_sendmsg+0x8ae/0xd70 net/netlink/af_netlink.c:1917  sock_sendmsg_nosec net/socket.c:646 [inline]  sock_sendmsg+0xd7/0x130 net/socket.c:665  sock_write_iter+0x27c/0x3e0 net/socket.c:994  call_write_iter include/linux/fs.h:1872 [inline]  new_sync_write+0x4d3/0x770 fs/read_write.c:483  __vfs_write+0xe1/0x110 fs/read_write.c:496  vfs_write+0x20c/0x580 fs/read_write.c:558  ksys_write+0x14f/0x290 fs/read_write.c:611  __do_sys_write fs/read_write.c:623 [inline]  __se_sys_write fs/read_write.c:620 [inline]  __x64_sys_write+0x73/0xb0 fs/read_write.c:620  do_syscall_64+0xfd/0x680 arch/x86/entry/common.c:301  entry_SYSCALL_64_after_hwframe+0x49/0xbe ",3b525691529b01cbea03ce07e5df487da5e44a31,1
netfilter: x_tables: initialise match/target check parameter struct,"syzbot reports following splat:  BUG: KMSAN: uninit-value in ebt_stp_mt_check+0x24b/0x450  net/bridge/netfilter/ebt_stp.c:162  ebt_stp_mt_check+0x24b/0x450 net/bridge/netfilter/ebt_stp.c:162  xt_check_match+0x1438/0x1650 net/netfilter/x_tables.c:506  ebt_check_match net/bridge/netfilter/ebtables.c:372 [inline]  ebt_check_entry net/bridge/netfilter/ebtables.c:702 [inline]  The uninitialised access is    xt_mtchk_param->nft_compat  ... which should be set to 0. Fix it by zeroing the struct beforehand, same for tgchk.  ip(6)tables targetinfo uses c99-style initialiser, so no change needed there.  ",c568503ef02030f169c9e19204def610a3510918,1
bpf: reject any prog that failed read-only lock,"We currently lock any JITed image as read-only via bpf_jit_binary_lock_ro() as well as the BPF image as read-only through bpf_prog_lock_ro(). In the case any of these would fail we throw a WARN_ON_ONCE() in order to yell loudly to the log. Perhaps, to some extend, this may be comparable to an allocation where __GFP_NOWARN is explicitly not set.  Added via 65869a47f348 (""bpf: improve read-only handling""), this behavior is slightly different compared to any of the other in-kernel set_memory_ro() users who do not check the return code of set_memory_ro() and friends /at all/ (e.g. in the case of module_enable_ro() / module_disable_ro()). Given in BPF this is mandatory hardening step, we want to know whether there are any issues that would leave both BPF data writable. So it happens that syzkaller enabled fault injection and it triggered memory allocation failure deep inside x86's change_page_attr_set_clr() which was triggered from set_memory_ro().  Now, there are two options: i) leaving everything as is, and ii) reworking the image locking code in order to have a final checkpoint out of the central bpf_prog_select_runtime() which probes whether any of the calls during prog setup weren't successful, and then bailing out with an error. Option ii) is a better approach since this additional paranoia avoids altogether leaving any potential W+X pages from BPF side in the system. Therefore, lets be strict about it, and reject programs in such unlikely occasion. While testing I noticed also that one bpf_prog_lock_ro() call was missing on the outer dummy prog in case of calls, e.g. in the destructor we call bpf_prog_free_deferred() on the main prog where we try to bpf_prog_unlock_free() the program, and since we go via bpf_prog_select_runtime() do that as well.  ",9facc336876f7ecf9edba4c67b90426fde4ec898,1
io_uring: use current task creds instead of allocating a new one,"syzbot reports:  kasan: CONFIG_KASAN_INLINE enabled kasan: GPF could be caused by NULL-ptr deref or user memory access general protection fault: 0000 [#1] PREEMPT SMP KASAN CPU: 0 PID: 9217 Comm: io_uring-sq Not tainted 5.4.0-syzkaller #0 Hardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 01/01/2011 ",0b8c0ec7eedcd8f9f1a1f238d87f9b512b09e71a,1
proc: Use a dedicated lock in struct pid,syzbot wrote: > ,63f818f46af9f8b3f17b9695501e8d08959feb60,0
net_sched: fix a refcount_t issue with noop_qdisc,"syzkaller reported a refcount_t warning [1]  Issue here is that noop_qdisc refcnt was never really considered as a true refcount, since qdisc_destroy() found TCQ_F_BUILTIN set :  if (qdisc->flags & TCQ_F_BUILTIN ||     !refcount_dec_and_test(&qdisc->refcnt))) 	return;  Meaning that all atomic_inc() we did on noop_qdisc.refcnt were not really needed, but harmless until refcount_t came.  To fix this problem, we simply need to not increment noop_qdisc.refcnt, since we never decrement it.  [1] refcount_t: increment on 0; use-after-free. ",551143d8d954fe398324a5caa276f518466c428b,1
staging: wlan-ng: properly check endpoint types,"As syzkaller detected, wlan-ng driver does not do sanity check of endpoints in prism2sta_probe_usb(), add check for xfer direction and type  ",faaff9765664009c1c7c65551d32e9ed3b1dda8f,1
tun: correct header offsets in napi frags mode,"Tun in IFF_NAPI_FRAGS mode calls napi_gro_frags. Unlike netif_rx and netif_gro_receive, this expects skb->data to point to the mac layer.  But skb_probe_transport_header, __skb_get_hash_symmetric, and xdp_do_generic in tun_get_user need skb->data to point to the network header. Flow dissection also needs skb->protocol set, so eth_type_trans has to be called.  Ensure the link layer header lies in linear as eth_type_trans pulls ETH_HLEN. Then take the same code paths for frags as for not frags. Push the link layer header back just before calling napi_gro_frags.  By pulling up to ETH_HLEN from frag0 into linear, this disables the frag0 optimization in the special case when IFF_NAPI_FRAGS is used with zero length iov[0] (and thus empty skb->linear).  ",96aa1b22bd6bb9fccf62f6261f390ed6f3e7967f,0
ubi: fastmap: Free unused fastmap anchor peb during detach,"When CONFIG_MTD_UBI_FASTMAP is enabled, fm_anchor will be assigned a free PEB during ubi_wl_init() or ubi_update_fastmap(). However if fastmap is not used or disabled on the MTD device, ubi_wl_entry related with the PEB will not be freed during detach.  So Fix it by freeing the unused fastmap anchor during detach.  ",c16f39d14a7e0ec59881fbdb22ae494907534384,0
loop: Avoid circular locking dependency between loop_ctl_mutex and bd_mutex,Code in loop_change_fd() drops reference to the old file (and also the new file in a failure case) under loop_ctl_mutex. Similarly to a situation in loop_set_fd() this can create a circular locking dependency if this was the last reference holding the file open. Delay dropping of the file reference until we have released loop_ctl_mutex.  ,1dded9acf6dc9a34cd27fcf8815507e4e65b3c4f,0
macvlan: fix null dereference in macvlan_device_event(),"In the macvlan_device_event(), the list_first_entry_or_null() is used. This function could return null pointer if there is no node. But, the macvlan module doesn't check the null pointer. So, null-ptr-deref would occur.        bond0         |    +",4dee15b4fd0d61ec6bbd179238191e959d34cf7a,1
netfilter: on sockopt() acquire sock lock only in the required scope,"Syzbot reported several deadlocks in the netfilter area caused by rtnl lock and socket lock being acquired with a different order on different code paths, leading to backtraces like the following one:  ",3f34cfae1238848fd53f25e5c8fd59da57901f4b,0
block: nbd: add sanity check for first_minor,Syzbot hit ,b1a811633f7321cf1ae2bb76a66805b7720e44c9,1
hfsplus: don't return 0 when fill_super() failed,"syzbot is reporting NULL pointer dereference at mount_fs() [1].  This is because hfsplus_fill_super() is by error returning 0 when hfsplus_fill_super() detected invalid filesystem image, and mount_bdev() is returning NULL because dget(s->s_root) == NULL if s->s_root == NULL, and mount_fs() is accessing root->d_sb because IS_ERR(root) == false if root == NULL.  Fix this by returning -EINVAL when hfsplus_fill_super() detected invalid filesystem image.  [1] https://syzkaller.appspot.com/bug?id=21acb6850cecbc960c927229e597158cf35f33d0  ",7464726cb5998846306ed0a7d6714afb2e37b25d,1
bfs: don't use WARNING: string when it's just info.,"Make the printk() [bfs ""printf"" macro] seem less severe by changing """,dc889b8d4a8122549feabe99eead04e6b23b6513,0
kcm: do not attach PF_KCM sockets to avoid deadlock,"syzkaller had no problem to trigger a deadlock, attaching a KCM socket to another one (or itself). (original syzkaller report was a very confusing lockdep splat during a sendmsg())  It seems KCM claims to only support TCP, but no enforcement is done, so we might need to add additional checks.  ",351050ecd6523374b370341cc29fe61e2201556b,1
tipc: fix uninit-value in tipc_nl_compat_link_set,"syzbot reports following splat:  BUG: KMSAN: uninit-value in strlen+0x3b/0xa0 lib/string.c:486 CPU: 1 PID: 9306 Comm: syz-executor172 Not tainted 4.20.0-rc7+ #2 Hardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 01/01/2011 Call Trace:   __dump_stack lib/dump_stack.c:77 [inline]   dump_stack+0x173/0x1d0 lib/dump_stack.c:113   kmsan_report+0x12e/0x2a0 mm/kmsan/kmsan.c:613   __msan_warning+0x82/0xf0 mm/kmsan/kmsan_instr.c:313   strlen+0x3b/0xa0 lib/string.c:486   nla_put_string include/net/netlink.h:1154 [inline]   __tipc_nl_compat_link_set net/tipc/netlink_compat.c:708 [inline]   tipc_nl_compat_link_set+0x929/0x1220 net/tipc/netlink_compat.c:744   __tipc_nl_compat_doit net/tipc/netlink_compat.c:311 [inline]   tipc_nl_compat_doit+0x3aa/0xaf0 net/tipc/netlink_compat.c:344   tipc_nl_compat_handle net/tipc/netlink_compat.c:1107 [inline]   tipc_nl_compat_recv+0x14d7/0x2760 net/tipc/netlink_compat.c:1210   genl_family_rcv_msg net/netlink/genetlink.c:601 [inline]   genl_rcv_msg+0x185f/0x1a60 net/netlink/genetlink.c:626   netlink_rcv_skb+0x444/0x640 net/netlink/af_netlink.c:2477   genl_rcv+0x63/0x80 net/netlink/genetlink.c:637   netlink_unicast_kernel net/netlink/af_netlink.c:1310 [inline]   netlink_unicast+0xf40/0x1020 net/netlink/af_netlink.c:1336   netlink_sendmsg+0x127f/0x1300 net/netlink/af_netlink.c:1917   sock_sendmsg_nosec net/socket.c:621 [inline]   sock_sendmsg net/socket.c:631 [inline]   ___sys_sendmsg+0xdb9/0x11b0 net/socket.c:2116   __sys_sendmsg net/socket.c:2154 [inline]   __do_sys_sendmsg net/socket.c:2163 [inline]   __se_sys_sendmsg+0x305/0x460 net/socket.c:2161   __x64_sys_sendmsg+0x4a/0x70 net/socket.c:2161   do_syscall_64+0xbc/0xf0 arch/x86/entry/common.c:291   entry_SYSCALL_64_after_hwframe+0x63/0xe7  The uninitialised access happened in     nla_put_string(skb, TIPC_NLA_LINK_NAME, lc->name)  This is because lc->name string is not validated before it's used.  ",edf5ff04a45750ac8ce2435974f001dc9cfbf055,1
mptcp: fix double-unlock in mptcp_poll,"mptcp_connect/28740 is trying to release lock (sk_lock-AF_INET) at: [<ffffffff82c15869>] mptcp_poll+0xb9/0x550 but there are no more locks to release! Call Trace:  lock_release+0x50f/0x750  release_sock+0x171/0x1b0  mptcp_poll+0xb9/0x550  sock_poll+0x157/0x470  ? get_net_ns+0xb0/0xb0  do_sys_poll+0x63c/0xdd0  Problem is that __mptcp_tcp_fallback() releases the mptcp socket lock, but after recent change it doesn't do this in all of its return paths.  To fix this, remove the unlock from __mptcp_tcp_fallback() and always do the unlock in the caller.  Also add a small comment as to why we have this __mptcp_needs_tcp_fallback().  ",e154659ba39a1c2be576aaa0a5bda8088d707950,0
nbd: verify socket is supported during setup,nbd requires socket families to support the shutdown method so the nbd recv workqueue can be woken up from its sock_recvmsg call. If the socket does not support the callout we will leave recv works running or get hangs later when the device or module is removed.  This adds a check during socket connection/reconnection to make sure the socket being passed in supports the needed callout.  ,cf1b2326b734896734c6e167e41766f9cee7686a,0
loop: add recursion validation to LOOP_CHANGE_FD,"Refactor the validation code used in LOOP_SET_FD so it is also used in LOOP_CHANGE_FD.  Otherwise it is possible to construct a set of loop devices that all refer to each other.  This can lead to a infinite loop in starting with ""while (is_loop_device(f)) .."" in loop_set_fd().  Fix this by refactoring out the validation code and using it for LOOP_CHANGE_FD as well as LOOP_SET_FD.  ",d2ac838e4cd7e5e9891ecc094d626734b0245c99,1
net_sched: cls_route: remove the right filter from hashtable,"route4_change() allocates a new filter and copies values from the old one. After the new filter is inserted into the hash table, the old filter should be removed and freed, as the final step of the update.  However, the current code mistakenly removes the new one. This looks apparently wrong to me, and it causes double ""free"" and use-after-free too, as reported by syzbot.  ",ef299cc3fa1a9e1288665a9fdc8bff55629fd359,1
media: dvbdev: Fix memory leak in dvb_media_device_free(),"dvb_media_device_free() is leaking memory. Free `dvbdev->adapter->conn` before setting it to NULL, as documented in include/media/media-device.h: ""The media_entity instance itself must be freed explicitly by the driver if required.""   ",bf9a40ae8d722f281a2721779595d6df1c33a0bf,1
net: usb: sr9800: fix uninitialized local variable,Make sure res does not contain random value if the call to sr_read_cmd fails for some reason.  ,77b6d09f4ae66d42cd63b121af67780ae3d1a5e9,1
net_sched: gen_estimator: fix lockdep splat,"syzbot reported a lockdep splat in gen_new_estimator() / est_fetch_counters() when attempting to lock est->stats_lock.  Since est_fetch_counters() is called from BH context from timer interrupt, we need to block BH as well when calling it from process context.  Most qdiscs use per cpu counters and are immune to the problem, but net/sched/act_api.c and net/netfilter/xt_RATEEST.c are using a spinlock to protect their data. They both call gen_new_estimator() while object is created and not yet alive, so this bug could not trigger a deadlock, only a lockdep splat.  ",40ca54e3a686f13117f3de0c443f8026dadf7c44,0
sctp: fix race on sctp_id2asoc,"syzbot reported an use-after-free involving sctp_id2asoc.  Dmitry Vyukov helped to root cause it and it is because of reading the asoc after it was freed:          CPU 1                       CPU 2 (working on socket 1)            (working on socket 2) 	                         sctp_association_destroy sctp_id2asoc    spin lock      grab the asoc from idr    spin unlock                                    spin lock 				     remove asoc from idr 				   spin unlock 				   free(asoc)    if asoc->base.sk != sk ... [*]  This can only be hit if trying to fetch asocs from different sockets. As we have a single IDR for all asocs, in all SCTP sockets, their id is unique on the system. An application can try to send stuff on an id that matches on another socket, and the if in [*] will protect from such usage. But it didn't consider that as that asoc may belong to another socket, it may be freed in parallel (read: under another socket lock).  We fix it by moving the checks in [*] into the protected region. This fixes it because the asoc cannot be freed while the lock is held.  ",b336decab22158937975293aea79396525f92bb3,1
net/x25: Fix null-ptr-deref in x25_disconnect,"We should check null before do x25_neigh_put in x25_disconnect, otherwise may cause null-ptr-deref like this:   #include <sys/socket.h>  #include <linux/x25.h>   int main() {     int sck_x25;     sck_x25 = socket(AF_X25, SOCK_SEQPACKET, 0);     close(sck_x25);     return 0;  }  BUG: kernel NULL pointer dereference, ",8999dc89497ab1c80d0718828e838c7cd5f6bffe,1
bpf: tcp: Limit calling some tcp cc functions to CONFIG_DYNAMIC_FTRACE,"pahole currently only generates the btf_id for external function and ftrace-able function.  Some functions in the bpf_tcp_ca_kfunc_ids are static (e.g. cubictcp_init).  Thus, unless CONFIG_DYNAMIC_FTRACE is set, btf_ids for those functions will not be generated and the compilation fails during resolve_btfids.  This patch limits those functions to CONFIG_DYNAMIC_FTRACE.  I will address the pahole generation in a followup and then remove the CONFIG_DYNAMIC_FTRACE limitation.  ",7aae231ac93b9d9c45487dcafd844fa756069f3b,0
btrfs: don't access possibly stale fs_info data for printing duplicate device,"Syzbot reported a possible use-after-free when printing a duplicate device warning device_list_add().  At this point it can happen that a btrfs_device::fs_info is not correctly setup yet, so we're accessing stale data, when printing the warning message using the btrfs_printk() wrappers.    ",0697d9a610998b8bdee6b2390836cb2391d8fd1a,1
vhost: reject zero size iova range,We used to accept zero size iova range which will lead a infinite loop in translate_desc(). Fixing this by failing the request in this case.  ,813dbeb656d6c90266f251d8bd2b02d445afa63f,1
batman-adv: Avoid WARN on net_device without parent in netns,It is not allowed to use WARN* helpers on potential incorrect input from the user or transient problems because systems configured as panic_on_warn will reboot due to such a problem.  A NULL return value of __dev_get_by_index can be caused by various problems which can either be related to the system configuration or problems (incorrectly returned network namespaces) in other (virtual) net_device drivers. batman-adv should not cause a (harmful) WARN in this situation and instead only report it via a simple message.  ,955d3411a17f590364238bd0d3329b61f20c1cd2,0
xfrm_user: prevent leaking 2 bytes of kernel memory,"struct xfrm_userpolicy_type has two holes, so we should not use C99 style initializer.  KMSAN report:  BUG: KMSAN: kernel-infoleak in copyout lib/iov_iter.c:140 [inline] BUG: KMSAN: kernel-infoleak in _copy_to_iter+0x1b14/0x2800 lib/iov_iter.c:571 CPU: 1 PID: 4520 Comm: syz-executor841 Not tainted 4.17.0+ #5 Hardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 01/01/2011 Call Trace:  __dump_stack lib/dump_stack.c:77 [inline]  dump_stack+0x185/0x1d0 lib/dump_stack.c:113  kmsan_report+0x188/0x2a0 mm/kmsan/kmsan.c:1117  kmsan_internal_check_memory+0x138/0x1f0 mm/kmsan/kmsan.c:1211  kmsan_copy_to_user+0x7a/0x160 mm/kmsan/kmsan.c:1253  copyout lib/iov_iter.c:140 [inline]  _copy_to_iter+0x1b14/0x2800 lib/iov_iter.c:571  copy_to_iter include/linux/uio.h:106 [inline]  skb_copy_datagram_iter+0x422/0xfa0 net/core/datagram.c:431  skb_copy_datagram_msg include/linux/skbuff.h:3268 [inline]  netlink_recvmsg+0x6f1/0x1900 net/netlink/af_netlink.c:1959  sock_recvmsg_nosec net/socket.c:802 [inline]  sock_recvmsg+0x1d6/0x230 net/socket.c:809  ___sys_recvmsg+0x3fe/0x810 net/socket.c:2279  __sys_recvmmsg+0x58e/0xe30 net/socket.c:2391  do_sys_recvmmsg+0x2a6/0x3e0 net/socket.c:2472  __do_sys_recvmmsg net/socket.c:2485 [inline]  __se_sys_recvmmsg net/socket.c:2481 [inline]  __x64_sys_recvmmsg+0x15d/0x1c0 net/socket.c:2481  do_syscall_64+0x15b/0x230 arch/x86/entry/common.c:287  entry_SYSCALL_64_after_hwframe+0x44/0xa9 ",45c180bc29babbedd6b8c01b975780ef44d9d09c,1
ipv4: add sanity checks in ipv4_link_failure(),"Before calling __ip_options_compile(), we need to ensure the network header is a an IPv4 one, and that it is already pulled in skb->head.  RAW sockets going through a tunnel can end up calling ipv4_link_failure() with total garbage in the skb, or arbitrary lengthes.  syzbot report :  BUG: KASAN: stack-out-of-bounds in memcpy include/linux/string.h:355 [inline] BUG: KASAN: stack-out-of-bounds in __ip_options_echo+0x294/0x1120 net/ipv4/ip_options.c:123 Write of size 69 at addr ffff888096abf068 by task syz-executor.4/9204  CPU: 0 PID: 9204 Comm: syz-executor.4 Not tainted 5.1.0-rc5+ #77 Hardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 01/01/2011 Call Trace:  __dump_stack lib/dump_stack.c:77 [inline]  dump_stack+0x172/0x1f0 lib/dump_stack.c:113  print_address_description.cold+0x7c/0x20d mm/kasan/report.c:187  kasan_report.cold+0x1b/0x40 mm/kasan/report.c:317  check_memory_region_inline mm/kasan/generic.c:185 [inline]  check_memory_region+0x123/0x190 mm/kasan/generic.c:191  memcpy+0x38/0x50 mm/kasan/common.c:133  memcpy include/linux/string.h:355 [inline]  __ip_options_echo+0x294/0x1120 net/ipv4/ip_options.c:123  __icmp_send+0x725/0x1400 net/ipv4/icmp.c:695  ipv4_link_failure+0x29f/0x550 net/ipv4/route.c:1204  dst_link_failure include/net/dst.h:427 [inline]  vti6_xmit net/ipv6/ip6_vti.c:514 [inline]  vti6_tnl_xmit+0x10d4/0x1c0c net/ipv6/ip6_vti.c:553  __netdev_start_xmit include/linux/netdevice.h:4414 [inline]  netdev_start_xmit include/linux/netdevice.h:4423 [inline]  xmit_one net/core/dev.c:3292 [inline]  dev_hard_start_xmit+0x1b2/0x980 net/core/dev.c:3308  __dev_queue_xmit+0x271d/0x3060 net/core/dev.c:3878  dev_queue_xmit+0x18/0x20 net/core/dev.c:3911  neigh_direct_output+0x16/0x20 net/core/neighbour.c:1527  neigh_output include/net/neighbour.h:508 [inline]  ip_finish_output2+0x949/0x1740 net/ipv4/ip_output.c:229  ip_finish_output+0x73c/0xd50 net/ipv4/ip_output.c:317  NF_HOOK_COND include/linux/netfilter.h:278 [inline]  ip_output+0x21f/0x670 net/ipv4/ip_output.c:405  dst_output include/net/dst.h:444 [inline]  NF_HOOK include/linux/netfilter.h:289 [inline]  raw_send_hdrinc net/ipv4/raw.c:432 [inline]  raw_sendmsg+0x1d2b/0x2f20 net/ipv4/raw.c:663  inet_sendmsg+0x147/0x5d0 net/ipv4/af_inet.c:798  sock_sendmsg_nosec net/socket.c:651 [inline]  sock_sendmsg+0xdd/0x130 net/socket.c:661  sock_write_iter+0x27c/0x3e0 net/socket.c:988  call_write_iter include/linux/fs.h:1866 [inline]  new_sync_write+0x4c7/0x760 fs/read_write.c:474  __vfs_write+0xe4/0x110 fs/read_write.c:487  vfs_write+0x20c/0x580 fs/read_write.c:549  ksys_write+0x14f/0x2d0 fs/read_write.c:599  __do_sys_write fs/read_write.c:611 [inline]  __se_sys_write fs/read_write.c:608 [inline]  __x64_sys_write+0x73/0xb0 fs/read_write.c:608  do_syscall_64+0x103/0x610 arch/x86/entry/common.c:290  entry_SYSCALL_64_after_hwframe+0x49/0xbe ",20ff83f10f113c88d0bb74589389b05250994c16,1
fsnotify: fix false positive warning on inode delete,"When inode is getting deleted and someone else holds reference to a mark attached to the inode, we just detach the connector from the inode. In that case fsnotify_put_mark() called from fsnotify_destroy_marks() will decide to recalculate mask for the inode and __fsnotify_recalc_mask() will WARN about invalid connector type:  ",d3bc0fa8411c35194f99046157e2e26fe60e1d91,0
mac80211: don't attempt to rename ERR_PTR() debugfs dirs,"We need to dereference the directory to get its parent to be able to rename it, so it's clearly not safe to try to do this with ERR_PTR() pointers. Skip in this case.  It seems that this is most likely what was causing the report by syzbot, but I'm not entirely sure as it didn't come with a reproducer this time.  ",517879147493a5e1df6b89a50f708f1133fcaddb,1
sched: etf: do not assume all sockets are full blown,"skb->sk does not always point to a full blown socket, we need to use sk_fullsock() before accessing fields which only make sense on full socket.  BUG: KASAN: use-after-free in report_sock_error+0x286/0x300 net/sched/sch_etf.c:141 Read of size 1 at addr ffff88805eb9b245 by task syz-executor.5/9630  CPU: 1 PID: 9630 Comm: syz-executor.5 Not tainted 5.7.0-rc2-syzkaller #0 Hardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 01/01/2011 Call Trace:  <IRQ>  __dump_stack lib/dump_stack.c:77 [inline]  dump_stack+0x188/0x20d lib/dump_stack.c:118  print_address_description.constprop.0.cold+0xd3/0x315 mm/kasan/report.c:382  __kasan_report.cold+0x35/0x4d mm/kasan/report.c:511  kasan_report+0x33/0x50 mm/kasan/common.c:625  report_sock_error+0x286/0x300 net/sched/sch_etf.c:141  etf_enqueue_timesortedlist+0x389/0x740 net/sched/sch_etf.c:170  __dev_xmit_skb net/core/dev.c:3710 [inline]  __dev_queue_xmit+0x154a/0x30a0 net/core/dev.c:4021  neigh_hh_output include/net/neighbour.h:499 [inline]  neigh_output include/net/neighbour.h:508 [inline]  ip6_finish_output2+0xfb5/0x25b0 net/ipv6/ip6_output.c:117  __ip6_finish_output+0x442/0xab0 net/ipv6/ip6_output.c:143  ip6_finish_output+0x34/0x1f0 net/ipv6/ip6_output.c:153  NF_HOOK_COND include/linux/netfilter.h:296 [inline]  ip6_output+0x239/0x810 net/ipv6/ip6_output.c:176  dst_output include/net/dst.h:435 [inline]  NF_HOOK include/linux/netfilter.h:307 [inline]  NF_HOOK include/linux/netfilter.h:301 [inline]  ip6_xmit+0xe1a/0x2090 net/ipv6/ip6_output.c:280  tcp_v6_send_synack+0x4e7/0x960 net/ipv6/tcp_ipv6.c:521  tcp_rtx_synack+0x10d/0x1a0 net/ipv4/tcp_output.c:3916  inet_rtx_syn_ack net/ipv4/inet_connection_sock.c:669 [inline]  reqsk_timer_handler+0x4c2/0xb40 net/ipv4/inet_connection_sock.c:763  call_timer_fn+0x1ac/0x780 kernel/time/timer.c:1405  expire_timers kernel/time/timer.c:1450 [inline]  __run_timers kernel/time/timer.c:1774 [inline]  __run_timers kernel/time/timer.c:1741 [inline]  run_timer_softirq+0x623/0x1600 kernel/time/timer.c:1787  __do_softirq+0x26c/0x9f7 kernel/softirq.c:292  invoke_softirq kernel/softirq.c:373 [inline]  irq_exit+0x192/0x1d0 kernel/softirq.c:413  exiting_irq arch/x86/include/asm/apic.h:546 [inline]  smp_apic_timer_interrupt+0x19e/0x600 arch/x86/kernel/apic/apic.c:1140  apic_timer_interrupt+0xf/0x20 arch/x86/entry/entry_64.S:829  </IRQ> ",a1211bf9a7774706722ba3b18c6157d980319f79,1
Bluetooth: Fix slab-out-of-bounds read in hci_extended_inquiry_result_evt(),Check upon `num_rsp` is insufficient. A malformed event packet with a large `num_rsp` number makes hci_extended_inquiry_result_evt() go out of bounds. Fix it.  This patch fixes the following syzbot bug:      https://syzkaller.appspot.com/bug?id=4bf11aa05c4ca51ce0df86e500fce486552dc8d2  ,51c19bf3d5cfaa66571e4b88ba2a6f6295311101,1
"fs, elf: make sure to page align bss in load_elf_library","The current code does not make sure to page align bss before calling vm_brk(), and this can lead to a VM_BUG_ON() in __mm_populate() due to the requested lenght not being correctly aligned.  Let us make sure to align it properly.  Kees: only applicable to CONFIG_USELIB kernels: 32-bit and configured for libc5.  ",24962af7e1041b7e50c1bc71d8d10dc678c556b5,1
rcu: Avoid data-race in rcu_gp_fqs_check_wake(),"The rcu_gp_fqs_check_wake() function uses rcu_preempt_blocked_readers_cgp() to read ->gp_tasks while other cpus might overwrite this field.  We need READ_ONCE()/WRITE_ONCE() pairs to avoid compiler tricks and KCSAN splats like the following :  BUG: KCSAN: data-race in rcu_gp_fqs_check_wake / rcu_preempt_deferred_qs_irqrestore  write to 0xffffffff85a7f190 of 8 bytes by task 7317 on cpu 0:  rcu_preempt_deferred_qs_irqrestore+0x43d/0x580 kernel/rcu/tree_plugin.h:507  rcu_read_unlock_special+0xec/0x370 kernel/rcu/tree_plugin.h:659  __rcu_read_unlock+0xcf/0xe0 kernel/rcu/tree_plugin.h:394  rcu_read_unlock include/linux/rcupdate.h:645 [inline]  __ip_queue_xmit+0x3b0/0xa40 net/ipv4/ip_output.c:533  ip_queue_xmit+0x45/0x60 include/net/ip.h:236  __tcp_transmit_skb+0xdeb/0x1cd0 net/ipv4/tcp_output.c:1158  __tcp_send_ack+0x246/0x300 net/ipv4/tcp_output.c:3685  tcp_send_ack+0x34/0x40 net/ipv4/tcp_output.c:3691  tcp_cleanup_rbuf+0x130/0x360 net/ipv4/tcp.c:1575  tcp_recvmsg+0x633/0x1a30 net/ipv4/tcp.c:2179  inet_recvmsg+0xbb/0x250 net/ipv4/af_inet.c:838  sock_recvmsg_nosec net/socket.c:871 [inline]  sock_recvmsg net/socket.c:889 [inline]  sock_recvmsg+0x92/0xb0 net/socket.c:885  sock_read_iter+0x15f/0x1e0 net/socket.c:967  call_read_iter include/linux/fs.h:1864 [inline]  new_sync_read+0x389/0x4f0 fs/read_write.c:414  read to 0xffffffff85a7f190 of 8 bytes by task 10 on cpu 1:  rcu_gp_fqs_check_wake kernel/rcu/tree.c:1556 [inline]  rcu_gp_fqs_check_wake+0x93/0xd0 kernel/rcu/tree.c:1546  rcu_gp_fqs_loop+0x36c/0x580 kernel/rcu/tree.c:1611  rcu_gp_kthread+0x143/0x220 kernel/rcu/tree.c:1768  kthread+0x1d4/0x200 drivers/block/aoe/aoecmd.c:1253  ret_from_fork+0x1f/0x30 arch/x86/entry/entry_64.S:352  Reported by Kernel Concurrency Sanitizer on: CPU: 1 PID: 10 Comm: rcu_preempt Not tainted 5.3.0+ #0 Hardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 01/01/2011  ",6935c3983b246d5fbfebd3b891c825e65c118f2d,1
netrom: switch to sock timer API,sk_reset_timer() and sk_stop_timer() properly handle sock refcnt for timer function. Switching to them could fix a refcounting bug reported by syzbot.  ,63346650c1a94a92be61a57416ac88c0a47c4327,0
rcu: Use READ_ONCE() for ->expmask in rcu_read_unlock_special(),"The rcu_node structure's ->expmask field is updated only when holding the ->lock, but is also accessed locklessly.  This means that all ->expmask updates must use WRITE_ONCE() and all reads carried out without holding ->lock must use READ_ONCE().  This commit therefore changes the lockless ->expmask read in rcu_read_unlock_special() to use READ_ONCE().  ",c51f83c315c392d9776c33eb16a2fe1349d65c7f,0
USB: rio500: Fix lockdep violation,The syzbot fuzzer found a lockdep violation in the rio500 driver:  	,9472aff16ca0fd9351eea7773facef364743088f,0
io_uring: ignore double poll add on the same waitqueue head,"syzbot reports a deadlock, attempting to lock the same spinlock twice:  ",1c3b3e6527e57156bf4082f11c2151957560fe6a,0
reiserfs: only call unlock_new_inode() if I_NEW,"unlock_new_inode() is only meant to be called after a new inode has already been inserted into the hash table.  But reiserfs_new_inode() can call it even before it has inserted the inode, triggering the ",8859bf2b1278d064a139e3031451524a49a56bd0,0
strparser: initialize all callbacks,"commit bbb03029a899 (""strparser: Generalize strparser"") added more function pointers to 'struct strp_callbacks'; however, kcm_attach() was not updated to initialize them.  This could cause the ->lock() and/or ->unlock() function pointers to be set to garbage values, causing a crash in strp_work().  Fix the bug by moving the callback structs into static memory, so unspecified members are zeroed.  Also constify them while we're at it.  This bug was found by syzkaller, which encountered the following splat:      IP: 0x55     PGD 3b1ca067     P4D 3b1ca067     PUD 3b12f067     PMD 0      Oops: 0010 [#1] SMP KASAN     Dumping ftrace buffer:        (ftrace buffer empty)     ",3fd87127073292538047adf1c9c757e9cab0dd56,1
net/rds: An rds_sock is added too early to the hash table,"In rds_bind(), an rds_sock is added to the RDS bind hash table before rs_transport is set.  This means that the socket can be found by the receive code path when rs_transport is NULL.  And the receive code path de-references rs_transport for congestion update check.  This can cause a panic.  An rds_sock should not be added to the bind hash table before all the needed fields are set.  ",c5c1a030a7dbf8dd4e1fa4405ae9a89dc1d2a8db,0
net_sched: add a temporary refcnt for struct tcindex_data,"Although we intentionally use an ordered workqueue for all tc filter works, the ordering is not guaranteed by RCU work, given that tcf_queue_work() is esstenially a call_rcu().  This problem is demostrated by Thomas:    CPU 0:     tcf_queue_work()       tcf_queue_work(&r->rwork, tcindex_destroy_rexts_work);    -> Migration to CPU 1    CPU 1:      tcf_queue_work(&p->rwork, tcindex_destroy_work);  so the 2nd work could be queued before the 1st one, which leads to a free-after-free.  Enforcing this order in RCU work is hard as it requires to change RCU code too. Fortunately we can workaround this problem in tcindex filter by taking a temporary refcnt, we only refcnt it right before we begin to destroy it. This simplifies the code a lot as a full refcnt requires much more changes in tcindex_set_parms().  ",304e024216a802a7dc8ba75d36de82fa136bbf3e,0
net: bridge: fix under estimation in br_get_linkxstats_size(),"Commit de1799667b00 (""net: bridge: add STP xstats"") added an additional nla_reserve_64bit() in br_fill_linkxstats(), but forgot to update br_get_linkxstats_size() accordingly.  This can trigger the following in rtnl_stats_get()  	WARN_ON(err == -EMSGSIZE);  ",0854a0513321cf70bea5fa483ebcaa983cc7c62e,0
rxrpc: Fix potential deadlock,"There is a potential deadlock in rxrpc_peer_keepalive_dispatch() whereby rxrpc_put_peer() is called with the peer_hash_lock held, but if it reduces the peer's refcount to 0, rxrpc_put_peer() calls __rxrpc_put_peer() - which the tries to take the already held lock.  Fix this by providing a version of rxrpc_put_peer() that can be called in situations where the lock is already held.  The bug may produce the following lockdep report:  ",60034d3d146b11922ab1db613bce062dddc0327a,0
jfs: fix GPF in diFree,Avoid passing inode with JFS_SBI(inode->i_sb)->ipimap == NULL to diFree()[1]. GFP will appear:  	struct inode *ipimap = JFS_SBI(ip->i_sb)->ipimap; 	struct inomap *imap = JFS_IP(ipimap)->i_imap;  JFS_IP() will return invalid pointer when ipimap == NULL  Call Trace:  diFree+0x13d/0x2dc0 fs/jfs/jfs_imap.c:853 [1]  jfs_evict_inode+0x2c9/0x370 fs/jfs/inode.c:154  evict+0x2ed/0x750 fs/inode.c:578  iput_final fs/inode.c:1654 [inline]  iput.part.0+0x3fe/0x820 fs/inode.c:1680  iput+0x58/0x70 fs/inode.c:1670  ,9d574f985fe33efd6911f4d752de6f485a1ea732,0
crypto: algif_aead - fix reference counting of null skcipher,"In the AEAD interface for AF_ALG, the reference to the ""null skcipher"" held by each tfm was being dropped in the wrong place -- when each af_alg_ctx was freed instead of when the aead_tfm was freed.  As discovered by syzkaller, a specially crafted program could use this to cause the null skcipher to be freed while it is still in use.  Fix it by dropping the reference in the right place.  ",b32a7dc8aef1882fbf983eb354837488cc9d54dc,1
riscv: evaluate put_user() arg before enabling user access,"The <asm/uaccess.h> header has a problem with put_user(a, ptr) if the 'a' is not a simple variable, such as a function. This can lead to the compiler producing code as so:  1:	enable_user_access() 2:	evaluate 'a' into register 'r' 3:	put 'r' to 'ptr' 4:	disable_user_acess()  The issue is that 'a' is now being evaluated with the user memory protections disabled. So we try and force the evaulation by assigning 'x' to __val at the start, and hoping the compiler barriers in  enable_user_access() do the job of ordering step 2 before step 1.  This has shown up in a bug where 'a' sleeps and thus schedules out and loses the SR_SUM flag. This isn't sufficient to fully fix, but should reduce the window of opportunity. The first instance of this we found is in scheudle_tail() where the code does:  $ less -N kernel/sched/core.c  4263  if (current->set_child_tid) 4264         put_user(task_pid_vnr(current), current->set_child_tid);  Here, the task_pid_vnr(current) is called within the block that has enabled the user memory access. This can be made worse with KASAN which makes task_pid_vnr() a rather large call with plenty of opportunity to sleep.  ",285a76bb2cf51b0c74c634f2aaccdb93e1f2a359,1
workqueue: Only unregister a registered lockdep key,"The recent change to prevent use after free and a memory leak introduced an unconditional call to wq_unregister_lockdep() in the error handling path. If the lockdep key had not been registered yet, then the lockdep core emits a warning.  Only call wq_unregister_lockdep() if wq_register_lockdep() has been called first.  ",82efcab3b9f3ef59e9713237c6e3c05c3a95c1ae,1
rxrpc: Fix trace-after-put looking at the put peer record,"rxrpc_put_peer() calls trace_rxrpc_peer() after it has done the decrement of the refcount - which looks at the debug_id in the peer record.  But unless the refcount was reduced to zero, we no longer have the right to look in the record and, indeed, it may be deleted by some other thread.  Fix this by getting the debug_id out before decrementing the refcount and then passing that into the tracepoint.  This can cause the following symptoms:      BUG: KASAN: use-after-free in __rxrpc_put_peer net/rxrpc/peer_object.c:411     [inline]     BUG: KASAN: use-after-free in rxrpc_put_peer+0x685/0x6a0     net/rxrpc/peer_object.c:435     Read of size 8 at addr ffff888097ec0058 by task syz-executor823/24216  ",55f6c98e3674ce16038a1949c3f9ca5a9a99f289,1
"media: cpia2_usb: first wake up, then free in disconnect",Kasan reported a use after free in cpia2_usb_disconnect() It first freed everything and then woke up those waiting. The reverse order is correct.  ,eff73de2b1600ad8230692f00bc0ab49b166512a,1
io_uring: pin SQPOLL data before unlocking ring lock,"We need to re-check sqd->thread after we've dropped the lock. Pin the sqd before doing the lockdep lock dance, and check if the thread is alive after that. It's either NULL or alive, as the SQPOLL thread cannot exit without holding the same sqd->lock.  ",41d3a6bd1d37149b18331fc4bb789c5456a7aeb0,0
tcp: annotate tp->write_seq lockless reads,"There are few places where we fetch tp->write_seq while this field can change from IRQ or other cpu.  We need to add READ_ONCE() annotations, and also make sure write sides use corresponding WRITE_ONCE() to avoid store-tearing.  ",0f31746452e6793ad6271337438af8f4defb8940,0
sctp: return error if the asoc has been peeled off in sctp_wait_for_sndbuf,"After commit cea0cc80a677 (""sctp: use the right sk after waking up from wait_buf sleep""), it may change to lock another sk if the asoc has been peeled off in sctp_wait_for_sndbuf.  However, the asoc's new sk could be already closed elsewhere, as it's in the sendmsg context of the old sk that can't avoid the new sk's closing. If the sk's last one refcnt is held by this asoc, later on after putting this asoc, the new sk will be freed, while under it's own lock.  This patch is to revert that commit, but fix the old issue by returning error under the old sk's lock.  ",a0ff660058b88d12625a783ce9e5c1371c87951f,0
ipvs: fix buffer overflow with sync daemon and service,"syzkaller reports for buffer overflow for interface name when starting sync daemons [1]  What we do is that we copy user structure into larger stack buffer but later we search NUL past the stack buffer. The same happens for sched_name when adding/editing virtual server.  We are restricted by IP_VS_SCHEDNAME_MAXLEN and IP_VS_IFNAME_MAXLEN being used as size in include/uapi/linux/ip_vs.h, so they include the space for NUL.  As using strlcpy is wrong for unsafe source, replace it with strscpy and add checks to return EINVAL if source string is not NUL-terminated. The incomplete strlcpy fix comes from 2.6.13.  For the netlink interface reduce the len parameter for IPVS_DAEMON_ATTR_MCAST_IFN and IPVS_SVC_ATTR_SCHED_NAME, so that we get proper EINVAL.  [1] kernel BUG at lib/string.c:1052! invalid opcode: 0000 [#1] SMP KASAN Dumping ftrace buffer:     (ftrace buffer empty) ",52f96757905bbf0edef47f3ee6c7c784e7f8ff8a,1
netfilter: xt_hashlimit: unregister proc file before releasing mutex,"Before releasing the global mutex, we only unlink the hashtable from the hash list, its proc file is still not unregistered at this point. So syzbot could trigger a race condition where a parallel htable_create() could register the same file immediately after the mutex is released.  Move htable_remove_proc_entry() back to mutex protection to fix this. And, fold htable_destroy() into htable_put() to make the code slightly easier to understand.  ",99b79c3900d4627672c85d9f344b5b0f06bc2a4d,1
rsi: fix use-after-free on probe errors,"The driver would fail to stop the command timer in most error paths, something which specifically could lead to the timer being freed while still active on I/O errors during probe.  Fix this by making sure that each function starting the timer also stops it in all relevant error paths.  ",92aafe77123ab478e5f5095878856ab0424910da,1
Bluetooth: Fix slab-out-of-bounds read in hci_le_direct_adv_report_evt(),`num_reports` is not being properly checked. A malformed event packet with a large `num_reports` number makes hci_le_direct_adv_report_evt() read out of bounds. Fix it.  ,f7e0e8b2f1b0a09b527885babda3e912ba820798,1
cfg80211: fix memory leak of wiphy device name,"In wiphy_new_nm(), if an error occurs after dev_set_name() and device_initialize() have already been called, it's necessary to call put_device() (via wiphy_free()) to avoid a memory leak.  ",4f488fbca2a86cc7714a128952eead92cac279ab,1
ovl: add splice file read write helper,"Now overlayfs falls back to use default file splice read and write, which is not compatiple with overlayfs, returning EFAULT. xfstests generic/591 can reproduce part of this.  Tested this patch with xfstests auto group tests.  ",1a980b8cbf0059a5308eea61522f232fd03002e2,0
"vt: selection, push sel_lock up",sel_lock cannot nest in the console lock. ,e8c75a30a23c6ba63f4ef6895cbf41fd42f21aa2,0
net: silence KCSAN warnings about sk->sk_backlog.len reads,"sk->sk_backlog.len can be written by BH handlers, and read from process contexts in a lockless way.  Note the write side should also use WRITE_ONCE() or a variant. We need some agreement about the best way to do this.  syzbot reported :  BUG: KCSAN: data-race in tcp_add_backlog / tcp_grow_window.isra.0  write to 0xffff88812665f32c of 4 bytes by interrupt on cpu 1:  sk_add_backlog include/net/sock.h:934 [inline]  tcp_add_backlog+0x4a0/0xcc0 net/ipv4/tcp_ipv4.c:1737  tcp_v4_rcv+0x1aba/0x1bf0 net/ipv4/tcp_ipv4.c:1925  ip_protocol_deliver_rcu+0x51/0x470 net/ipv4/ip_input.c:204  ip_local_deliver_finish+0x110/0x140 net/ipv4/ip_input.c:231  NF_HOOK include/linux/netfilter.h:305 [inline]  NF_HOOK include/linux/netfilter.h:299 [inline]  ip_local_deliver+0x133/0x210 net/ipv4/ip_input.c:252  dst_input include/net/dst.h:442 [inline]  ip_rcv_finish+0x121/0x160 net/ipv4/ip_input.c:413  NF_HOOK include/linux/netfilter.h:305 [inline]  NF_HOOK include/linux/netfilter.h:299 [inline]  ip_rcv+0x18f/0x1a0 net/ipv4/ip_input.c:523  __netif_receive_skb_one_core+0xa7/0xe0 net/core/dev.c:5004  __netif_receive_skb+0x37/0xf0 net/core/dev.c:5118  netif_receive_skb_internal+0x59/0x190 net/core/dev.c:5208  napi_skb_finish net/core/dev.c:5671 [inline]  napi_gro_receive+0x28f/0x330 net/core/dev.c:5704  receive_buf+0x284/0x30b0 drivers/net/virtio_net.c:1061  virtnet_receive drivers/net/virtio_net.c:1323 [inline]  virtnet_poll+0x436/0x7d0 drivers/net/virtio_net.c:1428  napi_poll net/core/dev.c:6352 [inline]  net_rx_action+0x3ae/0xa50 net/core/dev.c:6418  read to 0xffff88812665f32c of 4 bytes by task 7292 on cpu 0:  tcp_space include/net/tcp.h:1373 [inline]  tcp_grow_window.isra.0+0x6b/0x480 net/ipv4/tcp_input.c:413  tcp_event_data_recv+0x68f/0x990 net/ipv4/tcp_input.c:717  tcp_rcv_established+0xbfe/0xf50 net/ipv4/tcp_input.c:5618  tcp_v4_do_rcv+0x381/0x4e0 net/ipv4/tcp_ipv4.c:1542  sk_backlog_rcv include/net/sock.h:945 [inline]  __release_sock+0x135/0x1e0 net/core/sock.c:2427  release_sock+0x61/0x160 net/core/sock.c:2943  tcp_recvmsg+0x63b/0x1a30 net/ipv4/tcp.c:2181  inet_recvmsg+0xbb/0x250 net/ipv4/af_inet.c:838  sock_recvmsg_nosec net/socket.c:871 [inline]  sock_recvmsg net/socket.c:889 [inline]  sock_recvmsg+0x92/0xb0 net/socket.c:885  sock_read_iter+0x15f/0x1e0 net/socket.c:967  call_read_iter include/linux/fs.h:1864 [inline]  new_sync_read+0x389/0x4f0 fs/read_write.c:414  __vfs_read+0xb1/0xc0 fs/read_write.c:427  vfs_read fs/read_write.c:461 [inline]  vfs_read+0x143/0x2c0 fs/read_write.c:446  Reported by Kernel Concurrency Sanitizer on: CPU: 0 PID: 7292 Comm: syz-fuzzer Not tainted 5.3.0+ #0 Hardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 01/01/2011  ",70c2655849a25431f31b505a07fe0c861e5e41fb,1
sctp: fix slab-out-of-bounds in SCTP_DELAYED_SACK processing,"This sockopt accepts two kinds of parameters, using struct sctp_sack_info and struct sctp_assoc_value. The mentioned commit didn't notice an implicit cast from the smaller (latter) struct to the bigger one (former) when copying the data from the user space, which now leads to an attempt to write beyond the buffer (because it assumes the storing buffer is bigger than the parameter itself).  Fix it by allocating a sctp_sack_info on stack and filling it out based on the small struct for the compat case.  Changelog stole from an earlier patch from Marcelo Ricardo Leitner.  ",dfd3d5266dc1d9a2b06e5a09bbff4cee547eeb5f,1
batman-adv: Avoid free/alloc race when handling OGM buffer,Each slave interface of an B.A.T.M.A.N. IV virtual interface has an OGM packet buffer which is initialized using data from netdevice notifier and other rtnetlink related hooks. It is sent regularly via various slave interfaces of the batadv virtual interface and in this process also modified (realloced) to integrate additional state information via TVLV containers.  It must be avoided that the worker item is executed without a common lock with the netdevice notifier/rtnetlink helpers. Otherwise it can either happen that half modified/freed data is sent out or functions modifying the OGM buffer try to access already freed memory regions.  ,40e220b4218bb3d278e5e8cc04ccdfd1c7ff8307,1
usblp: poison URBs upon disconnect,"syzkaller reported an URB that should have been killed to be active. We do not understand it, but this should fix the issue if it is real.  ",296a193b06120aa6ae7cf5c0d7b5e5b55968026e,1
ref_tracker: use __GFP_NOFAIL more carefully,syzbot was able to trigger this warning from new_slab() 		,c12837d1bb31032bead9060dec99ef310d5b9fb7,0
erspan: Check IFLA_GRE_ERSPAN_VER is set.,Add a check to make sure the IFLA_GRE_ERSPAN_VER is provided by users.  ,51fa960d3b5163b1af22efdebcabfccc5d615ad6,0
qrtr: Convert qrtr_ports from IDR to XArray,The XArray interface is easier for this driver to use.  Also fixes a bug reported by the improper use of GFP_ATOMIC.  ,3cbf7530a163d048a6376cd22fecb9cdcb23b192,0
driver core: Fix use-after-free and double free on glue directory,"There is a race condition between removing glue directory and adding a new device under the glue dir. It can be reproduced in following test:  CPU1:                                         CPU2:  device_add()   get_device_parent()     class_dir_create_and_add()       kobject_add_internal()         create_dir()    // create glue_dir                                                device_add()                                                 get_device_parent()                                                   kobject_get() // get glue_dir  device_del()   cleanup_glue_dir()     kobject_del(glue_dir)                                                  kobject_add()                                                   kobject_add_internal()                                                     create_dir() // in glue_dir                                                       sysfs_create_dir_ns()                                                         kernfs_create_dir_ns(sd)        sysfs_remove_dir() // glue_dir->sd=NULL       sysfs_put()        // free glue_dir->sd                                                            // sd is freed                                                           kernfs_new_node(sd)                                                             kernfs_get(glue_dir)                                                             kernfs_add_one()                                                             kernfs_put()  Before CPU1 remove last child device under glue dir, if CPU2 add a new device under glue dir, the glue_dir kobject reference count will be increase to 2 via kobject_get() in get_device_parent(). And CPU2 has been called kernfs_create_dir_ns(), but not call kernfs_new_node(). Meanwhile, CPU1 call sysfs_remove_dir() and sysfs_put(). This result in glue_dir->sd is freed and it's reference count will be 0. Then CPU2 call kernfs_get(glue_dir) will trigger a warning in kernfs_get() and increase it's reference count to 1. Because glue_dir->sd is freed by CPU1, the next call kernfs_add_one() by CPU2 will fail(This is also use-after-free) and call kernfs_put() to decrease reference count. Because the reference count is decremented to 0, it will also call kmem_cache_free() to free the glue_dir->sd again. This will result in double free.  In order to avoid this happening, we also should make sure that kernfs_node for glue_dir is released in CPU1 only when refcount for glue_dir kobj is 1 to fix this race.  The following calltrace is captured in kernel 4.14 with the following patch applied:  commit 726e41097920 (""drivers: core: Remove glue dirs from sysfs earlier"")  ",ac43432cb1f5c2950408534987e57c2071e24d8f,1
net: stricter validation of untrusted gso packets,"Syzkaller again found a path to a kernel crash through bad gso input: a packet with transport header extending beyond skb_headlen(skb).  Tighten validation at kernel entry:  - Verify that the transport header lies within the linear section.      To avoid pulling linux/tcp.h, verify just sizeof tcphdr.     tcp_gso_segment will call pskb_may_pull (th->doff * 4) before use.  - Match the gso_type against the ip_proto found by the flow dissector.  ",9274124f023b5c56dc4326637d4f787968b03607,1
ALSA: seq: Use bool for snd_seq_queue internal flags,"The snd_seq_queue struct contains various flags in the bit fields. Those are categorized to two different use cases, both of which are protected by different spinlocks.  That implies that there are still potential risks of the bad operations for bit fields by concurrent accesses.  For addressing the problem, this patch rearranges those flags to be a standard bool instead of a bit field.  ",4ebd47037027c4beae99680bff3b20fdee5d7c1e,0
can: peak_usb: pcan_usb_fd: Fix info-leaks to USB devices,Uninitialized Kernel memory can leak to USB devices.  Fix by using kzalloc() instead of kmalloc() on the affected buffers.  ,30a8beeb3042f49d0537b7050fd21b490166a3d9,0
net/packet: fix use-after-free,"We should put copy_skb in receive_queue only after a successful call to virtio_net_hdr_from_skb().  syzbot report :  BUG: KASAN: use-after-free in __skb_unlink include/linux/skbuff.h:1843 [inline] BUG: KASAN: use-after-free in __skb_dequeue include/linux/skbuff.h:1863 [inline] BUG: KASAN: use-after-free in skb_dequeue+0x16a/0x180 net/core/skbuff.c:2815 Read of size 8 at addr ffff8801b044ecc0 by task syz-executor217/4553  CPU: 0 PID: 4553 Comm: syz-executor217 Not tainted 4.18.0-rc1+ #111 Hardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 01/01/2011 Call Trace:  __dump_stack lib/dump_stack.c:77 [inline]  dump_stack+0x1c9/0x2b4 lib/dump_stack.c:113  print_address_description+0x6c/0x20b mm/kasan/report.c:256  kasan_report_error mm/kasan/report.c:354 [inline]  kasan_report.cold.7+0x242/0x2fe mm/kasan/report.c:412  __asan_report_load8_noabort+0x14/0x20 mm/kasan/report.c:433  __skb_unlink include/linux/skbuff.h:1843 [inline]  __skb_dequeue include/linux/skbuff.h:1863 [inline]  skb_dequeue+0x16a/0x180 net/core/skbuff.c:2815  skb_queue_purge+0x26/0x40 net/core/skbuff.c:2852  packet_set_ring+0x675/0x1da0 net/packet/af_packet.c:4331  packet_release+0x630/0xd90 net/packet/af_packet.c:2991  __sock_release+0xd7/0x260 net/socket.c:603  sock_close+0x19/0x20 net/socket.c:1186  __fput+0x35b/0x8b0 fs/file_table.c:209  ____fput+0x15/0x20 fs/file_table.c:243  task_work_run+0x1ec/0x2a0 kernel/task_work.c:113  exit_task_work include/linux/task_work.h:22 [inline]  do_exit+0x1b08/0x2750 kernel/exit.c:865  do_group_exit+0x177/0x440 kernel/exit.c:968  __do_sys_exit_group kernel/exit.c:979 [inline]  __se_sys_exit_group kernel/exit.c:977 [inline]  __x64_sys_exit_group+0x3e/0x50 kernel/exit.c:977  do_syscall_64+0x1b9/0x820 arch/x86/entry/common.c:290  entry_SYSCALL_64_after_hwframe+0x49/0xbe ",945d015ee0c3095d2290e845565a23dedfd8027c,1
ipv6/flowlabel: wait rcu grace period before put_pid(),"syzbot was able to catch a use-after-free read in pid_nr_ns() [1]  ip6fl_seq_show() seems to use RCU protection, dereferencing fl->owner.pid but fl_free() releases fl->owner.pid before rcu grace period is started.  [1]  BUG: KASAN: use-after-free in pid_nr_ns+0x128/0x140 kernel/pid.c:407 Read of size 4 at addr ffff888094012a04 by task syz-executor.0/18087  CPU: 0 PID: 18087 Comm: syz-executor.0 Not tainted 5.1.0-rc6+ #89 Hardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 01/01/2011 Call Trace:  __dump_stack lib/dump_stack.c:77 [inline]  dump_stack+0x172/0x1f0 lib/dump_stack.c:113  print_address_description.cold+0x7c/0x20d mm/kasan/report.c:187  kasan_report.cold+0x1b/0x40 mm/kasan/report.c:317  __asan_report_load4_noabort+0x14/0x20 mm/kasan/generic_report.c:131  pid_nr_ns+0x128/0x140 kernel/pid.c:407  ip6fl_seq_show+0x2f8/0x4f0 net/ipv6/ip6_flowlabel.c:794  seq_read+0xad3/0x1130 fs/seq_file.c:268  proc_reg_read+0x1fe/0x2c0 fs/proc/inode.c:227  do_loop_readv_writev fs/read_write.c:701 [inline]  do_loop_readv_writev fs/read_write.c:688 [inline]  do_iter_read+0x4a9/0x660 fs/read_write.c:922  vfs_readv+0xf0/0x160 fs/read_write.c:984  kernel_readv fs/splice.c:358 [inline]  default_file_splice_read+0x475/0x890 fs/splice.c:413  do_splice_to+0x12a/0x190 fs/splice.c:876  splice_direct_to_actor+0x2d2/0x970 fs/splice.c:953  do_splice_direct+0x1da/0x2a0 fs/splice.c:1062  do_sendfile+0x597/0xd00 fs/read_write.c:1443  __do_sys_sendfile64 fs/read_write.c:1498 [inline]  __se_sys_sendfile64 fs/read_write.c:1490 [inline]  __x64_sys_sendfile64+0x15a/0x220 fs/read_write.c:1490  do_syscall_64+0x103/0x610 arch/x86/entry/common.c:290  entry_SYSCALL_64_after_hwframe+0x49/0xbe ",6c0afef5fb0c27758f4d52b2210c61b6bd8b4470,1
Bluetooth: hci_uart: Check if socket buffer is ERR_PTR in h4_recv_buf(),"h4_recv_buf() callers store the return value to socket buffer and recursively pass the buffer to h4_recv_buf() without protection. So, ERR_PTR returned from h4_recv_buf() can be dereferenced, if called again before setting the socket buffer to NULL from previous error. Check if skb is ERR_PTR in h4_recv_buf().  ",1dc2d785156cbdc80806c32e8d2c7c735d0b4721,1
tipc: fix modprobe tipc failed after switch order of device registration,"Error message printed: modprobe: ERROR: could not insert 'tipc': Address family not supported by protocol. when modprobe tipc after the following patch: switch order of device registration, commit 7e27e8d6130c (""tipc: switch order of device registration to fix a crash"")  Because sock_create_kern(net, AF_TIPC, ...) called by tipc_topsrv_create_listener() in the initialization process of tipc_init_net(), so tipc_socket_init() must be execute before that. Meanwhile, tipc_net_id need to be initialized when sock_create() called, and tipc_socket_init() is no need to be called for each namespace.  I add a variable tipc_topsrv_net_ops, and split the register_pernet_subsys() of tipc into two parts, and split tipc_socket_init() with initialization of pernet params.  By the way, I fixed resources rollback error when tipc_bcast_init() failed in tipc_init_net().  ",526f5b851a96566803ee4bee60d0a34df56c77f8,1
net/smc: avoid fallback in case of non-blocking connect,"FASTOPEN is not possible with SMC. sendmsg() with msg_flag MSG_FASTOPEN triggers a fallback to TCP if the socket is in state SMC_INIT. But if a nonblocking connect is already started, fallback to TCP is no longer possible, even though the socket may still be in state SMC_INIT. And if a nonblocking connect is already started, a listen() call does not make sense.  ",cd2063604ea6a8c2683b4eb9b5f4c4da74592d87,0
sg: pass the device name to blk_trace_setup,Fix a regression that passed a NULL device name to blk_trace_setup accidentally.  ,1d1cf156dc176e30eeaced5cf1450d582d387b81,0
usbtmc: more sanity checking for packet size,A malicious device can make the driver divide ny zero with a nonsense maximum packet size.  ,de7b9aa633b693e77942e12f1769506efae6917b,1
can: j1939: fix kernel-infoleak in j1939_sk_sock2sockaddr_can(),"syzbot found that at least 2 bytes of kernel information were leaked during getsockname() on AF_CAN CAN_J1939 socket.  Since struct sockaddr_can has in fact two holes, simply clear the whole area before filling it with useful data.  BUG: KMSAN: kernel-infoleak in kmsan_copy_to_user+0x81/0x90 mm/kmsan/kmsan_hooks.c:253 CPU: 0 PID: 8466 Comm: syz-executor511 Not tainted 5.8.0-rc5-syzkaller #0 Hardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 01/01/2011 Call Trace:  __dump_stack lib/dump_stack.c:77 [inline]  dump_stack+0x21c/0x280 lib/dump_stack.c:118  kmsan_report+0xf7/0x1e0 mm/kmsan/kmsan_report.c:121  kmsan_internal_check_memory+0x238/0x3d0 mm/kmsan/kmsan.c:423  kmsan_copy_to_user+0x81/0x90 mm/kmsan/kmsan_hooks.c:253  instrument_copy_to_user include/linux/instrumented.h:91 [inline]  _copy_to_user+0x18e/0x260 lib/usercopy.c:39  copy_to_user include/linux/uaccess.h:186 [inline]  move_addr_to_user+0x3de/0x670 net/socket.c:237  __sys_getsockname+0x407/0x5e0 net/socket.c:1909  __do_sys_getsockname net/socket.c:1920 [inline]  __se_sys_getsockname+0x91/0xb0 net/socket.c:1917  __x64_sys_getsockname+0x4a/0x70 net/socket.c:1917  do_syscall_64+0xad/0x160 arch/x86/entry/common.c:386  entry_SYSCALL_64_after_hwframe+0x44/0xa9 ",38ba8b9241f5848a49b80fddac9ab5f4692e434e,1
net: avoid potential infinite loop in tc_ctl_action(),"tc_ctl_action() has the ability to loop forever if tcf_action_add() returns -EAGAIN.  This special case has been done in case a module needed to be loaded, but it turns out that tcf_add_notify() could also return -EAGAIN if the socket sk_rcvbuf limit is hit.  We need to separate the two cases, and only loop for the module loading case.  While we are at it, add a limit of 10 attempts since unbounded loops are always scary.  syzbot repro was something like :  socket(PF_NETLINK, SOCK_RAW|SOCK_NONBLOCK, NETLINK_ROUTE) = 3 write(3, ..., 38) = 38 setsockopt(3, SOL_SOCKET, SO_RCVBUF, [0], 4) = 0 sendmsg(3, {msg_name(0)=NULL, msg_iov(1)=[{..., 388}], msg_controllen=0, msg_flags=0x10}, ...)  NMI backtrace for cpu 0 CPU: 0 PID: 1054 Comm: khungtaskd Not tainted 5.4.0-rc1+ #0 Hardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 01/01/2011 Call Trace:  __dump_stack lib/dump_stack.c:77 [inline]  dump_stack+0x172/0x1f0 lib/dump_stack.c:113  nmi_cpu_backtrace.cold+0x70/0xb2 lib/nmi_backtrace.c:101  nmi_trigger_cpumask_backtrace+0x23b/0x28b lib/nmi_backtrace.c:62  arch_trigger_cpumask_backtrace+0x14/0x20 arch/x86/kernel/apic/hw_nmi.c:38  trigger_all_cpu_backtrace include/linux/nmi.h:146 [inline]  check_hung_uninterruptible_tasks kernel/hung_task.c:205 [inline]  watchdog+0x9d0/0xef0 kernel/hung_task.c:289  kthread+0x361/0x430 kernel/kthread.c:255  ret_from_fork+0x24/0x30 arch/x86/entry/entry_64.S:352 Sending NMI from CPU 0 to CPUs 1: NMI backtrace for cpu 1 CPU: 1 PID: 8859 Comm: syz-executor910 Not tainted 5.4.0-rc1+ #0 Hardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 01/01/2011 ",39f13ea2f61b439ebe0060393e9c39925c9ee28c,1
netfilter: ipt_CLUSTERIP: fix out-of-bounds accesses in clusterip_tg_check(),Commit 136e92bbec0a switched local_nodes from an array to a bitmask but did not add proper bounds checks. As the result clusterip_config_init_nodelist() can both over-read ipt_clusterip_tgt_info.local_nodes and over-write clusterip_config.local_nodes.  Add bounds checks for both.  ,1a38956cce5eabd7b74f94bab70265e4df83165e,1
xfrm: Use correct address family in xfrm_state_find,"The struct flowi must never be interpreted by itself as its size depends on the address family.  Therefore it must always be grouped with its original family value.  In this particular instance, the original family value is lost in the function xfrm_state_find.  Therefore we get a bogus read when it's coupled with the wrong family which would occur with inter- family xfrm states.  This patch fixes it by keeping the original family value.  Note that the same bug could potentially occur in LSM through the xfrm_state_pol_flow_match hook.  I checked the current code there and it seems to be safe for now as only secid is used which is part of struct flowi_common.  But that API should be changed so that so that we don't get new bugs in the future.  We could do that by replacing fl with just secid or adding a family field.  ",e94ee171349db84c7cfdc5fefbebe414054d0924,0
Input: ff-memless - kill timer in destroy(),No timer must be left running when the device goes away.  ,fa3a5a1880c91bb92594ad42dfe9eedad7996b86,0
vti6: better validate user provided tunnel names,Use valid_name() to make sure user does not provide illegal device name.  ,537b361fbcbcc3cd6fe2bb47069fd292b9256d16,0
binder: fix handling of misaligned binder object,Fixes crash found by syzbot: kernel BUG at drivers/android/binder_alloc.c:LINE! (2)  ,26528be6720bb40bc8844e97ee73a37e530e9c5e,1
sock_diag: fix use-after-free read in __sk_free,"We must not call sock_diag_has_destroy_listeners(sk) on a socket that has no reference on net structure.  BUG: KASAN: use-after-free in sock_diag_has_destroy_listeners include/linux/sock_diag.h:75 [inline] BUG: KASAN: use-after-free in __sk_free+0x329/0x340 net/core/sock.c:1609 Read of size 8 at addr ffff88018a02e3a0 by task swapper/1/0  CPU: 1 PID: 0 Comm: swapper/1 Not tainted 4.17.0-rc5+ #54 Hardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 01/01/2011 Call Trace:  <IRQ>  __dump_stack lib/dump_stack.c:77 [inline]  dump_stack+0x1b9/0x294 lib/dump_stack.c:113  print_address_description+0x6c/0x20b mm/kasan/report.c:256  kasan_report_error mm/kasan/report.c:354 [inline]  kasan_report.cold.7+0x242/0x2fe mm/kasan/report.c:412  __asan_report_load8_noabort+0x14/0x20 mm/kasan/report.c:433  sock_diag_has_destroy_listeners include/linux/sock_diag.h:75 [inline]  __sk_free+0x329/0x340 net/core/sock.c:1609  sk_free+0x42/0x50 net/core/sock.c:1623  sock_put include/net/sock.h:1664 [inline]  reqsk_free include/net/request_sock.h:116 [inline]  reqsk_put include/net/request_sock.h:124 [inline]  inet_csk_reqsk_queue_drop_and_put net/ipv4/inet_connection_sock.c:672 [inline]  reqsk_timer_handler+0xe27/0x10e0 net/ipv4/inet_connection_sock.c:739  call_timer_fn+0x230/0x940 kernel/time/timer.c:1326  expire_timers kernel/time/timer.c:1363 [inline]  __run_timers+0x79e/0xc50 kernel/time/timer.c:1666  run_timer_softirq+0x4c/0x70 kernel/time/timer.c:1692  __do_softirq+0x2e0/0xaf5 kernel/softirq.c:285  invoke_softirq kernel/softirq.c:365 [inline]  irq_exit+0x1d1/0x200 kernel/softirq.c:405  exiting_irq arch/x86/include/asm/apic.h:525 [inline]  smp_apic_timer_interrupt+0x17e/0x710 arch/x86/kernel/apic/apic.c:1052  apic_timer_interrupt+0xf/0x20 arch/x86/entry/entry_64.S:863  </IRQ> ",9709020c86f6bf8439ca3effc58cfca49a5de192,1
x86/insn-eval: Use new for_each_insn_prefix() macro to loop over prefixes bytes,"Since insn.prefixes.nbytes can be bigger than the size of insn.prefixes.bytes[] when a prefix is repeated, the proper check must be    insn.prefixes.bytes[i] != 0 and i < 4  instead of using insn.prefixes.nbytes. Use the new for_each_insn_prefix() macro which does it correctly.  Debugged by Kees Cook <keescook@chromium.org>.   ",12cb908a11b2544b5f53e9af856e6b6a90ed5533,0
ovl: fix lockdep warning for async write,"Lockdep reports """,c853680453ac235e9010987a8bdaaba0e116d3c8,0
net/packet: fix memory leak in packet_set_ring(),"syzbot found we can leak memory in packet_set_ring(), if user application provides buggy parameters.  ",55655e3d1197fff16a7a05088fb0e5eba50eac55,1
Bluetooth: hci_bcsp: Fix memory leak in rx_skb,Syzkaller found that it is possible to provoke a memory leak by never freeing rx_skb in struct bcsp_struct.  Fix by freeing in bcsp_close()  ,4ce9146e0370fcd573f0372d9b4e5a211112567c,1
mm: mempolicy: require at least one nodeid for MPOL_PREFERRED,"Using an empty (malformed) nodelist that is not caught during mount option parsing leads to a stack-out-of-bounds access.  The option string that was used was: ""mpol=prefer:,"".  However, MPOL_PREFERRED requires a single node number, which is not being provided here.  Add a check that 'nodes' is not empty after parsing for MPOL_PREFERRED's nodeid.  ",aa9f7d5172fac9bf1f09e678c35e287a40a7b7dd,1
udf: Fix memory leak when mounting,udf_process_sequence() allocates temporary array for processing partition descriptors on volume which it fails to free. Free the array when it is not needed anymore.  ,a7be300de800e755714c71103ae4a0d205e41e99,1
bdi: Fix oops in wb_workfn(),"Syzbot has reported that it can hit a NULL pointer dereference in wb_workfn() due to wb->bdi->dev being NULL. This indicates that wb_workfn() was called for an already unregistered bdi which should not happen as wb_shutdown() called from bdi_unregister() should make sure all pending writeback works are completed before bdi is unregistered. Except that wb_workfn() itself can requeue the work with:  	mod_delayed_work(bdi_wq, &wb->dwork, 0);  and if this happens while wb_shutdown() is waiting in:  	flush_delayed_work(&wb->dwork);  the dwork can get executed after wb_shutdown() has finished and bdi_unregister() has cleared wb->bdi->dev.  Make wb_workfn() use wakeup_wb() for requeueing the work which takes all the necessary precautions against racing with bdi unregistration.  CC: Tetsuo Handa <penguin-kernel@I-love.SAKURA.ne.jp> CC: Tejun Heo <tj@kernel.org> ",b8b784958eccbf8f51ebeee65282ca3fd59ea391,1
tls: fix use-after-free in tls_push_record,"syzkaller managed to trigger a use-after-free in tls like the following:    BUG: KASAN: use-after-free in tls_push_record.constprop.15+0x6a2/0x810 [tls]   Write of size 1 at addr ffff88037aa08000 by task a.out/2317    CPU: 3 PID: 2317 Comm: a.out Not tainted 4.17.0+ #144   Hardware name: LENOVO 20FBCTO1WW/20FBCTO1WW, BIOS N1FET47W (1.21 ) 11/28/2016   Call Trace:    dump_stack+0x71/0xab    print_address_description+0x6a/0x280    kasan_report+0x258/0x380    ? tls_push_record.constprop.15+0x6a2/0x810 [tls]    tls_push_record.constprop.15+0x6a2/0x810 [tls]    tls_sw_push_pending_record+0x2e/0x40 [tls]    tls_sk_proto_close+0x3fe/0x710 [tls]    ? tcp_check_oom+0x4c0/0x4c0    ? tls_write_space+0x260/0x260 [tls]    ? kmem_cache_free+0x88/0x1f0    inet_release+0xd6/0x1b0    __sock_release+0xc0/0x240    sock_close+0x11/0x20    __fput+0x22d/0x660    task_work_run+0x114/0x1a0    do_exit+0x71a/0x2780    ? mm_update_next_owner+0x650/0x650    ? handle_mm_fault+0x2f5/0x5f0    ? __do_page_fault+0x44f/0xa50    ? mm_fault_error+0x2d0/0x2d0    do_group_exit+0xde/0x300    __x64_sys_exit_group+0x3a/0x50    do_syscall_64+0x9a/0x300    ? page_fault+0x8/0x30    entry_SYSCALL_64_after_hwframe+0x44/0xa9  This happened through fault injection where aead_req allocation in tls_do_encryption() eventually failed and we returned -ENOMEM from the function. Turns out that the use-after-free is triggered from tls_sw_sendmsg() in the second tls_push_record(). The error then triggers a jump to waiting for memory in sk_stream_wait_memory() resp. returning immediately in case of MSG_DONTWAIT. What follows is the trim_both_sgl(sk, orig_size), which drops elements from the sg list added via tls_sw_sendmsg(). Now the use-after-free gets triggered when the socket is being closed, where tls_sk_proto_close() callback is invoked. The tls_complete_pending_work() will figure that there's a pending closed tls record to be flushed and thus calls into the tls_push_pending_closed_record() from there. ctx->push_pending_record() is called from the latter, which is the tls_sw_push_pending_record() from sw path. This again calls into tls_push_record(). And here the tls_fill_prepend() will panic since the buffer address has been freed earlier via trim_both_sgl(). One way to fix it is to move the aead request allocation out of tls_do_encryption() early into tls_push_record(). This means we don't prep the tls header and advance state to the TLS_PENDING_CLOSED_RECORD before allocation which could potentially fail happened. That fixes the issue on my side.  ",a447da7d00410278c90d3576782a43f8b675d7be,1
macsec: fix NULL dereference in macsec_upd_offload(),"macsec_upd_offload() gets the value of MACSEC_OFFLOAD_ATTR_TYPE without checking its presence in the request message, and this causes a NULL dereference. Fix it rejecting any configuration that does not include this attribute.  ",aa81700cf2326e288c9ca1fe7b544039617f1fc2,1
bonding: fix lockdep warning in bond_get_stats(),"In the ""struct bonding"", there is stats_lock. This lock protects ""bond_stats"" in the ""struct bonding"". bond_stats is updated in the bond_get_stats() and this function would be executed concurrently. So, the lock is needed.  Bonding interfaces would be nested. So, either stats_lock should use dynamic lockdep class key or stats_lock should be used by spin_lock_nested(). In the current code, stats_lock is using a dynamic lockdep class key. But there is no updating stats_lock_key routine So, lockdep warning will occur.  Test commands:     ip link add bond0 type bond     ip link add bond1 type bond     ip link set bond0 master bond1     ip link set bond0 nomaster     ip link set bond1 master bond0  Splat looks like: ",b3e80d44f5b1b470dd9e2dbc6816e63a5c519709,0
taprio: Fix allowing too small intervals,It's possible that the user specifies an interval that couldn't allow any packet to be transmitted. This also avoids the issue of the hrtimer handler starving the other threads because it's running too often.  The solution is to reject interval sizes that according to the current link speed wouldn't allow any packet to be transmitted.  ,b5b73b26b3ca34574124ed7ae9c5ba8391a7f176,0
ALSA: pcm: oss: Remove superfluous WARN_ON() for mulaw sanity check,"The PCM OSS mulaw plugin has a check of the format of the counter part whether it's a linear format.  The check is with snd_BUG_ON() that emits WARN_ON() when the debug config is set, and it confuses syzkaller as if it were a serious issue.  Let's drop snd_BUG_ON() for avoiding that.  While we're at it, correct the error code to a more suitable, EINVAL.  ",949a1ebe8cea7b342085cb6a4946b498306b9493,1
mwifiex: don't call del_timer_sync() on uninitialized timer,"syzbot is reporting that del_timer_sync() is called from mwifiex_usb_cleanup_tx_aggr() from mwifiex_unregister_dev() without checking timer_setup() from mwifiex_usb_tx_init() was called [1].  Ganapathi Bhat proposed a possibly cleaner fix, but it seems that that fix was forgotten [2].  ""grep -FrB1 'del_timer' drivers/ | grep -FA1 '.function)'"" says that currently there are 28 locations which call del_timer[_sync]() only if that timer's function field was initialized (because timer_setup() sets that timer's function field). Therefore, let's use same approach here.  [1] https://syzkaller.appspot.com/bug?id=26525f643f454dd7be0078423e3cdb0d57744959 [2] https://lkml.kernel.org/r/CA+ASDXMHt2gq9Hy+iP_BYkWXsSreWdp3_bAfMkNcuqJ3K+-jbQ@mail.gmail.com  ",621a3a8b1c0ecf16e1e5667ea5756a76a082b738,1
capabilities: fix buffer overread on very short xattr,"If userspace attempted to set a ""security.capability"" xattr shorter than 4 bytes (e.g. 'setfattr -n security.capability -v x file'), then cap_convert_nscap() read past the end of the buffer containing the xattr value because it accessed the ->magic_etc field without verifying that the xattr value is long enough to contain that field.  Fix it by validating the xattr value size first.  This bug was found using syzkaller with KASAN.  The KASAN report was as follows (cleaned up slightly):      BUG: KASAN: slab-out-of-bounds in cap_convert_nscap+0x514/0x630 security/commoncap.c:498     Read of size 4 at addr ffff88002d8741c0 by task syz-executor1/2852      CPU: 0 PID: 2852 Comm: syz-executor1 Not tainted 4.15.0-rc6-00200-gcc0aac99d977 #253     Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS 1.11.0-20171110_100015-anatol 04/01/2014     Call Trace:      __dump_stack lib/dump_stack.c:17 [inline]      dump_stack+0xe3/0x195 lib/dump_stack.c:53      print_address_description+0x73/0x260 mm/kasan/report.c:252      kasan_report_error mm/kasan/report.c:351 [inline]      kasan_report+0x235/0x350 mm/kasan/report.c:409      cap_convert_nscap+0x514/0x630 security/commoncap.c:498      setxattr+0x2bd/0x350 fs/xattr.c:446      path_setxattr+0x168/0x1b0 fs/xattr.c:472      SYSC_setxattr fs/xattr.c:487 [inline]      SyS_setxattr+0x36/0x50 fs/xattr.c:483      entry_SYSCALL_64_fastpath+0x18/0x85  ",dc32b5c3e6e2ef29cef76d9ce1b92d394446150e,1
fuse: make sure reclaim doesn't write the inode,"In writeback cache mode mtime/ctime updates are cached, and flushed to the server using the ->write_inode() callback.  Closing the file will result in a dirty inode being immediately written, but in other cases the inode can remain dirty after all references are dropped.  This result in the inode being written back from reclaim, which can deadlock on a regular allocation while the request is being served.  The usual mechanisms (GFP_NOFS/PF_MEMALLOC*) don't work for FUSE, because serving a request involves unrelated userspace process(es).  Instead do the same as for dirty pages: make sure the inode is written before the last reference is gone.   - fallocate(2)/copy_file_range(2): these call file_update_time() or    file_modified(), so flush the inode before returning from the call   - unlink(2), link(2) and rename(2): these call fuse_update_ctime(), so    flush the ctime directly from this helper  ",5c791fe1e2a4f401f819065ea4fc0450849f1818,0
rcu-tasks: Don't delete holdouts within trc_inspect_reader(),"As Yanfei pointed out, although invoking trc_del_holdout() is safe from the viewpoint of the integrity of the holdout list itself, the put_task_struct() invoked by trc_del_holdout() can result in use-after-free errors due to later accesses to this task_struct structure by the RCU Tasks Trace grace-period kthread.  This commit therefore removes this call to trc_del_holdout() from trc_inspect_reader() in favor of the grace-period thread's existing call to trc_del_holdout(), thus eliminating that particular class of use-after-free errors.  ",1d10bf55d85d34eb73dd8263635f43fd72135d2d,1
net-caif: avoid user-triggerable WARN_ON(1),"syszbot triggers this warning, which looks something we can easily prevent.  If we initialize priv->list_field in chnl_net_init(), then always use list_del_init(), we can remove robust_list_del() completely.  ",550ac9c1aaaaf51fd42e20d461f0b1cdbd55b3d2,0
bpf: fix incorrect kmalloc usage in lpm_trie MAP_GET_NEXT_KEY rcu region,"In commit b471f2f1de8b (""bpf: implement MAP_GET_NEXT_KEY command for LPM_TRIE map""), the implemented MAP_GET_NEXT_KEY callback function is guarded with rcu read lock. In the function body, ""kmalloc(size, GFP_USER | __GFP_NOWARN)"" is used which may sleep and violate rcu read lock region requirements. This patch fixed the issue by using GFP_ATOMIC instead to avoid blocking kmalloc. Tested with CONFIG_DEBUG_ATOMIC_SLEEP=y as suggested by Eric Dumazet.  ",2310035fa03f651dd5b03f19a26a97512aa8842c,1
tracing: Enforce passing in filter=NULL to create_filter(),"There's some inconsistency with what to set the output parameter filterp when passing to create_filter(..., struct event_filter **filterp).  Whatever filterp points to, should be NULL when calling this function. The create_filter() calls create_filter_start() with a pointer to a local ""filter"" variable that is set to NULL. The create_filter_start() has a WARN_ON() if the passed in pointer isn't pointing to a value set to NULL.  Ideally, create_filter() should pass the filterp variable it received to create_filter_start() and not hide it as with a local variable, this allowed create_filter() to fail, and not update the passed in filter, and the caller of create_filter() then tried to free filter, which was never initialized to anything, causing memory corruption.   ",0b3dec05dbbce023f4f25aba975b5d253c313ebb,1
net: use correct this_cpu primitive in dev_recursion_level,syzbot reports: BUG: using __this_cpu_read() in preemptible code: caller is dev_recursion_level include/linux/netdevice.h:3052 [inline]  __this_cpu_preempt_check+0x246/0x270 lib/smp_processor_id.c:47  dev_recursion_level include/linux/netdevice.h:3052 [inline]  ip6_skb_dst_mtu include/net/ip6_route.h:245 [inline]  I erronously downgraded a this_cpu_read to __this_cpu_read when moving dev_recursion_level() around.  ,28b05b92886871bdd8e6a9df73e3a15845fe8ef4,1
"6pack,mkiss: fix possible deadlock",We got another syzbot report [1] that tells us we must use write_lock_irq()/write_unlock_irq() to avoid possible deadlock.  [1]  ,5c9934b6767b16ba60be22ec3cbd4379ad64170d,0
ubifs: Check for name being NULL while mounting,"The requested device name can be NULL or an empty string. Check for that and refuse to continue. UBIFS has to do this manually since we cannot use mount_bdev(), which checks for this condition.  ",37f31b6ca4311b94d985fb398a72e5399ad57925,0
tcp: fix slab-out-of-bounds in tcp_zerocopy_receive(),"Apparently a refactoring patch brought a bug, that was caught by syzbot [1]  Original code was correct, do not try to be smarter than the compiler :/  [1] BUG: KASAN: slab-out-of-bounds in tcp_zerocopy_receive net/ipv4/tcp.c:1807 [inline] BUG: KASAN: slab-out-of-bounds in do_tcp_getsockopt.isra.0+0x2c6c/0x3120 net/ipv4/tcp.c:3654 Read of size 4 at addr ffff8880943cf188 by task syz-executor.2/17508  CPU: 0 PID: 17508 Comm: syz-executor.2 Not tainted 5.3.0-rc7+ #0 Hardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 01/01/2011 Call Trace:  __dump_stack lib/dump_stack.c:77 [inline]  dump_stack+0x172/0x1f0 lib/dump_stack.c:113  print_address_description.cold+0xd4/0x306 mm/kasan/report.c:351  __kasan_report.cold+0x1b/0x36 mm/kasan/report.c:482  kasan_report+0x12/0x17 mm/kasan/common.c:618  __asan_report_load4_noabort+0x14/0x20 mm/kasan/generic_report.c:131  tcp_zerocopy_receive net/ipv4/tcp.c:1807 [inline]  do_tcp_getsockopt.isra.0+0x2c6c/0x3120 net/ipv4/tcp.c:3654  tcp_getsockopt+0xbf/0xe0 net/ipv4/tcp.c:3680  sock_common_getsockopt+0x94/0xd0 net/core/sock.c:3098  __sys_getsockopt+0x16d/0x310 net/socket.c:2129  __do_sys_getsockopt net/socket.c:2144 [inline]  __se_sys_getsockopt net/socket.c:2141 [inline]  __x64_sys_getsockopt+0xbe/0x150 net/socket.c:2141  do_syscall_64+0xfd/0x6a0 arch/x86/entry/common.c:296  ",3afb0961884046c8fb4acbce65139088959681c8,1
sch_netem: fix a divide by zero in tabledist(),syzbot managed to crash the kernel in tabledist() loading an empty distribution table.  	t = dist->table[rnd % dist->size];  Simply return an error when such load is attempted.  ,b41d936b5ecfdb3a4abc525ce6402a6c49cffddc,1
media: vivid: fix error handling of kthread_run,"kthread_run returns an error pointer, but elsewhere in the code dev->kthread_vid_cap/out is checked against NULL.  If kthread_run returns an error, then set the pointer to NULL.  I chose this method over changing all kthread_vid_cap/out tests elsewhere since this is more robust.  ",701f49bc028edb19ffccd101997dd84f0d71e279,1
netfilter: nf_tables: remove WARN and add NLA_STRING upper limits,This WARN can trigger because some of the names fed to the module autoload function can be of arbitrary length.  Remove the WARN and add limits for all NLA_STRING attributes.  ,9332d27d7918182add34e8043f6a754530fdd022,0
fuse: fix live lock in fuse_iget(),"Commit 5d069dbe8aaf (""fuse: fix bad inode"") replaced make_bad_inode() in fuse_iget() with a private implementation fuse_make_bad().  The private implementation fails to remove the bad inode from inode cache, so the retry loop with iget5_locked() finds the same bad inode and marks it bad forever.  kmsg snip:  ",775c5033a0d164622d9d10dd0f0a5531639ed3ed,0
KVM: x86/pmu: Fix UBSAN shift-out-of-bounds warning in intel_pmu_refresh(),"Since we know vPMU will not work properly when (1) the guest bit_width(s) of the [gp|fixed] counters are greater than the host ones, or (2) guest requested architectural events exceeds the range supported by the host, so we can setup a smaller left shift value and refresh the guest cpuid entry, thus fixing the following UBSAN shift-out-of-bounds warning:  shift exponent 197 is too large for 64-bit type 'long long unsigned int'  Call Trace:  __dump_stack lib/dump_stack.c:79 [inline]  dump_stack+0x107/0x163 lib/dump_stack.c:120  ubsan_epilogue+0xb/0x5a lib/ubsan.c:148  __ubsan_handle_shift_out_of_bounds.cold+0xb1/0x181 lib/ubsan.c:395  intel_pmu_refresh.cold+0x75/0x99 arch/x86/kvm/vmx/pmu_intel.c:348  kvm_vcpu_after_set_cpuid+0x65a/0xf80 arch/x86/kvm/cpuid.c:177  kvm_vcpu_ioctl_set_cpuid2+0x160/0x440 arch/x86/kvm/cpuid.c:308  kvm_arch_vcpu_ioctl+0x11b6/0x2d70 arch/x86/kvm/x86.c:4709  kvm_vcpu_ioctl+0x7b9/0xdb0 arch/x86/kvm/../../../virt/kvm/kvm_main.c:3386  vfs_ioctl fs/ioctl.c:48 [inline]  __do_sys_ioctl fs/ioctl.c:753 [inline]  __se_sys_ioctl fs/ioctl.c:739 [inline]  __x64_sys_ioctl+0x193/0x200 fs/ioctl.c:739  do_syscall_64+0x2d/0x70 arch/x86/entry/common.c:46  entry_SYSCALL_64_after_hwframe+0x44/0xa9  ",e61ab2a320c3dfd6209efe18a575979e07470597,1
"block, locking/lockdep: Assign a lock_class per gendisk used for wait_for_completion()",Darrick posted the following warning and Dave Chinner analyzed it:  > ,e319e1fbd9d42420ab6eec0bfd75eb9ad7ca63b1,0
bpf: Reject too big ctx_size_in for raw_tp test run,syzbot reported a ,7ac6ad051150592557520b45773201b987ecfce3,0
can: mcba_usb: fix memory leak in mcba_usb,"Syzbot reported memory leak in SocketCAN driver for Microchip CAN BUS Analyzer Tool. The problem was in unfreed usb_coherent.  In mcba_usb_start() 20 coherent buffers are allocated and there is nothing, that frees them:  1) In callback function the urb is resubmitted and that's all 2) In disconnect function urbs are simply killed, but URB_FREE_BUFFER    is not set (see mcba_usb_start) and this flag cannot be used with    coherent buffers.  Fail log: | ",91c02557174be7f72e46ed7311e3bea1939840b0,1
mac80211: track only QoS data frames for admission control,"For admission control, obviously all of that only works for QoS data frames, otherwise we cannot even access the QoS field in the header.  Syzbot reported (see below) an uninitialized value here due to a status of a non-QoS nullfunc packet, which isn't even long enough to contain the QoS header.  Fix this to only do anything for QoS data packets.  ",d5e568c3a4ec2ddd23e7dc5ad5b0c64e4f22981a,1
sctp: remove sctp_chunk_put from fail_mark err path in sctp_ulpevent_make_rcvmsg,"In Commit 1f45f78f8e51 (""sctp: allow GSO frags to access the chunk too""), it held the chunk in sctp_ulpevent_make_rcvmsg to access it safely later in recvmsg. However, it also added sctp_chunk_put in fail_mark err path, which is only triggered before holding the chunk.  syzbot reported a use-after-free crash happened on this err path, where it shouldn't call sctp_chunk_put.  This patch simply removes this call.  ",6910e25de2257e2c82c7a2d126e3463cd8e50810,1
staging: comedi: ni_usb6501: Fix use of uninitialized mutex,"If `ni6501_auto_attach()` returns an error, the core comedi module code will call `ni6501_detach()` to clean up.  If `ni6501_auto_attach()` successfully allocated the comedi device private data, `ni6501_detach()` assumes that a `struct mutex mut` contained in the private data has been initialized and uses it.  Unfortunately, there are a couple of places where `ni6501_auto_attach()` can return an error after allocating the device private data but before initializing the mutex, so this assumption is invalid.  Fix it by initializing the mutex just after allocating the private data in `ni6501_auto_attach()` before any other errors can be retturned.  Also move the call to `usb_set_intfdata()` just to keep the code a bit neater (either position for the call is fine).  I believe this was the cause of the following syzbot crash report <https://syzkaller.appspot.com/bug?extid=cf4f2b6c24aff0a3edf6>:  usb 1-1: New USB device strings: Mfr=0, Product=0, SerialNumber=0 usb 1-1: config 0 descriptor?? usb 1-1: string descriptor 0 read error: -71 comedi comedi0: Wrong number of endpoints ni6501 1-1:0.233: driver 'ni6501' failed to auto-configure device. INFO: trying to register non-static key. the code is fine but needs lockdep annotation. turning off the locking correctness validator. CPU: 0 PID: 585 Comm: kworker/0:3 Not tainted 5.1.0-rc4-319354-g9a33b36 #3 Hardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 01/01/2011 Workqueue: usb_hub_wq hub_event Call Trace:  __dump_stack lib/dump_stack.c:77 [inline]  dump_stack+0xe8/0x16e lib/dump_stack.c:113  assign_lock_key kernel/locking/lockdep.c:786 [inline]  register_lock_class+0x11b8/0x1250 kernel/locking/lockdep.c:1095  __lock_acquire+0xfb/0x37c0 kernel/locking/lockdep.c:3582  lock_acquire+0x10d/0x2f0 kernel/locking/lockdep.c:4211  __mutex_lock_common kernel/locking/mutex.c:925 [inline]  __mutex_lock+0xfe/0x12b0 kernel/locking/mutex.c:1072  ni6501_detach+0x5b/0x110 drivers/staging/comedi/drivers/ni_usb6501.c:567  comedi_device_detach+0xed/0x800 drivers/staging/comedi/drivers.c:204  comedi_device_cleanup.part.0+0x68/0x140 drivers/staging/comedi/comedi_fops.c:156  comedi_device_cleanup drivers/staging/comedi/comedi_fops.c:187 [inline]  comedi_free_board_dev.part.0+0x16/0x90 drivers/staging/comedi/comedi_fops.c:190  comedi_free_board_dev drivers/staging/comedi/comedi_fops.c:189 [inline]  comedi_release_hardware_device+0x111/0x140 drivers/staging/comedi/comedi_fops.c:2880  comedi_auto_config.cold+0x124/0x1b0 drivers/staging/comedi/drivers.c:1068  usb_probe_interface+0x31d/0x820 drivers/usb/core/driver.c:361  really_probe+0x2da/0xb10 drivers/base/dd.c:509  driver_probe_device+0x21d/0x350 drivers/base/dd.c:671  __device_attach_driver+0x1d8/0x290 drivers/base/dd.c:778  bus_for_each_drv+0x163/0x1e0 drivers/base/bus.c:454  __device_attach+0x223/0x3a0 drivers/base/dd.c:844  bus_probe_device+0x1f1/0x2a0 drivers/base/bus.c:514  device_add+0xad2/0x16e0 drivers/base/core.c:2106  usb_set_configuration+0xdf7/0x1740 drivers/usb/core/message.c:2021  generic_probe+0xa2/0xda drivers/usb/core/generic.c:210  usb_probe_device+0xc0/0x150 drivers/usb/core/driver.c:266  really_probe+0x2da/0xb10 drivers/base/dd.c:509  driver_probe_device+0x21d/0x350 drivers/base/dd.c:671  __device_attach_driver+0x1d8/0x290 drivers/base/dd.c:778  bus_for_each_drv+0x163/0x1e0 drivers/base/bus.c:454  __device_attach+0x223/0x3a0 drivers/base/dd.c:844  bus_probe_device+0x1f1/0x2a0 drivers/base/bus.c:514  device_add+0xad2/0x16e0 drivers/base/core.c:2106  usb_new_device.cold+0x537/0xccf drivers/usb/core/hub.c:2534  hub_port_connect drivers/usb/core/hub.c:5089 [inline]  hub_port_connect_change drivers/usb/core/hub.c:5204 [inline]  port_event drivers/usb/core/hub.c:5350 [inline]  hub_event+0x138e/0x3b00 drivers/usb/core/hub.c:5432  process_one_work+0x90f/0x1580 kernel/workqueue.c:2269  worker_thread+0x9b/0xe20 kernel/workqueue.c:2415  kthread+0x313/0x420 kernel/kthread.c:253  ret_from_fork+0x3a/0x50 arch/x86/entry/entry_64.S:352  ",660cf4ce9d0f3497cc7456eaa6d74c8b71d6282c,1
net: fix rtnh_ok(),"syzbot reported :  BUG: KMSAN: uninit-value in rtnh_ok include/net/nexthop.h:11 [inline] BUG: KMSAN: uninit-value in fib_count_nexthops net/ipv4/fib_semantics.c:469 [inline] BUG: KMSAN: uninit-value in fib_create_info+0x554/0x8d20 net/ipv4/fib_semantics.c:1091  @remaining is an integer, coming from user space. If it is negative we want rtnh_ok() to return false.  ",b1993a2de12c9e75c35729e2ffbc3a92d50c0d31,1
virt_wifi: fix deadlock on RTNL,"Fix a regression where everything in virt_wifi would just hang. This happened due to overlapping changes between commit a05829a7222e (""cfg80211: avoid holding the RTNL when calling the driver"") which had originally needed to change the locking, but then I introduced commit 2fe8ef106238 (""cfg80211: change netdev registration/unregistration semantics"") instead. virt_wifi somehow fell through the cracks when I undid all the previous locking changes. Fix it now.  ",38ec7c6b6bd69b9ccc1873b9f465d4f16b46b26e,0
usb: wusbcore: fix unbalanced get/put cluster_id,"syzboot reported that https://syzkaller.appspot.com/bug?extid=fd2bd7df88c606eea4ef  There is not consitency parameter in cluste_id_get/put calling. In case of getting the id with result is failure, the wusbhc->cluster_id will not be updated and this can not be used for wusb_cluster_id_put().  Tested report https://groups.google.com/d/msg/syzkaller-bugs/0znZopp3-9k/oxOrhLkLEgAJ  Reproduce and gdb got the details:  139		addr = wusb_cluster_id_get(); (gdb) n 140		if (addr == 0) (gdb) print addr $1 = 254 '\376' (gdb) n 142		result = __hwahc_set_cluster_id(hwahc, addr); (gdb) print result $2 = -71 (gdb) break wusb_cluster_id_put Breakpoint 3 at 0xffffffff836e3f20: file drivers/usb/wusbcore/wusbhc.c, line 384. (gdb) s Thread 2 hit Breakpoint 3, wusb_cluster_id_put (id=0 '\000') at drivers/usb/wusbcore/wusbhc.c:384 384		id = 0xff - id; (gdb) n 385		BUG_ON(id >= CLUSTER_IDS); (gdb) print id $3 = 255 '\377'  ",f90bf1ece48a736097ea224430578fe586a9544c,1
io_uring: ensure SQPOLL startup is triggered before error shutdown,syzbot reports the following hang:  INFO: task syz-executor.0:12538 can't die for more than 143 seconds. ,eb85890b29e4d7ae1accdcfba35ed8b16ba9fb97,0
md: fix a warning caused by a race between concurrent md_ioctl()s,Syzkaller reports a warning as belows. ,c731b84b51bf7fe83448bea8f56a6d55006b0615,1
tipc: check msg->req data len in tipc_nl_compat_bearer_disable,"This patch is to fix an uninit-value issue, reported by syzbot:    BUG: KMSAN: uninit-value in memchr+0xce/0x110 lib/string.c:981   Call Trace:     __dump_stack lib/dump_stack.c:77 [inline]     dump_stack+0x191/0x1f0 lib/dump_stack.c:113     kmsan_report+0x130/0x2a0 mm/kmsan/kmsan.c:622     __msan_warning+0x75/0xe0 mm/kmsan/kmsan_instr.c:310     memchr+0xce/0x110 lib/string.c:981     string_is_valid net/tipc/netlink_compat.c:176 [inline]     tipc_nl_compat_bearer_disable+0x2a1/0x480 net/tipc/netlink_compat.c:449     __tipc_nl_compat_doit net/tipc/netlink_compat.c:327 [inline]     tipc_nl_compat_doit+0x3ac/0xb00 net/tipc/netlink_compat.c:360     tipc_nl_compat_handle net/tipc/netlink_compat.c:1178 [inline]     tipc_nl_compat_recv+0x1b1b/0x27b0 net/tipc/netlink_compat.c:1281  TLV_GET_DATA_LEN() may return a negtive int value, which will be used as size_t (becoming a big unsigned long) passed into memchr, cause this issue.  Similar to what it does in tipc_nl_compat_bearer_enable(), this fix is to return -EINVAL when TLV_GET_DATA_LEN() is negtive in tipc_nl_compat_bearer_disable(), as well as in tipc_nl_compat_link_stat_dump() and tipc_nl_compat_link_reset_stats().  v1->v2:   - add the missing Fixes tags per Eric's request.  ",4f07b80c973348a99b5d2a32476a2e7877e94a05,1
net: sit: unregister_netdevice on newlink's error path,"We need to unregister the netdevice if config failed. .ndo_uninit takes care of most of the heavy lifting.  This was uncovered by recent commit c269a24ce057 (""net: make free_netdev() more lenient with unregistering devices""). Previously the partially-initialized device would be left in the system.  ",47e4bb147a96f1c9b4e7691e7e994e53838bfff8,0
fbdev: zero-fill colormap in fbcmap.c,"Use kzalloc() rather than kmalloc() for the dynamically allocated parts of the colormap in fb_alloc_cmap_gfp, to prevent a leak of random kernel data to userspace under certain circumstances.  Fixes a KMSAN-found infoleak bug reported by syzbot at: https://syzkaller.appspot.com/bug?id=741578659feabd108ad9e06696f0c1f2e69c4b6e  ",19ab233989d0f7ab1de19a036e247afa4a0a1e9c,1
media: uvcvideo: Avoid cyclic entity chains due to malformed USB descriptors,"Way back in 2017, fuzzing the 4.14-rc2 USB stack with syzkaller kicked up the following ",68035c80e129c4cfec659aac4180354530b26527,1
af_key: relax availability checks for skb size calculation,"xfrm_probe_algs() probes kernel crypto modules and changes the availability of struct xfrm_algo_desc. But there is a small window where ealg->available and aalg->available get changed between count_ah_combs()/count_esp_combs() and dump_ah_combs()/dump_esp_combs(), in this case we may allocate a smaller skb but later put a larger amount of data and trigger the panic in skb_put().  Fix this by relaxing the checks when counting the size, that is, skipping the test of ->available. We may waste some memory for a few of sizeof(struct sadb_comb), but it is still much better than a panic.  ",afbc293add6466f8f3f0c3d944d85f53709c170f,0
net: sched: Allow statistics reads from softirq.,Eric reported that the rate estimator reads statics from the softirq which in turn triggers a warning introduced in the statistics rework.  The warning is too cautious. The updates happen in the softirq context so reads from softirq are fine since the writes can not be preempted. The updates/writes happen during qdisc_run() which ensures one writer and the softirq context. The remaining bad context for reading statistics remains in hard-IRQ because it may preempt a writer.  ,e22db7bd552f7f7f19fe4ef60abfb7e7b364e3a8,0
udf: Fix error handling in udf_new_inode(),"When memory allocation of iinfo or block allocation fails, already allocated struct udf_inode_info gets freed with iput() and udf_evict_inode() may look at inode fields which are not properly initialized. Fix it by marking inode bad before dropping reference to it in udf_new_inode().  ",f05f2429eec60851b98bdde213de31dab697c01b,1
tun/tap: sanitize TUNSETSNDBUF input,Syzkaller found several variants of the lockup below by setting negative values with the TUNSETSNDBUF ioctl.  This patch adds a sanity check to both the tun and tap versions of this ioctl.    watchdog: BUG: soft lockup - CPU#0 stuck for 22s! [repro:2389]   ,93161922c658c714715686cd0cf69b090cb9bf1d,1
staging: wlan-ng: fix ODEBUG bug in prism2sta_disconnect_usb,We should cancel hw->usb_work before kfree(hw).  ,a1f165a6b738f0c9d744bad4af7a53909278f5fc,1
net/ipv6: prevent use after free in ip6_route_mpath_notify,"syzbot reported a use-after-free:  BUG: KASAN: use-after-free in ip6_route_mpath_notify+0xe9/0x100 net/ipv6/route.c:4180 Read of size 4 at addr ffff8801bf789cf0 by task syz-executor756/4555  CPU: 1 PID: 4555 Comm: syz-executor756 Not tainted 4.17.0-rc7+ #78 Hardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 01/01/2011 Call Trace:  __dump_stack lib/dump_stack.c:77 [inline]  dump_stack+0x1b9/0x294 lib/dump_stack.c:113  print_address_description+0x6c/0x20b mm/kasan/report.c:256  kasan_report_error mm/kasan/report.c:354 [inline]  kasan_report.cold.7+0x242/0x2fe mm/kasan/report.c:412  __asan_report_load4_noabort+0x14/0x20 mm/kasan/report.c:432  ip6_route_mpath_notify+0xe9/0x100 net/ipv6/route.c:4180  ip6_route_multipath_add+0x615/0x1910 net/ipv6/route.c:4303  inet6_rtm_newroute+0xe3/0x160 net/ipv6/route.c:4391  ...  Allocated by task 4555:  save_stack+0x43/0xd0 mm/kasan/kasan.c:448  set_track mm/kasan/kasan.c:460 [inline]  kasan_kmalloc+0xc4/0xe0 mm/kasan/kasan.c:553  kasan_slab_alloc+0x12/0x20 mm/kasan/kasan.c:490  kmem_cache_alloc+0x12e/0x760 mm/slab.c:3554  dst_alloc+0xbb/0x1d0 net/core/dst.c:104  __ip6_dst_alloc+0x35/0xa0 net/ipv6/route.c:361  ip6_dst_alloc+0x29/0xb0 net/ipv6/route.c:376  ip6_route_info_create+0x4d4/0x3a30 net/ipv6/route.c:2834  ip6_route_multipath_add+0xc7e/0x1910 net/ipv6/route.c:4240  inet6_rtm_newroute+0xe3/0x160 net/ipv6/route.c:4391  ...  Freed by task 4555:  save_stack+0x43/0xd0 mm/kasan/kasan.c:448  set_track mm/kasan/kasan.c:460 [inline]  __kasan_slab_free+0x11a/0x170 mm/kasan/kasan.c:521  kasan_slab_free+0xe/0x10 mm/kasan/kasan.c:528  __cache_free mm/slab.c:3498 [inline]  kmem_cache_free+0x86/0x2d0 mm/slab.c:3756  dst_destroy+0x267/0x3c0 net/core/dst.c:140  dst_release_immediate+0x71/0x9e net/core/dst.c:205  fib6_add+0xa40/0x1650 net/ipv6/ip6_fib.c:1305  __ip6_ins_rt+0x6c/0x90 net/ipv6/route.c:1011  ip6_route_multipath_add+0x513/0x1910 net/ipv6/route.c:4267  inet6_rtm_newroute+0xe3/0x160 net/ipv6/route.c:4391  ...  The problem is that rt_last can point to a deleted route if the insert fails.  One reproducer is to insert a route and then add a multipath route that has a duplicate nexthop.e.g,:     $ ip -6 ro add vrf red 2001:db8:101::/64 nexthop via 2001:db8:1::2     $ ip -6 ro append vrf red 2001:db8:101::/64 nexthop via 2001:db8:1::4 nexthop via 2001:db8:1::2  Fix by not setting rt_last until the it is verified the insert succeeded.  ",f7225172f25aaf0dfd9ad65f05be8da5d6108b12,1
ppp: Fix memory leak in ppp_write,"When ppp is closing, __ppp_xmit_process() failed to enqueue skb and skb allocated in ppp_write() is leaked.  syzbot reported : BUG: memory leak unreferenced object 0xffff88812a17bc00 (size 224):   comm ""syz-executor673"", pid 6952, jiffies 4294942888 (age 13.040s)   ",4c247de564f1ff614d11b3bb5313fb70d7b9598b,1
USB: legousbtower: fix deadlock on disconnect,"Fix a potential deadlock if disconnect races with open.  Since commit d4ead16f50f9 (""USB: prevent char device open/deregister race"") core holds an rw-semaphore while open is called and when releasing the minor number during deregistration. This can lead to an ABBA deadlock if a driver takes a lock in open which it also holds during deregistration.  This effectively reverts commit 78663ecc344b (""USB: disconnect open race in legousbtower"") which needlessly introduced this issue after a generic fix for this race had been added to core by commit d4ead16f50f9 (""USB: prevent char device open/deregister race"").  ",33a7813219f208f4952ece60ee255fd983272dec,1
netfilter: x_tables: fix missing timer initialization in xt_LED,syzbot reported that xt_LED may try to use the ledinternal->timer without previously initializing it:  ,10414014bc085aac9f787a5890b33b5605fbcfc4,0
smackfs: use netlbl_cfg_cipsov4_del() for deleting cipso_v4_doi,"syzbot is reporting UAF at cipso_v4_doi_search() [1], for smk_cipso_doi() is calling kfree() without removing from the cipso_v4_doi_list list after netlbl_cfg_cipsov4_map_add() returned an error. We need to use netlbl_cfg_cipsov4_del() in order to remove from the list and wait for RCU grace period before kfree().  ",0934ad42bb2c5df90a1b9de690f93de735b622fe,0
KVM: X86: Fix SMRAM accessing even if VM is shutdown,Reported by syzkaller:     ,95e057e25892eaa48cad1e2d637b80d0f1a4fac5,1
tracepoint: Add tracepoint_probe_register_may_exist() for BPF tracing,"All internal use cases for tracepoint_probe_register() is set to not ever be called with the same function and data. If it is, it is considered a bug, as that means the accounting of handling tracepoints is corrupted. If the function and data for a tracepoint is already registered when tracepoint_probe_register() is called, it will call WARN_ON_ONCE() and return with EEXISTS.  The BPF system call can end up calling tracepoint_probe_register() with the same data, which now means that this can trigger the warning because of a user space process. As WARN_ON_ONCE() should not be called because user space called a system call with bad data, there needs to be a way to register a tracepoint without triggering a warning.  Enter tracepoint_probe_register_may_exist(), which can be called, but will not cause a WARN_ON() if the probe already exists. It will still error out with EEXIST, which will then be sent to the user space that performed the BPF system call.  This keeps the previous testing for issues with other users of the tracepoint code, while letting BPF call it with duplicated data and not warn about it.   ",9913d5745bd720c4266805c8d29952a3702e4eca,1
netfilter: nftables: avoid overflows in nft_hash_buckets(),"Number of buckets being stored in 32bit variables, we have to ensure that no overflows occur in nft_hash_buckets()  syzbot injected a size == 0x40000000 and reported:  UBSAN: shift-out-of-bounds in ./include/linux/log2.h:57:13 shift exponent 64 is too large for 64-bit type 'long unsigned int' CPU: 1 PID: 29539 Comm: syz-executor.4 Not tainted 5.12.0-rc7-syzkaller #0 Hardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 01/01/2011 Call Trace:  __dump_stack lib/dump_stack.c:79 [inline]  dump_stack+0x141/0x1d7 lib/dump_stack.c:120  ubsan_epilogue+0xb/0x5a lib/ubsan.c:148  __ubsan_handle_shift_out_of_bounds.cold+0xb1/0x181 lib/ubsan.c:327  __roundup_pow_of_two include/linux/log2.h:57 [inline]  nft_hash_buckets net/netfilter/nft_set_hash.c:411 [inline]  nft_hash_estimate.cold+0x19/0x1e net/netfilter/nft_set_hash.c:652  nft_select_set_ops net/netfilter/nf_tables_api.c:3586 [inline]  nf_tables_newset+0xe62/0x3110 net/netfilter/nf_tables_api.c:4322  nfnetlink_rcv_batch+0xa09/0x24b0 net/netfilter/nfnetlink.c:488  nfnetlink_rcv_skb_batch net/netfilter/nfnetlink.c:612 [inline]  nfnetlink_rcv+0x3af/0x420 net/netfilter/nfnetlink.c:630  netlink_unicast_kernel net/netlink/af_netlink.c:1312 [inline]  netlink_unicast+0x533/0x7d0 net/netlink/af_netlink.c:1338  netlink_sendmsg+0x856/0xd90 net/netlink/af_netlink.c:1927  sock_sendmsg_nosec net/socket.c:654 [inline]  sock_sendmsg+0xcf/0x120 net/socket.c:674  ____sys_sendmsg+0x6e8/0x810 net/socket.c:2350  ___sys_sendmsg+0xf3/0x170 net/socket.c:2404  __sys_sendmsg+0xe5/0x1b0 net/socket.c:2433  do_syscall_64+0x2d/0x70 arch/x86/entry/common.c:46  ",a54754ec9891830ba548e2010c889e3c8146e449,1
tipc: call rcu_read_lock() in tipc_aead_encrypt_done(),"b->media->send_msg() requires rcu_read_lock(), as we can see elsewhere in tipc,  tipc_bearer_xmit, tipc_bearer_xmit_skb and tipc_bearer_bc_xmit().  Syzbot has reported this issue as:    net/tipc/bearer.c:466 suspicious rcu_dereference_check() usage!   Workqueue: cryptd cryptd_queue_worker   Call Trace:    tipc_l2_send_msg+0x354/0x420 net/tipc/bearer.c:466    tipc_aead_encrypt_done+0x204/0x3a0 net/tipc/crypto.c:761    cryptd_aead_crypt+0xe8/0x1d0 crypto/cryptd.c:739    cryptd_queue_worker+0x118/0x1b0 crypto/cryptd.c:181    process_one_work+0x94c/0x1670 kernel/workqueue.c:2269    worker_thread+0x64c/0x1120 kernel/workqueue.c:2415    kthread+0x3b5/0x4a0 kernel/kthread.c:291    ret_from_fork+0x1f/0x30 arch/x86/entry/entry_64.S:293  So fix it by calling rcu_read_lock() in tipc_aead_encrypt_done() for b->media->send_msg().  ",f6db9096416209474090d64d8284e7c16c3d8873,1
tun: napi flags belong to tfile,"Since tun->flags might be shared by multiple tfile structures, it is better to make sure tun_get_user() is using the flags for the current tfile.  Presence of the READ_ONCE() in tun_napi_frags_enabled() gave a hint of what could happen, but we need something stronger to please syzbot.  kasan: CONFIG_KASAN_INLINE enabled kasan: GPF could be caused by NULL-ptr deref or user memory access general protection fault: 0000 [#1] PREEMPT SMP KASAN CPU: 0 PID: 13647 Comm: syz-executor5 Not tainted 4.19.0-rc5+ #59 Hardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 01/01/2011 ",af3fb24eecb2c59246e03c99386037fd5ad84ffd,1
net/sched: fq_pie: fix OOB access in the traffic path,"the following script:    # tc qdisc add dev eth0 handle 0x1 root fq_pie flows 2   # tc qdisc add dev eth0 clsact   # tc filter add dev eth0 egress matchall action skbedit priority 0x10002   # ping 192.0.2.2 -I eth0 -c2 -w1 -q  produces the following splat:   BUG: KASAN: slab-out-of-bounds in fq_pie_qdisc_enqueue+0x1314/0x19d0 [sch_fq_pie]  Read of size 4 at addr ffff888171306924 by task ping/942   CPU: 3 PID: 942 Comm: ping Not tainted 5.12.0+ #441  Hardware name: Red Hat KVM, BIOS 1.11.1-4.module+el8.1.0+4066+0f1aadab 04/01/2014  Call Trace:   dump_stack+0x92/0xc1   print_address_description.constprop.7+0x1a/0x150   kasan_report.cold.13+0x7f/0x111   fq_pie_qdisc_enqueue+0x1314/0x19d0 [sch_fq_pie]   __dev_queue_xmit+0x1034/0x2b10   ip_finish_output2+0xc62/0x2120   __ip_finish_output+0x553/0xea0   ip_output+0x1ca/0x4d0   ip_send_skb+0x37/0xa0   raw_sendmsg+0x1c4b/0x2d00   sock_sendmsg+0xdb/0x110   __sys_sendto+0x1d7/0x2b0   __x64_sys_sendto+0xdd/0x1b0   do_syscall_64+0x3c/0x80   entry_SYSCALL_64_after_hwframe+0x44/0xae  ",e70f7a11876a1a788ceadf75e9e5f7af2c868680,1
crypto: pcrypt - fix freeing pcrypt instances,"pcrypt is using the old way of freeing instances, where the ->free() method specified in the 'struct crypto_template' is passed a pointer to the 'struct crypto_instance'.  But the crypto_instance is being kfree()'d directly, which is incorrect because the memory was actually allocated as an aead_instance, which contains the crypto_instance at a nonzero offset.  Thus, the wrong pointer was being kfree()'d.  Fix it by switching to the new way to free aead_instance's where the ->free() method is specified in the aead_instance itself.  ",d76c68109f37cb85b243a1cf0f40313afd2bae68,0
i2c: validate user data in compat ioctl,"Wrong user data may cause warning in i2c_transfer(), ex: zero msgs. Userspace should not be able to trigger warnings, so this patch adds validation checks for user data in compact ioctl to prevent reported warnings  ",bb436283e25aaf1533ce061605d23a9564447bdf,0
ath9k: hif_usb: fix race condition between usb_get_urb() and usb_kill_anchored_urbs(),"Calls to usb_kill_anchored_urbs() after usb_kill_urb() on multiprocessor systems create a race condition in which usb_kill_anchored_urbs() deallocates the URB before the completer callback is called in usb_kill_urb(), resulting in a use-after-free. To fix this, add proper lock protection to usb_kill_urb() calls that can possibly run concurrently with usb_kill_anchored_urbs().  ",03fb92a432ea5abe5909bca1455b7e44a9380480,1
Bluetooth: Fix kernel oops triggered by hci_adv_monitors_clear(),"This fixes the kernel oops by removing unnecessary background scan update from hci_adv_monitors_clear() which shouldn't invoke any work queue.  The following test was performed. - Run ""rmmod btusb"" and verify that no kernel oops is triggered.  ",b83764f9220a4a14525657466f299850bbc98de9,1
tomoyo: Use atomic_t for statistics counter,"syzbot is reporting that there is a race at tomoyo_stat_update() [1]. Although it is acceptable to fail to track exact number of times policy was updated, convert to atomic_t because this is not a hot path.  [1] https://syzkaller.appspot.com/bug?id=a4d7b973972eeed410596e6604580e0133b0fc04  ",a8772fad0172aeae339144598b809fd8d4823331,1
lib: fix stall in __bitmap_parselist(),"syzbot is catching stalls at __bitmap_parselist() (https://syzkaller.appspot.com/bug?id=ad7e0351fbc90535558514a71cd3edc11681997a). The trigger is    unsigned long v = 0;   bitmap_parselist(""7:,"", &v, BITS_PER_LONG);  which results in hitting infinite loop at      while (a <= b) { 	    off = min(b - a + 1, used_size); 	    bitmap_set(maskp, a, off); 	    a += group_size;     }  due to used_size == group_size == 0.  ",8351760ff5b2042039554b4948ddabaac644a976,1
net/x25: do not hold the cpu too long in x25_new_lci(),"Due to quadratic behavior of x25_new_lci(), syzbot was able to trigger an rcu stall.  Fix this by not blocking BH for the whole duration of the function, and inserting a reschedule point when possible.  If we care enough, using a bitmap could get rid of the quadratic behavior.  syzbot report :  rcu: INFO: rcu_preempt self-detected stall on CPU rcu:    0-...!: (10500 ticks this GP) idle=4fa/1/0x4000000000000002 softirq=283376/283376 fqs=0 rcu:     (t=10501 jiffies g=383105 q=136) rcu: rcu_preempt kthread starved for 10502 jiffies! g383105 f0x0 RCU_GP_WAIT_FQS(5) ->state=0x402 ->cpu=0 rcu: RCU grace-period kthread stack dump: rcu_preempt     I28928    10      2 0x80000000 Call Trace:  context_switch kernel/sched/core.c:2844 [inline]  __schedule+0x817/0x1cc0 kernel/sched/core.c:3485  schedule+0x92/0x180 kernel/sched/core.c:3529  schedule_timeout+0x4db/0xfd0 kernel/time/timer.c:1803  rcu_gp_fqs_loop kernel/rcu/tree.c:1948 [inline]  rcu_gp_kthread+0x956/0x17a0 kernel/rcu/tree.c:2105  kthread+0x357/0x430 kernel/kthread.c:246  ret_from_fork+0x3a/0x50 arch/x86/entry/entry_64.S:352 NMI backtrace for cpu 0 CPU: 0 PID: 8759 Comm: syz-executor2 Not tainted 5.0.0-rc4+ #51 Hardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 01/01/2011 Call Trace:  <IRQ>  __dump_stack lib/dump_stack.c:77 [inline]  dump_stack+0x172/0x1f0 lib/dump_stack.c:113  nmi_cpu_backtrace.cold+0x63/0xa4 lib/nmi_backtrace.c:101  nmi_trigger_cpumask_backtrace+0x1be/0x236 lib/nmi_backtrace.c:62  arch_trigger_cpumask_backtrace+0x14/0x20 arch/x86/kernel/apic/hw_nmi.c:38  trigger_single_cpu_backtrace include/linux/nmi.h:164 [inline]  rcu_dump_cpu_stacks+0x183/0x1cf kernel/rcu/tree.c:1211  print_cpu_stall kernel/rcu/tree.c:1348 [inline]  check_cpu_stall kernel/rcu/tree.c:1422 [inline]  rcu_pending kernel/rcu/tree.c:3018 [inline]  rcu_check_callbacks.cold+0x500/0xa4a kernel/rcu/tree.c:2521  update_process_times+0x32/0x80 kernel/time/timer.c:1635  tick_sched_handle+0xa2/0x190 kernel/time/tick-sched.c:161  tick_sched_timer+0x47/0x130 kernel/time/tick-sched.c:1271  __run_hrtimer kernel/time/hrtimer.c:1389 [inline]  __hrtimer_run_queues+0x33e/0xde0 kernel/time/hrtimer.c:1451  hrtimer_interrupt+0x314/0x770 kernel/time/hrtimer.c:1509  local_apic_timer_interrupt arch/x86/kernel/apic/apic.c:1035 [inline]  smp_apic_timer_interrupt+0x120/0x570 arch/x86/kernel/apic/apic.c:1060  apic_timer_interrupt+0xf/0x20 arch/x86/entry/entry_64.S:807  </IRQ> ",cf657d22ee1f0e887326a92169f2e28dc932fd10,0
sched: Improve wake_up_all_idle_cpus() take #2,"As reported by syzbot and experienced by Pavel, using cpus_read_lock() in wake_up_all_idle_cpus() generates lock inversion (against mmap_sem and possibly others).  Instead, shrink the preempt disable region by iterating all CPUs and checking the online status for each individual CPU while having preemption disabled.  ",96611c26dc351c33f73b48756a9feacc109e5bab,0
nsh: set mac len based on inner packet,"When pulling the NSH header in nsh_gso_segment, set the mac length based on the encapsulated packet type.  skb_reset_mac_len computes an offset to the network header, which here still points to the outer packet:    >     skb_reset_network_header(skb);   >     [...]   >     __skb_pull(skb, nsh_len);   >     skb_reset_mac_header(skb);    // now mac hdr starts nsh_len == 8B after net hdr   >     skb_reset_mac_len(skb);       // mac len = net hdr - mac hdr == (u16) -8 == 65528   >     [..]   >     skb_mac_gso_segment(skb, ..)  ",bab2c80e5a6c855657482eac9e97f5f3eedb509a,0
KVM: Check validity of resolved slot when searching memslots,"Check that the resolved slot (somewhat confusingly named 'start') is a valid/allocated slot before doing the final comparison to see if the specified gfn resides in the associated slot.  The resolved slot can be invalid if the binary search loop terminated because the search index was incremented beyond the number of used slots.  This bug has existed since the binary search algorithm was introduced, but went unnoticed because KVM statically allocated memory for the max number of slots, i.e. the access would only be truly out-of-bounds if all possible slots were allocated and the specified gfn was less than the base of the lowest memslot.  Commit 36947254e5f98 (""KVM: Dynamically size memslot array based on number of used slots"") eliminated the ""all possible slots allocated"" condition and made the bug embarrasingly easy to hit.  ",b6467ab142b708dd076f6186ca274f14af379c72,1
tun: properly test for IFF_UP,"Same reasons than the ones explained in commit 4179cb5a4c92 (""vxlan: test dev->flags & IFF_UP before calling netif_rx()"")  netif_rx_ni() or napi_gro_frags() must be called under a strict contract.  At device dismantle phase, core networking clears IFF_UP and flush_all_backlogs() is called after rcu grace period to make sure no incoming packet might be in a cpu backlog and still referencing the device.  A similar protocol is used for gro layer.  Most drivers call netif_rx() from their interrupt handler, and since the interrupts are disabled at device dismantle, netif_rx() does not have to check dev->flags & IFF_UP  Virtual drivers do not have this guarantee, and must therefore make the check themselves.  ",4477138fa0ae4e1b699786ef0600863ea6e6c61c,0
usb: iowarrior: fix deadlock on disconnect,"We have to drop the mutex before we close() upon disconnect() as close() needs the lock. This is safe to do by dropping the mutex as intfdata is already set to NULL, so open() will fail.  ",c468a8aa790e0dfe0a7f8a39db282d39c2c00b46,0
udf: Check LVID earlier,"We were checking validity of LVID entries only when getting implementation use information from LVID in udf_sb_lvidiu(). However if the LVID is suitably corrupted, it can cause problems also to code such as udf_count_free() which doesn't use udf_sb_lvidiu(). So check validity of LVID already when loading it from the disk and just disable LVID altogether when it is not valid.  ",781d2a9a2fc7d0be53a072794dc03ef6de770f3d,0
ipv4: Fix refcount warning for new fib_info,Ioana reported a refcount warning when booting over NFS:  ,28814cd18cd7bfb40321b95f85fd214111ccdf68,0
sctp: Fix double free in sctp_sendmsg_to_asoc,"syzbot/kasan detected a double free in sctp_sendmsg_to_asoc: BUG: KASAN: use-after-free in sctp_association_free+0x7b7/0x930 net/sctp/associola.c:332 Read of size 8 at addr ffff8801d8006ae0 by task syzkaller914861/4202  CPU: 1 PID: 4202 Comm: syzkaller914861 Not tainted 4.16.0-rc4+ #258 Hardware name: Google Google Compute Engine/Google Compute Engine 01/01/2011 Call Trace:  __dump_stack lib/dump_stack.c:17 [inline]  dump_stack+0x194/0x24d lib/dump_stack.c:53  print_address_description+0x73/0x250 mm/kasan/report.c:256  kasan_report_error mm/kasan/report.c:354 [inline]  kasan_report+0x23c/0x360 mm/kasan/report.c:412  __asan_report_load8_noabort+0x14/0x20 mm/kasan/report.c:433  sctp_association_free+0x7b7/0x930 net/sctp/associola.c:332  sctp_sendmsg+0xc67/0x1a80 net/sctp/socket.c:2075  inet_sendmsg+0x11f/0x5e0 net/ipv4/af_inet.c:763  sock_sendmsg_nosec net/socket.c:629 [inline]  sock_sendmsg+0xca/0x110 net/socket.c:639  SYSC_sendto+0x361/0x5c0 net/socket.c:1748  SyS_sendto+0x40/0x50 net/socket.c:1716  do_syscall_64+0x281/0x940 arch/x86/entry/common.c:287  entry_SYSCALL_64_after_hwframe+0x42/0xb7  This was introduced by commit: f84af33 sctp: factor out sctp_sendmsg_to_asoc from sctp_sendmsg  As the newly refactored function moved the wait_for_sndbuf call to a point after the association was connected, allowing for peeloff events to occur, which in turn caused wait_for_sndbuf to return -EPIPE which was not caught by the logic that determines if an association should be freed or not.  Fix it the easy way by returning the ordering of sctp_primitive_ASSOCIATE and sctp_wait_for_sndbuf to the old order, to ensure that EPIPE will not happen.  Tested by myself using the syzbot reproducers with positive results  ",0aee4c259849099cb07ead6cd7fff74e561d5225,1
net: silence KCSAN warnings around sk_add_backlog() calls,"sk_add_backlog() callers usually read sk->sk_rcvbuf without owning the socket lock. This means sk_rcvbuf value can be changed by other cpus, and KCSAN complains.  Add READ_ONCE() annotations to document the lockless nature of these reads.  Note that writes over sk_rcvbuf should also use WRITE_ONCE(), but this will be done in separate patches to ease stable backports (if we decide this is relevant for stable trees).  BUG: KCSAN: data-race in tcp_add_backlog / tcp_recvmsg  write to 0xffff88812ab369f8 of 8 bytes by interrupt on cpu 1:  __sk_add_backlog include/net/sock.h:902 [inline]  sk_add_backlog include/net/sock.h:933 [inline]  tcp_add_backlog+0x45a/0xcc0 net/ipv4/tcp_ipv4.c:1737  tcp_v4_rcv+0x1aba/0x1bf0 net/ipv4/tcp_ipv4.c:1925  ip_protocol_deliver_rcu+0x51/0x470 net/ipv4/ip_input.c:204  ip_local_deliver_finish+0x110/0x140 net/ipv4/ip_input.c:231  NF_HOOK include/linux/netfilter.h:305 [inline]  NF_HOOK include/linux/netfilter.h:299 [inline]  ip_local_deliver+0x133/0x210 net/ipv4/ip_input.c:252  dst_input include/net/dst.h:442 [inline]  ip_rcv_finish+0x121/0x160 net/ipv4/ip_input.c:413  NF_HOOK include/linux/netfilter.h:305 [inline]  NF_HOOK include/linux/netfilter.h:299 [inline]  ip_rcv+0x18f/0x1a0 net/ipv4/ip_input.c:523  __netif_receive_skb_one_core+0xa7/0xe0 net/core/dev.c:5004  __netif_receive_skb+0x37/0xf0 net/core/dev.c:5118  netif_receive_skb_internal+0x59/0x190 net/core/dev.c:5208  napi_skb_finish net/core/dev.c:5671 [inline]  napi_gro_receive+0x28f/0x330 net/core/dev.c:5704  receive_buf+0x284/0x30b0 drivers/net/virtio_net.c:1061  virtnet_receive drivers/net/virtio_net.c:1323 [inline]  virtnet_poll+0x436/0x7d0 drivers/net/virtio_net.c:1428  napi_poll net/core/dev.c:6352 [inline]  net_rx_action+0x3ae/0xa50 net/core/dev.c:6418  read to 0xffff88812ab369f8 of 8 bytes by task 7271 on cpu 0:  tcp_recvmsg+0x470/0x1a30 net/ipv4/tcp.c:2047  inet_recvmsg+0xbb/0x250 net/ipv4/af_inet.c:838  sock_recvmsg_nosec net/socket.c:871 [inline]  sock_recvmsg net/socket.c:889 [inline]  sock_recvmsg+0x92/0xb0 net/socket.c:885  sock_read_iter+0x15f/0x1e0 net/socket.c:967  call_read_iter include/linux/fs.h:1864 [inline]  new_sync_read+0x389/0x4f0 fs/read_write.c:414  __vfs_read+0xb1/0xc0 fs/read_write.c:427  vfs_read fs/read_write.c:461 [inline]  vfs_read+0x143/0x2c0 fs/read_write.c:446  ksys_read+0xd5/0x1b0 fs/read_write.c:587  __do_sys_read fs/read_write.c:597 [inline]  __se_sys_read fs/read_write.c:595 [inline]  __x64_sys_read+0x4c/0x60 fs/read_write.c:595  do_syscall_64+0xcf/0x2f0 arch/x86/entry/common.c:296  entry_SYSCALL_64_after_hwframe+0x44/0xa9  Reported by Kernel Concurrency Sanitizer on: CPU: 0 PID: 7271 Comm: syz-fuzzer Not tainted 5.3.0+ #0 Hardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 01/01/2011  ",8265792bf8871acc2d00fd03883d830e2249d395,1
net: ipv4: fix for a race condition in raw_sendmsg,"inet->hdrincl is racy, and could lead to uninitialized stack pointer usage, so its value should be read only once.  ",8f659a03a0ba9289b9aeb9b4470e6fb263d6f483,1
sctp: not bind the socket in sctp_connect,"Now when sctp_connect() is called with a wrong sa_family, it binds to a port but doesn't set bp->port, then sctp_get_af_specific will return NULL and sctp_connect() returns -EINVAL.  Then if sctp_bind() is called to bind to another port, the last port it has bound will leak due to bp->port is NULL by then.  sctp_connect() doesn't need to bind ports, as later __sctp_connect will do it if bp->port is NULL. So remove it from sctp_connect(). While at it, remove the unnecessary sockaddr.sa_family len check as it's already done in sctp_inet_connect.  ",9b6c08878e23adb7cc84bdca94d8a944b03f099e,0
netfilter: ipset: fix shift-out-of-bounds in htable_bits(),htable_bits() can call jhash_size(32) and trigger shift-out-of-bounds  UBSAN: shift-out-of-bounds in net/netfilter/ipset/ip_set_hash_gen.h:151:6 shift exponent 32 is too large for 32-bit type 'unsigned int' CPU: 0 PID: 8498 Comm: syz-executor519  Not tainted 5.10.0-rc7-next-20201208-syzkaller #0 Call Trace:  __dump_stack lib/dump_stack.c:79 [inline]  dump_stack+0x107/0x163 lib/dump_stack.c:120  ubsan_epilogue+0xb/0x5a lib/ubsan.c:148  __ubsan_handle_shift_out_of_bounds.cold+0xb1/0x181 lib/ubsan.c:395  htable_bits net/netfilter/ipset/ip_set_hash_gen.h:151 [inline]  hash_mac_create.cold+0x58/0x9b net/netfilter/ipset/ip_set_hash_gen.h:1524  ip_set_create+0x610/0x1380 net/netfilter/ipset/ip_set_core.c:1115  nfnetlink_rcv_msg+0xecc/0x1180 net/netfilter/nfnetlink.c:252  netlink_rcv_skb+0x153/0x420 net/netlink/af_netlink.c:2494  nfnetlink_rcv+0x1ac/0x420 net/netfilter/nfnetlink.c:600  netlink_unicast_kernel net/netlink/af_netlink.c:1304 [inline]  netlink_unicast+0x533/0x7d0 net/netlink/af_netlink.c:1330  netlink_sendmsg+0x907/0xe40 net/netlink/af_netlink.c:1919  sock_sendmsg_nosec net/socket.c:652 [inline]  sock_sendmsg+0xcf/0x120 net/socket.c:672  ____sys_sendmsg+0x6e8/0x810 net/socket.c:2345  ___sys_sendmsg+0xf3/0x170 net/socket.c:2399  __sys_sendmsg+0xe5/0x1b0 net/socket.c:2432  do_syscall_64+0x2d/0x70 arch/x86/entry/common.c:46  entry_SYSCALL_64_after_hwframe+0x44/0xa9  This patch replaces htable_bits() by simple fls(hashsize - 1) call: it alone returns valid nbits both for round and non-round hashsizes. It is normal to set any nbits here because it is validated inside following htable_size() call which returns 0 for nbits>31.  ,5c8193f568ae16f3242abad6518dc2ca6c8eef86,1
USB: serial: io_edgeport: fix slab-out-of-bounds read in edge_interrupt_callback,Fix slab-out-of-bounds read in the interrupt-URB completion handler.  The boundary condition should be (length - 1) as we access data[position + 1].  ,57aa9f294b09463492f604feaa5cc719beaace32,1
block: add __must_check for *add_disk*() callers,"Now that we have done a spring cleaning on all drivers and added error checking / handling, let's keep it that way and ensure no new drivers fail to stick with it.  ",278167fd2f8ffe679351605fe03e29ff3ab8db18,1
tipc: fix kernel WARNING in tipc_msg_append(),syzbot found the following issue:  ,c9aa81faf19115fc2e732e7f210b37bb316987ff,0
ext4: fix kernel infoleak via ext4_extent_header,Initialize eh_generation of struct ext4_extent_header to prevent leaking info to userspace. Fixes KMSAN kernel-infoleak bug reported by syzbot at: http://syzkaller.appspot.com/bug?id=78e9ad0e6952a3ca16e8234724b2fa92d041b9b8  ,ce3aba43599f0b50adbebff133df8d08a3d5fffe,1
bpf: Fix error path under memory pressure,Restore the 'if (env->cur_state)' check that was incorrectly removed during code move. Under memory pressure env->cur_state can be freed and zeroed inside do_check(). Hence the check is necessary.  ,f59bbfc2f6099e8655f9e8f585e10ffde17176d0,0
Bluetooth: fix use-after-free error in lock_sock_nested(),use-after-free error in lock_sock_nested is reported:  ,1bff51ea59a9afb67d2dd78518ab0582a54a472c,1
xfrm: destroy xfrm_state synchronously on net exit path,"xfrm_state_put() moves struct xfrm_state to the GC list and schedules the GC work to clean it up. On net exit call path, xfrm_state_flush() is called to clean up and xfrm_flush_gc() is called to wait for the GC work to complete before exit.  However, this doesn't work because one of the ->destructor(), ipcomp_destroy(), schedules the same GC work again inside the GC work. It is hard to wait for such a nested async callback. This is also why syzbot still reports the following warning:   ",f75a2804da391571563c4b6b29e7797787332673,0
sctp: set stream ext to NULL after freeing it in sctp_stream_outq_migrate,"In sctp_stream_init(), after sctp_stream_outq_migrate() freed the surplus streams' ext, but sctp_stream_alloc_out() returns -ENOMEM, stream->outcnt will not be set to 'outcnt'.  With the bigger value on stream->outcnt, when closing the assoc and freeing its streams, the ext of those surplus streams will be freed again since those stream exts were not set to NULL after freeing in sctp_stream_outq_migrate(). Then the invalid-free issue reported by syzbot would be triggered.  We fix it by simply setting them to NULL after freeing.  ",af98c5a78517c04adb5fd68bb64b1ad6fe3d473f,0
vti6: Properly adjust vti6 MTU from MTU of lower device,"If a lower device is found, we don't need to subtract LL_MAX_HEADER to calculate our MTU: just use its MTU, the link layer headers are already taken into account by it.  If the lower device is not found, start from ETH_DATA_LEN instead, and only in this case subtract a worst-case LL_MAX_HEADER.  We then need to subtract our additional IPv6 header from the calculation.  While at it, note that vti6 doesn't have a hardware header, so it doesn't need to set dev->hard_header_len. And as vti6_link_config() now always sets the MTU, there's no need to set a default value in vti6_dev_setup().  This makes the behaviour consistent with IPv4 vti, after commit a32452366b72 (""vti4: Don't count header length twice.""), which was accidentally reverted by merge commit f895f0cfbb77 (""Merge branch 'master' of git://git.kernel.org/pub/scm/linux/kernel/git/klassert/ipsec"").  While commit 53c81e95df17 (""ip6_vti: adjust vti mtu according to mtu of lower device"") improved on the original situation, this was still not ideal. As reported in that commit message itself, if we start from an underlying veth MTU of 9000, we end up with an MTU of 8832, that is, 9000 - LL_MAX_HEADER - sizeof(ipv6hdr). This should simply be 8880, or 9000 - sizeof(ipv6hdr) instead: we found the lower device (veth) and we know we don't have any additional link layer header, so there's no need to subtract an hypothetical worst-case number.  ",c6741fbed6dc0f183d26c4b6bca4517672f92e6c,0
"Revert ""mm/secretmem: use refcount_t instead of atomic_t""","This reverts commit 110860541f443f950c1274f217a1a3e298670a33.  Converting the ""secretmem_users"" counter to a refcount is incorrect, because a refcount is special in zero and can't just be incremented (but a count of users is not, and ""no users"" is actually perfectly valid and not a sign of a free'd resource).  ",87066fdd2e30fe9dd531125d95257c118a74617e,0
rds: Fix build regression.,Use DECLARE_* not DEFINE_*  ,16fdf8ba98391650ce4bc4f3f71629d8a413bc21,0
net: ieee802154: fix nl802154 add llsec key,This patch fixes a nullpointer dereference if NL802154_ATTR_SEC_KEY is not set by the user. If this is the case nl802154 will return -EINVAL.  ,20d5fe2d7103f5c43ad11a3d6d259e9d61165c35,1
bpf: Fix false positive kmemleak report in bpf_ringbuf_area_alloc(),"kmemleak scans struct page, but it does not scan the page content. If we allocate some memory with kmalloc(), then allocate page with alloc_page(), and if we put kmalloc pointer somewhere inside that page, kmemleak will report kmalloc pointer as a false positive.  We can instruct kmemleak to scan the memory area by calling kmemleak_alloc() and kmemleak_free(), but part of struct bpf_ringbuf is mmaped to user space, and if struct bpf_ringbuf changes we would have to revisit and review size argument in kmemleak_alloc(), because we do not want kmemleak to scan the user space memory. Let's simplify things and use kmemleak_not_leak() here.  For posterity, also adding additional prior analysis from Andrii:    I think either kmemleak or syzbot are misreporting this. I've added a   bunch of printks around all allocations performed by BPF ringbuf. [...]   On repro side I get these two warnings:    [vmuser@archvm bpf]$ sudo ./repro   BUG: memory leak   unreferenced object 0xffff88810d538c00 (size 64):     comm ""repro"", pid 2140, jiffies 4294692933 (age 14.540s)     ",ccff81e1d028bbbf8573d3364a87542386c707bf,1
packet: validate address length,Packet sockets with SOCK_DGRAM may pass an address for use in dev_hard_header. Ensure that it is of sufficient length.  ,99137b7888f4058087895d035d81c6b2d31015c5,0
can: j1939: transport: j1939_session_tx_dat(): fix use-after-free read in j1939_tp_txtimer(),"The current stack implementation do not support ECTS requests of not aligned TP sized blocks.  If ECTS will request a block with size and offset spanning two TP blocks, this will cause memcpy() to read beyond the queued skb (which does only contain one TP sized block).  Sometimes KASAN will detect this read if the memory region beyond the skb was previously allocated and freed. In other situations it will stay undetected. The ETP transfer in any case will be corrupted.  This patch adds a sanity check to avoid this kind of read and abort the session with error J1939_XTP_ABORT_ECTS_TOO_BIG.  ",cd3b3636c99fcac52c598b64061f3fe4413c6a12,1
ima: Directly free *entry in ima_alloc_init_template() if digests is NULL,"To support multiple template digests, the static array entry->digest has been replaced with a dynamically allocated array in commit aa724fe18a8a (""ima: Switch to dynamically allocated buffer for template digests""). The array is allocated in ima_alloc_init_template() and if the returned pointer is NULL, ima_free_template_entry() is called.  However, (*entry)->template_desc is not yet initialized while it is used by ima_free_template_entry(). This patch fixes the issue by directly freeing *entry without calling ima_free_template_entry().  ",42413b49804b250ced70dac8815388af2d4ad872,0
pppoe: fix reception of frames with no mac header,pppoe_rcv() needs to look back at the Ethernet header in order to lookup the PPPoE session. Therefore we need to ensure that the mac header is big enough to contain an Ethernet header. Otherwise eth_hdr(skb)->h_source might access invalid data.  ,8540827ebac6b654ab2f69c8fbce9e4fbd6304a0,0
bpf/xskmap: Return ERR_PTR for failure case instead of NULL.,"When kzalloc() failed, NULL was returned to the caller, which tested the pointer with IS_ERR(), which didn't match, so the pointer was used later, resulting in a NULL dereference.  Return ERR_PTR(-ENOMEM) instead of NULL.  ",fcd30ae0665c778e283f73c1c885c7fd26d12ef2,1
vhost: Check docket sk_family instead of call getname,"Doing so, we save one call to get data we already have in the struct.  Also, since there is no guarantee that getname use sockaddr_ll parameter beyond its size, we add a little bit of security here. It should do not do beyond MAX_ADDR_LEN, but syzbot found that ax25_getname writes more (72 bytes, the size of full_sockaddr_ax25, versus 20 + 32 bytes of sockaddr_ll + MAX_ADDR_LEN in syzbot repro).  ",42d84c8490f9f0931786f1623191fcab397c3d64,0
mm: avoid data corruption on CoW fault into PFN-mapped VMA,Jeff Moyer has reported that one of xfstests triggers a warning when run on DAX-enabled filesystem:  	,c3e5ea6ee574ae5e845a40ac8198de1fb63bb3ab,1
"x86/perf: Use RET0 as default for guest_get_msrs to handle ""no PMU"" case","Initialize x86_pmu.guest_get_msrs to return 0/NULL to handle the ""nop"" case.  Patching in perf_guest_get_msrs_nop() during setup does not work if there is no PMU, as setup bails before updating the static calls, leaving x86_pmu.guest_get_msrs NULL and thus a complete nop.  Ultimately, this causes VMX abort on VM-Exit due to KVM putting random garbage from the stack into the MSR load list.  Add a comment in KVM to note that nr_msrs is valid if and only if the return value is non-NULL.  ",c8e2fe13d1d1f3a02842b7b909d4e4846a4b6a2c,0
KVM: x86: Fix kernel info-leak in KVM_HC_CLOCK_PAIRING hypercall,"kvm_pv_clock_pairing() allocates local var ""struct kvm_clock_pairing clock_pairing"" on stack and initializes all it's fields besides padding (clock_pairing.pad[]).  Because clock_pairing var is written completely (including padding) to guest memory, failure to init struct padding results in kernel info-leak.  Fix the issue by making sure to also init the padding with zeroes.  ",bcbfbd8ec21096027f1ee13ce6c185e8175166f6,0
crypto: chacha20poly1305 - validate the digest size,"If the rfc7539 template was instantiated with a hash algorithm with digest size larger than 16 bytes (POLY1305_DIGEST_SIZE), then the digest overran the 'tag' buffer in 'struct chachapoly_req_ctx', corrupting the subsequent memory, including 'cryptlen'.  This caused a crash during crypto_skcipher_decrypt().  Fix it by, when instantiating the template, requiring that the underlying hash algorithm has the digest size expected for Poly1305.  Reproducer:      #include <linux/if_alg.h>     #include <sys/socket.h>     #include <unistd.h>      int main()     {             int algfd, reqfd;             struct sockaddr_alg addr = {                     .salg_type = ""aead"",                     .salg_name = ""rfc7539(chacha20,sha256)"",             };             unsigned char buf[32] = { 0 };              algfd = socket(AF_ALG, SOCK_SEQPACKET, 0);             bind(algfd, (void *)&addr, sizeof(addr));             setsockopt(algfd, SOL_ALG, ALG_SET_KEY, buf, sizeof(buf));             reqfd = accept(algfd, 0, 0);             write(reqfd, buf, 16);             read(reqfd, buf, 16);     }  ",e57121d08c38dabec15cf3e1e2ad46721af30cae,1
Smack: fix use-after-free in smk_write_relabel_self(),"smk_write_relabel_self() frees memory from the task's credentials with no locking, which can easily cause a use-after-free because multiple tasks can share the same credentials structure.  Fix this by using prepare_creds() and commit_creds() to correctly modify the task's credentials.  Reproducer for ""BUG: KASAN: use-after-free in smk_write_relabel_self"":  	#include <fcntl.h> 	#include <pthread.h> 	#include <unistd.h>  	static void *thrproc(void *arg) 	{ 		int fd = open(""/sys/fs/smackfs/relabel-self"", O_WRONLY); 		for (;;) write(fd, ""foo"", 3); 	}  	int main() 	{ 		pthread_t t; 		pthread_create(&t, NULL, thrproc, NULL); 		thrproc(NULL); 	}  ",beb4ee6770a89646659e6a2178538d2b13e2654e,1
tty: Fix data race between tiocsti() and flush_to_ldisc(),"The ops->receive_buf() may be accessed concurrently from these two functions.  If the driver flushes data to the line discipline receive_buf() method while tiocsti() is waiting for the ops->receive_buf() to finish its work, the data race will happen.  For example: tty_ioctl			|tty_ldisc_receive_buf  ->tioctsi			| ->tty_port_default_receive_buf 				|  ->tty_ldisc_receive_buf    ->hci_uart_tty_receive	|   ->hci_uart_tty_receive     ->h4_recv                   |    ->h4_recv  In this case, the h4 receive buffer will be overwritten by the latecomer, and we will lost the data.  Hence, change tioctsi() function to use the exclusive lock interface from tty_buffer to avoid the data race.  ",bb2853a6a421a052268eee00fd5d3f6b3504b2b1,1
hugetlb_cgroup: fix illegal access to memory,"This appears to be a mistake in commit faced7e0806cf (""mm: hugetlb controller for cgroups v2"").  Essentially that commit does a hugetlb_cgroup_from_counter assuming that page_counter_try_charge has initialized counter.  But if that has failed then it seems will not initialize counter, so hugetlb_cgroup_from_counter(counter) ends up pointing to random memory, causing kasan to complain.  The solution is to simply use 'h_cg', instead of hugetlb_cgroup_from_counter(counter), since that is a reference to the hugetlb_cgroup anyway.  After this change kasan ceases to complain.  ",726b7bbeafd4e0219c37b74673d368b21ff3d039,0
USB: yurex: Don't retry on unexpected errors,"According to Greg KH, it has been generally agreed that when a USB driver encounters an unknown error (or one it can't handle directly), it should just give up instead of going into a potentially infinite retry loop.  The three codes -EPROTO, -EILSEQ, and -ETIME fall into this category. They can be caused by bus errors such as packet loss or corruption, attempting to communicate with a disconnected device, or by malicious firmware.  Nowadays the extent of packet loss or corruption is negligible, so it should be safe for a driver to give up whenever one of these errors occurs.  Although the yurex driver handles -EILSEQ errors in this way, it doesn't do the same for -EPROTO (as discovered by the syzbot fuzzer) or other unrecognized errors.  This patch adjusts the driver so that it doesn't log an error message for -EPROTO or -ETIME, and it doesn't retry after any errors.  ",32a0721c6620b77504916dac0cea8ad497c4878a,1
rds: fix crash in rds_info_getsockopt(),The conversion to pin_user_pages() had a bug: it overlooked the case of allocation of pages failing. Fix that by restoring an equivalent check.  ,f78cdbd75a57245ecc68f5a40e470933426a082b,1
rpc_pipefs: fix double-dput(),if we ever hit rpc_gssd_dummy_depopulate() dentry passed to it has refcount equal to 1.  __rpc_rmpipe() drops it and dput() done after that hits an already freed dentry.  ,4a3877c4cedd95543f8726b0a98743ed8db0c0fb,0
ipvs: ignore IP_VS_SVC_F_HASHED flag when adding service,"syzbot reported memory leak [1] when adding service with HASHED flag. We should ignore this flag both from sockopt and netlink provided data, otherwise the service is not hashed and not visible while releasing resources.  [1] BUG: memory leak unreferenced object 0xffff888115227800 (size 512):   comm ""syz-executor263"", pid 8658, jiffies 4294951882 (age 12.560s)   ",56e4ee82e850026d71223262c07df7d6af3bd872,1
fuse: allow sharing existing sb,"Make it possible to create a new mount from a already working server.  Here's a detailed description of the problem from Jakob:    ""The background for this question is occasional problems we see with our    fuse filesystem [1] and mount namespaces. On a usual client, we have    system-wide, autofs managed mountpoints. When a new mount namespace is    created (which can be done unprivileged in combination with user    namespaces), it can happen that a mountpoint is used inside the new    namespace but idle in the root mount namespace. So autofs unmounts the    parent, system-wide mountpoint. But the fuse module stays active and    still serves mountpoint in the child mount namespace. Because the fuse    daemon also blocks other system wide resources corresponding to the    mountpoint, this situation effectively prevents new mounts until the    child mount namespaces closes.     [1] https://github.com/cvmfs/cvmfs""  ",5d5b74aa9c766f0dd37d5cc1a2a7a94586130501,1
cfg80211: check for set_wiphy_params,"Check if set_wiphy_params is assigned and return an error if not, some drivers (e.g. virt_wifi where syzbot reported it) don't have it.  ",24953de0a5e31dcca7e82c8a3c79abc2dfe8fb6e,0
bpf: Add missing map_delete_elem method to bloom filter map,"Without it, kernel crashes in map_delete_elem(), as reported by syzbot.  BUG: kernel NULL pointer dereference, ",ad10c381d133d9f786564bff4b223be1372f6c2a,1
media: mceusb: sanity check for prescaler value,"prescaler larger than 8 would mean the carrier is at most 152Hz, which does not make sense for IR carriers.  ",9dec0f48a75e0dadca498002d25ef4e143e60194,1
f2fs: fix to avoid racing on fsync_entry_slab by multi filesystem instances,"As syzbot reported, there is an use-after-free issue during f2fs recovery:  Use-after-free write at 0xffff88823bc16040 (in kfence-#10):  kmem_cache_destroy+0x1f/0x120 mm/slab_common.c:486  f2fs_recover_fsync_data+0x75b0/0x8380 fs/f2fs/recovery.c:869  f2fs_fill_super+0x9393/0xa420 fs/f2fs/super.c:3945  mount_bdev+0x26c/0x3a0 fs/super.c:1367  legacy_get_tree+0xea/0x180 fs/fs_context.c:592  vfs_get_tree+0x86/0x270 fs/super.c:1497  do_new_mount fs/namespace.c:2905 [inline]  path_mount+0x196f/0x2be0 fs/namespace.c:3235  do_mount fs/namespace.c:3248 [inline]  __do_sys_mount fs/namespace.c:3456 [inline]  __se_sys_mount+0x2f9/0x3b0 fs/namespace.c:3433  do_syscall_64+0x3f/0xb0 arch/x86/entry/common.c:47  entry_SYSCALL_64_after_hwframe+0x44/0xae  The root cause is multi f2fs filesystem instances can race on accessing global fsync_entry_slab pointer, result in use-after-free issue of slab cache, fixes to init/destroy this slab cache only once during module init/destroy procedure to avoid this issue.  ",cad83c968c2ebe97905f900326988ed37146c347,1
vsock/virtio: free queued packets when closing socket,"As reported by syzbot [1], there is a memory leak while closing the socket. We partially solved this issue with commit ac03046ece2b (""vsock/virtio: free packets during the socket release""), but we forgot to drain the RX queue when the socket is definitely closed by the scheduled work.  To avoid future issues, let's use the new virtio_transport_remove_sock() to drain the RX queue before removing the socket from the af_vsock lists calling vsock_remove_sock().  [1] https://syzkaller.appspot.com/bug?extid=24452624fc4c571eedd9  ",8432b8114957235f42e070a16118a7f750de9d39,1
video: fbdev: fix OOB read in vga_8planes_imageblit(),"syzbot is reporting OOB read at vga_8planes_imageblit() [1], for ""cdat[y] >> 4"" can become a negative value due to ""const char *cdat"".  [1] https://syzkaller.appspot.com/bug?id=0d7a0da1557dcd1989e00cb3692b26d4173b4132  ",bd018a6a75cebb511bb55a0e7690024be975fe93,1
bpf: fix 32-bit divide by zero,due to some JITs doing if (src_reg == 0) check in 64-bit mode for div/mod operations mask upper 32-bits of src register before doing the check  ,68fda450a7df51cff9e5a4d4a4d9d0d5f2589153,0
team: Forbid enslaving team device to itself,"team's ndo_add_slave() acquires 'team->lock' and later tries to open the newly enslaved device via dev_open(). This emits a 'NETDEV_UP' event that causes the VLAN driver to add VLAN 0 on the team device. team's ndo_vlan_rx_add_vid() will also try to acquire 'team->lock' and deadlock.  Fix this by checking early at the enslavement function that a team device is not being enslaved to itself.  A similar check was added to the bond driver in commit 09a89c219baf (""bonding: disallow enslaving a bond to itself"").  ",471b83bd8bbe4e89743683ef8ecb78f7029d8288,0
tty: fix compat TIOCGSERIAL leaking uninitialized memory,"Commit 77654350306a (""take compat TIOC[SG]SERIAL treatment into tty_compat_ioctl()"") changed the compat version of TIOCGSERIAL to start copying a whole 'serial_struct32' to userspace rather than individual fields, but failed to initialize all padding and fields -- namely the hole after the 'iomem_reg_shift' field, and the 'reserved' field.  Fix this by initializing the struct to zero.  [v2: use sizeof, and convert the adjacent line for consistency.]  ",17329563a97df3ba474eca5037c1336e46e14ff8,1
sctp: use call_rcu to free endpoint,"This patch is to delay the endpoint free by calling call_rcu() to fix another use-after-free issue in sctp_sock_dump():    BUG: KASAN: use-after-free in __lock_acquire+0x36d9/0x4c20   Call Trace:     __lock_acquire+0x36d9/0x4c20 kernel/locking/lockdep.c:3218     lock_acquire+0x1ed/0x520 kernel/locking/lockdep.c:3844     __raw_spin_lock_bh include/linux/spinlock_api_smp.h:135 [inline]     _raw_spin_lock_bh+0x31/0x40 kernel/locking/spinlock.c:168     spin_lock_bh include/linux/spinlock.h:334 [inline]     __lock_sock+0x203/0x350 net/core/sock.c:2253     lock_sock_nested+0xfe/0x120 net/core/sock.c:2774     lock_sock include/net/sock.h:1492 [inline]     sctp_sock_dump+0x122/0xb20 net/sctp/diag.c:324     sctp_for_each_transport+0x2b5/0x370 net/sctp/socket.c:5091     sctp_diag_dump+0x3ac/0x660 net/sctp/diag.c:527     __inet_diag_dump+0xa8/0x140 net/ipv4/inet_diag.c:1049     inet_diag_dump+0x9b/0x110 net/ipv4/inet_diag.c:1065     netlink_dump+0x606/0x1080 net/netlink/af_netlink.c:2244     __netlink_dump_start+0x59a/0x7c0 net/netlink/af_netlink.c:2352     netlink_dump_start include/linux/netlink.h:216 [inline]     inet_diag_handler_cmd+0x2ce/0x3f0 net/ipv4/inet_diag.c:1170     __sock_diag_cmd net/core/sock_diag.c:232 [inline]     sock_diag_rcv_msg+0x31d/0x410 net/core/sock_diag.c:263     netlink_rcv_skb+0x172/0x440 net/netlink/af_netlink.c:2477     sock_diag_rcv+0x2a/0x40 net/core/sock_diag.c:274  This issue occurs when asoc is peeled off and the old sk is freed after getting it by asoc->base.sk and before calling lock_sock(sk).  To prevent the sk free, as a holder of the sk, ep should be alive when calling lock_sock(). This patch uses call_rcu() and moves sock_put and ep free into sctp_endpoint_destroy_rcu(), so that it's safe to try to hold the ep under rcu_read_lock in sctp_transport_traverse_process().  If sctp_endpoint_hold() returns true, it means this ep is still alive and we have held it and can continue to dump it; If it returns false, it means this ep is dead and can be freed after rcu_read_unlock, and we should skip it.  In sctp_sock_dump(), after locking the sk, if this ep is different from tsp->asoc->ep, it means during this dumping, this asoc was peeled off before calling lock_sock(), and the sk should be skipped; If this ep is the same with tsp->asoc->ep, it means no peeloff happens on this asoc, and due to lock_sock, no peeloff will happen either until release_sock.  Note that delaying endpoint free won't delay the port release, as the port release happens in sctp_endpoint_destroy() before calling call_rcu(). Also, freeing endpoint by call_rcu() makes it safe to access the sk by asoc->base.sk in sctp_assocs_seq_show() and sctp_rcv().  Thanks Jones to bring this issue up.  v1->v2:   - improve the changelog.   - add kfree(ep) into sctp_endpoint_destroy_rcu(), as Jakub noticed.  ",5ec7d18d1813a5bead0b495045606c93873aecbb,1
ipv6: prevent user from adding cached routes,"Cached routes should only be created by the system when receiving pmtu discovery or ip redirect msg. Users should not be allowed to create cached routes.  Furthermore, after the patch series to move cached routes into exception table, user added cached routes will trigger the following warning in fib6_add():  ",2ea2352ede9d97585164a7e19224955f4e4ca8db,0
ext4: check for invalid block size early when mounting a file system,"Check for valid block size directly by validating s_log_block_size; we were doing this in two places.  First, by calculating blocksize via BLOCK_SIZE << s_log_block_size, and then checking that the blocksize was valid.  And then secondly, by checking s_log_block_size directly.  The first check is not reliable, and can trigger an UBSAN warning if s_log_block_size on a maliciously corrupted superblock is greater than 22.  This is harmless, since the second test will correctly reject the maliciously fuzzed file system, but to make syzbot shut up, and because the two checks are duplicative in any case, delete the blocksize check, and move the s_log_block_size earlier in ext4_fill_super().  ",c9200760da8a728eb9767ca41a956764b28c1310,0
fs/locks: use properly initialized file_lock when unlocking.,"Both locks_remove_posix() and locks_remove_flock() use a struct file_lock without calling locks_init_lock() on it. This means the various list_heads are not initialized, which will become a problem with a later patch.  So change them both to initialize properly.  For flock locks, this involves using flock_make_lock(), and changing it to allow a file_lock to be passed in, so memory allocation isn't always needed.  ",d6367d6241371566597c9ab6efe4de0abf254eed,0
cls_flower: call nla_ok() before nla_next(),"fl_set_enc_opt() simply checks if there are still bytes left to parse, but this is not sufficent as syzbot seems to be able to generate malformatted netlink messages. nla_ok() is more strict so should be used to validate the next nlattr here.  And nla_validate_nested_deprecated() has less strict check too, it is probably too late to switch to the strict version, but we can just call nla_ok() too after it.  ",c96adff95619178e2118925578343ad54857c80c,0
io-wq: fix silly logic error in io_task_work_match(),"We check for the func with an OR condition, which means it always ends up being false and we never match the task_work we want to cancel. In the unexpected case that we do exit with that pending, we can trigger a hang waiting for a worker to exit, but it was never created. syzbot reports that as such:  INFO: task syz-executor687:8514 blocked for more than 143 seconds.       Not tainted 5.14.0-syzkaller #0 ""echo 0 > /proc/sys/kernel/hung_task_timeout_secs"" disables this message. ",3b33e3f4a6c0296812a7ee757bdae83290e64aed,1
llc: better deal with too small mtu,"syzbot loves to set very small mtu on devices, since it brings joy. We must make llc_ui_sendmsg() fool proof.  usercopy: Kernel memory overwrite attempt detected to wrapped address (offset 0, size 18446612139802320068)!  kernel BUG at mm/usercopy.c:100! invalid opcode: 0000 [#1] SMP KASAN Dumping ftrace buffer:    (ftrace buffer empty) ",2c5d5b13c6eb79f5677e206b8aad59b3a2097f60,1
xfrm: Fix stack-out-of-bounds read in xfrm_state_find.,"When we do tunnel or beet mode, we pass saddr and daddr from the template to xfrm_state_find(), this is ok. On transport mode, we pass the addresses from the flowi, assuming that the IP addresses (and address family) don't change during transformation. This assumption is wrong in the IPv4 mapped IPv6 case, packet is IPv4 and template is IPv6. Fix this by using the addresses from the template unconditionally.  ",c9f3f813d462c72dbe412cee6a5cbacf13c4ad5e,1
loop: fix LOOP_GET_STATUS lock imbalance,"Commit 2d1d4c1e591f made loop_get_status() drop lo_ctx_mutex before returning, but the loop_get_status_old(), loop_get_status64(), and loop_get_status_compat() wrappers don't call loop_get_status() if the passed argument is NULL. The callers expect that the lock is dropped, so make sure we drop it in that case, too.  ",bdac616db9bbadb90b7d6a406144571015e138f7,0
io_uring: initialize ctx->sqo_wait earlier,"Ensure that ctx->sqo_wait is initialized as soon as the ctx is allocated, instead of deferring it to the offload setup. This fixes a syzbot reported lockdep complaint, which is really due to trying to wake_up on an uninitialized wait queue:  ",583863ed918136412ddf14de2e12534f17cfdc6f,1
nl80211: validate key indexes for cfg80211_registered_device,"syzbot discovered a bug in which an OOB access was being made because an unsuitable key_idx value was wrongly considered to be acceptable while deleting a key in nl80211_del_key().  Since we don't know the cipher at the time of deletion, if cfg80211_validate_key_settings() were to be called directly in nl80211_del_key(), even valid keys would be wrongly determined invalid, and deletion wouldn't occur correctly. For this reason, a new function - cfg80211_valid_key_idx(), has been created, to determine if the key_idx value provided is valid or not. cfg80211_valid_key_idx() is directly called in 2 places - nl80211_del_key(), and cfg80211_validate_key_settings().  ",2d9463083ce92636a1bdd3e30d1236e3e95d859e,1
bpf: fix verifier NULL pointer dereference,do_check() can fail early without allocating env->cur_state under memory pressure.  Syzkaller found the stack below on the linux-next tree because of this.    kasan: CONFIG_KASAN_INLINE enabled   kasan: GPF could be caused by NULL-ptr deref or user memory access   general protection fault: 0000 [#1] SMP KASAN   Dumping ftrace buffer:      (ftrace buffer empty)   ,8c01c4f896aa3404af948880dcb29a2d51c833dc,1
net: mcs7830: handle usb read errors properly,"Syzbot reported uninit value in mcs7830_bind(). The problem was in missing validation check for bytes read via usbnet_read_cmd().  usbnet_read_cmd() internally calls usb_control_msg(), that returns number of bytes read. Code should validate that requested number of bytes was actually read.  So, this patch adds missing size validation check inside mcs7830_get_reg() to prevent uninit value bugs  ",d668769eb9c52b150753f1653f7f5a0aeb8239d2,0
net: sched: do not allocate a tracker in tcf_exts_init(),"While struct tcf_exts has a net pointer, it is not refcounted until tcf_exts_get_net() is called.  ",cb963a19d99fc42d9abf4238968ef85fcc2ef3e3,0
"net, neigh: clear whole pneigh_entry at alloc time","Commit 2c611ad97a82 (""net, neigh: Extend neigh->flags to 32 bit to allow for extensions"") enables a new KMSAM warning [1]  I think the bug is actually older, because the following intruction only occurred if ndm->ndm_flags had NTF_PROXY set.  	pn->flags = ndm->ndm_flags;  Let's clear all pneigh_entry fields at alloc time.  [1] BUG: KMSAN: uninit-value in pneigh_fill_info+0x986/0xb30 net/core/neighbour.c:2593  pneigh_fill_info+0x986/0xb30 net/core/neighbour.c:2593  pneigh_dump_table net/core/neighbour.c:2715 [inline]  neigh_dump_info+0x1e3f/0x2c60 net/core/neighbour.c:2832  netlink_dump+0xaca/0x16a0 net/netlink/af_netlink.c:2265  __netlink_dump_start+0xd1c/0xee0 net/netlink/af_netlink.c:2370  netlink_dump_start include/linux/netlink.h:254 [inline]  rtnetlink_rcv_msg+0x181b/0x18c0 net/core/rtnetlink.c:5534  netlink_rcv_skb+0x447/0x800 net/netlink/af_netlink.c:2491  rtnetlink_rcv+0x50/0x60 net/core/rtnetlink.c:5589  netlink_unicast_kernel net/netlink/af_netlink.c:1319 [inline]  netlink_unicast+0x1095/0x1360 net/netlink/af_netlink.c:1345  netlink_sendmsg+0x16f3/0x1870 net/netlink/af_netlink.c:1916  sock_sendmsg_nosec net/socket.c:704 [inline]  sock_sendmsg net/socket.c:724 [inline]  sock_write_iter+0x594/0x690 net/socket.c:1057  call_write_iter include/linux/fs.h:2162 [inline]  new_sync_write fs/read_write.c:503 [inline]  vfs_write+0x1318/0x2030 fs/read_write.c:590  ksys_write+0x28c/0x520 fs/read_write.c:643  __do_sys_write fs/read_write.c:655 [inline]  __se_sys_write fs/read_write.c:652 [inline]  __x64_sys_write+0xdb/0x120 fs/read_write.c:652  do_syscall_x64 arch/x86/entry/common.c:51 [inline]  do_syscall_64+0x54/0xd0 arch/x86/entry/common.c:82  entry_SYSCALL_64_after_hwframe+0x44/0xae  ",e195e9b5dee6459d8c8e6a314cc71a644a0537fd,1
devlink: Fix use-after-free when destroying health reporters,Dereferencing the reporter after it was destroyed in order to unlock the reporters lock results in a use-after-free [1].  Fix this by storing a pointer to the lock in a local variable before destroying the reporter.  [1] ,5d037b4d3df7b77ecd22fa8e10f5000bdc42cc8b,1
tun: relax check on eth_get_headlen() return value,"syzkaller hit the WARN() in tun_get_user(), providing skb with payload in fragments only, and nothing in skb->head  GRO layer is fine with this, so relax the check.  ",010f245b9dd734adda6386c494a4ace953ea8dc4,1
genetlink: fix memory leaks in genl_family_rcv_msg_dumpit(),"There are two kinds of memory leaks in genl_family_rcv_msg_dumpit():  1. Before we call ops->start(), whenever an error happens, we forget    to free the memory allocated in genl_family_rcv_msg_dumpit().  2. When ops->start() fails, the 'info' has been already installed on    the per socket control block, so we should not free it here. More    importantly, nlk->cb_running is still false at this point, so    netlink_sock_destruct() cannot free it either.  The first kind of memory leaks is easier to resolve, but the second one requires some deeper thoughts.  After reviewing how netfilter handles this, the most elegant solution I find is just to use a similar way to allocate the memory, that is, moving memory allocations from caller into ops->start(). With this, we can solve both kinds of memory leaks: for 1), no memory allocation happens before ops->start(); for 2), ops->start() handles its own failures and 'info' is installed to the socket control block only when success. The only ugliness here is we have to pass all local variables on stack via a struct, but this is not hard to understand.  Alternatively, we can introduce a ops->free() to solve this too, but it is overkill as only genetlink has this problem so far.  ",c36f05559104b66bcd7f617e931e38c680227b74,1
ANDROID: binder: remove waitqueue when thread exits.,"binder_poll() passes the thread->wait waitqueue that can be slept on for work. When a thread that uses epoll explicitly exits using BINDER_THREAD_EXIT, the waitqueue is freed, but it is never removed from the corresponding epoll data structure. When the process subsequently exits, the epoll cleanup code tries to access the waitlist, which results in a use-after-free.  Prevent this by using POLLFREE when the thread exits.  ",f5cb779ba16334b45ba8946d6bfa6d9834d1527f,1
wireguard: send: account for mtu=0 devices,"It turns out there's an easy way to get packets queued up while still having an MTU of zero, and that's via persistent keep alive. This commit makes sure that in whatever condition, we don't wind up dividing by zero. Note that an MTU of zero for a wireguard interface is something quasi-valid, so I don't think the correct fix is to limit it via min_mtu. This can be reproduced easily with:  ip link add wg0 type wireguard ip link add wg1 type wireguard ip link set wg0 up mtu 0 ip link set wg1 up wg set wg0 private-key <(wg genkey) wg set wg1 listen-port 1 private-key <(wg genkey) peer $(wg show wg0 public-key) wg set wg0 peer $(wg show wg1 public-key) persistent-keepalive 1 endpoint 127.0.0.1:1  However, while min_mtu=0 seems fine, it makes sense to restrict the max_mtu. This commit also restricts the maximum MTU to the greatest number for which rounding up to the padding multiple won't overflow a signed integer. Packets this large were always rejected anyway eventually, due to checks deeper in, but it seems more sound not to even let the administrator configure something that won't work anyway.  We use this opportunity to clean up this function a bit so that it's clear which paths we're expecting.  ",175f1ca9a9ed8689d2028da1a7c624bb4fb4ff7e,1
ALSA: usb-audio: Fix incorrect size check for processing/extension units,"The recently introduced unit descriptor validation had some bug for processing and extension units, it counts a bControlSize byte twice so it expected a bigger size than it should have been.  This seems resulting in a probe error on a few devices.  Fix the calculation for proper checks of PU and EU.  ",976a68f06b2ea49e2ab67a5f84919a8b105db8be,0
cfg80211: regulatory: reject invalid hints,Reject invalid hints early in order to not cause a kernel WARN later if they're restored to or similar.  ,47caf685a6854593348f216e0b489b71c10cbe03,0
net/ipv6: Fix ip6_convert_metrics() bug,"If ip6_convert_metrics() fails to allocate memory, it should not overwrite rt->fib6_metrics or we risk a crash later as syzbot found.  BUG: KASAN: null-ptr-deref in atomic_read include/asm-generic/atomic-instrumented.h:21 [inline] BUG: KASAN: null-ptr-deref in refcount_sub_and_test+0x92/0x330 lib/refcount.c:179 Read of size 4 at addr 0000000000000044 by task syzkaller832429/4487  CPU: 1 PID: 4487 Comm: syzkaller832429 Not tainted 4.16.0+ #6 Hardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 01/01/2011 Call Trace:  __dump_stack lib/dump_stack.c:77 [inline]  dump_stack+0x1b9/0x294 lib/dump_stack.c:113  kasan_report_error mm/kasan/report.c:352 [inline]  kasan_report.cold.7+0x6d/0x2fe mm/kasan/report.c:412  check_memory_region_inline mm/kasan/kasan.c:260 [inline]  check_memory_region+0x13e/0x1b0 mm/kasan/kasan.c:267  kasan_check_read+0x11/0x20 mm/kasan/kasan.c:272  atomic_read include/asm-generic/atomic-instrumented.h:21 [inline]  refcount_sub_and_test+0x92/0x330 lib/refcount.c:179  refcount_dec_and_test+0x1a/0x20 lib/refcount.c:212  fib6_info_destroy+0x2d0/0x3c0 net/ipv6/ip6_fib.c:206  fib6_info_release include/net/ip6_fib.h:304 [inline]  ip6_route_info_create+0x677/0x3240 net/ipv6/route.c:3020  ip6_route_add+0x23/0xb0 net/ipv6/route.c:3030  inet6_rtm_newroute+0x142/0x160 net/ipv6/route.c:4406  rtnetlink_rcv_msg+0x466/0xc10 net/core/rtnetlink.c:4648  netlink_rcv_skb+0x172/0x440 net/netlink/af_netlink.c:2448  rtnetlink_rcv+0x1c/0x20 net/core/rtnetlink.c:4666  netlink_unicast_kernel net/netlink/af_netlink.c:1310 [inline]  netlink_unicast+0x58b/0x740 net/netlink/af_netlink.c:1336  netlink_sendmsg+0x9f0/0xfa0 net/netlink/af_netlink.c:1901  sock_sendmsg_nosec net/socket.c:629 [inline]  sock_sendmsg+0xd5/0x120 net/socket.c:639  ___sys_sendmsg+0x805/0x940 net/socket.c:2117  __sys_sendmsg+0x115/0x270 net/socket.c:2155  SYSC_sendmsg net/socket.c:2164 [inline]  SyS_sendmsg+0x29/0x30 net/socket.c:2162  do_syscall_64+0x29e/0x9d0 arch/x86/entry/common.c:287  entry_SYSCALL_64_after_hwframe+0x42/0xb7  ",263243d6c2573cd761ef7ab773d3c467db0122f6,1
locking/lockdep: Fix bad recursion pattern,There were two patterns for lockdep_recursion:  Pattern-A: 	if (current->lockdep_recursion) 		return  	current->lockdep_recursion = 1; 	,10476e6304222ced7df9b3d5fb0a043b3c2a1ad8,0
Input: mousedev - add a schedule point in mousedev_write(),syzbot was able to trigger rcu stalls by calling write() with large number of bytes.  Add a cond_resched() in the loop to avoid this.  ,f74c371fe72a4f820d287db8067683fb533e4ede,0
mac80211: fix locking in ieee80211_start_ap error path,"We need to hold the local->mtx to release the channel context, as even encoded by the lockdep_assert_held() there. Fix it.  ",87a270625a89fc841f1a7e21aae6176543d8385c,0
bpfilter: fix race in pipe access,syzbot reported the following crash ,66e58e0ef80a56a1d7857b6ce121141563cdd93e,1
block: add an explicit ->disk backpointer to the request_queue,"Replace the magic lookup through the kobject tree with an explicit backpointer, given that the device model links are set up and torn down at times when I/O is still possible, leading to potential NULL or invalid pointer dereferences.  ",d152c682f03ceb65c0d9663d4ba6ee2d46aa784d,1
ethtool: strset: fix message length calculation,Outer nest for ETHTOOL_A_STRSET_STRINGSETS is not accounted for. This may result in ETHTOOL_MSG_STRSET_GET producing a warning like:      calculated message payload length (684) not sufficient     ,e175aef902697826d344ce3a12189329848fe898,0
net: rtnetlink: fix bugs in rtnl_alt_ifname(),"Since IFLA_ALT_IFNAME is an NLA_STRING, we have no guarantee it is nul terminated.  We should use nla_strdup() instead of kstrdup(), since this helper will make sure not accessing out-of-bounds data.  BUG: KMSAN: uninit-value in strlen+0x5e/0xa0 lib/string.c:535 CPU: 1 PID: 19157 Comm: syz-executor.5 Not tainted 5.5.0-rc5-syzkaller #0 Hardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 01/01/2011 Call Trace:  __dump_stack lib/dump_stack.c:77 [inline]  dump_stack+0x1c9/0x220 lib/dump_stack.c:118  kmsan_report+0xf7/0x1e0 mm/kmsan/kmsan_report.c:118  __msan_warning+0x58/0xa0 mm/kmsan/kmsan_instr.c:215  strlen+0x5e/0xa0 lib/string.c:535  kstrdup+0x7f/0x1a0 mm/util.c:59  rtnl_alt_ifname net/core/rtnetlink.c:3495 [inline]  rtnl_linkprop+0x85d/0xc00 net/core/rtnetlink.c:3553  rtnl_newlinkprop+0x9d/0xb0 net/core/rtnetlink.c:3568  rtnetlink_rcv_msg+0x1153/0x1570 net/core/rtnetlink.c:5424  netlink_rcv_skb+0x451/0x650 net/netlink/af_netlink.c:2477  rtnetlink_rcv+0x50/0x60 net/core/rtnetlink.c:5442  netlink_unicast_kernel net/netlink/af_netlink.c:1302 [inline]  netlink_unicast+0xf9e/0x1100 net/netlink/af_netlink.c:1328  netlink_sendmsg+0x1248/0x14d0 net/netlink/af_netlink.c:1917  sock_sendmsg_nosec net/socket.c:639 [inline]  sock_sendmsg net/socket.c:659 [inline]  ____sys_sendmsg+0x12b6/0x1350 net/socket.c:2330  ___sys_sendmsg net/socket.c:2384 [inline]  __sys_sendmsg+0x451/0x5f0 net/socket.c:2417  __do_sys_sendmsg net/socket.c:2426 [inline]  __se_sys_sendmsg+0x97/0xb0 net/socket.c:2424  __x64_sys_sendmsg+0x4a/0x70 net/socket.c:2424  do_syscall_64+0xb8/0x160 arch/x86/entry/common.c:296  entry_SYSCALL_64_after_hwframe+0x44/0xa9 ",44bfa9c5e5f06c72540273813e4c66beb5a8c213,1
io_uring: park SQPOLL thread if it's percpu,"kthread expects this, or we can throw a warning on exit:  ",06058632464845abb1af91521122fd04dd3daaec,0
locking/lockdep: Make lockdep_unregister_key() honor 'debug_locks' again,If lockdep_register_key() and lockdep_unregister_key() are called with debug_locks == false then the following warning is reported:    ,8b39adbee805c539a461dbf208b125b096152b1c,0
NFC: pn533: fix use-after-free and memleaks,The driver would fail to deregister and its class device and free related resources on late probe errors.  ,6af3aa57a0984e061f61308fe181a9a12359fecc,1
fou: Prevent unbounded recursion in GUE error handler,"Handling exceptions for direct UDP encapsulation in GUE (that is, UDP-in-UDP) leads to unbounded recursion in the GUE exception handler, syzbot reported.  While draft-ietf-intarea-gue-06 doesn't explicitly forbid direct encapsulation of UDP in GUE, it probably doesn't make sense to set up GUE this way, and it's currently not even possible to configure this.  Skip exception handling if the GUE proto/ctype field is set to the UDP protocol number. Should we need to handle exceptions for UDP-in-GUE one day, we might need to either explicitly set a bound for recursion, or implement a special iterative handling for these cases.  ",11789039da536fea96c98a40c2b441decf2e7323,1
media: em28xx: fix memory leak,"If some error occurs, URB buffers should also be freed. If they aren't freed with the dvb here, the em28xx_dvb_fini call doesn't frees the URB buffers as dvb is set to NULL. The function in which error occurs should do all the cleanup for the allocations it had done.  Tested the patch with the reproducer provided by syzbot. This patch fixes the memleak.  ",0ae10a7dc8992ee682ff0b1752ff7c83d472eef1,1
ipv4: update fib_info_cnt under spinlock protection,"In the past, free_fib_info() was supposed to be called under RTNL protection.  This eventually was no longer the case.  Instead of enforcing RTNL it seems we simply can move fib_info_cnt changes to occur when fib_info_lock is held.  v2: David Laight suggested to update fib_info_cnt only when an entry is added/deleted to/from the hash table, as fib_info_cnt is used to make sure hash table size is optimal.  BUG: KCSAN: data-race in fib_create_info / free_fib_info  write to 0xffffffff86e243a0 of 4 bytes by task 26429 on cpu 0:  fib_create_info+0xe78/0x3440 net/ipv4/fib_semantics.c:1428  fib_table_insert+0x148/0x10c0 net/ipv4/fib_trie.c:1224  fib_magic+0x195/0x1e0 net/ipv4/fib_frontend.c:1087  fib_add_ifaddr+0xd0/0x2e0 net/ipv4/fib_frontend.c:1109  fib_netdev_event+0x178/0x510 net/ipv4/fib_frontend.c:1466  notifier_call_chain kernel/notifier.c:83 [inline]  raw_notifier_call_chain+0x53/0xb0 kernel/notifier.c:391  __dev_notify_flags+0x1d3/0x3b0  dev_change_flags+0xa2/0xc0 net/core/dev.c:8872  do_setlink+0x810/0x2410 net/core/rtnetlink.c:2719  rtnl_group_changelink net/core/rtnetlink.c:3242 [inline]  __rtnl_newlink net/core/rtnetlink.c:3396 [inline]  rtnl_newlink+0xb10/0x13b0 net/core/rtnetlink.c:3506  rtnetlink_rcv_msg+0x745/0x7e0 net/core/rtnetlink.c:5571  netlink_rcv_skb+0x14e/0x250 net/netlink/af_netlink.c:2496  rtnetlink_rcv+0x18/0x20 net/core/rtnetlink.c:5589  netlink_unicast_kernel net/netlink/af_netlink.c:1319 [inline]  netlink_unicast+0x5fc/0x6c0 net/netlink/af_netlink.c:1345  netlink_sendmsg+0x726/0x840 net/netlink/af_netlink.c:1921  sock_sendmsg_nosec net/socket.c:704 [inline]  sock_sendmsg net/socket.c:724 [inline]  ____sys_sendmsg+0x39a/0x510 net/socket.c:2409  ___sys_sendmsg net/socket.c:2463 [inline]  __sys_sendmsg+0x195/0x230 net/socket.c:2492  __do_sys_sendmsg net/socket.c:2501 [inline]  __se_sys_sendmsg net/socket.c:2499 [inline]  __x64_sys_sendmsg+0x42/0x50 net/socket.c:2499  do_syscall_x64 arch/x86/entry/common.c:50 [inline]  do_syscall_64+0x44/0xd0 arch/x86/entry/common.c:80  entry_SYSCALL_64_after_hwframe+0x44/0xae  read to 0xffffffff86e243a0 of 4 bytes by task 31505 on cpu 1:  free_fib_info+0x35/0x80 net/ipv4/fib_semantics.c:252  fib_info_put include/net/ip_fib.h:575 [inline]  nsim_fib4_rt_destroy drivers/net/netdevsim/fib.c:294 [inline]  nsim_fib4_rt_replace drivers/net/netdevsim/fib.c:403 [inline]  nsim_fib4_rt_insert drivers/net/netdevsim/fib.c:431 [inline]  nsim_fib4_event drivers/net/netdevsim/fib.c:461 [inline]  nsim_fib_event drivers/net/netdevsim/fib.c:881 [inline]  nsim_fib_event_work+0x15ca/0x2cf0 drivers/net/netdevsim/fib.c:1477  process_one_work+0x3fc/0x980 kernel/workqueue.c:2298  process_scheduled_works kernel/workqueue.c:2361 [inline]  worker_thread+0x7df/0xa70 kernel/workqueue.c:2447  kthread+0x2c7/0x2e0 kernel/kthread.c:327  ret_from_fork+0x1f/0x30  value changed: 0x00000d2d -> 0x00000d2e  Reported by Kernel Concurrency Sanitizer on: CPU: 1 PID: 31505 Comm: kworker/1:21 Not tainted 5.16.0-rc6-syzkaller #0 Hardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 01/01/2011 Workqueue: events nsim_fib_event_work  ",0a6e6b3c7db6c34e3d149f09cd714972f8753e3f,1
KVM: X86: Fix warning caused by stale emulation context,Reported by syzkaller:    ,da6393cdd8aaa354b3a2437cd73ebb34cac958e3,1
net/tls: fix page double free on TX cleanup,"With commit 94850257cf0f (""tls: Fix tls_device handling of partial records"") a new path was introduced to cleanup partial records during sk_proto_close. This path does not handle the SW KTLS tx_list cleanup.  This is unnecessary though since the free_resources calls for both SW and offload paths will cleanup a partial record.  The visible effect is the following warning, but this bug also causes a page double free.      ",9354544cbccf68da1b047f8fb7b47630e3c8a59d,1
netdevsim: init u64 stats for 32bit hardware,Init the u64 stats in order to avoid the lockdep prints on the 32bit hardware like   INFO: trying to register non-static key.  the code is fine but needs lockdep annotation.  turning off the locking correctness validator.  CPU: 0 PID: 4695 Comm: syz-executor.0 Not tainted 5.11.0-rc5-syzkaller #0  Hardware name: ARM-Versatile Express  Backtrace:  [<826fc5b8>] (dump_backtrace) from [<826fc82c>] (show_stack+0x18/0x1c arch/arm/kernel/traps.c:252)  [<826fc814>] (show_stack) from [<8270d1f8>] (__dump_stack lib/dump_stack.c:79 [inline])  [<826fc814>] (show_stack) from [<8270d1f8>] (dump_stack+0xa8/0xc8 lib/dump_stack.c:120)  [<8270d150>] (dump_stack) from [<802bf9c0>] (assign_lock_key kernel/locking/lockdep.c:935 [inline])  [<8270d150>] (dump_stack) from [<802bf9c0>] (register_lock_class+0xabc/0xb68 kernel/locking/lockdep.c:1247)  [<802bef04>] (register_lock_class) from [<802baa2c>] (__lock_acquire+0x84/0x32d4 kernel/locking/lockdep.c:4711)  [<802ba9a8>] (__lock_acquire) from [<802be840>] (lock_acquire.part.0+0xf0/0x554 kernel/locking/lockdep.c:5442)  [<802be750>] (lock_acquire.part.0) from [<802bed10>] (lock_acquire+0x6c/0x74 kernel/locking/lockdep.c:5415)  [<802beca4>] (lock_acquire) from [<81560548>] (seqcount_lockdep_reader_access include/linux/seqlock.h:103 [inline])  [<802beca4>] (lock_acquire) from [<81560548>] (__u64_stats_fetch_begin include/linux/u64_stats_sync.h:164 [inline])  [<802beca4>] (lock_acquire) from [<81560548>] (u64_stats_fetch_begin include/linux/u64_stats_sync.h:175 [inline])  [<802beca4>] (lock_acquire) from [<81560548>] (nsim_get_stats64+0xdc/0xf0 drivers/net/netdevsim/netdev.c:70)  [<8156046c>] (nsim_get_stats64) from [<81e2efa0>] (dev_get_stats+0x44/0xd0 net/core/dev.c:10405)  [<81e2ef5c>] (dev_get_stats) from [<81e53204>] (rtnl_fill_stats+0x38/0x120 net/core/rtnetlink.c:1211)  [<81e531cc>] (rtnl_fill_stats) from [<81e59d58>] (rtnl_fill_ifinfo+0x6d4/0x148c net/core/rtnetlink.c:1783)  [<81e59684>] (rtnl_fill_ifinfo) from [<81e5ceb4>] (rtmsg_ifinfo_build_skb+0x9c/0x108 net/core/rtnetlink.c:3798)  [<81e5ce18>] (rtmsg_ifinfo_build_skb) from [<81e5d0ac>] (rtmsg_ifinfo_event net/core/rtnetlink.c:3830 [inline])  [<81e5ce18>] (rtmsg_ifinfo_build_skb) from [<81e5d0ac>] (rtmsg_ifinfo_event net/core/rtnetlink.c:3821 [inline])  [<81e5ce18>] (rtmsg_ifinfo_build_skb) from [<81e5d0ac>] (rtmsg_ifinfo+0x44/0x70 net/core/rtnetlink.c:3839)  [<81e5d068>] (rtmsg_ifinfo) from [<81e45c2c>] (register_netdevice+0x664/0x68c net/core/dev.c:10103)  [<81e455c8>] (register_netdevice) from [<815608bc>] (nsim_create+0xf8/0x124 drivers/net/netdevsim/netdev.c:317)  [<815607c4>] (nsim_create) from [<81561184>] (__nsim_dev_port_add+0x108/0x188 drivers/net/netdevsim/dev.c:941)  [<8156107c>] (__nsim_dev_port_add) from [<815620d8>] (nsim_dev_port_add_all drivers/net/netdevsim/dev.c:990 [inline])  [<8156107c>] (__nsim_dev_port_add) from [<815620d8>] (nsim_dev_probe+0x5cc/0x750 drivers/net/netdevsim/dev.c:1119)  [<81561b0c>] (nsim_dev_probe) from [<815661dc>] (nsim_bus_probe+0x10/0x14 drivers/net/netdevsim/bus.c:287)  [<815661cc>] (nsim_bus_probe) from [<811724c0>] (really_probe+0x100/0x50c drivers/base/dd.c:554)  [<811723c0>] (really_probe) from [<811729c4>] (driver_probe_device+0xf8/0x1c8 drivers/base/dd.c:740)  [<811728cc>] (driver_probe_device) from [<81172fe4>] (__device_attach_driver+0x8c/0xf0 drivers/base/dd.c:846)  [<81172f58>] (__device_attach_driver) from [<8116fee0>] (bus_for_each_drv+0x88/0xd8 drivers/base/bus.c:431)  [<8116fe58>] (bus_for_each_drv) from [<81172c6c>] (__device_attach+0xdc/0x1d0 drivers/base/dd.c:914)  [<81172b90>] (__device_attach) from [<8117305c>] (device_initial_probe+0x14/0x18 drivers/base/dd.c:961)  [<81173048>] (device_initial_probe) from [<81171358>] (bus_probe_device+0x90/0x98 drivers/base/bus.c:491)  [<811712c8>] (bus_probe_device) from [<8116e77c>] (device_add+0x320/0x824 drivers/base/core.c:3109)  [<8116e45c>] (device_add) from [<8116ec9c>] (device_register+0x1c/0x20 drivers/base/core.c:3182)  [<8116ec80>] (device_register) from [<81566710>] (nsim_bus_dev_new drivers/net/netdevsim/bus.c:336 [inline])  [<8116ec80>] (device_register) from [<81566710>] (new_device_store+0x178/0x208 drivers/net/netdevsim/bus.c:215)  [<81566598>] (new_device_store) from [<8116fcb4>] (bus_attr_store+0x2c/0x38 drivers/base/bus.c:122)  [<8116fc88>] (bus_attr_store) from [<805b4b8c>] (sysfs_kf_write+0x48/0x54 fs/sysfs/file.c:139)  [<805b4b44>] (sysfs_kf_write) from [<805b3c90>] (kernfs_fop_write_iter+0x128/0x1ec fs/kernfs/file.c:296)  [<805b3b68>] (kernfs_fop_write_iter) from [<804d22fc>] (call_write_iter include/linux/fs.h:1901 [inline])  [<805b3b68>] (kernfs_fop_write_iter) from [<804d22fc>] (new_sync_write fs/read_write.c:518 [inline])  [<805b3b68>] (kernfs_fop_write_iter) from [<804d22fc>] (vfs_write+0x3dc/0x57c fs/read_write.c:605)  [<804d1f20>] (vfs_write) from [<804d2604>] (ksys_write+0x68/0xec fs/read_write.c:658)  [<804d259c>] (ksys_write) from [<804d2698>] (__do_sys_write fs/read_write.c:670 [inline])  [<804d259c>] (ksys_write) from [<804d2698>] (sys_write+0x10/0x14 fs/read_write.c:667)  [<804d2688>] (sys_write) from [<80200060>] (ret_fast_syscall+0x0/0x2c arch/arm/mm/proc-v7.S:64)  ,863a42b289c22df63db62b10fc2c2ffc237e2125,1
bpf: fix access to skb_shared_info->gso_segs,"It is possible we reach bpf_convert_ctx_access() with si->dst_reg == si->src_reg  Therefore, we need to load BPF_REG_AX before eventually mangling si->src_reg.  syzbot generated this x86 code :    3:   55                      push   %rbp    4:   48 89 e5                mov    %rsp,%rbp    7:   48 81 ec 00 00 00 00    sub    $0x0,%rsp // Might be avoided ?    e:   53                      push   %rbx    f:   41 55                   push   %r13   11:   41 56                   push   %r14   13:   41 57                   push   %r15   15:   6a 00                   pushq  $0x0   17:   31 c0                   xor    %eax,%eax   19:   48 8b bf c0 00 00 00    mov    0xc0(%rdi),%rdi   20:   44 8b 97 bc 00 00 00    mov    0xbc(%rdi),%r10d   27:   4c 01 d7                add    %r10,%rdi   2a:   48 0f b7 7f 06          movzwq 0x6(%rdi),%rdi // Crash   2f:   5b                      pop    %rbx   30:   41 5f                   pop    %r15   32:   41 5e                   pop    %r14   34:   41 5d                   pop    %r13   36:   5b                      pop    %rbx   37:   c9                      leaveq   38:   c3                      retq  ",06a22d897d82f12776d44dbf0850f5895469cb2a,0
HID: hidraw: Fix invalid read in hidraw_ioctl,"The syzbot fuzzer has reported a pair of problems in the hidraw_ioctl() function: slab-out-of-bounds read and use-after-free read.  An example of the first:  BUG: KASAN: slab-out-of-bounds in strlen+0x79/0x90 lib/string.c:525 Read of size 1 at addr ffff8881c8035f38 by task syz-executor.4/2833  CPU: 1 PID: 2833 Comm: syz-executor.4 Not tainted 5.3.0-rc2+ #1 Hardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 01/01/2011 Call Trace:   __dump_stack lib/dump_stack.c:77 [inline]   dump_stack+0xca/0x13e lib/dump_stack.c:113   print_address_description+0x6a/0x32c mm/kasan/report.c:351   __kasan_report.cold+0x1a/0x33 mm/kasan/report.c:482   kasan_report+0xe/0x12 mm/kasan/common.c:612   strlen+0x79/0x90 lib/string.c:525   strlen include/linux/string.h:281 [inline]   hidraw_ioctl+0x245/0xae0 drivers/hid/hidraw.c:446   vfs_ioctl fs/ioctl.c:46 [inline]   file_ioctl fs/ioctl.c:509 [inline]   do_vfs_ioctl+0xd2d/0x1330 fs/ioctl.c:696   ksys_ioctl+0x9b/0xc0 fs/ioctl.c:713   __do_sys_ioctl fs/ioctl.c:720 [inline]   __se_sys_ioctl fs/ioctl.c:718 [inline]   __x64_sys_ioctl+0x6f/0xb0 fs/ioctl.c:718   do_syscall_64+0xb7/0x580 arch/x86/entry/common.c:296   entry_SYSCALL_64_after_hwframe+0x49/0xbe ",416dacb819f59180e4d86a5550052033ebb6d72c,1
mptcp: avoid NULL-ptr derefence on fallback,"In the MPTCP receive path we must cope with TCP fallback on blocking recvmsg(). Currently in such code path we detect the fallback condition, but we don't fetch the struct socket required for fallback.  The above allowed syzkaller to trigger a NULL pointer dereference:  general protection fault, probably for non-canonical address 0xdffffc0000000004: 0000 [#1] PREEMPT SMP KASAN KASAN: null-ptr-deref in range [0x0000000000000020-0x0000000000000027] CPU: 1 PID: 7226 Comm: syz-executor523 Not tainted 5.7.0-rc6-syzkaller #0 Hardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 01/01/2011 ",0a82e230c68860b7286dad8644d9d9f7cfd755d2,1
net: bridge: always clear mcast matching struct on reports and leaves,"We need to be careful and always zero the whole br_ip struct when it is used for matching since the rhashtable change. This patch fixes all the places which didn't properly clear it which in turn might've caused mismatches.  Thanks for the great bug report with reproducing steps and bisection.  Steps to reproduce (from the bug report): ip link add br0 type bridge mcast_querier 1 ip link set br0 up  ip link add v2 type veth peer name v3 ip link set v2 master br0 ip link set v2 up ip link set v3 up ip addr add 3.0.0.2/24 dev v3  ip netns add test ip link add v1 type veth peer name v1 netns test ip link set v1 master br0 ip link set v1 up ip -n test link set v1 up ip -n test addr add 3.0.0.1/24 dev v1  # Multicast receiver ip netns exec test socat UDP4-RECVFROM:5588,ip-add-membership=224.224.224.224:3.0.0.1,fork -  # Multicast sender echo hello | nc -u -s 3.0.0.2 224.224.224.224 5588  ",1515a63fc413f160d20574ab0894e7f1020c7be2,0
KVM: x86: fix handling of role.cr4_pae and rename it to 'gpte_size',"The cr4_pae flag is a bit of a misnomer, its purpose is really to track whether the guest PTE that is being shadowed is a 4-byte entry or an 8-byte entry.  Prior to supporting nested EPT, the size of the gpte was reflected purely by CR4.PAE.  KVM fudged things a bit for direct sptes, but it was mostly harmless since the size of the gpte never mattered. Now that a spte may be tracking an indirect EPT entry, relying on CR4.PAE is wrong and ill-named.  For direct shadow pages, force the gpte_size to '1' as they are always 8-byte entries; EPT entries can only be 8-bytes and KVM always uses 8-byte entries for NPT and its identity map (when running with EPT but not unrestricted guest).  Likewise, nested EPT entries are always 8-bytes.  Nested EPT presents a unique scenario as the size of the entries are not dictated by CR4.PAE, but neither is the shadow page a direct map.  To handle this scenario, set cr0_wp=1 and smap_andnot_wp=1, an otherwise impossible combination, to denote a nested EPT shadow page.  Use the information to avoid incorrectly zapping an unsync'd indirect page in __kvm_sync_page().  Providing a consistent and accurate gpte_size fixes a bug reported by Vitaly where fast_cr3_switch() always fails when switching from L2 to L1 as kvm_mmu_get_page() would force role.cr4_pae=0 for direct pages, whereas kvm_calc_mmu_role_common() would set it according to CR4.PAE.  ",47c42e6b4192a2ac8b6c9858ebcf400a9eff7a10,1
gfs2: Fix use-after-free in gfs2_glock_shrink_scan,"The GLF_LRU flag is checked under lru_lock in gfs2_glock_remove_from_lru() to remove the glock from the lru list in __gfs2_glock_put().  On the shrink scan path, the same flag is cleared under lru_lock but because of cond_resched_lock(&lru_lock) in gfs2_dispose_glock_lru(), progress on the put side can be made without deleting the glock from the lru list.  Keep GLF_LRU across the race window opened by cond_resched_lock(&lru_lock) to ensure correct behavior on both sides - clear GLF_LRU after list_del under lru_lock.  ",1ab19c5de4c537ec0d9b21020395a5b5a6c059b2,1
staging: rtl8712: error handling refactoring,"There was strange error handling logic in case of fw load failure. For some reason fw loader callback was doing clean up stuff when fw is not available. I don't see any reason behind doing this. Since this driver doesn't have EEPROM firmware let's just disconnect it in case of fw load failure. Doing clean up stuff in 2 different place which can run concurently is not good idea and syzbot found 2 bugs related to this strange approach.  So, in this pacth I deleted all clean up code from fw callback and made a call to device_release_driver() under device_lock(parent) in case of fw load failure. This approach is more generic and it defend driver from UAF bugs, since all clean up code is moved to one place.  ",e9e6aa51b2735d83a67d9fa0119cf11abef80d99,1
cls_rsvp: fix rsvp_policy,"NLA_BINARY can be confusing, since .len value represents the max size of the blob.  cls_rsvp really wants user space to provide long enough data for TCA_RSVP_DST and TCA_RSVP_SRC attributes.  BUG: KMSAN: uninit-value in rsvp_get net/sched/cls_rsvp.h:258 [inline] BUG: KMSAN: uninit-value in gen_handle net/sched/cls_rsvp.h:402 [inline] BUG: KMSAN: uninit-value in rsvp_change+0x1ae9/0x4220 net/sched/cls_rsvp.h:572 CPU: 1 PID: 13228 Comm: syz-executor.1 Not tainted 5.5.0-rc5-syzkaller #0 Hardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 01/01/2011 Call Trace:  __dump_stack lib/dump_stack.c:77 [inline]  dump_stack+0x1c9/0x220 lib/dump_stack.c:118  kmsan_report+0xf7/0x1e0 mm/kmsan/kmsan_report.c:118  __msan_warning+0x58/0xa0 mm/kmsan/kmsan_instr.c:215  rsvp_get net/sched/cls_rsvp.h:258 [inline]  gen_handle net/sched/cls_rsvp.h:402 [inline]  rsvp_change+0x1ae9/0x4220 net/sched/cls_rsvp.h:572  tc_new_tfilter+0x31fe/0x5010 net/sched/cls_api.c:2104  rtnetlink_rcv_msg+0xcb7/0x1570 net/core/rtnetlink.c:5415  netlink_rcv_skb+0x451/0x650 net/netlink/af_netlink.c:2477  rtnetlink_rcv+0x50/0x60 net/core/rtnetlink.c:5442  netlink_unicast_kernel net/netlink/af_netlink.c:1302 [inline]  netlink_unicast+0xf9e/0x1100 net/netlink/af_netlink.c:1328  netlink_sendmsg+0x1248/0x14d0 net/netlink/af_netlink.c:1917  sock_sendmsg_nosec net/socket.c:639 [inline]  sock_sendmsg net/socket.c:659 [inline]  ____sys_sendmsg+0x12b6/0x1350 net/socket.c:2330  ___sys_sendmsg net/socket.c:2384 [inline]  __sys_sendmsg+0x451/0x5f0 net/socket.c:2417  __do_sys_sendmsg net/socket.c:2426 [inline]  __se_sys_sendmsg+0x97/0xb0 net/socket.c:2424  __x64_sys_sendmsg+0x4a/0x70 net/socket.c:2424  do_syscall_64+0xb8/0x160 arch/x86/entry/common.c:296  entry_SYSCALL_64_after_hwframe+0x44/0xa9 ",cb3c0e6bdf64d0d124e94ce43cbe4ccbb9b37f51,1
cgroup: verify that source is a string,"The following sequence can be used to trigger a UAF:      int fscontext_fd = fsopen(""cgroup"");     int fd_null = open(""/dev/null, O_RDONLY);     int fsconfig(fscontext_fd, FSCONFIG_SET_FD, ""source"", fd_null);     close_range(3, ~0U, 0);  The cgroup v1 specific fs parser expects a string for the ""source"" parameter.  However, it is perfectly legitimate to e.g.  specify a file descriptor for the ""source"" parameter.  The fs parser doesn't know what a filesystem allows there.  So it's a bug to assume that ""source"" is always of type fs_value_is_string when it can reasonably also be fs_value_is_file.  This assumption in the cgroup code causes a UAF because struct fs_parameter uses a union for the actual value.  Access to that union is guarded by the param->type member.  Since the cgroup paramter parser didn't check param->type but unconditionally moved param->string into fc->source a close on the fscontext_fd would trigger a UAF during put_fs_context() which frees fc->source thereby freeing the file stashed in param->file causing a UAF during a close of the fd_null.  Fix this by verifying that param->type is actually a string and report an error if not.  In follow up patches I'll add a new generic helper that can be used here and by other filesystems instead of this error-prone copy-pasta fix. But fixing it in here first makes backporting a it to stable a lot easier.  ",3b0462726e7ef281c35a7a4ae33e93ee2bc9975b,0
"tcp, ulp: remove socket lock assertion on ULP cleanup","Eric reported that syzkaller triggered a splat in tcp_cleanup_ulp() where assertion sock_owned_by_me() failed. This happened through inet_csk_prepare_forced_close() first releasing the socket lock, then calling into tcp_done(newsk) which is called after the inet_csk_prepare_forced_close() and therefore without the socket lock held. The sock_owned_by_me() assertion can generally be removed as the only place where tcp_cleanup_ulp() is called from now is out of inet_csk_destroy_sock() -> sk->sk_prot->destroy() where socket is in dead state and unreachable. Therefore, add a comment why the check is not needed instead.  ",aadd4355918fe6e9044a9042fa5968e0a0901681,1
net: asix: fix uninit value bugs,"Syzbot reported uninit-value in asix_mdio_read(). The problem was in missing error handling. asix_read_cmd() should initialize passed stack variable smsr, but it can fail in some cases. Then while condidition checks possibly uninit smsr variable.  Since smsr is uninitialized stack variable, driver can misbehave, because smsr will be random in case of asix_read_cmd() failure. Fix it by adding error handling and just continue the loop instead of checking uninit value.  Added helper function for checking Host_En bit, since wrong loop was used in 4 functions and there is no need in copy-pasting code parts.  ",a786e3195d6af183033e86f0518ffd2c51c0e8ac,1
tcp: md5: fix potential overestimation of TCP option space,"Back in 2008, Adam Langley fixed the corner case of packets for flows having all of the following options : MD5 TS SACK  Since MD5 needs 20 bytes, and TS needs 12 bytes, no sack block can be cooked from the remaining 8 bytes.  tcp_established_options() correctly sets opts->num_sack_blocks to zero, but returns 36 instead of 32.  This means TCP cooks packets with 4 extra bytes at the end of options, containing unitialized bytes.  ",9424e2e7ad93ffffa88f882c9bc5023570904b55,0
netfilter: xt_hashlimit: limit the max size of hashtable,"The user-specified hashtable size is unbound, this could easily lead to an OOM or a hung task as we hold the global mutex while allocating and initializing the new hashtable.  Add a max value to cap both cfg->size and cfg->max, as suggested by Florian.  ",8d0015a7ab76b8b1e89a3e5f5710a6e5103f2dd5,0
inet: clear num_timeout reqsk_alloc(),"KMSAN caught uninit-value in tcp_create_openreq_child() [1] This is caused by a recent change, combined by the fact that TCP cleared num_timeout, num_retrans and sk fields only when a request socket was about to be queued.  Under syncookie mode, a temporary request socket is used, and req->num_timeout could contain garbage.  Lets clear these three fields sooner, there is really no point trying to defer this and risk other bugs.  [1]  BUG: KMSAN: uninit-value in tcp_create_openreq_child+0x157f/0x1cc0 net/ipv4/tcp_minisocks.c:526 CPU: 1 PID: 13357 Comm: syz-executor591 Not tainted 5.2.0-rc4+ #3 Hardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 01/01/2011 Call Trace:  <IRQ>  __dump_stack lib/dump_stack.c:77 [inline]  dump_stack+0x191/0x1f0 lib/dump_stack.c:113  kmsan_report+0x162/0x2d0 mm/kmsan/kmsan.c:611  __msan_warning+0x75/0xe0 mm/kmsan/kmsan_instr.c:304  tcp_create_openreq_child+0x157f/0x1cc0 net/ipv4/tcp_minisocks.c:526  tcp_v6_syn_recv_sock+0x761/0x2d80 net/ipv6/tcp_ipv6.c:1152  tcp_get_cookie_sock+0x16e/0x6b0 net/ipv4/syncookies.c:209  cookie_v6_check+0x27e0/0x29a0 net/ipv6/syncookies.c:252  tcp_v6_cookie_check net/ipv6/tcp_ipv6.c:1039 [inline]  tcp_v6_do_rcv+0xf1c/0x1ce0 net/ipv6/tcp_ipv6.c:1344  tcp_v6_rcv+0x60b7/0x6a30 net/ipv6/tcp_ipv6.c:1554  ip6_protocol_deliver_rcu+0x1433/0x22f0 net/ipv6/ip6_input.c:397  ip6_input_finish net/ipv6/ip6_input.c:438 [inline]  NF_HOOK include/linux/netfilter.h:305 [inline]  ip6_input+0x2af/0x340 net/ipv6/ip6_input.c:447  dst_input include/net/dst.h:439 [inline]  ip6_rcv_finish net/ipv6/ip6_input.c:76 [inline]  NF_HOOK include/linux/netfilter.h:305 [inline]  ipv6_rcv+0x683/0x710 net/ipv6/ip6_input.c:272  __netif_receive_skb_one_core net/core/dev.c:4981 [inline]  __netif_receive_skb net/core/dev.c:5095 [inline]  process_backlog+0x721/0x1410 net/core/dev.c:5906  napi_poll net/core/dev.c:6329 [inline]  net_rx_action+0x738/0x1940 net/core/dev.c:6395  __do_softirq+0x4ad/0x858 kernel/softirq.c:293  do_softirq_own_stack+0x49/0x80 arch/x86/entry/entry_64.S:1052  </IRQ>  do_softirq kernel/softirq.c:338 [inline]  __local_bh_enable_ip+0x199/0x1e0 kernel/softirq.c:190  local_bh_enable+0x36/0x40 include/linux/bottom_half.h:32  rcu_read_unlock_bh include/linux/rcupdate.h:682 [inline]  ip6_finish_output2+0x213f/0x2670 net/ipv6/ip6_output.c:117  ip6_finish_output+0xae4/0xbc0 net/ipv6/ip6_output.c:150  NF_HOOK_COND include/linux/netfilter.h:294 [inline]  ip6_output+0x5d3/0x720 net/ipv6/ip6_output.c:167  dst_output include/net/dst.h:433 [inline]  NF_HOOK include/linux/netfilter.h:305 [inline]  ip6_xmit+0x1f53/0x2650 net/ipv6/ip6_output.c:271  inet6_csk_xmit+0x3df/0x4f0 net/ipv6/inet6_connection_sock.c:135  __tcp_transmit_skb+0x4076/0x5b40 net/ipv4/tcp_output.c:1156  tcp_transmit_skb net/ipv4/tcp_output.c:1172 [inline]  tcp_write_xmit+0x39a9/0xa730 net/ipv4/tcp_output.c:2397  __tcp_push_pending_frames+0x124/0x4e0 net/ipv4/tcp_output.c:2573  tcp_send_fin+0xd43/0x1540 net/ipv4/tcp_output.c:3118  tcp_close+0x16ba/0x1860 net/ipv4/tcp.c:2403  inet_release+0x1f7/0x270 net/ipv4/af_inet.c:427  inet6_release+0xaf/0x100 net/ipv6/af_inet6.c:470  __sock_release net/socket.c:601 [inline]  sock_close+0x156/0x490 net/socket.c:1273  __fput+0x4c9/0xba0 fs/file_table.c:280  ____fput+0x37/0x40 fs/file_table.c:313  task_work_run+0x22e/0x2a0 kernel/task_work.c:113  tracehook_notify_resume include/linux/tracehook.h:185 [inline]  exit_to_usermode_loop arch/x86/entry/common.c:168 [inline]  prepare_exit_to_usermode+0x39d/0x4d0 arch/x86/entry/common.c:199  syscall_return_slowpath+0x90/0x5c0 arch/x86/entry/common.c:279  do_syscall_64+0xe2/0xf0 arch/x86/entry/common.c:305  entry_SYSCALL_64_after_hwframe+0x63/0xe7 ",85f9aa7565bd79b039325f2c01af7ffa717924df,1
wext: fix NULL-ptr-dereference with cfg80211's lack of commit(),"Since cfg80211 doesn't implement commit, we never really cared about that code there (and it's configured out w/o CONFIG_WIRELESS_EXT). After all, since it has no commit, it shouldn't return -EIWCOMMIT to indicate commit is needed.  However, EIWCOMMIT is actually an alias for EINPROGRESS, which _can_ happen if e.g. we try to change the frequency but we're already in the process of connecting to some network, and drivers could return that value (or even cfg80211 itself might).  This then causes us to crash because dev->wireless_handlers is NULL but we try to check dev->wireless_handlers->standard[0].  Fix this by also checking dev->wireless_handlers. Also simplify the code a little bit.  ",5122565188bae59d507d90a9a9fd2fd6107f4439,1
ALSA: pcm: Fix UAF at PCM release via PCM timer access,"The PCM runtime object is created and freed dynamically at PCM stream open / close time.  This is tracked via substream->runtime, and it's cleared at snd_pcm_detach_substream().  The runtime object assignment is protected by PCM open_mutex, so for all PCM operations, it's safely handled.  However, each PCM substream provides also an ALSA timer interface, and user-space can access to this while closing a PCM substream.  This may eventually lead to a UAF, as snd_pcm_timer_resolution() tries to access the runtime while clearing it in other side.  Fortunately, it's the only concurrent access from the PCM timer, and it merely reads runtime->timer_resolution field.  So, we can avoid the race by reordering kfree() and wrapping the substream->runtime clearance with the corresponding timer lock.  ",a820ccbe21e8ce8e86c39cd1d3bc8c7d1cbb949b,1
net/smc: add fallback check to connect(),"FASTOPEN setsockopt() or sendmsg() may switch the SMC socket to fallback mode. Once fallback mode is active, the native TCP socket functions are called. Nevertheless there is a small race window, when FASTOPEN setsockopt/sendmsg runs in parallel to a connect(), and switch the socket into fallback mode before connect() takes the sock lock. Make sure the SMC-specific connect setup is omitted in this case.  This way a syzbot-reported refcount problem is fixed, triggered by different threads running non-blocking connect() and FASTOPEN_KEY setsockopt.  ",86434744fedf0cfe07a9eee3f4632c0e25c1d136,1
tun: handle register_netdevice() failures properly,"syzkaller reported a double free [1], caused by the fact that tun driver was not updated properly when priv_destructor was added.  When/if register_netdevice() fails, priv_destructor() must have been called already.  [1] BUG: KASAN: double-free or invalid-free in selinux_tun_dev_free_security+0x15/0x20 security/selinux/hooks.c:5023  CPU: 0 PID: 2919 Comm: syzkaller227220 Not tainted 4.13.0-rc4+ #23 Hardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 01/01/2011 Call Trace:  __dump_stack lib/dump_stack.c:16 [inline]  dump_stack+0x194/0x257 lib/dump_stack.c:52  print_address_description+0x7f/0x260 mm/kasan/report.c:252  kasan_report_double_free+0x55/0x80 mm/kasan/report.c:333  kasan_slab_free+0xa0/0xc0 mm/kasan/kasan.c:514  __cache_free mm/slab.c:3503 [inline]  kfree+0xd3/0x260 mm/slab.c:3820  selinux_tun_dev_free_security+0x15/0x20 security/selinux/hooks.c:5023  security_tun_dev_free_security+0x48/0x80 security/security.c:1512  tun_set_iff drivers/net/tun.c:1884 [inline]  __tun_chr_ioctl+0x2ce6/0x3d50 drivers/net/tun.c:2064  tun_chr_ioctl+0x2a/0x40 drivers/net/tun.c:2309  vfs_ioctl fs/ioctl.c:45 [inline]  do_vfs_ioctl+0x1b1/0x1520 fs/ioctl.c:685  SYSC_ioctl fs/ioctl.c:700 [inline]  SyS_ioctl+0x8f/0xc0 fs/ioctl.c:691  entry_SYSCALL_64_fastpath+0x1f/0xbe ",ff244c6b29b176f3f448bc75e55df297225e1b3a,1
crypto: adiantum - initialize crypto_spawn::inst,"crypto_grab_*() doesn't set crypto_spawn::inst, so templates must set it beforehand.  Otherwise it will be left NULL, which causes a crash in certain cases where algorithms are dynamically loaded/unloaded.  E.g. with CONFIG_CRYPTO_CHACHA20_X86_64=m, the following caused a crash:      insmod chacha-x86_64.ko     python -c 'import socket; socket.socket(socket.AF_ALG, 5, 0).bind((""skcipher"", ""adiantum(xchacha12,aes)""))'     rmmod chacha-x86_64.ko     python -c 'import socket; socket.socket(socket.AF_ALG, 5, 0).bind((""skcipher"", ""adiantum(xchacha12,aes)""))'  ",6db43410179bc40419a9859ebb333f178a49829d,1
smackfs: restrict bytes count in smackfs write functions,syzbot found ,7ef4c19d245f3dc233fd4be5acea436edd1d83d8,0
net: sched: fix possible crash in tcf_action_destroy(),"If the allocation done in tcf_exts_init() failed, we end up with a NULL pointer in exts->actions.  kasan: GPF could be caused by NULL-ptr deref or user memory access general protection fault: 0000 [#1] PREEMPT SMP KASAN CPU: 1 PID: 8198 Comm: syz-executor.3 Not tainted 5.3.0-rc8+ #0 Hardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 01/01/2011 ",3d66b89c30f9220a72e92847768fc8ba4d027d88,1
packet: fix crash in fanout_demux_rollover(),"syzkaller found a race condition fanout_demux_rollover() while removing a packet socket from a fanout group.  po->rollover is read and operated on during packet_rcv_fanout(), via fanout_demux_rollover(), but the pointer is currently cleared before the synchronization in packet_release().   It is safer to delay the cleanup until after synchronize_net() has been called, ensuring all calls to packet_rcv_fanout() for this socket have finished.  To further simplify synchronization around the rollover structure, set po->rollover in fanout_add() only if there are no errors.  This removes the need for rcu in the struct and in the call to packet_getsockopt(..., PACKET_ROLLOVER_STATS, ...).  Crashing stack trace:  fanout_demux_rollover+0xb6/0x4d0 net/packet/af_packet.c:1392  packet_rcv_fanout+0x649/0x7c8 net/packet/af_packet.c:1487  dev_queue_xmit_nit+0x835/0xc10 net/core/dev.c:1953  xmit_one net/core/dev.c:2975 [inline]  dev_hard_start_xmit+0x16b/0xac0 net/core/dev.c:2995  __dev_queue_xmit+0x17a4/0x2050 net/core/dev.c:3476  dev_queue_xmit+0x17/0x20 net/core/dev.c:3509  neigh_connected_output+0x489/0x720 net/core/neighbour.c:1379  neigh_output include/net/neighbour.h:482 [inline]  ip6_finish_output2+0xad1/0x22a0 net/ipv6/ip6_output.c:120  ip6_finish_output+0x2f9/0x920 net/ipv6/ip6_output.c:146  NF_HOOK_COND include/linux/netfilter.h:239 [inline]  ip6_output+0x1f4/0x850 net/ipv6/ip6_output.c:163  dst_output include/net/dst.h:459 [inline]  NF_HOOK.constprop.35+0xff/0x630 include/linux/netfilter.h:250  mld_sendpack+0x6a8/0xcc0 net/ipv6/mcast.c:1660  mld_send_initial_cr.part.24+0x103/0x150 net/ipv6/mcast.c:2072  mld_send_initial_cr net/ipv6/mcast.c:2056 [inline]  ipv6_mc_dad_complete+0x99/0x130 net/ipv6/mcast.c:2079  addrconf_dad_completed+0x595/0x970 net/ipv6/addrconf.c:4039  addrconf_dad_work+0xac9/0x1160 net/ipv6/addrconf.c:3971  process_one_work+0xbf0/0x1bc0 kernel/workqueue.c:2113  worker_thread+0x223/0x1990 kernel/workqueue.c:2247  kthread+0x35e/0x430 kernel/kthread.c:231  ret_from_fork+0x2a/0x40 arch/x86/entry/entry_64.S:432  ",57f015f5eccf25fd4a3336fe3cbbee920a8fba6f,1
bpf: fix kernel page fault in lpm map trie_get_next_key,"Commit b471f2f1de8b (""bpf: implement MAP_GET_NEXT_KEY command for LPM_TRIE map"") introduces a bug likes below:      if (!rcu_dereference(trie->root))         return -ENOENT;     if (!key || key->prefixlen > trie->max_prefixlen) {         root = &trie->root;         goto find_leftmost;     }     ......   find_leftmost:     for (node = rcu_dereference(*root); node;) {  In the code after label find_leftmost, it is assumed that *root should not be NULL, but it is not true as it is possbile trie->root is changed to NULL by an asynchronous delete operation.  The issue is reported by syzbot and Eric Dumazet with the below error log:   ......   kasan: CONFIG_KASAN_INLINE enabled   kasan: GPF could be caused by NULL-ptr deref or user memory access   general protection fault: 0000 [#1] SMP KASAN   Dumping ftrace buffer:      (ftrace buffer empty)   ",6dd1ec6c7a2c304e9e2e2edd9e7ccb8e8791d36a,1
net/smc: fix fastopen for non-blocking connect(),"FASTOPEN does not work with SMC-sockets. Since SMC allows fallback to TCP native during connection start, the FASTOPEN setsockopts trigger this fallback, if the SMC-socket is still in state SMC_INIT. But if a FASTOPEN setsockopt is called after a non-blocking connect(), this is broken, and fallback does not make sense. This change complements commit cd2063604ea6 (""net/smc: avoid fallback in case of non-blocking connect"") and fixes the syzbot reported problem """,8204df72bea1a7d83d0777add6da98a41dfbdc34,0
bpf: fix mlock precharge on arraymaps,"syzkaller recently triggered OOM during percpu map allocation; while there is work in progress by Dennis Zhou to add __GFP_NORETRY semantics for percpu allocator under pressure, there seems also a missing bpf_map_precharge_memlock() check in array map allocation.  Given today the actual bpf_map_charge_memlock() happens after the find_and_alloc_map() in syscall path, the bpf_map_precharge_memlock() is there to bail out early before we go and do the map setup work when we find that we hit the limits anyway. Therefore add this for array map as well.  ",9c2d63b843a5c8a8d0559cc067b5398aa5ec3ffc,1
tcp: highest_sack fix,"syzbot easily found a regression added in our latest patches [1]  No longer set tp->highest_sack to the head of the send queue since this is not logical and error prone.  Only sack processing should maintain the pointer to an skb from rtx queue.  We might in the future only remember the sequence instead of a pointer to skb, since rb-tree should allow a fast lookup.  [1] BUG: KASAN: use-after-free in tcp_highest_sack_seq include/net/tcp.h:1706 [inline] BUG: KASAN: use-after-free in tcp_ack+0x42bb/0x4fd0 net/ipv4/tcp_input.c:3537 Read of size 4 at addr ffff8801c154faa8 by task syz-executor4/12860  CPU: 0 PID: 12860 Comm: syz-executor4 Not tainted 4.14.0-next-20171113+ #41 Hardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 01/01/2011 Call Trace:  __dump_stack lib/dump_stack.c:17 [inline]  dump_stack+0x194/0x257 lib/dump_stack.c:53  print_address_description+0x73/0x250 mm/kasan/report.c:252  kasan_report_error mm/kasan/report.c:351 [inline]  kasan_report+0x25b/0x340 mm/kasan/report.c:409  __asan_report_load4_noabort+0x14/0x20 mm/kasan/report.c:429  tcp_highest_sack_seq include/net/tcp.h:1706 [inline]  tcp_ack+0x42bb/0x4fd0 net/ipv4/tcp_input.c:3537  tcp_rcv_established+0x672/0x18a0 net/ipv4/tcp_input.c:5439  tcp_v4_do_rcv+0x2ab/0x7d0 net/ipv4/tcp_ipv4.c:1468  sk_backlog_rcv include/net/sock.h:909 [inline]  __release_sock+0x124/0x360 net/core/sock.c:2264  release_sock+0xa4/0x2a0 net/core/sock.c:2778  tcp_sendmsg+0x3a/0x50 net/ipv4/tcp.c:1462  inet_sendmsg+0x11f/0x5e0 net/ipv4/af_inet.c:763  sock_sendmsg_nosec net/socket.c:632 [inline]  sock_sendmsg+0xca/0x110 net/socket.c:642  ___sys_sendmsg+0x75b/0x8a0 net/socket.c:2048  __sys_sendmsg+0xe5/0x210 net/socket.c:2082  SYSC_sendmsg net/socket.c:2093 [inline]  SyS_sendmsg+0x2d/0x50 net/socket.c:2089  entry_SYSCALL_64_fastpath+0x1f/0x96 ",50895b9de1d3e0258e015e8e55128d835d9a9f19,1
dccp: don't free ccid2_hc_tx_sock struct in dccp_disconnect(),"Syzbot reported the use-after-free in timer_is_static_object() [1].  This can happen because the structure for the rto timer (ccid2_hc_tx_sock) is removed in dccp_disconnect(), and ccid2_hc_tx_rto_expire() can be called after that.  The report [1] is similar to the one in commit 120e9dabaf55 (""dccp: defer ccid_hc_tx_delete() at dismantle time""). And the fix is the same, delay freeing ccid2_hc_tx_sock structure, so that it is freed in dccp_sk_destruct().  [1]  ",2677d20677314101293e6da0094ede7b5526d2b1,1
mm: thp: KVM: Explicitly check for THP when populating secondary MMU,"Add a helper, is_transparent_hugepage(), to explicitly check whether a compound page is a THP and use it when populating KVM's secondary MMU. The explicit check fixes a bug where a remapped compound page, e.g. for an XDP Rx socket, is mapped into a KVM guest and is mistaken for a THP, which results in KVM incorrectly creating a huge page in its secondary MMU.  ",005ba37cb89bcc0cf63c2029a41f8db165aeb615,0
xfrm/compat: Translate by copying XFRMA_UNSPEC attribute,"xfrm_xlate32() translates 64-bit message provided by kernel to be sent for 32-bit listener (acknowledge or monitor). Translator code doesn't expect XFRMA_UNSPEC attribute as it doesn't know its payload. Kernel never attaches such attribute, but a user can.  I've searched if any opensource does it and the answer is no. Nothing on github and google finds only tfcproject that has such code commented-out.  What will happen if a user sends a netlink message with XFRMA_UNSPEC attribute? Ipsec code ignores this attribute. But if there is a monitor-process or 32-bit user requested ack - kernel will try to translate such message and will hit WARN_ONCE() in xfrm_xlate64_attr().  Deal with XFRMA_UNSPEC by copying the attribute payload with xfrm_nla_cpy(). In result, the default switch-case in xfrm_xlate64_attr() becomes an unused code. Leave those 3 lines in case a new xfrm attribute will be added.  ",dbd7ae5154d5fff7e84a9f3010bb06499017ef29,0
HID: magicmouse: fix NULL-deref on disconnect,"Commit 9d7b18668956 (""HID: magicmouse: add support for Apple Magic Trackpad 2"") added a sanity check for an Apple trackpad but returned success instead of -ENODEV when the check failed. This means that the remove callback will dereference the never-initialised driver data pointer when the driver is later unbound (e.g. on USB disconnect).  ",4b4f6cecca446abcb686c6e6c451d4f1ec1a7497,1
media: vp7045: do not read uninitialized values if usb transfer fails,It is not a fatal error if reading the mac address or the remote control decoder state fails.  ,26cff637121d8bb866ebd6515c430ac890e6ec80,1
