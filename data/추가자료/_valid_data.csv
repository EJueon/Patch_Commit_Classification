title,desc,number,label
udp: annotate data races around unix_sk(sk)->gso_size,"Accesses to unix_sk(sk)->gso_size are lockless. Add READ_ONCE()/WRITE_ONCE() around them.  BUG: KCSAN: data-race in udp_lib_setsockopt / udpv6_sendmsg  write to 0xffff88812d78f47c of 2 bytes by task 10849 on cpu 1:  udp_lib_setsockopt+0x3b3/0x710 net/ipv4/udp.c:2696  udpv6_setsockopt+0x63/0x90 net/ipv6/udp.c:1630  sock_common_setsockopt+0x5d/0x70 net/core/sock.c:3265  __sys_setsockopt+0x18f/0x200 net/socket.c:2104  __do_sys_setsockopt net/socket.c:2115 [inline]  __se_sys_setsockopt net/socket.c:2112 [inline]  __x64_sys_setsockopt+0x62/0x70 net/socket.c:2112  do_syscall_64+0x4a/0x90 arch/x86/entry/common.c:47  entry_SYSCALL_64_after_hwframe+0x44/0xae  read to 0xffff88812d78f47c of 2 bytes by task 10852 on cpu 0:  udpv6_sendmsg+0x161/0x16b0 net/ipv6/udp.c:1299  inet6_sendmsg+0x5f/0x80 net/ipv6/af_inet6.c:642  sock_sendmsg_nosec net/socket.c:654 [inline]  sock_sendmsg net/socket.c:674 [inline]  ____sys_sendmsg+0x360/0x4d0 net/socket.c:2337  ___sys_sendmsg net/socket.c:2391 [inline]  __sys_sendmmsg+0x315/0x4b0 net/socket.c:2477  __do_sys_sendmmsg net/socket.c:2506 [inline]  __se_sys_sendmmsg net/socket.c:2503 [inline]  __x64_sys_sendmmsg+0x53/0x60 net/socket.c:2503  do_syscall_64+0x4a/0x90 arch/x86/entry/common.c:47  entry_SYSCALL_64_after_hwframe+0x44/0xae  value changed: 0x0000 -> 0x0005  Reported by Kernel Concurrency Sanitizer on: CPU: 0 PID: 10852 Comm: syz-executor.0 Not tainted 5.13.0-syzkaller #0 Hardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 01/01/2011  ",18a419bad63b7f68a1979e28459782518e7b6bbe,1
KEYS: always initialize keyring_index_key::desc_len,"syzbot hit the 'BUG_ON(index_key->desc_len == 0);' in __key_link_begin() called from construct_alloc_key() during sys_request_key(), because the length of the key description was never calculated.  The problem is that we rely on ->desc_len being initialized by search_process_keyrings(), specifically by search_nested_keyrings(). But, if the process isn't subscribed to any keyrings that never happens.  Fix it by always initializing keyring_index_key::desc_len as soon as the description is set, like we already do in some places.  The following program reproduces the BUG_ON() when it's run as root and no session keyring has been installed.  If it doesn't work, try removing pam_keyinit.so from /etc/pam.d/login and rebooting.      #include <stdlib.h>     #include <unistd.h>     #include <keyutils.h>      int main(void)     {             int id = add_key(""keyring"", ""syz"", NULL, 0, KEY_SPEC_USER_KEYRING);              keyctl_setperm(id, KEY_OTH_WRITE);             setreuid(5000, 5000);             request_key(""user"", ""desc"", """", id);     }  ",ede0fa98a900e657d1fcd80b50920efc896c1a4c,1
tracing: Fix sched switch start/stop refcount racy updates,"Reading the sched_cmdline_ref and sched_tgid_ref initial state within tracing_start_sched_switch without holding the sched_register_mutex is racy against concurrent updates, which can lead to tracepoint probes being registered more than once (and thus trigger warnings within tracepoint.c).  ",64ae572bc7d0060429e40e1c8d803ce5eb31a0d6,0
io_uring: don't modify req->poll for rw,"__io_queue_proc() is used by both poll and apoll, so we should not access req->poll directly but selecting right struct io_poll_iocb depending on use case.  ",7a274727702cc07d27cdebd36d1d5132abeea12f,0
USB: yurex: fix control-URB timeout handling,Make sure to always cancel the control URB in write() so that it can be reused after a timeout or spurious CMD_ACK.  Currently any further write requests after a timeout would fail after triggering a WARN() in usb_submit_urb() when attempting to submit the already active URB.  ,372c93131998c0622304bed118322d2a04489e63,1
rxrpc: Fix local endpoint refcounting,The object lifetime management on the rxrpc_local struct is broken in that the rxrpc_local_processor() function is expected to clean up and remove an object - but it may get requeued by packets coming in on the backing UDP socket once it starts running.  This may result in the assertion in rxrpc_local_rcu() firing because the memory has been scheduled for RCU destruction whilst still queued:  	rxrpc: Assertion failed 	,730c5fd42c1e3652a065448fd235cb9fafb2bd10,0
can: purge socket error queue on sock destruct,CAN supports software tx timestamps as of the below commit. Purge any queued timestamp packets on socket destroy.  ,fd704bd5ee749d560e86c4f1fd2ef486d8abf7cf,0
locking/lockdep: Reduce space occupied by stack traces,"Although commit 669de8bda87b (""kernel/workqueue: Use dynamic lockdep keys for workqueues"") unregisters dynamic lockdep keys when a workqueue is destroyed, a side effect of that commit is that all stack traces associated with the lockdep key are leaked when a workqueue is destroyed. Fix this by storing each unique stack trace once. Other changes in this patch are:  - Use NULL instead of { .nr_entries = 0 } to represent 'no trace'. - Store a pointer to a stack trace in struct lock_class and struct   lock_list instead of storing 'nr_entries' and 'offset'.  This patch avoids that the following program triggers the ""BUG: MAX_STACK_TRACE_ENTRIES too low!"" complaint:  	#include <fcntl.h> 	#include <unistd.h>  	int main() 	{ 		for (;;) { 			int fd = open(""/dev/infiniband/rdma_cm"", O_RDWR); 			close(fd); 		} 	}  Suggested-by: Peter Zijlstra <peterz@infradead.org> ",12593b7467f9130b64a6d4b6a26ed4ec217b6784,1
driver core: Don't ignore class_dir_create_and_add() failure.,syzbot is hitting WARN() at kernfs_add_one() [1]. This is because kernfs_create_link() is confused by previous device_add() call which continued without setting dev->kobj.parent field when get_device_parent() failed by memory allocation fault injection. Fix this by propagating the error from class_dir_create_and_add() to the calllers of get_device_parent().  [1] https://syzkaller.appspot.com/bug?id=fae0fb607989ea744526d1c082a5b8de6529116f  ,84d0c27d6233a9ba0578b20f5a09701eb66cee42,1
net: check extack._msg before print,"dev_set_mtu_ext is able to fail with a valid mtu value, at that condition, extack._msg is not set and random since it is in stack, then kernel will crash when print it.  ",a6bcfc89694ed8cb482a82cdc8b93aae63a8b691,1
ipv4: fix use-after-free in ip_cmsg_recv_dstaddr(),"Caching ip_hdr(skb) before a call to pskb_may_pull() is buggy, do not do it.  ",64199fc0a46ba211362472f7f942f900af9492fd,1
crypto: af_alg - wait for data at beginning of recvmsg,The wait for data is a non-atomic operation that can sleep and therefore potentially release the socket lock. The release of the socket lock allows another thread to modify the context data structure. The waiting operation for new data therefore must be called at the beginning of recvmsg. This prevents a race condition where checks of the members of the context data structure are performed by recvmsg while there is a potential for modification of these values.  ,11edb555966ed2c66c533d17c604f9d7e580a829,1
KVM: x86: hyperv: implement PV IPI send hypercalls,"Using hypercall for sending IPIs is faster because this allows to specify any number of vCPUs (even > 64 with sparse CPU set), the whole procedure will take only one VMEXIT.  Current Hyper-V TLFS (v5.0b) claims that HvCallSendSyntheticClusterIpi hypercall can't be 'fast' (passing parameters through registers) but apparently this is not true, Windows always uses it as 'fast' so we need to support that.  ",214ff83d4473a7757fa18a64dc7efe3b0e158486,0
ipv6: fix races in ip6_dst_destroy(),"We had many syzbot reports that seem to be caused by use-after-free of struct fib6_info.  ip6_dst_destroy(), fib6_drop_pcpu_from() and rt6_remove_exception() are writers vs rt->from, and use non consistent synchronization among themselves.  Switching to xchg() will solve the issues with no possible lockdep issues.  BUG: KASAN: user-memory-access in atomic_dec_and_test include/asm-generic/atomic-instrumented.h:747 [inline] BUG: KASAN: user-memory-access in fib6_info_release include/net/ip6_fib.h:294 [inline] BUG: KASAN: user-memory-access in fib6_info_release include/net/ip6_fib.h:292 [inline] BUG: KASAN: user-memory-access in fib6_drop_pcpu_from net/ipv6/ip6_fib.c:927 [inline] BUG: KASAN: user-memory-access in fib6_purge_rt+0x4f6/0x670 net/ipv6/ip6_fib.c:960 Write of size 4 at addr 0000000000ffffb4 by task syz-executor.1/7649  CPU: 0 PID: 7649 Comm: syz-executor.1 Not tainted 5.1.0-rc6+ #183 Hardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 01/01/2011 Call Trace:  __dump_stack lib/dump_stack.c:77 [inline]  dump_stack+0x172/0x1f0 lib/dump_stack.c:113  kasan_report.cold+0x5/0x40 mm/kasan/report.c:321  check_memory_region_inline mm/kasan/generic.c:185 [inline]  check_memory_region+0x123/0x190 mm/kasan/generic.c:191  kasan_check_write+0x14/0x20 mm/kasan/common.c:108  atomic_dec_and_test include/asm-generic/atomic-instrumented.h:747 [inline]  fib6_info_release include/net/ip6_fib.h:294 [inline]  fib6_info_release include/net/ip6_fib.h:292 [inline]  fib6_drop_pcpu_from net/ipv6/ip6_fib.c:927 [inline]  fib6_purge_rt+0x4f6/0x670 net/ipv6/ip6_fib.c:960  fib6_del_route net/ipv6/ip6_fib.c:1813 [inline]  fib6_del+0xac2/0x10a0 net/ipv6/ip6_fib.c:1844  fib6_clean_node+0x3a8/0x590 net/ipv6/ip6_fib.c:2006  fib6_walk_continue+0x495/0x900 net/ipv6/ip6_fib.c:1928  fib6_walk+0x9d/0x100 net/ipv6/ip6_fib.c:1976  fib6_clean_tree+0xe0/0x120 net/ipv6/ip6_fib.c:2055  __fib6_clean_all+0x118/0x2a0 net/ipv6/ip6_fib.c:2071  fib6_clean_all+0x2b/0x40 net/ipv6/ip6_fib.c:2082  rt6_sync_down_dev+0x134/0x150 net/ipv6/route.c:4057  rt6_disable_ip+0x27/0x5f0 net/ipv6/route.c:4062  addrconf_ifdown+0xa2/0x1220 net/ipv6/addrconf.c:3705  addrconf_notify+0x19a/0x2260 net/ipv6/addrconf.c:3630  notifier_call_chain+0xc7/0x240 kernel/notifier.c:93  __raw_notifier_call_chain kernel/notifier.c:394 [inline]  raw_notifier_call_chain+0x2e/0x40 kernel/notifier.c:401  call_netdevice_notifiers_info+0x3f/0x90 net/core/dev.c:1753  call_netdevice_notifiers_extack net/core/dev.c:1765 [inline]  call_netdevice_notifiers net/core/dev.c:1779 [inline]  dev_close_many+0x33f/0x6f0 net/core/dev.c:1522  rollback_registered_many+0x43b/0xfd0 net/core/dev.c:8177  rollback_registered+0x109/0x1d0 net/core/dev.c:8242  unregister_netdevice_queue net/core/dev.c:9289 [inline]  unregister_netdevice_queue+0x1ee/0x2c0 net/core/dev.c:9282  unregister_netdevice include/linux/netdevice.h:2658 [inline]  __tun_detach+0xd5b/0x1000 drivers/net/tun.c:727  tun_detach drivers/net/tun.c:744 [inline]  tun_chr_close+0xe0/0x180 drivers/net/tun.c:3443  __fput+0x2e5/0x8d0 fs/file_table.c:278  ____fput+0x16/0x20 fs/file_table.c:309  task_work_run+0x14a/0x1c0 kernel/task_work.c:113  exit_task_work include/linux/task_work.h:22 [inline]  do_exit+0x90a/0x2fa0 kernel/exit.c:876  do_group_exit+0x135/0x370 kernel/exit.c:980  __do_sys_exit_group kernel/exit.c:991 [inline]  __se_sys_exit_group kernel/exit.c:989 [inline]  __x64_sys_exit_group+0x44/0x50 kernel/exit.c:989  do_syscall_64+0x103/0x610 arch/x86/entry/common.c:290  entry_SYSCALL_64_after_hwframe+0x49/0xbe ",0e2338749192ce0e52e7174c5352f627632f478a,1
tun: call dev_get_valid_name() before register_netdevice(),"register_netdevice() could fail early when we have an invalid dev name, in which case ->ndo_uninit() is not called. For tun device, this is a problem because a timer etc. are already initialized and it expects ->ndo_uninit() to clean them up.  We could move these initializations into a ->ndo_init() so that register_netdevice() knows better, however this is still complicated due to the logic in tun_detach().  Therefore, I choose to just call dev_get_valid_name() before register_netdevice(), which is quicker and much easier to audit. And for this specific case, it is already enough.  ",0ad646c81b2182f7fa67ec0c8c825e0ee165696d,0
tomoyo: Don't use nifty names on sockets.,"syzbot is reporting that use of SOCKET_I()->sk from open() can result in use after free problem [1], for socket's inode is still reachable via /proc/pid/fd/n despite destruction of SOCKET_I()->sk already completed.  At first I thought that this race condition applies to only open/getattr permission checks. But James Morris has pointed out that there are more permission checks where this race condition applies to. Thus, get rid of tomoyo_get_socket_name() instead of conditionally bypassing permission checks on sockets. As a side effect of this patch, ""socket:[family=\$:type=\$:protocol=\$]"" in the policy files has to be rewritten to ""socket:[\$]"".  [1] https://syzkaller.appspot.com/bug?id=73d590010454403d55164cca23bd0565b1eb3b74  ",6f7c41374b62fd80bbd8aae3536c43688c54d95e,1
mm/rmap: fix potential batched TLB flush race,"In theory, the following race is possible for batched TLB flushing.    CPU0                               CPU1   ",5ee2fa2f063649570c702164f47a558a3432dd9e,1
net/smc: restrict non-blocking connect finish,"The smc_poll code tries to finish connect() if the socket is in state SMC_INIT and polling of the internal CLC-socket returns with EPOLLOUT. This makes sense for a select/poll call following a connect call, but not without preceding connect(). With this patch smc_poll starts connect logic only, if the CLC-socket is no longer in its initial state TCP_CLOSE.  In addition, a poll error on the internal CLC-socket is always propagated to the SMC socket.  With this patch the code path mentioned by syzbot https://syzkaller.appspot.com/bug?extid=03faa2dc16b8b64be396 is no longer possible.  ",784813aed6ba24a1f24e7e11d9d0f208cee37a7d,1
net/rose: fix NULL ax25_cb kernel panic,"When an internally generated frame is handled by rose_xmit(), rose_route_frame() is called:          if (!rose_route_frame(skb, NULL)) {                 dev_kfree_skb(skb);                 stats->tx_errors++;                 return NETDEV_TX_OK;         }  We have the same code sequence in Net/Rom where an internally generated frame is handled by nr_xmit() calling nr_route_frame(skb, NULL). However, in this function NULL argument is tested while it is not in rose_route_frame(). Then kernel panic occurs later on when calling ax25cmp() with a NULL ax25_cb argument as reported many times and recently with syzbot.  We need to test if ax25 is NULL before using it.  Testing: Built kernel with CONFIG_ROSE=y.  ",b0cf029234f9b18e10703ba5147f0389c382bccc,0
dsa: fix flow disector null pointer,A recent change to fix up DSA device behavior made the assumption that all skbs passing through the flow disector will be associated with a device. This does not appear to be a safe assumption.  Syzkaller found the crash below by attaching a BPF socket filter that tries to find the payload offset of a packet passing between two unix sockets.  kasan: GPF could be caused by NULL-ptr deref or user memory access general protection fault: 0000 [#1] SMP KASAN Dumping ftrace buffer:    (ftrace buffer empty) ,7324157b8af19ff797b550b7b1543aa1c9c07b48,1
netfilter: x_tables: avoid stack-out-of-bounds read in xt_copy_counters_from_user,"syzkaller reports an out of bound read in strlcpy(), triggered by xt_copy_counters_from_user()  Fix this by using memcpy(), then forcing a zero byte at the last position of the destination, as Florian did for the non COMPAT code.  ",e466af75c074e76107ae1cd5a2823e9c61894ffb,1
sctp: sctp_sockaddr_af must check minimal addr length for AF_INET6,"Check must happen before call to ipv6_addr_v4mapped()  syzbot report was :  BUG: KMSAN: uninit-value in sctp_sockaddr_af net/sctp/socket.c:359 [inline] BUG: KMSAN: uninit-value in sctp_do_bind+0x60f/0xdc0 net/sctp/socket.c:384 CPU: 0 PID: 3576 Comm: syzkaller968804 Not tainted 4.16.0+ #82 Hardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 01/01/2011 Call Trace:  __dump_stack lib/dump_stack.c:17 [inline]  dump_stack+0x185/0x1d0 lib/dump_stack.c:53  kmsan_report+0x142/0x240 mm/kmsan/kmsan.c:1067  __msan_warning_32+0x6c/0xb0 mm/kmsan/kmsan_instr.c:676  sctp_sockaddr_af net/sctp/socket.c:359 [inline]  sctp_do_bind+0x60f/0xdc0 net/sctp/socket.c:384  sctp_bind+0x149/0x190 net/sctp/socket.c:332  inet6_bind+0x1fd/0x1820 net/ipv6/af_inet6.c:293  SYSC_bind+0x3f2/0x4b0 net/socket.c:1474  SyS_bind+0x54/0x80 net/socket.c:1460  do_syscall_64+0x309/0x430 arch/x86/entry/common.c:287  entry_SYSCALL_64_after_hwframe+0x3d/0xa2 ",81e98370293afcb58340ce8bd71af7b97f925c26,1
net_sched: avoid shift-out-of-bounds in tcindex_set_parms(),"tc_index being 16bit wide, we need to check that TCA_TCINDEX_SHIFT attribute is not silly.  UBSAN: shift-out-of-bounds in net/sched/cls_tcindex.c:260:29 shift exponent 255 is too large for 32-bit type 'int' CPU: 0 PID: 8516 Comm: syz-executor228 Not tainted 5.10.0-syzkaller #0 Hardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 01/01/2011 Call Trace:  __dump_stack lib/dump_stack.c:79 [inline]  dump_stack+0x107/0x163 lib/dump_stack.c:120  ubsan_epilogue+0xb/0x5a lib/ubsan.c:148  __ubsan_handle_shift_out_of_bounds.cold+0xb1/0x181 lib/ubsan.c:395  valid_perfect_hash net/sched/cls_tcindex.c:260 [inline]  tcindex_set_parms.cold+0x1b/0x215 net/sched/cls_tcindex.c:425  tcindex_change+0x232/0x340 net/sched/cls_tcindex.c:546  tc_new_tfilter+0x13fb/0x21b0 net/sched/cls_api.c:2127  rtnetlink_rcv_msg+0x8b6/0xb80 net/core/rtnetlink.c:5555  netlink_rcv_skb+0x153/0x420 net/netlink/af_netlink.c:2494  netlink_unicast_kernel net/netlink/af_netlink.c:1304 [inline]  netlink_unicast+0x533/0x7d0 net/netlink/af_netlink.c:1330  netlink_sendmsg+0x907/0xe40 net/netlink/af_netlink.c:1919  sock_sendmsg_nosec net/socket.c:652 [inline]  sock_sendmsg+0xcf/0x120 net/socket.c:672  ____sys_sendmsg+0x6e8/0x810 net/socket.c:2336  ___sys_sendmsg+0xf3/0x170 net/socket.c:2390  __sys_sendmsg+0xe5/0x1b0 net/socket.c:2423  do_syscall_64+0x2d/0x70 arch/x86/entry/common.c:46  entry_SYSCALL_64_after_hwframe+0x44/0xa9  ",bcd0cf19ef8258ac31b9a20248b05c15a1f4b4b0,1
RDMA/mad: Do not crash if the rdma device does not have a umad interface,"Non-IB devices do not have a umad interface and the client_data will be left set to NULL. In this case calling get_nl_info() will try to kref a NULL cdev causing a crash:    general protection fault, probably for non-canonical address 0xdffffc00000000ba: 0000 [#1] PREEMPT SMP KASAN   KASAN: null-ptr-deref in range [0x00000000000005d0-0x00000000000005d7]   CPU: 0 PID: 20851 Comm: syz-executor.0 Not tainted 5.6.0-rc2-syzkaller #0   Hardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 01/01/2011   ",5bdfa854013ce4193de0d097931fd841382c76a7,1
net: llc: fix skb_over_panic,"Syzbot reported skb_over_panic() in llc_pdu_init_as_xid_cmd(). The problem was in wrong LCC header manipulations.  Syzbot's reproducer tries to send XID packet. llc_ui_sendmsg() is doing following steps:  	1. skb allocation with size = len + header size 		len is passed from userpace and header size 		is 3 since addr->sllc_xid is set.  	2. skb_reserve() for header_len = 3 	3. filling all other space with memcpy_from_msg()  Ok, at this moment we have fully loaded skb, only headers needs to be filled.  Then code comes to llc_sap_action_send_xid_c(). This function pushes 3 bytes for LLC PDU header and initializes it. Then comes llc_pdu_init_as_xid_cmd(). It initalizes next 3 bytes *AFTER* LLC PDU header and call skb_push(skb, 3). This looks wrong for 2 reasons:  	1. Bytes rigth after LLC header are user data, so this function 	   was overwriting payload.  	2. skb_push(skb, 3) call can cause skb_over_panic() since 	   all free space was filled in llc_ui_sendmsg(). (This can 	   happen is user passed 686 len: 686 + 14 (eth header) + 3 (LLC 	   header) = 703. SKB_DATA_ALIGN(703) = 704)  So, in this patch I added 2 new private constansts: LLC_PDU_TYPE_U_XID and LLC_PDU_LEN_U_XID. LLC_PDU_LEN_U_XID is used to correctly reserve header size to handle LLC + XID case. LLC_PDU_TYPE_U_XID is used by llc_pdu_header_init() function to push 6 bytes instead of 3. And finally I removed skb_push() call from llc_pdu_init_as_xid_cmd().  This changes should not affect other parts of LLC, since after all steps we just transmit buffer.  ",c7c9d2102c9c098916ab9e0ab248006107d00d6c,0
net/sched: sch_taprio: properly cancel timer from taprio_destroy(),There is a comment in qdisc_create() about us not calling ops->reset() in some cases.  err_out4: 	,a56d447f196fa9973c568f54c0d76d5391c3b0c0,0
Input: cm109 - do not stomp on control URB,We need to make sure we are not stomping on the control URB that was issued when opening the device when attempting to toggle buzzer. To do that we need to mark it as pending in cm109_open().  ,82e06090473289ce63e23fdeb8737aad59b10645,0
blk-mq: protect debugfs_create_files() from failures,"If debugfs were to return a non-NULL error for a debugfs call, using that pointer later in debugfs_create_files() would crash.  Fix that by properly checking the pointer before referencing it.  ",36991ca68db9dd43bac7f3519f080ee3939263ef,1
KVM: X86: Fix NULL deref in vcpu_scan_ioapic,"Reported by syzkaller:      CPU: 1 PID: 5962 Comm: syz-executor118 Not tainted 4.20.0-rc6+ #374     Hardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 01/01/2011     ",dcbd3e49c2f0b2c2d8a321507ff8f3de4af76d7c,1
usbip: synchronize event handler with sysfs code paths,Fuzzing uncovered race condition between sysfs code paths in usbip drivers. Device connect/disconnect code paths initiated through sysfs interface are prone to races if disconnect happens during connect and vice versa.  Use sysfs_lock to synchronize event handler with sysfs paths in usbip drivers.  ,363eaa3a450abb4e63bd6e3ad79d1f7a0f717814,1
net/smc: fix sock refcounting in case of termination,"When an ISM device is removed, all its linkgroups are terminated, i.e. all the corresponding connections are killed. Connection killing invokes smc_close_active_abort(), which decreases the sock refcount for certain states to simulate passive closing. And it cancels the close worker and has to give up the sock lock for this timeframe. This opens the door for a passive close worker or a socket close to run in between. In this case smc_close_active_abort() and passive close worker resp. smc_release() might do a sock_put for passive closing. This causes:  ",5fb8642a17aa2ab9077372977d67a72d3899a98d,0
udf: Avoid accessing uninitialized data on failed inode read,"When we fail to read inode, some data accessed in udf_evict_inode() may be uninitialized. Move the accesses to !is_bad_inode() branch.  ",044e2e26f214e5ab26af85faffd8d1e4ec066931,1
USB: sisusbvga: fix oops in error path of sisusb_probe,The pointer used to log a failure of usb_register_dev() must be set before the error is logged.  v2: fix that minor is not available before registration  ,9a5729f68d3a82786aea110b1bfe610be318f80a,1
net/sched: fq_pie: prevent dismantle issue,"For some reason, fq_pie_destroy() did not copy working code from pie_destroy() and other qdiscs, thus causing elusive bug.  Before calling del_timer_sync(&q->adapt_timer), we need to ensure timer will not rearm itself.  rcu: INFO: rcu_preempt self-detected stall on CPU rcu:    0-....: (4416 ticks this GP) idle=60d/1/0x4000000000000000 softirq=10433/10434 fqs=2579         (t=10501 jiffies g=13085 q=3989) NMI backtrace for cpu 0 CPU: 0 PID: 13 Comm: ksoftirqd/0 Not tainted 5.16.0-rc4-syzkaller #0 Hardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 01/01/2011 Call Trace:  <IRQ>  __dump_stack lib/dump_stack.c:88 [inline]  dump_stack_lvl+0xcd/0x134 lib/dump_stack.c:106  nmi_cpu_backtrace.cold+0x47/0x144 lib/nmi_backtrace.c:111  nmi_trigger_cpumask_backtrace+0x1b3/0x230 lib/nmi_backtrace.c:62  trigger_single_cpu_backtrace include/linux/nmi.h:164 [inline]  rcu_dump_cpu_stacks+0x25e/0x3f0 kernel/rcu/tree_stall.h:343  print_cpu_stall kernel/rcu/tree_stall.h:627 [inline]  check_cpu_stall kernel/rcu/tree_stall.h:711 [inline]  rcu_pending kernel/rcu/tree.c:3878 [inline]  rcu_sched_clock_irq.cold+0x9d/0x746 kernel/rcu/tree.c:2597  update_process_times+0x16d/0x200 kernel/time/timer.c:1785  tick_sched_handle+0x9b/0x180 kernel/time/tick-sched.c:226  tick_sched_timer+0x1b0/0x2d0 kernel/time/tick-sched.c:1428  __run_hrtimer kernel/time/hrtimer.c:1685 [inline]  __hrtimer_run_queues+0x1c0/0xe50 kernel/time/hrtimer.c:1749  hrtimer_interrupt+0x31c/0x790 kernel/time/hrtimer.c:1811  local_apic_timer_interrupt arch/x86/kernel/apic/apic.c:1086 [inline]  __sysvec_apic_timer_interrupt+0x146/0x530 arch/x86/kernel/apic/apic.c:1103  sysvec_apic_timer_interrupt+0x8e/0xc0 arch/x86/kernel/apic/apic.c:1097  </IRQ>  <TASK>  asm_sysvec_apic_timer_interrupt+0x12/0x20 arch/x86/include/asm/idtentry.h:638 ",61c2402665f1e10c5742033fce18392e369931d7,1
RDMA/ucma: Don't allow setting RDMA_OPTION_IB_PATH without an RDMA device,Check to make sure that ctx->cm_id->device is set before we use it. Otherwise userspace can trigger a NULL dereference by doing RDMA_USER_CM_CMD_SET_OPTION on an ID that is not bound to a device.  ,8435168d50e66fa5eae01852769d20a36f9e5e83,1
net/smc: transfer fasync_list in case of fallback,"SMC does not work together with FASTOPEN. If sendmsg() is called with flag MSG_FASTOPEN in SMC_INIT state, the SMC-socket switches to fallback mode. To handle the previous ioctl FIOASYNC call correctly in this case, it is necessary to transfer the socket wait queue fasync_list to the internal TCP socket.  ",67f562e3e147750a02b2a91d21a163fc44a1d13e,0
media: ttusb-dec: Fix info-leak in ttusb_dec_send_command(),The function at issue does not always initialize each byte allocated for 'b' and can therefore leak uninitialized memory to a USB device in the call to usb_bulk_msg()  Use kzalloc() instead of kmalloc()  ,a10feaf8c464c3f9cfdd3a8a7ce17e1c0d498da1,1
bpf: fix x64 JIT code generation for jmp to 1st insn,"Introduction of bounded loops exposed old bug in x64 JIT. JIT maintains the array of offsets to the end of all instructions to compute jmp offsets. addrs[0] - offset of the end of the 1st insn (that includes prologue). addrs[1] - offset of the end of the 2nd insn. JIT didn't keep the offset of the beginning of the 1st insn, since classic BPF didn't have backward jumps and valid extended BPF couldn't have a branch to 1st insn, because it didn't allow loops. With bounded loops it's possible to construct a valid program that jumps backwards to the 1st insn. Fix JIT by computing: addrs[0] - offset of the end of prologue == start of the 1st insn. addrs[1] - offset of the end of 1st insn.  v1->v2: - Yonghong noticed a bug in jit linfo.   Fix it by passing 'addrs + 1' to bpf_prog_fill_jited_linfo(),   since it expects insn_to_jit_off array to be offsets to last byte.  ",7c2e988f400e83501e0a3568250780609b7c8263,1
io_uring: handle setup-failed ctx in kill_timeouts,"general protection fault, probably for non-canonical address 	0xdffffc0000000018: 0000 [#1] KASAN: null-ptr-deref 	in range [0x00000000000000c0-0x00000000000000c7] ",51520426f4bc3e61cbbf7a39ccf4e411b665002d,1
io_uring: fix files cancellation,"io_uring_cancel_files()'s task check condition mistakenly got flipped.  1. There can't be a request in the inflight list without IO_WQ_WORK_FILES, kill this check to keep the whole condition simpler. 2. Also, don't call the function for files==NULL to not do such a check, all that staff is already handled well by its counter part, __io_uring_cancel_task_requests().  With that just flip the task check.  Also, it iowq-cancels all request of current task there, don't forget to set right ->files into struct io_task_cancel.  ",bee749b187ac57d1faf00b2ab356ff322230fce8,0
tipc: switch to rhashtable iterator,"syzbot reported a use-after-free in tipc_group_fill_sock_diag(), where tipc_group_fill_sock_diag() still reads tsk->group meanwhile tipc_group_delete() just deletes it in tipc_release().  tipc_nl_sk_walk() aims to lock this sock when walking each sock in the hash table to close race conditions with sock changes like this one, by acquiring tsk->sk.sk_lock.slock spinlock, unfortunately this doesn't work at all. All non-BH call path should take lock_sock() instead to make it work.  tipc_nl_sk_walk() brutally iterates with raw rht_for_each_entry_rcu() where RCU read lock is required, this is the reason why lock_sock() can't be taken on this path. This could be resolved by switching to rhashtable iterator API's, where taking a sleepable lock is possible. Also, the iterator API's are friendly for restartable calls like diag dump, the last position is remembered behind the scence, all we need to do here is saving the iterator into cb->args[].  I tested this with parallel tipc diag dump and thousands of tipc socket creation and release, no crash or memory leak.  ",9a07efa9aea2f4a59f35da0785a4e6a6b5a96192,1
net: ieee802154: nl-mac: fix check on panid,This patch fixes a null pointer derefence for panid handle by move the check for the netlink variable directly before accessing them.  ,6f7f657f24405f426212c09260bf7fe8a52cef33,0
cfg80211: only allow S1G channels on S1G band,"As discovered by syzbot, cfg80211 was accepting S1G channel widths on non-S1G bands. Add a check for this, and consolidate the 1MHz frequency check as it ends up being a subset of the others.  ",c1cd35c6060140cebf85f43f8c702abef9eca997,0
drm/atomic-helper: reset vblank on crtc reset,"Only when vblanks are supported ofc.  Some drivers do this already, but most unfortunately missed it. This opens up bugs after driver load, before the crtc is enabled for the first time. syzbot spotted this when loading vkms as a secondary output. Given how many drivers are buggy it's best to solve this once and for all in shared helper code.  Aside from moving the few existing calls to drm_crtc_vblank_reset into helpers (i915 doesn't use helpers, so keeps its own) I think the regression risk is minimal: atomic helpers already rely on drivers calling drm_crtc_vblank_on/off correctly in their hooks when they support vblanks. And driver that's failing to handle vblanks after this is missing those calls already, and vblanks could only work by accident when enabling a CRTC for the first time right after boot.  Big thanks to Tetsuo for helping track down what's going wrong here.  There's only a few drivers which already had the necessary call and needed some updating: - komeda, atmel and tidss also needed to be changed to call   __drm_atomic_helper_crtc_reset() intead of open coding it - tegra and msm even had it in the same place already, just code   motion, and malidp already uses __drm_atomic_helper_crtc_reset(). - Laurent noticed that rcar-du and omap open-code their crtc reset and   hence would actually be broken by this patch now. So fix them up by   reusing the helpers, which brings the drm_crtc_vblank_reset() back.  Only call left is in i915, which doesn't use drm_mode_config_reset, but has its own fastboot infrastructure. So that's the only case where we actually want this in the driver still.  I've also reviewed all other drivers which set up vblank support with drm_vblank_init. After the previous patch fixing mxsfb all atomic drivers do call drm_crtc_vblank_on/off as they should, the remaining drivers are either legacy kms or legacy dri1 drivers, so not affected by this change to atomic helpers.  v2: Use the drm_dev_has_vblank() helper.  v3: Laurent pointed out that omap and rcar-du used drm_crtc_vblank_off instead of drm_crtc_vblank_reset. Adjust them too.  v4: Laurent noticed that rcar-du and omap open-code their crtc reset and hence would actually be broken by this patch now. So fix them up by reusing the helpers, which brings the drm_crtc_vblank_reset() back.  v5: also mention rcar-du and ompadrm in the proper commit message above (Laurent).  ",51f644b40b4b794b28b982fdd5d0dd8ee63f9272,0
udp: use skb_queue_empty_lockless(),"syzbot reported a data-race [1].  We should use skb_queue_empty_lockless() to document that we are not ensuring a mutual exclusion and silence KCSAN.  [1] BUG: KCSAN: data-race in __skb_recv_udp / __udp_enqueue_schedule_skb  write to 0xffff888122474b50 of 8 bytes by interrupt on cpu 0:  __skb_insert include/linux/skbuff.h:1852 [inline]  __skb_queue_before include/linux/skbuff.h:1958 [inline]  __skb_queue_tail include/linux/skbuff.h:1991 [inline]  __udp_enqueue_schedule_skb+0x2c1/0x410 net/ipv4/udp.c:1470  __udp_queue_rcv_skb net/ipv4/udp.c:1940 [inline]  udp_queue_rcv_one_skb+0x7bd/0xc70 net/ipv4/udp.c:2057  udp_queue_rcv_skb+0xb5/0x400 net/ipv4/udp.c:2074  udp_unicast_rcv_skb.isra.0+0x7e/0x1c0 net/ipv4/udp.c:2233  __udp4_lib_rcv+0xa44/0x17c0 net/ipv4/udp.c:2300  udp_rcv+0x2b/0x40 net/ipv4/udp.c:2470  ip_protocol_deliver_rcu+0x4d/0x420 net/ipv4/ip_input.c:204  ip_local_deliver_finish+0x110/0x140 net/ipv4/ip_input.c:231  NF_HOOK include/linux/netfilter.h:305 [inline]  NF_HOOK include/linux/netfilter.h:299 [inline]  ip_local_deliver+0x133/0x210 net/ipv4/ip_input.c:252  dst_input include/net/dst.h:442 [inline]  ip_rcv_finish+0x121/0x160 net/ipv4/ip_input.c:413  NF_HOOK include/linux/netfilter.h:305 [inline]  NF_HOOK include/linux/netfilter.h:299 [inline]  ip_rcv+0x18f/0x1a0 net/ipv4/ip_input.c:523  __netif_receive_skb_one_core+0xa7/0xe0 net/core/dev.c:5010  __netif_receive_skb+0x37/0xf0 net/core/dev.c:5124  process_backlog+0x1d3/0x420 net/core/dev.c:5955  read to 0xffff888122474b50 of 8 bytes by task 8921 on cpu 1:  skb_queue_empty include/linux/skbuff.h:1494 [inline]  __skb_recv_udp+0x18d/0x500 net/ipv4/udp.c:1653  udp_recvmsg+0xe1/0xb10 net/ipv4/udp.c:1712  inet_recvmsg+0xbb/0x250 net/ipv4/af_inet.c:838  sock_recvmsg_nosec+0x5c/0x70 net/socket.c:871  ___sys_recvmsg+0x1a0/0x3e0 net/socket.c:2480  do_recvmmsg+0x19a/0x5c0 net/socket.c:2601  __sys_recvmmsg+0x1ef/0x200 net/socket.c:2680  __do_sys_recvmmsg net/socket.c:2703 [inline]  __se_sys_recvmmsg net/socket.c:2696 [inline]  __x64_sys_recvmmsg+0x89/0xb0 net/socket.c:2696  do_syscall_64+0xcc/0x370 arch/x86/entry/common.c:290  entry_SYSCALL_64_after_hwframe+0x44/0xa9  Reported by Kernel Concurrency Sanitizer on: CPU: 1 PID: 8921 Comm: syz-executor.4 Not tainted 5.4.0-rc3+ #0 Hardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 01/01/2011  ",137a0dbe3426fd7bcfe3f8117b36a87b3590e4eb,1
net: rds: fix memory leak in rds_recvmsg,"Syzbot reported memory leak in rds. The problem was in unputted refcount in case of error.  int rds_recvmsg(struct socket *sock, struct msghdr *msg, size_t size, 		int msg_flags) { ...  	if (!rds_next_incoming(rs, &inc)) { 		... 	}  After this ""if"" inc refcount incremented and  	if (rds_cmsg_recv(inc, msg, rs)) { 		ret = -EFAULT; 		goto out; 	} ... out: 	return ret; }  in case of rds_cmsg_recv() fail the refcount won't be decremented. And it's easy to see from ftrace log, that rds_inc_addref() don't have rds_inc_put() pair in rds_recvmsg() after rds_cmsg_recv()   1)               |  rds_recvmsg() {  1)   3.721 us    |    rds_inc_addref();  1)   3.853 us    |    rds_message_inc_copy_to_user();  1) + 10.395 us   |    rds_cmsg_recv();  1) + 34.260 us   |  }  ",49bfcbfd989a8f1f23e705759a6bb099de2cff9f,1
block: pass no-op callback to INIT_WORK().,"syzbot is hitting flush_work() warning caused by commit 4d43d395fed12463 (""workqueue: Try to catch flush_work() without INIT_WORK()."") [1]. Although that commit did not expect INIT_WORK(NULL) case, calling flush_work() without setting a valid callback should be avoided anyway. Fix this problem by setting a no-op callback instead of NULL.  [1] https://syzkaller.appspot.com/bug?id=e390366bc48bc82a7c668326e0663be3b91cbd29  ",2e3c18d0ada16f145087b2687afcad1748c0827c,1
media: vb2: check memory model for VIDIOC_CREATE_BUFS,vb2_core_create_bufs did not check if the memory model for newly added buffers is the same as for already existing buffers. It should return an error if they aren't the same.  ,62dcb4f41836bd3c44b5b651bb6df07ea4cb1551,0
Yama: Check for pid death before checking ancestry,"It's possible that a pid has died before we take the rcu lock, in which case we can't walk the ancestry list as it may be detached. Instead, check for death first before doing the walk.  ",9474f4e7cd71a633fa1ef93b7daefd44bbdfd482,0
fbcon: fix null-ptr-deref in fbcon_switch,"Set logo_shown to FBCON_LOGO_CANSHOW when the vc was deallocated.  syzkaller report: https://lkml.org/lkml/2020/3/27/403 general protection fault, probably for non-canonical address 0xdffffc000000006c: 0000 [#1] SMP KASAN KASAN: null-ptr-deref in range [0x0000000000000360-0x0000000000000367] ",b139f8b00db4a8ea75a4174346eafa48041aa489,1
"Revert ""block: cover another queue enter recursion via BIO_QUEUE_ENTERED""","We can't touch a bio after ->make_request_fn(), for all we know it could already have been completed by the time this function returns.  This reverts commit 698cef173983b086977e633e46476e0f925ca01e.  ",947b7ac135b16aa60f9141ff72bd494eda0edb5e,0
devpts: fix error handling in devpts_mntget(),"If devpts_ptmx_path() returns an error code, then devpts_mntget() dereferences an ERR_PTR():      BUG: unable to handle kernel paging request at fffffffffffffff5     IP: devpts_mntget+0x13f/0x280 fs/devpts/inode.c:173  Fix it by returning early in the error paths.  Reproducer:      ",c9cc8d01fb04117928830449388512a5047569c9,1
ipv6: fib: Unlink replaced routes from their nodes,When a route is deleted its node pointer is set to NULL to indicate it's no longer linked to its node. Do the same for routes that are replaced.  This will later allow us to test if a route is still in the FIB by checking its node pointer instead of its reference count.  ,7483cea79957312e9f8e9cf760a1bc5d6c507113,0
sctp: fix memleak in sctp_send_reset_streams,"If the stream outq is not empty, need to kfree nstr_list.  ",6d5afe20397b478192ed8c38ec0ee10fa3aec649,0
net: initialize skb->peeked when cloning,syzbot reported __skb_try_recv_from_queue() was using skb->peeked while it was potentially unitialized.  We need to clear it in __skb_clone()  ,b13dda9f9aa7caceeee61c080c2e544d5f5d85e5,0
netfilter: nf_tables: skip netdev events generated on netns removal,syzbot reported following (harmless) WARN:   ,68a3765c659f809dcaac20030853a054646eb739,0
bpf: implement dummy fops for bpf objects,syzkaller was able to trigger the following warning in do_dentry_open():    ,b16558579576c8f2781062b638600f68954b1827,1
crypto: af_alg - avoid undefined behavior accessing salg_name,"Commit 3f69cc60768b (""crypto: af_alg - Allow arbitrarily long algorithm names"") made the kernel start accepting arbitrarily long algorithm names in sockaddr_alg.  However, the actual length of the salg_name field stayed at the original 64 bytes.  This is broken because the kernel can access indices >= 64 in salg_name, which is undefined behavior -- even though the memory that is accessed is still located within the sockaddr structure.  It would only be defined behavior if the array were properly marked as arbitrary-length (either by making it a flexible array, which is the recommended way these days, or by making it an array of length 0 or 1).  We can't simply change salg_name into a flexible array, since that would break source compatibility with userspace programs that embed sockaddr_alg into another struct, or (more commonly) declare a sockaddr_alg like 'struct sockaddr_alg sa = { .salg_name = ""foo"" };'.  One solution would be to change salg_name into a flexible array only when '#ifdef __KERNEL__'.  However, that would keep userspace without an easy way to actually use the longer algorithm names.  Instead, add a new structure 'sockaddr_alg_new' that has the flexible array field, and expose it to both userspace and the kernel. Make the kernel use it correctly in alg_bind().  This addresses the syzbot report ""UBSAN: array-index-out-of-bounds in alg_bind"" (https://syzkaller.appspot.com/bug?extid=92ead4eb8e26a26d465e).  ",92eb6c3060ebe3adf381fd9899451c5b047bb14d,1
RDMA/core: Check error status of rdma_find_ndev_for_src_ip_rcu,"rdma_find_ndev_for_src_ip_rcu() returns either valid netdev pointer or ERR_PTR().  Instead of checking for NULL, check for error.  ",fe33507ec38a8b2e8b782b83669943b7a5fefd4c,0
net: Fix untag for vlan packets without ethernet header,"In some situation vlan packets do not have ethernet headers. One example is packets from tun devices. Users can specify vlan protocol in tun_pi field instead of IP protocol, and skb_vlan_untag() attempts to untag such packets.  skb_vlan_untag() (more precisely, skb_reorder_vlan_header() called by it) however did not expect packets without ethernet headers, so in such a case size argument for memmove() underflowed and triggered crash.  ==== BUG: unable to handle kernel paging request at ffff8801cccb8000 IP: __memmove+0x24/0x1a0 arch/x86/lib/memmove_64.S:43 PGD 9cee067 P4D 9cee067 PUD 1d9401063 PMD 1cccb7063 PTE 2810100028101 Oops: 000b [#1] SMP KASAN Dumping ftrace buffer:    (ftrace buffer empty) ",ae4745730cf8e693d354ccd4dbaf59ea440c09a9,1
ALSA: usb-audio: Fix missing error check at mixer resolution test,"A check of the return value from get_cur_mix_raw() is missing at the resolution test code in get_min_max_with_quirks(), which may leave the variable untouched, leading to a random uninitialized value, as detected by syzkaller fuzzer.  Add the missing return error check for fixing that.  ",167beb1756791e0806365a3f86a0da10d7a327ee,1
reiserfs: update reiserfs_xattrs_initialized() condition,"syzbot is reporting NULL pointer dereference at reiserfs_security_init() [1], for commit ab17c4f02156c4f7 (""reiserfs: fixup xattr_root caching"") is assuming that REISERFS_SB(s)->xattr_root != NULL in reiserfs_xattr_jcreate_nblocks() despite that commit made REISERFS_SB(sb)->priv_root != NULL && REISERFS_SB(s)->xattr_root == NULL case possible.  I guess that commit 6cb4aff0a77cc0e6 (""reiserfs: fix oops while creating privroot with selinux enabled"") wanted to check xattr_root != NULL before reiserfs_xattr_jcreate_nblocks(), for the changelog is talking about the xattr root.    The issue is that while creating the privroot during mount   reiserfs_security_init calls reiserfs_xattr_jcreate_nblocks which   dereferences the xattr root. The xattr root doesn't exist, so we get   an oops.  Therefore, update reiserfs_xattrs_initialized() to check both the privroot and the xattr root.  ",5e46d1b78a03d52306f21f77a4e4a144b6d31486,1
mac80211: fix double free in ibss_leave,Clear beacon ie pointer and ie length after free in order to prevent double free.  ,3bd801b14e0c5d29eeddc7336558beb3344efaa3,1
fuse: Add bad inode check in fuse_destroy_inode(),"make_bad_inode() sets inode->i_mode to S_IFREG if I/O error is detected in fuse_do_getattr()/fuse_do_setattr(). If the inode is not a regular file, write_files and queued_writes in fuse_inode are not initialized and have NULL or invalid pointers written by other members in a union. So, list_empty() returns false in fuse_destroy_inode(). Add is_bad_inode() to check if make_bad_inode() was called.  ",4fc4bb796b0c75067fd65292dfd874869ff7c9dc,0
inet: protect against too small mtu values.,"syzbot was once again able to crash a host by setting a very small mtu on loopback device.  Let's make inetdev_valid_mtu() available in include/net/ip.h, and use it in ip_setup_cork(), so that we protect both ip_append_page() and __ip_append_data()  Also add a READ_ONCE() when the device mtu is read.  Pairs this lockless read with one WRITE_ONCE() in __dev_set_mtu(), even if other code paths might write over this field.  Add a big comment in include/linux/netdevice.h about dev->mtu needing READ_ONCE()/WRITE_ONCE() annotations.  Hopefully we will add the missing ones in followup patches.  [1]  refcount_t: saturated; leaking memory. ",501a90c945103e8627406763dac418f20f3837b2,1
cfg80211: Save the regulatory domain with a lock,Saving the regulatory domain while setting custom regulatory domain was done while accessing a RCU protected pointer but without any protection.  Fix this by using RTNL while accessing the pointer.  ,51d62f2f2c501a93d9a6a46f43731f984e227764,0
can: isotp: isotp_sendmsg(): add result check for wait_event_interruptible(),"Using wait_event_interruptible() to wait for complete transmission, but do not check the result of wait_event_interruptible() which can be interrupted. It will result in TX buffer has multiple accessors and the later process interferes with the previous process.  Following is one of the problems reported by syzbot.  ",9acf636215a6ce9362fe618e7da4913b8bfe84c8,0
media: v4l2-core: only zero-out ioctl-read buffers,"The memset() got moved out of the check for _IOC_NONE, so passing a made-up command number with a size but no direction would allow clearing data on user-provided pointers.  Move video_get_user() back into the _IOC_NONE check where it belongs.  ",1dc8b65c944e5cfce3d830a5b97b42be185a1984,0
btrfs: reset device back to allocation state when removing,"When closing a device, btrfs_close_one_device() first allocates a new device, copies the device to close's name, replaces it in the dev_list with the copy and then finally frees it.  This involves two memory allocation, which can potentially fail. As this code path is tricky to unwind, the allocation failures where handled by BUG_ON()s.  But this copying isn't strictly needed, all that is needed is resetting the device in question to it's state it had after the allocation.  ",321f69f86a0fc40203b43659c3a39464f15c2ee9,1
Bluetooth: prefetch channel before killing sock,Prefetch channel before killing sock in order to fix UAF like   BUG: KASAN: use-after-free in l2cap_sock_release+0x24c/0x290 net/bluetooth/l2cap_sock.c:1212  Read of size 8 at addr ffff8880944904a0 by task syz-fuzzer/9751  ,2a154903cec20fb64ff4d7d617ca53c16f8fd53a,1
ax25: fix inconsistent lock state in ax25_destroy_timer,Before thread in process context uses bh_lock_sock() we must disable bh.  sysbot reported :  ,d4d5d8e83c9616aeef28a2869cea49cc3fb35526,0
f2fs: give message and set need_fsck given broken node id,"syzbot hit the following crash on upstream commit 83beed7b2b26f232d782127792dd0cd4362fdc41 (Fri Apr 20 17:56:32 2018 +0000) Merge branch 'fixes' of git://git.kernel.org/pub/scm/linux/kernel/git/evalenti/linux-soc-thermal syzbot dashboard link: https://syzkaller.appspot.com/bug?extid=d154ec99402c6f628887  C reproducer: https://syzkaller.appspot.com/x/repro.c?id=5414336294027264 syzkaller reproducer: https://syzkaller.appspot.com/x/repro.syz?id=5471683234234368 Raw console output: https://syzkaller.appspot.com/x/log.txt?id=5436660795834368 Kernel config: https://syzkaller.appspot.com/x/.config?id=1808800213120130118 compiler: gcc (GCC) 8.0.1 20180413 (experimental)  IMPORTANT: if you fix the bug, please add the following tag to the commit: ",a4f843bd004d775cbb360cd375969b8a479568a9,1
macvlan: macvlan_count_rx() needs to be aware of preemption,"macvlan_count_rx() can be called from process context, it is thus necessary to disable preemption before calling u64_stats_update_begin()  syzbot was able to spot this on 32bit arch:  ",dd4fa1dae9f4847cc1fd78ca468ad69e16e5db3e,0
convert do_remount_sb() to fs_context,"Replace do_remount_sb() with a function, reconfigure_super(), that's fs_context aware.  The fs_context is expected to be parameterised already and have ->root pointing to the superblock to be reconfigured.  A legacy wrapper is provided that is intended to be called from the fs_context ops when those appear, but for now is called directly from reconfigure_super().  This wrapper invokes the ->remount_fs() superblock op for the moment.  It is intended that the remount_fs() op will be phased out.  The fs_context->purpose is set to FS_CONTEXT_FOR_RECONFIGURE to indicate that the context is being used for reconfiguration.  do_umount_root() is provided to consolidate remount-to-R/O for umount and emergency remount by creating a context and invoking reconfiguration.  do_remount(), do_umount() and do_emergency_remount_callback() are switched to use the new process.  [AV -- fold UMOUNT and EMERGENCY_REMOUNT in; fixes the umount / bug, gets rid of pointless complexity] [AV -- set ->net_ns in all cases; nfs remount will need that] [AV -- shift security_sb_remount() call into reconfigure_super(); the callers that didn't do security_sb_remount() have NULL fc->security anyway, so it's a no-op for them]  ",8d0347f6c3a9d4953ddd636a31c6584da082e084,0
"bpf: Sockmap/tls, during free we may call tcp_bpf_unhash() in loop","When a sockmap is free'd and a socket in the map is enabled with tls we tear down the bpf context on the socket, the psock struct and state, and then call tcp_update_ulp(). The tcp_update_ulp() call is to inform the tls stack it needs to update its saved sock ops so that when the tls socket is later destroyed it doesn't try to call the now destroyed psock hooks.  This is about keeping stacked ULPs in good shape so they always have the right set of stacked ops.  However, recently unhash() hook was removed from TLS side. But, the sockmap/bpf side is not doing any extra work to update the unhash op when is torn down instead expecting TLS side to manage it. So both TLS and sockmap believe the other side is managing the op and instead no one updates the hook so it continues to point at tcp_bpf_unhash(). When unhash hook is called we call tcp_bpf_unhash() which detects the psock has already been destroyed and calls sk->sk_prot_unhash() which calls tcp_bpf_unhash() yet again and so on looping and hanging the core.  To fix have sockmap tear down logic fixup the stale pointer.  ",4da6a196f93b1af7612340e8c1ad8ce71e18f955,0
crypto: api - check for ERR pointers in crypto_destroy_tfm(),"Given that crypto_alloc_tfm() may return ERR pointers, and to avoid crashes on obscure error paths where such pointers are presented to crypto_destroy_tfm() (such as [0]), add an ERR_PTR check there before dereferencing the second argument as a struct crypto_tfm pointer.  [0] https://lore.kernel.org/linux-crypto/000000000000de949705bc59e0f6@google.com/  ",83681f2bebb34dbb3f03fecd8f570308ab8b7c2c,1
mptcp: fix possible stall on recvmsg(),"recvmsg() can enter an infinite loop if the caller provides the MSG_WAITALL, the data present in the receive queue is not sufficient to fulfill the request, and no more data is received by the peer.  When the above happens, mptcp_wait_data() will always return with no wait, as the MPTCP_DATA_READY flag checked by such function is set and never cleared in such code path.  Leveraging the above syzbot was able to trigger an RCU stall:  rcu: INFO: rcu_preempt self-detected stall on CPU rcu:    0-...!: (10499 ticks this GP) idle=0af/1/0x4000000000000000 softirq=10678/10678 fqs=1         (t=10500 jiffies g=13089 q=109) rcu: rcu_preempt kthread starved for 10497 jiffies! g13089 f0x0 RCU_GP_WAIT_FQS(5) ->state=0x0 ->cpu=1 rcu:    Unless rcu_preempt kthread gets sufficient CPU time, OOM is now expected behavior. rcu: RCU grace-period kthread stack dump: ",612f71d7328c14369924384ad2170aae2a6abd92,1
"mm, thp, proc: report THP eligibility for each vma","Userspace falls short when trying to find out whether a specific memory range is eligible for THP.  There are usecases that would like to know that http://lkml.kernel.org/r/alpine.DEB.2.21.1809251248450.50347@chino.kir.corp.google.com : This is used to identify heap mappings that should be able to fault thp : but do not, and they normally point to a low-on-memory or fragmentation : issue.  The only way to deduce this now is to query for hg resp.  nh flags and confronting the state with the global setting.  Except that there is also PR_SET_THP_DISABLE that might change the picture.  So the final logic is not trivial.  Moreover the eligibility of the vma depends on the type of VMA as well.  In the past we have supported only anononymous memory VMAs but things have changed and shmem based vmas are supported as well these days and the query logic gets even more complicated because the eligibility depends on the mount option and another global configuration knob.  Simplify the current state and report the THP eligibility in /proc/<pid>/smaps for each existing vma.  Reuse transparent_hugepage_enabled for this purpose.  The original implementation of this function assumes that the caller knows that the vma itself is supported for THP so make the core checks into __transparent_hugepage_enabled and use it for existing callers. __show_smap just use the new transparent_hugepage_enabled which also checks the vma support status (please note that this one has to be out of line due to include dependency issues).  [mhocko@kernel.org: fix oops with NULL ->f_mapping]   ",7635d9cbe8327e131a1d3d8517dc186c2796ce2e,1
net/sched: sch_taprio: fix undefined behavior in ktime_mono_to_any,"1) if q->tk_offset == TK_OFFS_MAX, then get_tcp_tstamp() calls    ktime_mono_to_any() with out-of-bound value.  2) if q->tk_offset is changed in taprio_parse_clockid(),    taprio_get_time() might also call ktime_mono_to_any()    with out-of-bound value as sysbot found:  UBSAN: array-index-out-of-bounds in kernel/time/timekeeping.c:908:27 index 3 is out of range for type 'ktime_t *[3]' CPU: 1 PID: 25668 Comm: kworker/u4:0 Not tainted 5.15.0-syzkaller #0 Hardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 01/01/2011 Workqueue: bat_events batadv_iv_send_outstanding_bat_ogm_packet Call Trace:  <TASK>  __dump_stack lib/dump_stack.c:88 [inline]  dump_stack_lvl+0xcd/0x134 lib/dump_stack.c:106  ubsan_epilogue+0xb/0x5a lib/ubsan.c:151  __ubsan_handle_out_of_bounds.cold+0x62/0x6c lib/ubsan.c:291  ktime_mono_to_any+0x1d4/0x1e0 kernel/time/timekeeping.c:908  get_tcp_tstamp net/sched/sch_taprio.c:322 [inline]  get_packet_txtime net/sched/sch_taprio.c:353 [inline]  taprio_enqueue_one+0x5b0/0x1460 net/sched/sch_taprio.c:420  taprio_enqueue+0x3b1/0x730 net/sched/sch_taprio.c:485  dev_qdisc_enqueue+0x40/0x300 net/core/dev.c:3785  __dev_xmit_skb net/core/dev.c:3869 [inline]  __dev_queue_xmit+0x1f6e/0x3630 net/core/dev.c:4194  batadv_send_skb_packet+0x4a9/0x5f0 net/batman-adv/send.c:108  batadv_iv_ogm_send_to_if net/batman-adv/bat_iv_ogm.c:393 [inline]  batadv_iv_ogm_emit net/batman-adv/bat_iv_ogm.c:421 [inline]  batadv_iv_send_outstanding_bat_ogm_packet+0x6d7/0x8e0 net/batman-adv/bat_iv_ogm.c:1701  process_one_work+0x9b2/0x1690 kernel/workqueue.c:2298  worker_thread+0x658/0x11f0 kernel/workqueue.c:2445  kthread+0x405/0x4f0 kernel/kthread.c:327  ret_from_fork+0x1f/0x30 arch/x86/entry/entry_64.S:295  ",6dc25401cba4d428328eade8ceae717633fdd702,1
esp: Fix GRO when the headers not fully in the linear part of the skb.,"The GRO layer does not necessarily pull the complete headers into the linear part of the skb, a part may remain on the first page fragment. This can lead to a crash if we try to pull the headers, so make sure we have them on the linear part before pulling.  ",374d1b5a81f7f9cc5e7f095ac3d5aff3f6600376,1
flow_dissector: properly cap thoff field,"syzbot reported yet another crash [1] that is caused by insufficient validation of DODGY packets.  Two bugs are happening here to trigger the crash.  1) Flow dissection leaves with incorrect thoff field.  2) skb_probe_transport_header() sets transport header to this invalid thoff, even if pointing after skb valid data.  3) qdisc_pkt_len_init() reads out-of-bound data because it trusts tcp_hdrlen(skb)  Possible fixes :  - Full flow dissector validation before injecting bad DODGY packets in the stack.  This approach was attempted here : https://patchwork.ozlabs.org/patch/ 861874/  - Have more robust functions in the core.   This might be needed anyway for stable versions.  This patch fixes the flow dissection issue.  [1] CPU: 1 PID: 3144 Comm: syzkaller271204 Not tainted 4.15.0-rc4-mm1+ #49 Hardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 01/01/2011 Call Trace:  __dump_stack lib/dump_stack.c:17 [inline]  dump_stack+0x194/0x257 lib/dump_stack.c:53  print_address_description+0x73/0x250 mm/kasan/report.c:256  kasan_report_error mm/kasan/report.c:355 [inline]  kasan_report+0x23b/0x360 mm/kasan/report.c:413  __asan_report_load2_noabort+0x14/0x20 mm/kasan/report.c:432  __tcp_hdrlen include/linux/tcp.h:35 [inline]  tcp_hdrlen include/linux/tcp.h:40 [inline]  qdisc_pkt_len_init net/core/dev.c:3160 [inline]  __dev_queue_xmit+0x20d3/0x2200 net/core/dev.c:3465  dev_queue_xmit+0x17/0x20 net/core/dev.c:3554  packet_snd net/packet/af_packet.c:2943 [inline]  packet_sendmsg+0x3ad5/0x60a0 net/packet/af_packet.c:2968  sock_sendmsg_nosec net/socket.c:628 [inline]  sock_sendmsg+0xca/0x110 net/socket.c:638  sock_write_iter+0x31a/0x5d0 net/socket.c:907  call_write_iter include/linux/fs.h:1776 [inline]  new_sync_write fs/read_write.c:469 [inline]  __vfs_write+0x684/0x970 fs/read_write.c:482  vfs_write+0x189/0x510 fs/read_write.c:544  SYSC_write fs/read_write.c:589 [inline]  SyS_write+0xef/0x220 fs/read_write.c:581  entry_SYSCALL_64_fastpath+0x1f/0x96  ",d0c081b49137cd3200f2023c0875723be66e7ce5,1
mptcp: fix locking in mptcp_disconnect(),"tcp_disconnect() expects the caller acquires the sock lock, but mptcp_disconnect() is not doing that. Add the missing required lock.  ",13a9499e833387fcc7a53915bbe5cddf3c336b59,0
KVM: X86: Fix residual mmio emulation request to userspace,Reported by syzkaller:  The kvm-intel.unrestricted_guest=0     ,bbeac2830f4de270bb48141681cb730aadf8dce1,1
x86/hw_breakpoints: Make default case in hw_breakpoint_arch_parse() return an error,"When building with -Wsometimes-uninitialized, Clang warns:  arch/x86/kernel/hw_breakpoint.c:355:2: warning: variable 'align' is used uninitialized whenever switch default is taken [-Wsometimes-uninitialized]  The default cannot be reached because arch_build_bp_info() initializes hw->len to one of the specified cases. Nevertheless the warning is valid and returning -EINVAL makes sure that this cannot be broken by future modifications.  Suggested-by: Nick Desaulniers <ndesaulniers@google.com> ",e898e69d6b9475bf123f99b3c5d1a67bb7cb2361,1
xdp: Fix race in dev_map_hash_update_elem() when replacing element,"syzbot found a crash in dev_map_hash_update_elem(), when replacing an element with a new one. Jesper correctly identified the cause of the crash as a race condition between the initial lookup in the map (which is done before taking the lock), and the removal of the old element.  Rather than just add a second lookup into the hashmap after taking the lock, fix this by reworking the function logic to take the lock before the initial lookup.  ",af58e7ee6a8d83726ad8a2696e98d86400a7639c,1
tipc: purge deferredq list for each grp member in tipc_group_delete,"Syzbot reported a memleak caused by grp members' deferredq list not purged when the grp is be deleted.  The issue occurs when more(msg_grp_bc_seqno(hdr), m->bc_rcv_nxt) in tipc_group_filter_msg() and the skb will stay in deferredq.  So fix it by calling __skb_queue_purge for each member's deferredq in tipc_group_delete() when a tipc sk leaves the grp.  ",5cf02612b33f104fe1015b2dfaf1758ad3675588,0
sctp: handle two v4 addrs comparison in sctp_inet6_cmp_addr,"Since sctp ipv6 socket also supports v4 addrs, it's possible to compare two v4 addrs in pf v6 .cmp_addr, sctp_inet6_cmp_addr.  However after Commit 1071ec9d453a (""sctp: do not check port in sctp_inet6_cmp_addr""), it no longer calls af1->cmp_addr, which in this case is sctp_v4_cmp_addr, but calls __sctp_v6_cmp_addr where it handles them as two v6 addrs. It would cause a out of bounds crash.  syzbot found this crash when trying to bind two v4 addrs to a v6 socket.  This patch fixes it by adding the process for two v4 addrs in sctp_inet6_cmp_addr.  ",d625329b06e46bd20baf9ee40847d11982569204,1
bdi: Fix another oops in wb_workfn(),"syzbot is reporting NULL pointer dereference at wb_workfn() [1] due to wb->bdi->dev being NULL. And Dmitry confirmed that wb->state was WB_shutting_down after wb->bdi->dev became NULL. This indicates that unregister_bdi() failed to call wb_shutdown() on one of wb objects.  The problem is in cgwb_bdi_unregister() which does cgwb_kill() and thus drops bdi's reference to wb structures before going through the list of wbs again and calling wb_shutdown() on each of them. This way the loop iterating through all wbs can easily miss a wb if that wb has already passed through cgwb_remove_from_bdi_list() called from wb_shutdown() from cgwb_release_workfn() and as a result fully shutdown bdi although wb_workfn() for this wb structure is still running. In fact there are also other ways cgwb_bdi_unregister() can race with cgwb_release_workfn() leading e.g. to use-after-free issues:  CPU1                            CPU2                                 cgwb_bdi_unregister()                                   cgwb_kill(*slot);  cgwb_release()   queue_work(cgwb_release_wq, &wb->release_work); cgwb_release_workfn()                                   wb = list_first_entry(&bdi->wb_list, ...)                                   spin_unlock_irq(&cgwb_lock);   wb_shutdown(wb);   ...   kfree_rcu(wb, rcu);                                   wb_shutdown(wb); -> oops use-after-free  We solve these issues by synchronizing writeback structure shutdown from cgwb_bdi_unregister() with cgwb_release_workfn() using a new mutex. That way we also no longer need synchronization using WB_shutting_down as the mutex provides it for CONFIG_CGROUP_WRITEBACK case and without CONFIG_CGROUP_WRITEBACK wb_shutdown() can be called only once from bdi_unregister().  ",3ee7e8697d5860b173132606d80a9cd35e7113ee,1
x86/unwind: Add hardcoded ORC entry for NULL,"When the ORC unwinder is invoked for an oops caused by IP==0, it currently has no idea what to do because there is no debug information for the stack frame of NULL.  But if RIP is NULL, it is very likely that the last successfully executed instruction was an indirect CALL/JMP, and it is possible to unwind out in the same way as for the first instruction of a normal function. Hardcode a corresponding ORC entry.  With an artificially-added NULL call in prctl_set_seccomp(), before this patch, the trace is:  Call Trace:  ? __x64_sys_prctl+0x402/0x680  ? __ia32_sys_prctl+0x6e0/0x6e0  ? __do_page_fault+0x457/0x620  ? do_syscall_64+0x6d/0x160  ? entry_SYSCALL_64_after_hwframe+0x44/0xa9  After this patch, the trace looks like this:  Call Trace:  __x64_sys_prctl+0x402/0x680  ? __ia32_sys_prctl+0x6e0/0x6e0  ? __do_page_fault+0x457/0x620  do_syscall_64+0x6d/0x160  entry_SYSCALL_64_after_hwframe+0x44/0xa9  prctl_set_seccomp() still doesn't show up in the trace because for some reason, tail call optimization is only disabled in builds that use the frame pointer unwinder.  ",ac5ceccce5501e43d217c596e4ee859f2a3fef79,1
rds: tcp: must use spin_lock_irq* and not spin_lock_bh with rds_tcp_conn_lock,"rds_tcp_connection allocation/free management has the potential to be called from __rds_conn_create after IRQs have been disabled, so spin_[un]lock_bh cannot be used with rds_tcp_conn_lock.  Bottom-halves that need to synchronize for critical sections protected by rds_tcp_conn_lock should instead use rds_destroy_pending() correctly.  ",53d0e83f9329aa51dcc205b514dbee05cb4df309,0
blk-mq: fix use-after-free in blk_mq_exit_sched,"tagset can't be used after blk_cleanup_queue() is returned because freeing tagset usually follows blk_clenup_queue(). Commit d97e594c5166 (""blk-mq: Use request queue-wide tags for tagset-wide sbitmap"") adds check on q->tag_set->flags in blk_mq_exit_sched(), and causes use-after-free.  Fixes it by using hctx->flags.  ",f0c1c4d2864ed614f90d2da1bab1a1c42907b940,1
xsk: Fix possible crash in socket_release when out-of-memory,"Fix possible crash in socket_release when an out-of-memory error has occurred in the bind call. If a socket using the XDP_SHARED_UMEM flag encountered an error in xp_create_and_assign_umem, the bind code jumped to the exit routine but erroneously forgot to set the err value before jumping. This meant that the exit routine thought the setup went well and set the state of the socket to XSK_BOUND. The xsk socket release code will then, at application exit, think that this is a properly setup socket, when it is not, leading to a crash when all fields in the socket have in fact not been initialized properly. Fix this by setting the err variable in xsk_bind so that the socket is not set to XSK_BOUND which leads to the clean-up in xsk_release not being triggered.  ",1fd17c8cd0aa636afcf441ee23023b5a7cba4efa,1
staging: rtl8712: fix use-after-free in rtl8712_dl_fw,"Syzbot reported use-after-free in rtl8712_dl_fw(). The problem was in race condition between r871xu_dev_remove() ->ndo_open() callback.  It's easy to see from crash log, that driver accesses released firmware in ->ndo_open() callback. It may happen, since driver was releasing firmware _before_ unregistering netdev. Fix it by moving unregister_netdev() before cleaning up resources.  Call Trace: ...  rtl871x_open_fw drivers/staging/rtl8712/hal_init.c:83 [inline]  rtl8712_dl_fw+0xd95/0xe10 drivers/staging/rtl8712/hal_init.c:170  rtl8712_hal_init drivers/staging/rtl8712/hal_init.c:330 [inline]  rtl871x_hal_init+0xae/0x180 drivers/staging/rtl8712/hal_init.c:394  netdev_open+0xe6/0x6c0 drivers/staging/rtl8712/os_intfs.c:380  __dev_open+0x2bc/0x4d0 net/core/dev.c:1484  Freed by task 1306: ...  release_firmware+0x1b/0x30 drivers/base/firmware_loader/main.c:1053  r871xu_dev_remove+0xcc/0x2c0 drivers/staging/rtl8712/usb_intf.c:599  usb_unbind_interface+0x1d8/0x8d0 drivers/usb/core/driver.c:458  ",c052cc1a069c3e575619cf64ec427eb41176ca70,1
KVM: VMX: Fix rflags cache during vCPU reset,"Reported by syzkaller:     *** Guest State ***    CR0: actual=0x0000000080010031, shadow=0x0000000060000010, gh_mask=fffffffffffffff7    CR4: actual=0x0000000000002061, shadow=0x0000000000000000, gh_mask=ffffffffffffe8f1    CR3 = 0x000000002081e000    RSP = 0x000000000000fffa  RIP = 0x0000000000000000    RFLAGS=0x00023000         DR7 = 0x00000000000000           ^^^^^^^^^^    ",c37c28730bb031cc8a44a130c2555c0f3efbe2d0,1
"bpf: sockmap/tls, close can race with map free","When a map free is called and in parallel a socket is closed we have two paths that can potentially reset the socket prot ops, the bpf close() path and the map free path. This creates a problem with which prot ops should be used from the socket closed side.  If the map_free side completes first then we want to call the original lowest level ops. However, if the tls path runs first we want to call the sockmap ops. Additionally there was no locking around prot updates in TLS code paths so the prot ops could be changed multiple times once from TLS path and again from sockmap side potentially leaving ops pointed at either TLS or sockmap when psock and/or tls context have already been destroyed.  To fix this race first only update ops inside callback lock so that TLS, sockmap and lowest level all agree on prot state. Second and a ULP callback update() so that lower layers can inform the upper layer when they are being removed allowing the upper layer to reset prot ops.  This gets us close to allowing sockmap and tls to be stacked in arbitrary order but will save that patch for *next trees.  v4:  - make sure we don't free things for device;  - remove the checks which swap the callbacks back    only if TLS is at the top.  ",95fa145479fbc0a0c1fd3274ceb42ec03c042a4a,1
block: allow for_each_bvec to support zero len bvec,"Block layer usually doesn't support or allow zero-length bvec. Since commit 1bdc76aea115 (""iov_iter: use bvec iterator to implement iterate_bvec()""), iterate_bvec() switches to bvec iterator. However, Al mentioned that 'Zero-length segments are not disallowed' in iov_iter.  Fixes for_each_bvec() so that it can move on after seeing one zero length bvec.  ",7e24969022cbd61ddc586f14824fc205661bb124,0
bpf: Fix use-after-free of bpf_link when priming half-fails,"If bpf_link_prime() succeeds to allocate new anon file, but then fails to allocate ID for it, link priming is considered to be failed and user is supposed ot be able to directly kfree() bpf_link, because it was never exposed to user-space.  But at that point file already keeps a pointer to bpf_link and will eventually call bpf_link_release(), so if bpf_link was kfree()'d by caller, that would lead to use-after-free.  Fix this by first allocating ID and only then allocating file. Adding ID to link_idr is ok, because link at that point still doesn't have its ID set, so no user-space process can create a new FD for it.  ",138c67677ff5ac0bce7131033c39d52a81e87a60,1
KVM: coalesced_mmio: add bounds checking,The first/last indexes are typically shared with a user app. The app can change the 'last' index that the kernel uses to store the next result.  This change sanity checks the index before using it for writing to a potentially arbitrary address.  This fixes CVE-2019-14821.  ,b60fe990c6b07ef6d4df67bc0530c7c90a62623a,1
Make sure nd->path.mnt and nd->path.dentry are always valid pointers,"Initialize them in set_nameidata() and make sure that terminate_walk() clears them once the pointers become potentially invalid (i.e. we leave RCU mode or drop them in non-RCU one).  Currently we have ""path_init() always initializes them and nobody accesses them outside of path_init()/terminate_walk() segments"", which is asking for trouble.  With that change we would have nd->path.{mnt,dentry} 	1) always valid - NULL or pointing to currently allocated objects. 	2) non-NULL while we are successfully walking 	3) NULL when we are not walking at all 	4) contributing to refcounts whenever non-NULL outside of RCU mode.  ",7d01ef7585c07afaf487759a48486228cd065726,0
rxrpc: Fix clearance of Tx/Rx ring when releasing a call,"At the end of rxrpc_release_call(), rxrpc_cleanup_ring() is called to clear the Rx/Tx skbuff ring, but this doesn't lock the ring whilst it's accessing it.  Unfortunately, rxrpc_resend() might be trying to retransmit a packet concurrently with this - and whilst it does lock the ring, this isn't protection against rxrpc_cleanup_call().  Fix this by removing the call to rxrpc_cleanup_ring() from rxrpc_release_call().  rxrpc_cleanup_ring() will be called again anyway from rxrpc_cleanup_call().  The earlier call is just an optimisation to recycle skbuffs more quickly.  Alternative solutions include rxrpc_release_call() could try to cancel the work item or wait for it to complete or rxrpc_cleanup_ring() could lock when accessing the ring (which would require a bh lock).  This can produce a report like the following:    BUG: KASAN: use-after-free in rxrpc_send_data_packet+0x19b4/0x1e70 net/rxrpc/output.c:372   Read of size 4 at addr ffff888011606e04 by task kworker/0:0/5   ...   Workqueue: krxrpcd rxrpc_process_call   Call Trace:    ...    kasan_report.cold+0x79/0xd5 mm/kasan/report.c:413    rxrpc_send_data_packet+0x19b4/0x1e70 net/rxrpc/output.c:372    rxrpc_resend net/rxrpc/call_event.c:266 [inline]    rxrpc_process_call+0x1634/0x1f60 net/rxrpc/call_event.c:412    process_one_work+0x98d/0x15f0 kernel/workqueue.c:2275    ...    Allocated by task 2318:    ...    sock_alloc_send_pskb+0x793/0x920 net/core/sock.c:2348    rxrpc_send_data+0xb51/0x2bf0 net/rxrpc/sendmsg.c:358    rxrpc_do_sendmsg+0xc03/0x1350 net/rxrpc/sendmsg.c:744    rxrpc_sendmsg+0x420/0x630 net/rxrpc/af_rxrpc.c:560    ...    Freed by task 2318:    ...    kfree_skb+0x140/0x3f0 net/core/skbuff.c:704    rxrpc_free_skb+0x11d/0x150 net/rxrpc/skbuff.c:78    rxrpc_cleanup_ring net/rxrpc/call_object.c:485 [inline]    rxrpc_release_call+0x5dd/0x860 net/rxrpc/call_object.c:552    rxrpc_release_calls_on_socket+0x21c/0x300 net/rxrpc/call_object.c:579    rxrpc_release_sock net/rxrpc/af_rxrpc.c:885 [inline]    rxrpc_release+0x263/0x5a0 net/rxrpc/af_rxrpc.c:916    __sock_release+0xcd/0x280 net/socket.c:597    ...    The buggy address belongs to the object at ffff888011606dc0    which belongs to the cache skbuff_head_cache of size 232  ",7b5eab57cac45e270a0ad624ba157c5b30b3d44d,1
Bluetooth: initialize skb_queue_head at l2cap_chan_create(),"syzbot is hitting ""INFO: trying to register non-static key."" message [1], for ""struct l2cap_chan""->tx_q.lock spinlock is not yet initialized when l2cap_chan_del() is called due to e.g. timeout.  Since ""struct l2cap_chan""->lock mutex is initialized at l2cap_chan_create() immediately after ""struct l2cap_chan"" is allocated using kzalloc(), let's as well initialize ""struct l2cap_chan""->{tx_q,srej_q}.lock spinlocks there.  [1] https://syzkaller.appspot.com/bug?extid=fadfba6a911f6bf71842  ",be8597239379f0f53c9710dd6ab551bbf535bec6,1
net: sched: prevent invalid Scell_log shift count,Check Scell_log shift size in red_check_params() and modify all callers of red_check_params() to pass Scell_log.  This prevents a shift out-of-bounds as detected by UBSAN:   UBSAN: shift-out-of-bounds in ./include/net/red.h:252:22   shift exponent 72 is too large for 32-bit type 'int'  ,bd1248f1ddbc48b0c30565fce897a3b6423313b8,1
mptcp: update rtx timeout only if required.,"We must start the retransmission timer only there are pending data in the rtx queue. Otherwise we can hit a WARN_ON in mptcp_reset_timer(), as syzbot demonstrated.  ",b680a214ec281dbd44b5ebbf3f126a57f1ecf0f7,0
"io_uring: io_wq_create() returns an error pointer, not NULL","syzbot reported an issue where we crash at setup time if failslab is used. The issue is that io_wq_create() returns an error pointer on failure, not NULL. Hence io_uring thought the io-wq was setup just fine, but in reality it's a garbage error pointer.  Use IS_ERR() instead of a NULL check, and assign ret appropriately.  ",975c99a570967dd48e917dd7853867fee3febabd,1
"Revert ""netns: don't disable BHs when locking ""nsid_lock""""","This reverts commit 8d7e5dee972f1cde2ba96c621f1541fa36e7d4f4.  To protect netns id, the nsid_lock is used when netns id is being allocated and removed by peernet2id_alloc() and unhash_nsid(). The nsid_lock can be used in BH context but only spin_lock() is used in this code. Using spin_lock() instead of spin_lock_bh() can result in a deadlock in the following scenario reported by the lockdep. In order to avoid a deadlock, the spin_lock_bh() should be used instead of spin_lock() to acquire nsid_lock.  Test commands:     ip netns del nst     ip netns add nst     ip link add veth1 type veth peer name veth2     ip link set veth1 netns nst     ip netns exec nst ip link add name br1 type bridge vlan_filtering 1     ip netns exec nst ip link set dev br1 up     ip netns exec nst ip link set dev veth1 master br1     ip netns exec nst ip link set dev veth1 up     ip netns exec nst ip link add macvlan0 link br1 up type macvlan  Splat looks like: ",e1f469cd5866499ac40bfdca87411e1c525a10c7,0
RDMA: Fix software RDMA drivers for dma mapping error,"The commit f959dcd6ddfd (""dma-direct: Fix potential NULL pointer dereference"") made dma_mask as mandetory field to be setup even for dma_virt_ops based dma devices. The commit in the fixes tag omitted setting up the dma_mask on virtual devices triggering the below trace when they were combined during the merge window.  Fix it by setting empty DMA MASK for software based RDMA devices.    ",683a9c7ed81769b6ecb6229afb00b6cda8e4bcfb,1
batman-adv: Avoid WARN_ON timing related checks,The soft/batadv interface for a queued OGM can be changed during the time the OGM was queued for transmission and when the OGM is actually transmitted by the worker.  But WARN_ON must be used to denote kernel bugs and not to print simple warnings. A warning can simply be printed using pr_warn.  ,9f460ae31c4435fd022c443a6029352217a16ac1,0
x86/kexec: Avoid double free_page() upon do_kexec_load() failure,">From ff82bedd3e12f0d3353282054ae48c3bd8c72012 Mon Sep 17 00:00:00 2001 From: Tetsuo Handa <penguin-kernel@I-love.SAKURA.ne.jp> Date: Wed, 9 May 2018 12:12:39 +0900 Subject: [PATCH v3] x86/kexec: avoid double free_page() upon do_kexec_load() failure.  syzbot is reporting crashes after memory allocation failure inside do_kexec_load() [1]. This is because free_transition_pgtable() is called by both init_transition_pgtable() and machine_kexec_cleanup() when memory allocation failed inside init_transition_pgtable().  Regarding 32bit code, machine_kexec_free_page_tables() is called by both machine_kexec_alloc_page_tables() and machine_kexec_cleanup() when memory allocation failed inside machine_kexec_alloc_page_tables().  Fix this by leaving the error handling to machine_kexec_cleanup() (and optionally setting NULL after free_page()).  [1] https://syzkaller.appspot.com/bug?id=91e52396168cf2bdd572fe1e1bc0bc645c1c6b40  ",a466ef76b815b86748d9870ef2a430af7b39c710,1
fix cgroup_do_mount() handling of failure exits,"same story as with last May fixes in sysfs (7b745a4e4051 ""unfuck sysfs_mount()""); new_sb is left uninitialized in case of early errors in kernfs_mount_ns() and papering over it by treating any error from kernfs_mount_ns() as equivalent to !new_ns ends up conflating the cases when objects had never been transferred to a superblock with ones when that has happened and resulting new superblock had been dropped.  Easily fixed (same way as in sysfs case).  Additionally, there's a superblock leak on kernfs_node_dentry() failure *and* a dentry leak inside kernfs_node_dentry() itself - the latter on probably impossible errors, but the former not impossible to trigger (as the matter of fact, injecting allocation failures at that point *does* trigger it).  ",399504e21a10be16dd1408ba0147367d9d82a10c,1
drivers: net: fix memory leak in peak_usb_create_dev,"syzbot reported memory leak in peak_usb. The problem was in case of failure after calling ->dev_init()[2] in peak_usb_create_dev()[1]. The data allocated int dev_init() wasn't freed, so simple ->dev_free() call fix this problem.  backtrace:     [<0000000079d6542a>] kmalloc include/linux/slab.h:552 [inline]     [<0000000079d6542a>] kzalloc include/linux/slab.h:682 [inline]     [<0000000079d6542a>] pcan_usb_fd_init+0x156/0x210 drivers/net/can/usb/peak_usb/pcan_usb_fd.c:868   [2]     [<00000000c09f9057>] peak_usb_create_dev drivers/net/can/usb/peak_usb/pcan_usb_core.c:851 [inline] [1]     [<00000000c09f9057>] peak_usb_probe+0x389/0x490 drivers/net/can/usb/peak_usb/pcan_usb_core.c:949  ",a0b96b4a62745397aee662670cfc2157bac03f55,1
llc: do not use sk_eat_skb(),"syzkaller triggered a use-after-free [1], caused by a combination of skb_get() in llc_conn_state_process() and usage of sk_eat_skb()  sk_eat_skb() is assuming the skb about to be freed is only used by the current thread. TCP/DCCP stacks enforce this because current thread holds the socket lock.  llc_conn_state_process() wants to make sure skb does not disappear, and holds a reference on the skb it manipulates. But as soon as this skb is added to socket receive queue, another thread can consume it.  This means that llc must use regular skb_unlink() and kfree_skb() so that both producer and consumer can safely work on the same skb.  [1] BUG: KASAN: use-after-free in atomic_read include/asm-generic/atomic-instrumented.h:21 [inline] BUG: KASAN: use-after-free in refcount_read include/linux/refcount.h:43 [inline] BUG: KASAN: use-after-free in skb_unref include/linux/skbuff.h:967 [inline] BUG: KASAN: use-after-free in kfree_skb+0xb7/0x580 net/core/skbuff.c:655 Read of size 4 at addr ffff8801d1f6fba4 by task ksoftirqd/1/18  CPU: 1 PID: 18 Comm: ksoftirqd/1 Not tainted 4.19.0-rc8+ #295 Hardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 01/01/2011 Call Trace:  __dump_stack lib/dump_stack.c:77 [inline]  dump_stack+0x1c4/0x2b6 lib/dump_stack.c:113  print_address_description.cold.8+0x9/0x1ff mm/kasan/report.c:256  kasan_report_error mm/kasan/report.c:354 [inline]  kasan_report.cold.9+0x242/0x309 mm/kasan/report.c:412  check_memory_region_inline mm/kasan/kasan.c:260 [inline]  check_memory_region+0x13e/0x1b0 mm/kasan/kasan.c:267  kasan_check_read+0x11/0x20 mm/kasan/kasan.c:272  atomic_read include/asm-generic/atomic-instrumented.h:21 [inline]  refcount_read include/linux/refcount.h:43 [inline]  skb_unref include/linux/skbuff.h:967 [inline]  kfree_skb+0xb7/0x580 net/core/skbuff.c:655  llc_sap_state_process+0x9b/0x550 net/llc/llc_sap.c:224  llc_sap_rcv+0x156/0x1f0 net/llc/llc_sap.c:297  llc_sap_handler+0x65e/0xf80 net/llc/llc_sap.c:438  llc_rcv+0x79e/0xe20 net/llc/llc_input.c:208  __netif_receive_skb_one_core+0x14d/0x200 net/core/dev.c:4913  __netif_receive_skb+0x2c/0x1e0 net/core/dev.c:5023  process_backlog+0x218/0x6f0 net/core/dev.c:5829  napi_poll net/core/dev.c:6249 [inline]  net_rx_action+0x7c5/0x1950 net/core/dev.c:6315  __do_softirq+0x30c/0xb03 kernel/softirq.c:292  run_ksoftirqd+0x94/0x100 kernel/softirq.c:653  smpboot_thread_fn+0x68b/0xa00 kernel/smpboot.c:164  kthread+0x35a/0x420 kernel/kthread.c:246  ret_from_fork+0x3a/0x50 arch/x86/entry/entry_64.S:413  Allocated by task 18:  save_stack+0x43/0xd0 mm/kasan/kasan.c:448  set_track mm/kasan/kasan.c:460 [inline]  kasan_kmalloc+0xc7/0xe0 mm/kasan/kasan.c:553  kasan_slab_alloc+0x12/0x20 mm/kasan/kasan.c:490  kmem_cache_alloc_node+0x144/0x730 mm/slab.c:3644  __alloc_skb+0x119/0x770 net/core/skbuff.c:193  alloc_skb include/linux/skbuff.h:995 [inline]  llc_alloc_frame+0xbc/0x370 net/llc/llc_sap.c:54  llc_station_ac_send_xid_r net/llc/llc_station.c:52 [inline]  llc_station_rcv+0x1dc/0x1420 net/llc/llc_station.c:111  llc_rcv+0xc32/0xe20 net/llc/llc_input.c:220  __netif_receive_skb_one_core+0x14d/0x200 net/core/dev.c:4913  __netif_receive_skb+0x2c/0x1e0 net/core/dev.c:5023  process_backlog+0x218/0x6f0 net/core/dev.c:5829  napi_poll net/core/dev.c:6249 [inline]  net_rx_action+0x7c5/0x1950 net/core/dev.c:6315  __do_softirq+0x30c/0xb03 kernel/softirq.c:292  Freed by task 16383:  save_stack+0x43/0xd0 mm/kasan/kasan.c:448  set_track mm/kasan/kasan.c:460 [inline]  __kasan_slab_free+0x102/0x150 mm/kasan/kasan.c:521  kasan_slab_free+0xe/0x10 mm/kasan/kasan.c:528  __cache_free mm/slab.c:3498 [inline]  kmem_cache_free+0x83/0x290 mm/slab.c:3756  kfree_skbmem+0x154/0x230 net/core/skbuff.c:582  __kfree_skb+0x1d/0x20 net/core/skbuff.c:642  sk_eat_skb include/net/sock.h:2366 [inline]  llc_ui_recvmsg+0xec2/0x1610 net/llc/af_llc.c:882  sock_recvmsg_nosec net/socket.c:794 [inline]  sock_recvmsg+0xd0/0x110 net/socket.c:801  ___sys_recvmsg+0x2b6/0x680 net/socket.c:2278  __sys_recvmmsg+0x303/0xb90 net/socket.c:2390  do_sys_recvmmsg+0x181/0x1a0 net/socket.c:2466  __do_sys_recvmmsg net/socket.c:2484 [inline]  __se_sys_recvmmsg net/socket.c:2480 [inline]  __x64_sys_recvmmsg+0xbe/0x150 net/socket.c:2480  do_syscall_64+0x1b9/0x820 arch/x86/entry/common.c:290  entry_SYSCALL_64_after_hwframe+0x49/0xbe  The buggy address belongs to the object at ffff8801d1f6fac0  which belongs to the cache skbuff_head_cache of size 232 The buggy address is located 228 bytes inside of  232-byte region [ffff8801d1f6fac0, ffff8801d1f6fba8) The buggy address belongs to the page: page:ffffea000747dbc0 count:1 mapcount:0 mapping:ffff8801d9be7680 index:0xffff8801d1f6fe80 flags: 0x2fffc0000000100(slab) raw: 02fffc0000000100 ffffea0007346e88 ffffea000705b108 ffff8801d9be7680 raw: ffff8801d1f6fe80 ffff8801d1f6f0c0 000000010000000b 0000000000000000 page dumped because: kasan: bad access detected  Memory state around the buggy ",604d415e2bd642b7e02c80e719e0396b9d4a77a6,1
KVM: VMX: Fix vmx->nested freeing when no SMI handler,Reported by syzkaller:     ,b74558259c5149e5edd79348b70eb34177cbeea0,1
kcov: check kcov_softirq in kcov_remote_stop(),"kcov_remote_stop() should check that the corresponding kcov_remote_start() actually found the specified remote handle and started collecting coverage.  This is done by checking the per thread kcov_softirq flag.  A particular failure scenario where this was observed involved a softirq with a remote coverage collection section coming between check_kcov_mode() and the access to t->kcov_area in __sanitizer_cov_trace_pc().  In that softirq kcov_remote_start() bailed out after kcov_remote_find() check, but the matching kcov_remote_stop() didn't check if kcov_remote_start() succeeded, and overwrote per thread kcov parameters with invalid (zero) values.  ",3021e69219e2f3df6d01243000db32d1325cdd0d,0
KVM: VMX: check nested state and CR4.VMXE against SMM,"VMX cannot be enabled under SMM, check it when CR4 is set and when nested virtualization state is restored.  This should fix some WARNs reported by syzkaller, mostly around alloc_shadow_vmcs.  ",5bea5123cbf08f990a1aee8f08c643a272e06a0f,1
nfsd: fix dentry leak upon mkdir failure.,syzbot is reporting that nfsd_mkdir() forgot to remove dentry created by d_alloc_name() when __nfsd_mkdir() failed (due to memory allocation fault injection) [1].  [1] https://syzkaller.appspot.com/bug?id=ce41a1f769ea4637ebffedf004a803e8405b4674  ,d6846bfbeeac873d85f32bd2b988fa94c89dbcb8,1
llc: make sure applications use ARPHRD_ETHER,"syzbot was to trigger a bug by tricking AF_LLC with non sensible addr->sllc_arphrd  It seems clear LLC requires an Ethernet device.  Back in commit abf9d537fea2 (""llc: add support for SO_BINDTODEVICE"") Octavian Purdila added possibility for application to use a zero value for sllc_arphrd, convert it to ARPHRD_ETHER to not cause regressions on existing applications.  BUG: KASAN: use-after-free in __read_once_size include/linux/compiler.h:199 [inline] BUG: KASAN: use-after-free in list_empty include/linux/list.h:268 [inline] BUG: KASAN: use-after-free in waitqueue_active include/linux/wait.h:126 [inline] BUG: KASAN: use-after-free in wq_has_sleeper include/linux/wait.h:160 [inline] BUG: KASAN: use-after-free in skwq_has_sleeper include/net/sock.h:2092 [inline] BUG: KASAN: use-after-free in sock_def_write_space+0x642/0x670 net/core/sock.c:2813 Read of size 8 at addr ffff88801e0b4078 by task ksoftirqd/3/27  CPU: 3 PID: 27 Comm: ksoftirqd/3 Not tainted 5.5.0-rc1-syzkaller #0 Hardware name: QEMU Standard PC (Q35 + ICH9, 2009), BIOS rel-1.12.0-59-gc9ba5276e321-prebuilt.qemu.org 04/01/2014 Call Trace:  __dump_stack lib/dump_stack.c:77 [inline]  dump_stack+0x197/0x210 lib/dump_stack.c:118  print_address_description.constprop.0.cold+0xd4/0x30b mm/kasan/report.c:374  __kasan_report.cold+0x1b/0x41 mm/kasan/report.c:506  kasan_report+0x12/0x20 mm/kasan/common.c:639  __asan_report_load8_noabort+0x14/0x20 mm/kasan/generic_report.c:135  __read_once_size include/linux/compiler.h:199 [inline]  list_empty include/linux/list.h:268 [inline]  waitqueue_active include/linux/wait.h:126 [inline]  wq_has_sleeper include/linux/wait.h:160 [inline]  skwq_has_sleeper include/net/sock.h:2092 [inline]  sock_def_write_space+0x642/0x670 net/core/sock.c:2813  sock_wfree+0x1e1/0x260 net/core/sock.c:1958  skb_release_head_state+0xeb/0x260 net/core/skbuff.c:652  skb_release_all+0x16/0x60 net/core/skbuff.c:663  __kfree_skb net/core/skbuff.c:679 [inline]  consume_skb net/core/skbuff.c:838 [inline]  consume_skb+0xfb/0x410 net/core/skbuff.c:832  __dev_kfree_skb_any+0xa4/0xd0 net/core/dev.c:2967  dev_kfree_skb_any include/linux/netdevice.h:3650 [inline]  e1000_unmap_and_free_tx_resource.isra.0+0x21b/0x3a0 drivers/net/ethernet/intel/e1000/e1000_main.c:1963  e1000_clean_tx_irq drivers/net/ethernet/intel/e1000/e1000_main.c:3854 [inline]  e1000_clean+0x4cc/0x1d10 drivers/net/ethernet/intel/e1000/e1000_main.c:3796  napi_poll net/core/dev.c:6532 [inline]  net_rx_action+0x508/0x1120 net/core/dev.c:6600  __do_softirq+0x262/0x98c kernel/softirq.c:292  run_ksoftirqd kernel/softirq.c:603 [inline]  run_ksoftirqd+0x8e/0x110 kernel/softirq.c:595  smpboot_thread_fn+0x6a3/0xa40 kernel/smpboot.c:165  kthread+0x361/0x430 kernel/kthread.c:255  ret_from_fork+0x24/0x30 arch/x86/entry/entry_64.S:352  Allocated by task 8247:  save_stack+0x23/0x90 mm/kasan/common.c:72  set_track mm/kasan/common.c:80 [inline]  __kasan_kmalloc mm/kasan/common.c:513 [inline]  __kasan_kmalloc.constprop.0+0xcf/0xe0 mm/kasan/common.c:486  kasan_slab_alloc+0xf/0x20 mm/kasan/common.c:521  slab_post_alloc_hook mm/slab.h:584 [inline]  slab_alloc mm/slab.c:3320 [inline]  kmem_cache_alloc+0x121/0x710 mm/slab.c:3484  sock_alloc_inode+0x1c/0x1d0 net/socket.c:240  alloc_inode+0x68/0x1e0 fs/inode.c:230  new_inode_pseudo+0x19/0xf0 fs/inode.c:919  sock_alloc+0x41/0x270 net/socket.c:560  __sock_create+0xc2/0x730 net/socket.c:1384  sock_create net/socket.c:1471 [inline]  __sys_socket+0x103/0x220 net/socket.c:1513  __do_sys_socket net/socket.c:1522 [inline]  __se_sys_socket net/socket.c:1520 [inline]  __ia32_sys_socket+0x73/0xb0 net/socket.c:1520  do_syscall_32_irqs_on arch/x86/entry/common.c:337 [inline]  do_fast_syscall_32+0x27b/0xe16 arch/x86/entry/common.c:408  entry_SYSENTER_compat+0x70/0x7f arch/x86/entry/entry_64_compat.S:139  Freed by task 17:  save_stack+0x23/0x90 mm/kasan/common.c:72  set_track mm/kasan/common.c:80 [inline]  kasan_set_free_info mm/kasan/common.c:335 [inline]  __kasan_slab_free+0x102/0x150 mm/kasan/common.c:474  kasan_slab_free+0xe/0x10 mm/kasan/common.c:483  __cache_free mm/slab.c:3426 [inline]  kmem_cache_free+0x86/0x320 mm/slab.c:3694  sock_free_inode+0x20/0x30 net/socket.c:261  i_callback+0x44/0x80 fs/inode.c:219  __rcu_reclaim kernel/rcu/rcu.h:222 [inline]  rcu_do_batch kernel/rcu/tree.c:2183 [inline]  rcu_core+0x570/0x1540 kernel/rcu/tree.c:2408  rcu_core_si+0x9/0x10 kernel/rcu/tree.c:2417  __do_softirq+0x262/0x98c kernel/softirq.c:292  The buggy address belongs to the object at ffff88801e0b4000  which belongs to the cache sock_inode_cache of size 1152 The buggy address is located 120 bytes inside of  1152-byte region [ffff88801e0b4000, ffff88801e0b4480) The buggy address belongs to the page: page:ffffea0000782d00 refcount:1 mapcount:0 mapping:ffff88807aa59c40 index:0xffff88801e0b4ffd raw: 00fffe0000000200 ffffea00008e6c88 ffffea0000782d48 ffff88807aa59c40 raw: ffff88801e0b4ffd ffff88801e0b4000 0000000100000003 0000000000000000 page dumped because: kasan: bad access detected  Memory state around the buggy ",a9b1110162357689a34992d5c925852948e5b9fd,1
tty: vt: keyboard: reject invalid keycodes,"Do not try to handle keycodes that are too big, otherwise we risk doing out-of-bounds writes:  BUG: KASAN: global-out-of-bounds in clear_bit include/asm-generic/bitops-instrumented.h:56 [inline] BUG: KASAN: global-out-of-bounds in kbd_keycode drivers/tty/vt/keyboard.c:1411 [inline] BUG: KASAN: global-out-of-bounds in kbd_event+0xe6b/0x3790 drivers/tty/vt/keyboard.c:1495 Write of size 8 at addr ffffffff89a1b2d8 by task syz-executor108/1722 ...  kbd_keycode drivers/tty/vt/keyboard.c:1411 [inline]  kbd_event+0xe6b/0x3790 drivers/tty/vt/keyboard.c:1495  input_to_handler+0x3b6/0x4c0 drivers/input/input.c:118  input_pass_values.part.0+0x2e3/0x720 drivers/input/input.c:145  input_pass_values drivers/input/input.c:949 [inline]  input_set_keycode+0x290/0x320 drivers/input/input.c:954  evdev_handle_set_keycode_v2+0xc4/0x120 drivers/input/evdev.c:882  evdev_do_ioctl drivers/input/evdev.c:1150 [inline]  In this case we were dealing with a fuzzed HID device that declared over 12K buttons, and while HID layer should not be reporting to us such big keycodes, we should also be defensive and reject invalid data ourselves as well.  ",b2b2dd71e0859436d4e05b2f61f86140250ed3f8,1
tick/sched: Annotate lockless access to last_jiffies_update,"syzbot (KCSAN) reported a data-race in tick_do_update_jiffies64():  BUG: KCSAN: data-race in tick_do_update_jiffies64 / tick_do_update_jiffies64  write to 0xffffffff8603d008 of 8 bytes by interrupt on cpu 1:  tick_do_update_jiffies64+0x100/0x250 kernel/time/tick-sched.c:73  tick_sched_do_timer+0xd4/0xe0 kernel/time/tick-sched.c:138  tick_sched_timer+0x43/0xe0 kernel/time/tick-sched.c:1292  __run_hrtimer kernel/time/hrtimer.c:1514 [inline]  __hrtimer_run_queues+0x274/0x5f0 kernel/time/hrtimer.c:1576  hrtimer_interrupt+0x22a/0x480 kernel/time/hrtimer.c:1638  local_apic_timer_interrupt arch/x86/kernel/apic/apic.c:1110 [inline]  smp_apic_timer_interrupt+0xdc/0x280 arch/x86/kernel/apic/apic.c:1135  apic_timer_interrupt+0xf/0x20 arch/x86/entry/entry_64.S:830  arch_local_irq_restore arch/x86/include/asm/paravirt.h:756 [inline]  kcsan_setup_watchpoint+0x1d4/0x460 kernel/kcsan/core.c:436  check_access kernel/kcsan/core.c:466 [inline]  __tsan_read1 kernel/kcsan/core.c:593 [inline]  __tsan_read1+0xc2/0x100 kernel/kcsan/core.c:593  kallsyms_expand_symbol.constprop.0+0x70/0x160 kernel/kallsyms.c:79  kallsyms_lookup_name+0x7f/0x120 kernel/kallsyms.c:170  insert_report_filterlist kernel/kcsan/debugfs.c:155 [inline]  debugfs_write+0x14b/0x2d0 kernel/kcsan/debugfs.c:256  full_proxy_write+0xbd/0x100 fs/debugfs/file.c:225  __vfs_write+0x67/0xc0 fs/read_write.c:494  vfs_write fs/read_write.c:558 [inline]  vfs_write+0x18a/0x390 fs/read_write.c:542  ksys_write+0xd5/0x1b0 fs/read_write.c:611  __do_sys_write fs/read_write.c:623 [inline]  __se_sys_write fs/read_write.c:620 [inline]  __x64_sys_write+0x4c/0x60 fs/read_write.c:620  do_syscall_64+0xcc/0x370 arch/x86/entry/common.c:290  entry_SYSCALL_64_after_hwframe+0x44/0xa9  read to 0xffffffff8603d008 of 8 bytes by task 0 on cpu 0:  tick_do_update_jiffies64+0x2b/0x250 kernel/time/tick-sched.c:62  tick_nohz_update_jiffies kernel/time/tick-sched.c:505 [inline]  tick_nohz_irq_enter kernel/time/tick-sched.c:1257 [inline]  tick_irq_enter+0x139/0x1c0 kernel/time/tick-sched.c:1274  irq_enter+0x4f/0x60 kernel/softirq.c:354  entering_irq arch/x86/include/asm/apic.h:517 [inline]  entering_ack_irq arch/x86/include/asm/apic.h:523 [inline]  smp_apic_timer_interrupt+0x55/0x280 arch/x86/kernel/apic/apic.c:1133  apic_timer_interrupt+0xf/0x20 arch/x86/entry/entry_64.S:830  native_safe_halt+0xe/0x10 arch/x86/include/asm/irqflags.h:60  arch_cpu_idle+0xa/0x10 arch/x86/kernel/process.c:571  default_idle_call+0x1e/0x40 kernel/sched/idle.c:94  cpuidle_idle_call kernel/sched/idle.c:154 [inline]  do_idle+0x1af/0x280 kernel/sched/idle.c:263  cpu_startup_entry+0x1b/0x20 kernel/sched/idle.c:355  rest_init+0xec/0xf6 init/main.c:452  arch_call_rest_init+0x17/0x37  start_kernel+0x838/0x85e init/main.c:786  x86_64_start_reservations+0x29/0x2b arch/x86/kernel/head64.c:490  x86_64_start_kernel+0x72/0x76 arch/x86/kernel/head64.c:471  secondary_startup_64+0xa4/0xb0 arch/x86/kernel/head_64.S:241  Reported by Kernel Concurrency Sanitizer on: CPU: 0 PID: 0 Comm: swapper/0 Not tainted 5.4.0-rc7+ #0 Hardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 01/01/2011  Use READ_ONCE() and WRITE_ONCE() to annotate this expected race.  ",de95a991bb72e009f47e0c4bbc90fc5f594588d5,1
"bpf: sockhash, disallow bpf_tcp_close and update in parallel","After latest lock updates there is no longer anything preventing a close and recvmsg call running in parallel. Additionally, we can race update with close if we close a socket and simultaneously update if via the BPF userspace API (note the cgroup ops are already run with sock_lock held).  To resolve this take sock_lock in close and update paths.  ",99ba2b5aba24e022683a7db63204f9e306fe7ab9,1
virtio-net: correctly update XDP_TX counters,"Commit 5b8f3c8d30a6 (""virtio_net: Add XDP related stats"") tries to count TX XDP stats in virtnet_receive(). This will cause several issues:  - virtnet_xdp_sq() was called without checking whether or not XDP is   set. This may cause out of bound access when there's no enough txq   for XDP. - Stats were updated even if there's no XDP/XDP_TX.  Fixing this by reusing virtnet_xdp_xmit() for XDP_TX which can counts TX XDP counter itself and remove the unnecessary tx stats embedded in rx stats.  ",ca9e83b4a55bfa1cc1395b48c3bf70381833526b,1
fbcon: remove soft scrollback code,"This (and the VGA soft scrollback) turns out to have various nasty small special cases that nobody really is willing to fight.  The soft scrollback code was really useful a few decades ago when you typically used the console interactively as the main way to interact with the machine, but that just isn't the case any more.  So it's not worth dragging along.  ",50145474f6ef4a9c19205b173da6264a644c7489,0
media: imon: invalid dereference in imon_touch_event,"The touch timer is set up in intf1. If the second interface does not exist, the timer and touch input device are not setup and we get the following error, when touch events are reported via intf0.  kernel BUG at kernel/time/timer.c:956! invalid opcode: 0000 [#1] SMP KASAN CPU: 0 PID: 0 Comm: swapper/0 Not tainted 5.4.0-rc1+ #0 Hardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 01/01/2011 ",f3f5ba42c58d56d50f539854d8cc188944e96087,1
ttyprintk: Add TTY hangup callback.,"syzbot is reporting hung task due to flood of    tty_warn(tty, ""%s: tty->count = 1 port count = %d\n"", __func__,            port->count);  message [1], for ioctl(TIOCVHANGUP) prevents tty_port_close() from decrementing port->count due to tty_hung_up_p() == true.  ",c0070e1e60270f6a1e09442a9ab2335f3eaeaad2,0
netfilter: ebtables: handle string from userspace with care,"strlcpy() can't be safely used on a user-space provided string, as it can try to read beyond the buffer's end, if the latter is not NULL terminated.  Leveraging the above, syzbot has been able to trigger the following splat:  BUG: KASAN: stack-out-of-bounds in strlcpy include/linux/string.h:300 [inline] BUG: KASAN: stack-out-of-bounds in compat_mtw_from_user net/bridge/netfilter/ebtables.c:1957 [inline] BUG: KASAN: stack-out-of-bounds in ebt_size_mwt net/bridge/netfilter/ebtables.c:2059 [inline] BUG: KASAN: stack-out-of-bounds in size_entry_mwt net/bridge/netfilter/ebtables.c:2155 [inline] BUG: KASAN: stack-out-of-bounds in compat_copy_entries+0x96c/0x14a0 net/bridge/netfilter/ebtables.c:2194 Write of size 33 at addr ffff8801b0abf888 by task syz-executor0/4504  CPU: 0 PID: 4504 Comm: syz-executor0 Not tainted 4.17.0-rc2+ #40 Hardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 01/01/2011 Call Trace:   __dump_stack lib/dump_stack.c:77 [inline]   dump_stack+0x1b9/0x294 lib/dump_stack.c:113   print_address_description+0x6c/0x20b mm/kasan/report.c:256   kasan_report_error mm/kasan/report.c:354 [inline]   kasan_report.cold.7+0x242/0x2fe mm/kasan/report.c:412   check_memory_region_inline mm/kasan/kasan.c:260 [inline]   check_memory_region+0x13e/0x1b0 mm/kasan/kasan.c:267   memcpy+0x37/0x50 mm/kasan/kasan.c:303   strlcpy include/linux/string.h:300 [inline]   compat_mtw_from_user net/bridge/netfilter/ebtables.c:1957 [inline]   ebt_size_mwt net/bridge/netfilter/ebtables.c:2059 [inline]   size_entry_mwt net/bridge/netfilter/ebtables.c:2155 [inline]   compat_copy_entries+0x96c/0x14a0 net/bridge/netfilter/ebtables.c:2194   compat_do_replace+0x483/0x900 net/bridge/netfilter/ebtables.c:2285   compat_do_ebt_set_ctl+0x2ac/0x324 net/bridge/netfilter/ebtables.c:2367   compat_nf_sockopt net/netfilter/nf_sockopt.c:144 [inline]   compat_nf_setsockopt+0x9b/0x140 net/netfilter/nf_sockopt.c:156   compat_ip_setsockopt+0xff/0x140 net/ipv4/ip_sockglue.c:1279   inet_csk_compat_setsockopt+0x97/0x120 net/ipv4/inet_connection_sock.c:1041   compat_tcp_setsockopt+0x49/0x80 net/ipv4/tcp.c:2901   compat_sock_common_setsockopt+0xb4/0x150 net/core/sock.c:3050   __compat_sys_setsockopt+0x1ab/0x7c0 net/compat.c:403   __do_compat_sys_setsockopt net/compat.c:416 [inline]   __se_compat_sys_setsockopt net/compat.c:413 [inline]   __ia32_compat_sys_setsockopt+0xbd/0x150 net/compat.c:413   do_syscall_32_irqs_on arch/x86/entry/common.c:323 [inline]   do_fast_syscall_32+0x345/0xf9b arch/x86/entry/common.c:394   entry_SYSENTER_compat+0x70/0x7f arch/x86/entry/entry_64_compat.S:139 ",94c752f99954797da583a84c4907ff19e92550a4,1
ip_gre: fix parsing gre header in ipgre_err,"gre_parse_header stops parsing when csum_err is encountered, which means tpi->key is undefined and ip_tunnel_lookup will return NULL improperly.  This patch introduce a NULL pointer as csum_err parameter. Even when csum_err is encountered, it won't return error and continue parsing gre header as expected.  ",b0350d51f001e6edc13ee4f253b98b50b05dd401,0
ttyprintk: fix a potential deadlock in interrupt context issue,"tpk_write()/tpk_close() could be interrupted when holding a mutex, then in timer handler tpk_write() may be called again trying to acquire same mutex, lead to deadlock.  Google syzbot reported this issue with CONFIG_DEBUG_ATOMIC_SLEEP enabled:  BUG: sleeping function called from invalid context at kernel/locking/mutex.c:938 in_atomic(): 1, irqs_disabled(): 0, non_block: 0, pid: 0, name: swapper/1 1 lock held by swapper/1/0: ... Call Trace:   <IRQ>   dump_stack+0x197/0x210   ___might_sleep.cold+0x1fb/0x23e   __might_sleep+0x95/0x190   __mutex_lock+0xc5/0x13c0   mutex_lock_nested+0x16/0x20   tpk_write+0x5d/0x340   resync_tnc+0x1b6/0x320   call_timer_fn+0x1ac/0x780   run_timer_softirq+0x6c3/0x1790   __do_softirq+0x262/0x98c   irq_exit+0x19b/0x1e0   smp_apic_timer_interrupt+0x1a3/0x610   apic_timer_interrupt+0xf/0x20   </IRQ>  See link https://syzkaller.appspot.com/bug?extid=2eeef62ee31f9460ad65 for more details.  Fix it by using spinlock in process context instead of mutex and having interrupt disabled in critical section.  ",9a655c77ff8fc65699a3f98e237db563b37c439b,1
ip6_gre: proper dev_{hold|put} in ndo_[un]init methods,"After adopting CONFIG_PCPU_DEV_REFCNT=n option, syzbot was able to trigger a warning [1]  Issue here is that:  - all dev_put() should be paired with a corresponding dev_hold(),   and vice versa.  - A driver doing a dev_put() in its ndo_uninit() MUST also   do a dev_hold() in its ndo_init(), only when ndo_init()   is returning 0.  Otherwise, register_netdevice() would call ndo_uninit() in its error path and release a refcount too soon.  ip6_gre for example (among others problematic drivers) has to use dev_hold() in ip6gre_tunnel_init_common() instead of from ip6gre_newlink_common(), covering both ip6gre_tunnel_init() and ip6gre_tap_init()/  Note that ip6gre_tunnel_init_common() is not called from ip6erspan_tap_init() thus we also need to add a dev_hold() there, as ip6erspan_tunnel_uninit() does call dev_put()  [1] refcount_t: decrement hit 0; leaking memory. ",7f700334be9aeb91d5d86ef9ad2d901b9b453e9b,0
can: j1939: socket: j1939_sk_bind(): make sure ml_priv is allocated,"This patch adds check to ensure that the struct net_device::ml_priv is allocated, as it is used later by the j1939 stack.  The allocation is done by all mainline CAN network drivers, but when using bond or team devices this is not the case.  Bail out if no ml_priv is allocated.  ",af804b7826350d5af728dca4715e473338fbd7e5,0
fuse: don't increment nlink in link(),The fuse_iget() call in create_new_entry() already updated the inode with all the new attributes and incremented the attribute version.  Incrementing the nlink will result in the wrong count.  This wasn't noticed because the attributes were invalidated right after this.  Updating ctime is still needed for the writeback case when the ctime is not refreshed.  ,97f044f690bac2b094bfb7fb2d177ef946c85880,0
rds: avoid unenecessary cong_update in loop transport,"Loop transport which is self loopback, remote port congestion update isn't relevant. Infact the xmit path already ignores it. Receive path needs to do the same.  ",f1693c63ab133d16994cc50f773982b5905af264,0
bpf: fix numa_node validation,"syzkaller reported crashes in bpf map creation or map update [1]  Problem is that nr_node_ids is a signed integer, NUMA_NO_NODE is also an integer, so it is very tempting to declare numa_node as a signed integer.  This means the typical test to validate a user provided value :          if (numa_node != NUMA_NO_NODE &&             (numa_node >= nr_node_ids ||              !node_online(numa_node)))  must be written :          if (numa_node != NUMA_NO_NODE &&             ((unsigned int)numa_node >= nr_node_ids ||              !node_online(numa_node)))  [1] kernel BUG at mm/slab.c:3256! invalid opcode: 0000 [#1] SMP KASAN Dumping ftrace buffer:    (ftrace buffer empty) ",96e5ae4e76f1ea950d493f510399b49308bea731,1
can: isotp: isotp_getname(): fix kernel information leak,Initialize the sockaddr_can structure to prevent a data leak to user space.  Suggested-by: Cong Wang <xiyou.wangcong@gmail.com> ,b42b3a2744b3e8f427de79896720c72823af91ad,1
net/rds: Check address length before reading address family,syzbot is reporting uninitialized value at rds_connect() [1] and rds_bind() [2]. This is because syzbot is passing ulen == 0 whereas these functions expect that it is safe to access sockaddr->family field in order to determine minimal address length for validation.  [1] https://syzkaller.appspot.com/bug?id=f4e61c010416c1e6f0fa3ffe247561b60a50ad71 [2] https://syzkaller.appspot.com/bug?id=a4bf9e41b7e055c3823fdcd83e8c58ca7270e38f  ,dd3ac9a684358b8c1d5c432ca8322aaf5e4f28ee,1
flow_dissector: disable preemption around BPF calls,"Various things in eBPF really require us to disable preemption before running an eBPF program.  syzbot reported :  BUG: assuming atomic context at net/core/flow_dissector.c:737 in_atomic(): 0, irqs_disabled(): 0, pid: 24710, name: syz-executor.3 2 locks held by syz-executor.3/24710:  #0: 00000000e81a4bf1 (&tfile->napi_mutex){+.+.}, at: tun_get_user+0x168e/0x3ff0 drivers/net/tun.c:1850  #1: 00000000254afebd (rcu_read_lock){....}, at: __skb_flow_dissect+0x1e1/0x4bb0 net/core/flow_dissector.c:822 CPU: 1 PID: 24710 Comm: syz-executor.3 Not tainted 5.1.0+ #6 Hardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 01/01/2011 Call Trace:  __dump_stack lib/dump_stack.c:77 [inline]  dump_stack+0x172/0x1f0 lib/dump_stack.c:113  __cant_sleep kernel/sched/core.c:6165 [inline]  __cant_sleep.cold+0xa3/0xbb kernel/sched/core.c:6142  bpf_flow_dissect+0xfe/0x390 net/core/flow_dissector.c:737  __skb_flow_dissect+0x362/0x4bb0 net/core/flow_dissector.c:853  skb_flow_dissect_flow_keys_basic include/linux/skbuff.h:1322 [inline]  skb_probe_transport_header include/linux/skbuff.h:2500 [inline]  skb_probe_transport_header include/linux/skbuff.h:2493 [inline]  tun_get_user+0x2cfe/0x3ff0 drivers/net/tun.c:1940  tun_chr_write_iter+0xbd/0x156 drivers/net/tun.c:2037  call_write_iter include/linux/fs.h:1872 [inline]  do_iter_readv_writev+0x5fd/0x900 fs/read_write.c:693  do_iter_write fs/read_write.c:970 [inline]  do_iter_write+0x184/0x610 fs/read_write.c:951  vfs_writev+0x1b3/0x2f0 fs/read_write.c:1015  do_writev+0x15b/0x330 fs/read_write.c:1058  __do_sys_writev fs/read_write.c:1131 [inline]  __se_sys_writev fs/read_write.c:1128 [inline]  __x64_sys_writev+0x75/0xb0 fs/read_write.c:1128  do_syscall_64+0x103/0x670 arch/x86/entry/common.c:298  entry_SYSCALL_64_after_hwframe+0x49/0xbe  ",b1c17a9a353878602fd5bfe9103e4afe5e9a3f96,1
ax25: fix setsockopt(SO_BINDTODEVICE),"syzbot was able to trigger this trace [1], probably by using a zero optlen.  While we are at it, cap optlen to IFNAMSIZ - 1 instead of IFNAMSIZ.  [1] BUG: KMSAN: uninit-value in strnlen+0xf9/0x170 lib/string.c:569 CPU: 0 PID: 8807 Comm: syz-executor483 Not tainted 5.7.0-rc4-syzkaller #0 Hardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 01/01/2011 Call Trace:  __dump_stack lib/dump_stack.c:77 [inline]  dump_stack+0x1c9/0x220 lib/dump_stack.c:118  kmsan_report+0xf7/0x1e0 mm/kmsan/kmsan_report.c:121  __msan_warning+0x58/0xa0 mm/kmsan/kmsan_instr.c:215  strnlen+0xf9/0x170 lib/string.c:569  dev_name_hash net/core/dev.c:207 [inline]  netdev_name_node_lookup net/core/dev.c:277 [inline]  __dev_get_by_name+0x75/0x2b0 net/core/dev.c:778  ax25_setsockopt+0xfa3/0x1170 net/ax25/af_ax25.c:654  __compat_sys_setsockopt+0x4ed/0x910 net/compat.c:403  __do_compat_sys_setsockopt net/compat.c:413 [inline]  __se_compat_sys_setsockopt+0xdd/0x100 net/compat.c:410  __ia32_compat_sys_setsockopt+0x62/0x80 net/compat.c:410  do_syscall_32_irqs_on arch/x86/entry/common.c:339 [inline]  do_fast_syscall_32+0x3bf/0x6d0 arch/x86/entry/common.c:398  entry_SYSENTER_compat+0x68/0x77 arch/x86/entry/entry_64_compat.S:139 ",687775cec056b38a4c8f3291e0dd7a9145f7b667,1
sch_htb: Fix offload cleanup in htb_destroy on htb_init failure,"htb_init may fail to do the offload if it's not supported or if a runtime error happens when allocating direct qdiscs. In those cases TC_HTB_CREATE command is not sent to the driver, however, htb_destroy gets called anyway and attempts to send TC_HTB_DESTROY.  It shouldn't happen, because the driver didn't receive TC_HTB_CREATE, and also because the driver may not support ndo_setup_tc at all, while q->offload is true, and htb_destroy mistakenly thinks the offload is supported. Trying to call ndo_setup_tc in the latter case will lead to a NULL pointer dereference.  This commit fixes the issues with htb_destroy by deferring assignment of q->offload until after the TC_HTB_CREATE command. The necessary cleanup of the offload entities is already done in htb_init.  ",fb3a3e37de337ec2941c71ff0bcb83e701f3c9f4,1
ptr_ring: use kmalloc_array(),"As found by syzkaller, malicious users can set whatever tx_queue_len on a tun device and eventually crash the kernel.  Lets remove the ALIGN(XXX, SMP_CACHE_BYTES) thing since a small ring buffer is not fast anyway.  ",81fbfe8adaf38d4f5a98c19bebfd41c5d6acaee8,1
netfilter: nf_queue: augment nfqa_cfg_policy,"Three attributes are currently not verified, thus can trigger KMSAN warnings such as :  BUG: KMSAN: uninit-value in __arch_swab32 arch/x86/include/uapi/asm/swab.h:10 [inline] BUG: KMSAN: uninit-value in __fswab32 include/uapi/linux/swab.h:59 [inline] BUG: KMSAN: uninit-value in nfqnl_recv_config+0x939/0x17d0 net/netfilter/nfnetlink_queue.c:1268 CPU: 1 PID: 4521 Comm: syz-executor120 Not tainted 4.17.0+ #5 Hardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 01/01/2011 Call Trace:  __dump_stack lib/dump_stack.c:77 [inline]  dump_stack+0x185/0x1d0 lib/dump_stack.c:113  kmsan_report+0x188/0x2a0 mm/kmsan/kmsan.c:1117  __msan_warning_32+0x70/0xc0 mm/kmsan/kmsan_instr.c:620  __arch_swab32 arch/x86/include/uapi/asm/swab.h:10 [inline]  __fswab32 include/uapi/linux/swab.h:59 [inline]  nfqnl_recv_config+0x939/0x17d0 net/netfilter/nfnetlink_queue.c:1268  nfnetlink_rcv_msg+0xb2e/0xc80 net/netfilter/nfnetlink.c:212  netlink_rcv_skb+0x37e/0x600 net/netlink/af_netlink.c:2448  nfnetlink_rcv+0x2fe/0x680 net/netfilter/nfnetlink.c:513  netlink_unicast_kernel net/netlink/af_netlink.c:1310 [inline]  netlink_unicast+0x1680/0x1750 net/netlink/af_netlink.c:1336  netlink_sendmsg+0x104f/0x1350 net/netlink/af_netlink.c:1901  sock_sendmsg_nosec net/socket.c:629 [inline]  sock_sendmsg net/socket.c:639 [inline]  ___sys_sendmsg+0xec8/0x1320 net/socket.c:2117  __sys_sendmsg net/socket.c:2155 [inline]  __do_sys_sendmsg net/socket.c:2164 [inline]  __se_sys_sendmsg net/socket.c:2162 [inline]  __x64_sys_sendmsg+0x331/0x460 net/socket.c:2162  do_syscall_64+0x15b/0x230 arch/x86/entry/common.c:287  entry_SYSCALL_64_after_hwframe+0x44/0xa9 ",ba062ebb2cd561d404e0fba8ee4b3f5ebce7cbfc,1
mm/oom_kill.c: prevent a race between process_mrelease and exit_mmap,"Race between process_mrelease and exit_mmap, where free_pgtables is called while __oom_reap_task_mm is in progress, leads to kernel crash during pte_offset_map_lock call.  oom-reaper avoids this race by setting MMF_OOM_VICTIM flag and causing exit_mmap to take and release mmap_write_lock, blocking it until oom-reaper releases mmap_read_lock.  Reusing MMF_OOM_VICTIM for process_mrelease would be the simplest way to fix this race, however that would be considered a hack.  Fix this race by elevating mm->mm_users and preventing exit_mmap from executing until process_mrelease is finished.  Patch slightly refactors the code to adapt for a possible mmget_not_zero failure.  This fix has considerable negative impact on process_mrelease performance and will likely need later optimization.  ",337546e83fc7e50917f44846beee936abb9c9f1f,1
net: add annotations on hh->hh_len lockless accesses,"KCSAN reported a data-race [1]  While we can use READ_ONCE() on the read sides, we need to make sure hh->hh_len is written last.  [1]  BUG: KCSAN: data-race in eth_header_cache / neigh_resolve_output  write to 0xffff8880b9dedcb8 of 4 bytes by task 29760 on cpu 0:  eth_header_cache+0xa9/0xd0 net/ethernet/eth.c:247  neigh_hh_init net/core/neighbour.c:1463 [inline]  neigh_resolve_output net/core/neighbour.c:1480 [inline]  neigh_resolve_output+0x415/0x470 net/core/neighbour.c:1470  neigh_output include/net/neighbour.h:511 [inline]  ip6_finish_output2+0x7a2/0xec0 net/ipv6/ip6_output.c:116  __ip6_finish_output net/ipv6/ip6_output.c:142 [inline]  __ip6_finish_output+0x2d7/0x330 net/ipv6/ip6_output.c:127  ip6_finish_output+0x41/0x160 net/ipv6/ip6_output.c:152  NF_HOOK_COND include/linux/netfilter.h:294 [inline]  ip6_output+0xf2/0x280 net/ipv6/ip6_output.c:175  dst_output include/net/dst.h:436 [inline]  NF_HOOK include/linux/netfilter.h:305 [inline]  ndisc_send_skb+0x459/0x5f0 net/ipv6/ndisc.c:505  ndisc_send_ns+0x207/0x430 net/ipv6/ndisc.c:647  rt6_probe_deferred+0x98/0xf0 net/ipv6/route.c:615  process_one_work+0x3d4/0x890 kernel/workqueue.c:2269  worker_thread+0xa0/0x800 kernel/workqueue.c:2415  kthread+0x1d4/0x200 drivers/block/aoe/aoecmd.c:1253  ret_from_fork+0x1f/0x30 arch/x86/entry/entry_64.S:352  read to 0xffff8880b9dedcb8 of 4 bytes by task 29572 on cpu 1:  neigh_resolve_output net/core/neighbour.c:1479 [inline]  neigh_resolve_output+0x113/0x470 net/core/neighbour.c:1470  neigh_output include/net/neighbour.h:511 [inline]  ip6_finish_output2+0x7a2/0xec0 net/ipv6/ip6_output.c:116  __ip6_finish_output net/ipv6/ip6_output.c:142 [inline]  __ip6_finish_output+0x2d7/0x330 net/ipv6/ip6_output.c:127  ip6_finish_output+0x41/0x160 net/ipv6/ip6_output.c:152  NF_HOOK_COND include/linux/netfilter.h:294 [inline]  ip6_output+0xf2/0x280 net/ipv6/ip6_output.c:175  dst_output include/net/dst.h:436 [inline]  NF_HOOK include/linux/netfilter.h:305 [inline]  ndisc_send_skb+0x459/0x5f0 net/ipv6/ndisc.c:505  ndisc_send_ns+0x207/0x430 net/ipv6/ndisc.c:647  rt6_probe_deferred+0x98/0xf0 net/ipv6/route.c:615  process_one_work+0x3d4/0x890 kernel/workqueue.c:2269  worker_thread+0xa0/0x800 kernel/workqueue.c:2415  kthread+0x1d4/0x200 drivers/block/aoe/aoecmd.c:1253  ret_from_fork+0x1f/0x30 arch/x86/entry/entry_64.S:352  Reported by Kernel Concurrency Sanitizer on: CPU: 1 PID: 29572 Comm: kworker/1:4 Not tainted 5.4.0-rc6+ #0 Hardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 01/01/2011 Workqueue: events rt6_probe_deferred  ",c305c6ae79e2ce20c22660ceda94f0d86d639a82,1
hsr: avoid to create proc file after unregister,"When an interface is being deleted, ""/proc/net/dev_snmp6/<interface name>"" is deleted. The function for this is addrconf_ifdown() in the addrconf_notify() and it is called by notification, which is NETDEV_UNREGISTER. But, if NETDEV_CHANGEMTU is triggered after NETDEV_UNREGISTER, this proc file will be created again. This recreated proc file will be deleted by netdev_wati_allrefs(). Before netdev_wait_allrefs() is called, creating a new HSR interface routine can be executed and It tries to create a proc file but it will find an un-deleted proc file. At this point, it warns about it.  To avoid this situation, it can use ->dellink() instead of ->ndo_uninit() to release resources because ->dellink() is called before NETDEV_UNREGISTER. So, a proc file will not be recreated.  Test commands     ip link add dummy0 type dummy     ip link add dummy1 type dummy     ip link set dummy0 mtu 1300      #SHELL1     while :     do         ip link add hsr0 type hsr slave1 dummy0 slave2 dummy1     done      #SHELL2     while :     do         ip link del hsr0     done  Splat looks like: ",de0083c7ed7dba036d1ed6e012157649d45313c8,0
"kfence, kasan: make KFENCE compatible with KASAN","Make KFENCE compatible with KASAN. Currently this helps test KFENCE itself, where KASAN can catch potential corruptions to KFENCE state, or other corruptions that may be a result of freepointer corruptions in the main allocators.  [akpm@linux-foundation.org: merge fixup] [andreyknvl@google.com: untag addresses for KFENCE]    ",2b8305260fb37fc20e13f71e13073304d0a031c8,1
net_sched: fix NULL deref in fifo_set_limit(),"syzbot reported another NULL deref in fifo_set_limit() [1]  I could repro the issue with :  unshare -n tc qd add dev lo root handle 1:0 tbf limit 200000 burst 70000 rate 100Mbit tc qd replace dev lo parent 1:0 pfifo_fast tc qd change dev lo root handle 1:0 tbf limit 300000 burst 70000 rate 100Mbit  pfifo_fast does not have a change() operation. Make fifo_set_limit() more robust about this.  [1] BUG: kernel NULL pointer dereference, ",560ee196fe9e5037e5015e2cdb14b3aecb1cd7dc,1
sctp: free cmd->obj.chunk for the unprocessed SCTP_CMD_REPLY,"This patch is to fix a memleak caused by no place to free cmd->obj.chunk for the unprocessed SCTP_CMD_REPLY. This issue occurs when failing to process a cmd while there're still SCTP_CMD_REPLY cmds on the cmd seq with an allocated chunk in cmd->obj.chunk.  So fix it by freeing cmd->obj.chunk for each SCTP_CMD_REPLY cmd left on the cmd seq when any cmd returns error. While at it, also remove 'nomem' label.  ",be7a7729207797476b6666f046d765bdf9630407,0
block: don't create too many partitions,"Commit a33df75c6328 (""block: use an xarray for disk->part_tbl"") drops the check on max supported number of partitionsr, and allows partition with bigger partition numbers to be added. However, ->bd_partno is defined as u8, so partition index of xarray table may not match with ->bd_partno. Then delete_partition() may delete one unmatched partition, and caused use-after-free.  ",e82fc7855749aa197740a60ef22c492c41ea5d5f,1
blk-mq: Fix a recently introduced regression in blk_mq_realloc_hw_ctxs(),"q->nr_hw_queues must only be updated once it is known that blk_mq_realloc_hw_ctxs() has succeeded. Otherwise it can happen that reallocation fails and that q->nr_hw_queues is larger than the number of allocated hardware queues. This patch fixes the following crash if increasing the number of hardware queues fails:  BUG: KASAN: null-ptr-deref in blk_mq_map_swqueue+0x775/0x810 Write of size 8 at addr 0000000000000118 by task check/977  CPU: 3 PID: 977 Comm: check Not tainted 5.6.0-rc1-dbg+ #8 Hardware name: Bochs Bochs, BIOS Bochs 01/01/2011 Call Trace:  dump_stack+0xa5/0xe6  __kasan_report.cold+0x65/0x99  kasan_report+0x16/0x20  check_memory_region+0x140/0x1b0  memset+0x28/0x40  blk_mq_map_swqueue+0x775/0x810  blk_mq_update_nr_hw_queues+0x468/0x710  nullb_device_submit_queues_store+0xf7/0x1a0 [null_blk]  configfs_write_file+0x1c4/0x250 [configfs]  __vfs_write+0x4c/0x90  vfs_write+0x145/0x2c0  ksys_write+0xd7/0x180  __x64_sys_write+0x47/0x50  do_syscall_64+0x6f/0x2f0  entry_SYSCALL_64_after_hwframe+0x49/0xbe  ",d0930bb8f46b8fb4a7d429c0bf1c91b3ed00a7cf,1
kcm: Only allow TCP sockets to be attached to a KCM mux,TCP sockets for IPv4 and IPv6 that are not listeners or in closed stated are allowed to be attached to a KCM mux.  ,581e7226a5d43f629eb6399a121f85f6a15f81be,0
genetlink: get rid of family->attrbuf,"genl_family_rcv_msg_attrs_parse() reuses the global family->attrbuf when family->parallel_ops is false. However, family->attrbuf is not protected by any lock on the genl_family_rcv_msg_doit() code path.  This leads to several different consequences, one of them is UAF, like the following:  genl_family_rcv_msg_doit():		genl_start(): 					  genl_family_rcv_msg_attrs_parse() 					    attrbuf = family->attrbuf 					    __nlmsg_parse(attrbuf);   genl_family_rcv_msg_attrs_parse()     attrbuf = family->attrbuf     __nlmsg_parse(attrbuf); 					  info->attrs = attrs; 					  cb->data = info;  netlink_unicast_kernel():  consume_skb() 					genl_lock_dumpit(): 					  genl_dumpit_info(cb)->attrs  Note family->attrbuf is an array of pointers to the skb data, once the skb is freed, any dereference of family->attrbuf will be a UAF.  Maybe we could serialize the family->attrbuf with genl_mutex too, but that would make the locking more complicated. Instead, we can just get rid of family->attrbuf and always allocate attrbuf from heap like the family->parallel_ops==true code path. This may add some performance overhead but comparing with taking the global genl_mutex, it still looks better.  ",bf64ff4c2aac65d680dc639a511c781cf6b6ec08,1
iomap: Fix pipe page leakage during splicing,"When splicing using iomap_dio_rw() to a pipe, we may leak pipe pages because bio_iov_iter_get_pages() records that the pipe will have full extent worth of data however if file size is not block size aligned iomap_dio_rw() returns less than what bio_iov_iter_get_pages() set up and splice code gets confused leaking a pipe page with the file tail.  Handle the situation similarly to the old direct IO implementation and revert iter to actually returned read amount which makes iter consistent with value returned from iomap_dio_rw() and thus the splice code is happy.  ",419e9c38aa075ed0cd3c13d47e15954b686bcdb6,0
mptcp: ensure tx skbs always have the MPTCP ext,"Due to signed/unsigned comparison, the expression:  	info->size_goal - skb->len > 0  evaluates to true when the size goal is smaller than the skb size. That results in lack of tx cache refill, so that the skb allocated by the core TCP code lacks the required MPTCP skb extensions.  Due to the above, syzbot is able to trigger the following WARN_ON():  ",efe686ffce0145418b4e004f95c6d0c0200aedd2,0
net/9p/client.c: version pointer uninitialized,"The p9_client_version() does not initialize the version pointer. If the call to p9pdu_readf() returns an error and version has not been allocated in p9pdu_readf(), then the program will jump to the ""error"" label and will try to free the version pointer. If version is not initialized, free() will be called with uninitialized, garbage data and will provoke a crash.  ",7913690dcc5e18e235769fd87c34143072f5dbea,1
ALSA: seq: Break too long mutex context in the write loop,"The fix for the racy writes and ioctls to sequencer widened the application of client->ioctl_mutex to the whole write loop.  Although it does unlock/relock for the lengthy operation like the event dup, the loop keeps the ioctl_mutex for the whole time in other situations.  This may take quite long time if the user-space would give a huge buffer, and this is a likely cause of some weird behavior spotted by syzcaller fuzzer.  This patch puts a simple workaround, just adding a mutex break in the loop when a large number of events have been processed.  This shouldn't hit any performance drop because the threshold is set high enough for usual operations.  ",ede34f397ddb063b145b9e7d79c6026f819ded13,0
random: fix possible sleeping allocation from irq context,We can do a sleeping allocation from an irq context when CONFIG_NUMA is enabled.  Fix this by initializing the NUMA crng instances in a workqueue.  ,6c1e851c4edc13a43adb3ea4044e3fc8f43ccf7d,0
tipc: Fix missing list initializations in struct tipc_subscription,"When an item of struct tipc_subscription is created, we fail to initialize the two lists aggregated into the struct. This has so far never been a problem, since the items are just added to a root object by list_add(), which does not require the addee list to be pre-initialized. However, syzbot is provoking situations where this addition fails, whereupon the attempted removal if the item from the list causes a crash.  This problem seems to always have been around, despite that the code for creating this object was rewritten in commit 242e82cc95f6 (""tipc: collapse subscription creation functions""), which is still in net-next.  We fix this for that commit by initializing the two lists properly.  ",b714295abc59cfa2fe46f9341503d9a7eb790503,1
KVM: mmu: Fix overlap between public and private memslots,Reported by syzkaller:      pte_list_remove: ffff9714eb1f8078 0->BUG     ,b28676bb8ae4569cced423dc2a88f7cb319d5379,1
fs/minix: reject too-large maximum file size,"If the minix filesystem tries to map a very large logical block number to its on-disk location, block_to_path() can return offsets that are too large, causing out-of-bounds memory accesses when accessing indirect index blocks.  This should be prevented by the check against the maximum file size, but this doesn't work because the maximum file size is read directly from the on-disk superblock and isn't validated itself.  Fix this by validating the maximum file size at mount time.  ",270ef41094e9fa95273f288d7d785313ceab2ff3,1
hrtimer: Use raw_cpu_ptr() in clock_was_set(),clock_was_set() can be invoked from preemptible context. Use raw_cpu_ptr() to check whether high resolution mode is active or not. It does not matter whether the task migrates after acquiring the pointer.  ,9482fd71dbb8f0d1a61821a83e467dc0a9d7b429,0
tracing: Add back in rcu_irq_enter/exit_irqson() for rcuidle tracepoints,Borislav reported the following splat:   ,865e63b04e9b2a658d7f26bd13a71dcd964a9118,0
block: genhd: don't call blkdev_show() with major_names_lock held,"If CONFIG_BLK_DEV_LOOP && CONFIG_MTD (at least; there might be other combinations), lockdep complains circular locking dependency at __loop_clr_fd(), for major_names_lock serves as a locking dependency aggregating hub across multiple block modules.   ",dfbb3409b27fa42b96f5727a80d3ceb6a8663991,0
bpf/tracing: fix a deadlock in perf_event_detach_bpf_prog,syzbot reported a possible deadlock in perf_event_detach_bpf_prog. The error details:   ,3a38bb98d9abdc3856f26b5ed4332803065cd7cf,0
rtnetlink: give a user socket to get_target_net(),"This function is used from two places: rtnl_dump_ifinfo and rtnl_getlink. In rtnl_getlink(), we give a request skb into get_target_net(), but in rtnl_dump_ifinfo, we give a response skb into get_target_net(). The problem here is that NETLINK_CB() isn't initialized for the response skb. In both cases we can get a user socket and give it instead of skb into get_target_net().  This bug was found by syzkaller with this call-trace:  kasan: GPF could be caused by NULL-ptr deref or user memory access general protection fault: 0000 [#1] SMP KASAN ",f428fe4a04cc339166c8bbd489789760de3a0cee,1
tun: publish tfile after it's fully initialized,"BUG: unable to handle kernel NULL pointer dereference at 00000000000000d1 Call Trace:  ? napi_gro_frags+0xa7/0x2c0  tun_get_user+0xb50/0xf20  tun_chr_write_iter+0x53/0x70  new_sync_write+0xff/0x160  vfs_write+0x191/0x1e0  __x64_sys_write+0x5e/0xd0  do_syscall_64+0x47/0xf0  entry_SYSCALL_64_after_hwframe+0x44/0xa9  I think there is a subtle race between sending a packet via tap and attaching it:  CPU0:                    CPU1: tun_chr_ioctl(TUNSETIFF)   tun_set_iff     tun_attach       rcu_assign_pointer(tfile->tun, tun);                          tun_fops->write_iter()                            tun_chr_write_iter                              tun_napi_alloc_frags                                napi_get_frags                                  napi->skb = napi_alloc_skb       tun_napi_init         netif_napi_add           napi->skb = NULL                               napi->skb is NULL here                               napi_gro_frags                                 napi_frags_skb 				  skb = napi->skb 				  skb_reset_mac_header(skb) 				  panic()  Move rcu_assign_pointer(tfile->tun) and rcu_assign_pointer(tun->tfiles) to be the last thing we do in tun_attach(); this should guarantee that when we call tun_get() we always get an initialized object.  v2 changes: * remove extra napi_mutex locks/unlocks for napi operations  ",0b7959b6257322f7693b08a459c505d4938646f2,1
"Revert ""net-sysfs: Fix memory leak in netdev_register_kobject""",This reverts commit 6b70fc94afd165342876e53fc4b2f7d085009945.  The reverted bugfix will cause another issue. Reported by syzbot+6024817a931b2830bc93@syzkaller.appspotmail.com. See https://syzkaller.appspot.com/x/log.txt?x=1737671b200000 for details.  ,8ed633b9baf9ec7d593ebb8e256312ff1c70ab37,1
net: add a READ_ONCE() in skb_peek_tail(),"skb_peek_tail() can be used without protection of a lock, as spotted by KCSAN [1]  In order to avoid load-stearing, add a READ_ONCE()  Note that the corresponding WRITE_ONCE() are already there.  [1] BUG: KCSAN: data-race in sk_wait_data / skb_queue_tail  read to 0xffff8880b36a4118 of 8 bytes by task 20426 on cpu 1:  skb_peek_tail include/linux/skbuff.h:1784 [inline]  sk_wait_data+0x15b/0x250 net/core/sock.c:2477  kcm_wait_data+0x112/0x1f0 net/kcm/kcmsock.c:1103  kcm_recvmsg+0xac/0x320 net/kcm/kcmsock.c:1130  sock_recvmsg_nosec net/socket.c:871 [inline]  sock_recvmsg net/socket.c:889 [inline]  sock_recvmsg+0x92/0xb0 net/socket.c:885  ___sys_recvmsg+0x1a0/0x3e0 net/socket.c:2480  do_recvmmsg+0x19a/0x5c0 net/socket.c:2601  __sys_recvmmsg+0x1ef/0x200 net/socket.c:2680  __do_sys_recvmmsg net/socket.c:2703 [inline]  __se_sys_recvmmsg net/socket.c:2696 [inline]  __x64_sys_recvmmsg+0x89/0xb0 net/socket.c:2696  do_syscall_64+0xcc/0x370 arch/x86/entry/common.c:290  entry_SYSCALL_64_after_hwframe+0x44/0xa9  write to 0xffff8880b36a4118 of 8 bytes by task 451 on cpu 0:  __skb_insert include/linux/skbuff.h:1852 [inline]  __skb_queue_before include/linux/skbuff.h:1958 [inline]  __skb_queue_tail include/linux/skbuff.h:1991 [inline]  skb_queue_tail+0x7e/0xc0 net/core/skbuff.c:3145  kcm_queue_rcv_skb+0x202/0x310 net/kcm/kcmsock.c:206  kcm_rcv_strparser+0x74/0x4b0 net/kcm/kcmsock.c:370  __strp_recv+0x348/0xf50 net/strparser/strparser.c:309  strp_recv+0x84/0xa0 net/strparser/strparser.c:343  tcp_read_sock+0x174/0x5c0 net/ipv4/tcp.c:1639  strp_read_sock+0xd4/0x140 net/strparser/strparser.c:366  do_strp_work net/strparser/strparser.c:414 [inline]  strp_work+0x9a/0xe0 net/strparser/strparser.c:423  process_one_work+0x3d4/0x890 kernel/workqueue.c:2269  worker_thread+0xa0/0x800 kernel/workqueue.c:2415  kthread+0x1d4/0x200 drivers/block/aoe/aoecmd.c:1253  ret_from_fork+0x1f/0x30 arch/x86/entry/entry_64.S:352  Reported by Kernel Concurrency Sanitizer on: CPU: 0 PID: 451 Comm: kworker/u4:3 Not tainted 5.4.0-rc3+ #0 Hardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 01/01/2011 Workqueue: kstrp strp_work  ",f8cc62ca3e660ae3fdaee533b1d554297cd2ae82,1
"kernel/relay.c: revert ""kernel/relay.c: fix potential memory leak""","This reverts commit ba62bafe942b (""kernel/relay.c: fix potential memory leak"").  This commit introduced a double free bug, because 'chan' is already freed by the line:      kref_put(&chan->kref, relay_destroy_channel);  This bug was found by syzkaller, using the BLKTRACESETUP ioctl.  ",a1be1f3931bfe0a42b46fef77a04593c2b136e7f,1
ieee802154: 6lowpan: fix possible NULL deref in lowpan_device_event(),"A tun device type can trivially be set to arbitrary value using TUNSETLINK ioctl().  Therefore, lowpan_device_event() must really check that ieee802154_ptr is not NULL.  ",ca0edb131bdf1e6beaeb2b8289fd6b374b74147d,0
loop: reduce the loop_ctl_mutex scope,"syzbot is reporting circular locking problem at __loop_clr_fd() [1], for commit a160c6159d4a0cf8 (""block: add an optional probe callback to major_names"") is calling the module's probe function with major_names_lock held.  Fortunately, since commit 990e78116d38059c (""block: loop: fix deadlock between open and remove"") stopped holding loop_ctl_mutex in lo_open(), current role of loop_ctl_mutex is to serialize access to loop_index_idr and loop_add()/loop_remove(); in other words, management of id for IDR. To avoid holding loop_ctl_mutex during whole add/remove operation, use a bool flag to indicate whether the loop device is ready for use.  loop_unregister_transfer() which is called from cleanup_cryptoloop() currently has possibility of use-after-free problem due to lack of serialization between kfree() from loop_remove() from loop_control_remove() and mutex_lock() from unregister_transfer_cb(). But since lo->lo_encryption should be already NULL when this function is called due to module unload, and commit 222013f9ac30b9ce (""cryptoloop: add a deprecation warning"") indicates that we will remove this function shortly, this patch updates this function to emit warning instead of checking lo->lo_encryption.  Holding loop_ctl_mutex in loop_exit() is pointless, for all users must close /dev/loop-control and /dev/loop$num (in order to drop module's refcount to 0) before loop_exit() starts, and nobody can open /dev/loop-control or /dev/loop$num afterwards.  ",1c500ad706383f1a6609e63d0b5d1723fd84dab9,1
lockdep: Allow tuning tracing capacity constants.,"Since syzkaller continues various test cases until the kernel crashes, syzkaller tends to examine more locking dependencies than normal systems. As a result, syzbot is reporting that the fuzz testing was terminated due to hitting upper limits lockdep can track [1] [2] [3]. Since analysis via /proc/lockdep* did not show any obvious culprit [4] [5], we have no choice but allow tuning tracing capacity constants.  [1] https://syzkaller.appspot.com/bug?id=3d97ba93fb3566000c1c59691ea427370d33ea1b [2] https://syzkaller.appspot.com/bug?id=381cb436fe60dc03d7fd2a092b46d7f09542a72a [3] https://syzkaller.appspot.com/bug?id=a588183ac34c1437fc0785e8f220e88282e5a29f [4] https://lkml.kernel.org/r/4b8f7a57-fa20-47bd-48a0-ae35d860f233@i-love.sakura.ne.jp [5] https://lkml.kernel.org/r/1c351187-253b-2d49-acaf-4563c63ae7d2@i-love.sakura.ne.jp  References: https://lkml.kernel.org/r/1595640639-9310-1-git-send-email-penguin-kernel@I-love.SAKURA.ne.jp ",5dc33592e95534dc8455ce3e9baaaf3dae0fff82,1
media: cpia2: fix memory leak in cpia2_usb_probe,"syzbot reported leak in cpia2 usb driver. The problem was in invalid error handling.  v4l2_device_register() is called in cpia2_init_camera_struct(), but all error cases after cpia2_init_camera_struct() did not call the v4l2_device_unregister()  ",be8656e62e9e791837b606a027802b504a945c97,1
bonding: make tx_rebalance_counter an atomic,"KCSAN reported a data-race [1] around tx_rebalance_counter which can be accessed from different contexts, without the protection of a lock/mutex.  [1] BUG: KCSAN: data-race in bond_alb_init_slave / bond_alb_monitor  write to 0xffff888157e8ca24 of 4 bytes by task 7075 on cpu 0:  bond_alb_init_slave+0x713/0x860 drivers/net/bonding/bond_alb.c:1613  bond_enslave+0xd94/0x3010 drivers/net/bonding/bond_main.c:1949  do_set_master net/core/rtnetlink.c:2521 [inline]  __rtnl_newlink net/core/rtnetlink.c:3475 [inline]  rtnl_newlink+0x1298/0x13b0 net/core/rtnetlink.c:3506  rtnetlink_rcv_msg+0x745/0x7e0 net/core/rtnetlink.c:5571  netlink_rcv_skb+0x14e/0x250 net/netlink/af_netlink.c:2491  rtnetlink_rcv+0x18/0x20 net/core/rtnetlink.c:5589  netlink_unicast_kernel net/netlink/af_netlink.c:1319 [inline]  netlink_unicast+0x5fc/0x6c0 net/netlink/af_netlink.c:1345  netlink_sendmsg+0x6e1/0x7d0 net/netlink/af_netlink.c:1916  sock_sendmsg_nosec net/socket.c:704 [inline]  sock_sendmsg net/socket.c:724 [inline]  ____sys_sendmsg+0x39a/0x510 net/socket.c:2409  ___sys_sendmsg net/socket.c:2463 [inline]  __sys_sendmsg+0x195/0x230 net/socket.c:2492  __do_sys_sendmsg net/socket.c:2501 [inline]  __se_sys_sendmsg net/socket.c:2499 [inline]  __x64_sys_sendmsg+0x42/0x50 net/socket.c:2499  do_syscall_x64 arch/x86/entry/common.c:50 [inline]  do_syscall_64+0x44/0xd0 arch/x86/entry/common.c:80  entry_SYSCALL_64_after_hwframe+0x44/0xae  read to 0xffff888157e8ca24 of 4 bytes by task 1082 on cpu 1:  bond_alb_monitor+0x8f/0xc00 drivers/net/bonding/bond_alb.c:1511  process_one_work+0x3fc/0x980 kernel/workqueue.c:2298  worker_thread+0x616/0xa70 kernel/workqueue.c:2445  kthread+0x2c7/0x2e0 kernel/kthread.c:327  ret_from_fork+0x1f/0x30  value changed: 0x00000001 -> 0x00000064  Reported by Kernel Concurrency Sanitizer on: CPU: 1 PID: 1082 Comm: kworker/u4:3 Not tainted 5.16.0-rc3-syzkaller #0 Hardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 01/01/2011 Workqueue: bond1 bond_alb_monitor  ",dac8e00fb640e9569cdeefd3ce8a75639e5d0711,1
vhost/vsock: fix use-after-free in network stack callers,"If the network stack calls .send_pkt()/.cancel_pkt() during .release(), a struct vhost_vsock use-after-free is possible.  This occurs because .release() does not wait for other CPUs to stop using struct vhost_vsock.  Switch to an RCU-enabled hashtable (indexed by guest CID) so that .release() can wait for other CPUs by calling synchronize_rcu().  This also eliminates vhost_vsock_lock acquisition in the data path so it could have a positive effect on performance.  This is CVE-2018-14625 ""kernel: use-after-free Read in vhost_transport_send_pkt"".  ",834e772c8db0c6a275d75315d90aba4ebbb1e249,1
sysfs: turn WARN() into pr_warn(),"It's not good to crash the machine if panic_on_warn() is set just because someone made a stupid mistake of trying to create a sysfs file with the same name of an existing one.  This makes the automated testing tools a lot harder to find the real bugs in the kernel.  So just print a warning out and dump the stack to get the attention of the developer that they did something foolish.  Then keep on trucking, as this should not be a fatal error at all.  ",5d54f948aaac4a6ab6b908af379103559a5a002c,1
bonding: fix a potential double-unregister,"When we tear down a network namespace, we unregister all the netdevices within it. So we may queue a slave device and a bonding device together in the same unregister queue.  If the only slave device is non-ethernet, it would automatically unregister the bonding device as well. Thus, we may end up unregistering the bonding device twice.  Workaround this special case by checking reg_state.  ",832707021666411d04795c564a4adea5d6b94f17,0
9p: validate PDU length,"This commit adds length check for the PDU size. The size contained in the header has to match the actual size, except for TCP (trans_fd.c) where actual length is not known ahead and the header's length will be checked only against the validity range.  ",f984579a01d85166ee7380204a96d978a67687a1,0
acct_on(): don't mess with freeze protection,"What happens there is that we are replacing file->path.mnt of a file we'd just opened with a clone and we need the write count contribution to be transferred from original mount to new one.  That's it.  We do *NOT* want any kind of freeze protection for the duration of switchover.  IOW, we should just use __mnt_{want,drop}_write() for that switchover; no need to bother with mnt_{want,drop}_write() there.  ",9419a3191dcb27f24478d288abaab697228d28e6,0
nl80211: call cfg80211_dev_rename() under RTNL,"This is required, and we have an assertion, move the RTNL unlock down to cover cfg80211_dev_rename().  ",0391a45c800780f0aa33984542710451acd71b90,0
USB: cdc-wdm: fix race between write and disconnect due to flag abuse,"In case of a disconnect an ongoing flush() has to be made fail. Nevertheless we cannot be sure that any pending URB has already finished, so although they will never succeed, they still must not be touched. The clean solution for this is to check for WDM_IN_USE and WDM_DISCONNECTED in flush(). There is no point in ever clearing WDM_IN_USE, as no further writes make sense.  The issue is as old as the driver.  ",1426bd2c9f7e3126e2678e7469dca9fd9fc6dd3e,1
can: j1939: socket: rework socket locking for j1939_sk_release() and j1939_sk_sendmsg(),j1939_sk_sendmsg() should be protected by lock_sock() to avoid race with j1939_sk_bind() and j1939_sk_release().  ,fd81ebfe7975b9a69494430676d16f7125aac3ee,1
igmp: fix memory leak in igmpv3_del_delrec(),"im->tomb and/or im->sources might not be NULL, but we currently overwrite their values blindly.  Using swap() will make sure the following call to kfree_pmc(pmc) will properly free the psf structures.  Tested with the C repro provided by syzbot, which basically does :   socket(PF_INET, SOCK_DGRAM, IPPROTO_IP) = 3  setsockopt(3, SOL_IP, IP_ADD_MEMBERSHIP, ""\340\0\0\2\177\0\0\1\0\0\0\0"", 12) = 0  ioctl(3, SIOCSIFFLAGS, {ifr_name=""lo"", ifr_flags=0}) = 0  setsockopt(3, SOL_IP, IP_MSFILTER, ""\340\0\0\2\177\0\0\1\1\0\0\0\1\0\0\0\377\377\377\377"", 20) = 0  ioctl(3, SIOCSIFFLAGS, {ifr_name=""lo"", ifr_flags=IFF_UP}) = 0  exit_group(0)                    = ?  BUG: memory leak unreferenced object 0xffff88811450f140 (size 64):   comm ""softirq"", pid 0, jiffies 4294942448 (age 32.070s)   ",e5b1c6c6277d5a283290a8c033c72544746f9b5b,1
block: add bio_truncate to fix guard_bio_eod,"Some filesystem, such as vfat, may send bio which crosses device boundary, and the worse thing is that the IO request starting within device boundaries can contain more than one segment past EOD.  Commit dce30ca9e3b6 (""fs: fix guard_bio_eod to check for real EOD errors"") tries to fix this issue by returning -EIO for this situation. However, this way lets fs user code lose chance to handle -EIO, then sync_inodes_sb() may hang for ever.  Also the current truncating on last segment is dangerous by updating the last bvec, given bvec table becomes not immutable any more, and fs bio users may not retrieve the truncated pages via bio_for_each_segment_all() in its .end_io callback.  Fixes this issue by supporting multi-segment truncating. And the approach is simpler:  - just update bio size since block layer can make correct bvec with the updated bio size. Then bvec table becomes really immutable.  - zero all truncated segments for read bio  ",85a8ce62c2eabe28b9d76ca4eecf37922402df93,0
block: free sched's request pool in blk_cleanup_queue,"In theory, IO scheduler belongs to request queue, and the request pool of sched tags belongs to the request queue too.  However, the current tags allocation interfaces are re-used for both driver tags and sched tags, and driver tags is definitely host wide, and doesn't belong to any request queue, same with its request pool. So we need tagset instance for freeing request of sched tags.  Meantime, blk_mq_free_tag_set() often follows blk_cleanup_queue() in case of non-BLK_MQ_F_TAG_SHARED, this way requires that request pool of sched tags to be freed before calling blk_mq_free_tag_set().  Commit 47cdee29ef9d94e (""block: move blk_exit_queue into __blk_release_queue"") moves blk_exit_queue into __blk_release_queue for simplying the fast path in generic_make_request(), then causes oops during freeing requests of sched tags in __blk_release_queue().  Fix the above issue by move freeing request pool of sched tags into blk_cleanup_queue(), this way is safe becasue queue has been frozen and no any in-queue requests at that time. Freeing sched tags has to be kept in queue's release handler becasue there might be un-completed dispatch activity which might refer to sched tags.  ",c3e2219216c92919a6bd1711f340f5faa98695e6,1
fcntl: fix potential deadlocks for &fown_struct.lock,Syzbot reports a potential deadlock in do_fcntl:  ,f671a691e299f58835d4660d642582bf0e8f6fda,0
sctp: fix err handling of stream initialization,"The fix on 951c6db954a1 fixed the issued reported there but introduced another. When the allocation fails within sctp_stream_init() it is okay/necessary to free the genradix. But it is also called when adding new streams, from sctp_send_add_streams() and sctp_process_strreset_addstrm_in() and in those situations it cannot just free the genradix because by then it is a fully operational association.  The fix here then is to only free the genradix in sctp_stream_init() and on those other call sites  move on with what it already had and let the subsequent error handling to handle it.  Tested with the reproducers from this report and the previous one, with lksctp-tools and sctp-tests.  ",61d5d4062876e21331c3d0ba4b02dbd50c06a658,1
net/smc: return 0 for ioctl calls in states INIT and CLOSED,A connected SMC-socket contains addresses of descriptors for the send buffer and the rmb (receive buffer). Fields of these descriptors are used to determine the answer for certain ioctl requests. Add extra handling for unconnected SMC socket states without valid buffer descriptor addresses.  ,2351abe6f8736167a187cec867933bc66c3284c0,1
packet: refine ring v3 block size test to hold one frame,"TPACKET_V3 stores variable length frames in fixed length blocks. Blocks must be able to store a block header, optional private space and at least one minimum sized frame.  Frames, even for a zero snaplen packet, store metadata headers and optional reserved space.  In the block size bounds check, ensure that the frame of the chosen configuration fits. This includes sockaddr_ll and optional tp_reserve.  Syzbot was able to construct a ring with insuffient room for the sockaddr_ll in the header of a zero-length frame, triggering an out-of-bounds write in dev_parse_header.  Convert the comparison to less than, as zero is a valid snap len. This matches the test for minimum tp_frame_size immediately below.  ",4576cd469d980317c4edd9173f8b694aa71ea3a3,1
af_unix: Fix NULL pointer bug in unix_shutdown,"Commit 94531cfcbe79 (""af_unix: Add unix_stream_proto for sockmap"") introduced a bug for af_unix SEQPACKET type. In unix_shutdown, the unhash function will call prot->unhash(), which is NULL for SEQPACKET. And kernel will panic. On ARM32, it will show following messages: (it likely affects x86 too).  Fix the bug by checking the prot->unhash is NULL or not first.  Kernel log: <",d359902d5c357b280e7a0862bb8a1ba56b3fc197,0
media: zr364xx: fix memory leak in zr364xx_start_readpipe,syzbot reported memory leak in zr364xx driver. The problem was in non-freed urb in case of usb_submit_urb() fail.  backtrace:   [<ffffffff82baedf6>] kmalloc include/linux/slab.h:561 [inline]   [<ffffffff82baedf6>] usb_alloc_urb+0x66/0xe0 drivers/usb/core/urb.c:74   [<ffffffff82f7cce8>] zr364xx_start_readpipe+0x78/0x130 drivers/media/usb/zr364xx/zr364xx.c:1022   [<ffffffff84251dfc>] zr364xx_board_init drivers/media/usb/zr364xx/zr364xx.c:1383 [inline]   [<ffffffff84251dfc>] zr364xx_probe+0x6a3/0x851 drivers/media/usb/zr364xx/zr364xx.c:1516   [<ffffffff82bb6507>] usb_probe_interface+0x177/0x370 drivers/usb/core/driver.c:396   [<ffffffff826018a9>] really_probe+0x159/0x500 drivers/base/dd.c:576  ,0a045eac8d0427b64577a24d74bb8347c905ac65,1
rxrpc: Fix memory leak in rxrpc_lookup_local,"Commit 9ebeddef58c4 (""rxrpc: rxrpc_peer needs to hold a ref on the rxrpc_local record"") Then release ref in __rxrpc_put_peer and rxrpc_put_peer_locked.  	struct rxrpc_peer *rxrpc_alloc_peer(struct rxrpc_local *local, gfp_t gfp) 	-               peer->local = local; 	+               peer->local = rxrpc_get_local(local);  rxrpc_discard_prealloc also need ref release in discarding.  syzbot report: BUG: memory leak unreferenced object 0xffff8881080ddc00 (size 256):   comm ""syz-executor339"", pid 8462, jiffies 4294942238 (age 12.350s)   ",b8323f7288abd71794cd7b11a4c0a38b8637c8b5,1
tipc: check tsk->group in tipc_wait_for_cond(),"tipc_wait_for_cond() drops socket lock before going to sleep, but tsk->group could be freed right after that release_sock(). So we have to re-check and reload tsk->group after it wakes up.  After this patch, tipc_wait_for_cond() returns -ERESTARTSYS when tsk->group is NULL, instead of continuing with the assumption of a non-NULL tsk->group.  (It looks like 'dsts' should be re-checked and reloaded too, but it is a different bug.)  Similar for tipc_send_group_unicast() and tipc_send_group_anycast().  ",143ece654f9f5b37bedea252a990be37e48ae3a5,0
xdp: fix potential deadlock on socket mutex,There are 2 call chains:    a) xsk_bind --> xdp_umem_assign_dev   b) unregister_netdevice_queue --> xsk_notifier  with the following locking order:    a) xs->mutex --> rtnl_lock   b) rtnl_lock --> xdp.lock --> xs->mutex  Different order of taking 'xs->mutex' and 'rtnl_lock' could produce a deadlock here. Fix that by moving the 'rtnl_lock' before 'xs->lock' in the bind call chain (a).  ,5464c3a0e9a037b63d5229cdea08dddc01a98aac,0
gfs2: Fix NULL pointer dereference in gfs2_rgrp_dump,"When an rindex entry is found to be corrupt, compute_bitstructs() calls gfs2_consist_rgrpd() which calls gfs2_rgrp_dump() like this:      gfs2_rgrp_dump(NULL, rgd->rd_gl, fs_id_buf);  gfs2_rgrp_dump then dereferences the gl without checking it and we get      BUG: KASAN: null-ptr-deref in gfs2_rgrp_dump+0x28/0x280  because there's no rgrp glock involved while reading the rindex on mount.  Fix this by changing gfs2_rgrp_dump to take an rgrp argument.  ",0e539ca1bbbe85a86549c97a30a765ada4a09df9,1
mptcp: Check reclaim amount before reducing allocation,syzbot found a page counter underflow that was triggered by MPTCP's reclaim code:  page_counter underflow: -4294964789 nr_pages=4294967295 ,269bda9e7da48eafb599d01c96199caa2f7547e5,1
xfrm: fix rcu lock in xfrm_notify_userpolicy(),"As stated in the comment above xfrm_nlmsg_multicast(), rcu read lock must be held before calling this function.  ",93ec1320b0170d7a207eda2d119c669b673401ed,0
mac80211: remove warning in ieee80211_get_sband(),"Syzbot reports that it's possible to hit this from userspace, by trying to add a station before any other connection setup has been done. Instead of trying to catch this in some other way simply remove the warning, that will appropriately reject the call from userspace.  ",0ee4d55534f82a0624701d0bb9fc2304d4529086,0
USB: fix the usbfs flag sanitization for control transfers,"Commit 7a68d9fb8510 (""USB: usbdevfs: sanitize flags more"") checks the transfer flags for URBs submitted from userspace via usbfs.  However, the check for whether the USBDEVFS_URB_SHORT_NOT_OK flag should be allowed for a control transfer was added in the wrong place, before the code has properly determined the direction of the control transfer.  (Control transfers are special because for them, the direction is set by the bRequestType byte of the Setup packet rather than direction bit of the endpoint address.)  This patch moves code which sets up the allow_short flag for control transfers down after is_in has been set to the correct value.  ",665c365a77fbfeabe52694aedf3446d5f2f1ce42,0
drivers: net: fix memory leak in atusb_probe,"syzbot reported memory leak in atusb_probe()[1]. The problem was in atusb_alloc_urbs(). Since urb is anchored, we need to release the reference to correctly free the urb  backtrace:     [<ffffffff82ba0466>] kmalloc include/linux/slab.h:559 [inline]     [<ffffffff82ba0466>] usb_alloc_urb+0x66/0xe0 drivers/usb/core/urb.c:74     [<ffffffff82ad3888>] atusb_alloc_urbs drivers/net/ieee802154/atusb.c:362 [inline][2]     [<ffffffff82ad3888>] atusb_probe+0x158/0x820 drivers/net/ieee802154/atusb.c:1038 [1]  ",6b9fbe16955152626557ec6f439f3407b7769941,1
net: introduce CAN specific pointer in the struct net_device,"Since 20dd3850bcf8 (""can: Speed up CAN frame receiption by using ml_priv"") the CAN framework uses per device specific data in the AF_CAN protocol. For this purpose the struct net_device->ml_priv is used. Later the ml_priv usage in CAN was extended for other users, one of them being CAN_J1939.  Later in the kernel ml_priv was converted to an union, used by other drivers. E.g. the tun driver started storing it's stats pointer.  Since tun devices can claim to be a CAN device, CAN specific protocols will wrongly interpret this pointer, which will cause system crashes. Mostly this issue is visible in the CAN_J1939 stack.  To fix this issue, we request a dedicated CAN pointer within the net_device struct.  ",4e096a18867a5a989b510f6999d9c6b6622e8f7b,1
fbmem: add margin check to fb_check_caps(),"A fb_ioctl() FBIOPUT_VSCREENINFO call with invalid xres setting or yres setting in struct fb_var_screeninfo will result in a KASAN: vmalloc-out-of-bounds failure in bitfill_aligned() as the margins are being cleared. The margins are cleared in chunks and if the xres setting or yres setting is a value of zero upto the chunk size, the failure will occur.  Add a margin check to validate xres and yres settings.  ",a49145acfb975d921464b84fe00279f99827d816,1
net: qrtr: fix OOB Read in qrtr_endpoint_post,"Syzbot reported slab-out-of-bounds Read in qrtr_endpoint_post. The problem was in wrong _size_ type:  	if (len != ALIGN(size, 4) + hdrlen) 		goto err;  If size from qrtr_hdr is 4294967293 (0xfffffffd), the result of ALIGN(size, 4) will be 0. In case of len == hdrlen and size == 4294967293 in header this check won't fail and  	skb_put_data(skb, data + hdrlen, size);  will read out of bound from data, which is hdrlen allocated block.  ",ad9d24c9429e2159d1e279dc3a83191ccb4daf1d,1
ALSA: line6: Fix endless MIDI read loop,"The MIDI input event parser of the LINE6 driver may enter into an endless loop when the unexpected data sequence is given, as it tries to continue the secondary bytes without termination.  Also, when the input data is too short, the parser returns a negative error, while the caller doesn't handle it properly.  This would lead to the unexpected behavior as well.  This patch addresses those issues by checking the return value correctly and handling the one-byte event in the parser properly.  The bug was reported by syzkaller.  ",d683469b3c93d7e2afd39e6e1970f24700eb7a68,1
can: mcba_usb: fix use-after-free on disconnect,The driver was accessing its driver data after having freed it.  ,4d6636498c41891d0482a914dd570343a838ad79,1
dax: fix general protection fault in dax_alloc_inode,Don't crash in case of allocation failure in dax_alloc_inode.      syzkaller hit the following crash on e4880bc5dfb1      kasan: CONFIG_KASAN_INLINE enabled     kasan: GPF could be caused by NULL-ptr deref or user memory access     [..]     ,9f586fff6574f6ecbf323f92d44ffaf0d96225fe,1
loop: Fix double mutex_unlock(&loop_ctl_mutex) in loop_control_ioctl(),"Commit 0a42e99b58a20883 (""loop: Get rid of loop_index_mutex"") forgot to remove mutex_unlock(&loop_ctl_mutex) from loop_control_ioctl() when replacing loop_index_mutex with loop_ctl_mutex.  ",628bd85947091830a8c4872adfd5ed1d515a9cf2,0
bpf: fix off-by-one error in adjust_subprog_starts,"When patching in a new sequence for the first insn of a subprog, the start  of that subprog does not change (it's the first insn of the sequence), so  adjust_subprog_starts should check start <= off (rather than < off). Also added a test to test_verifier.c (it's essentially the syz reproducer).  ",afd594240806acc138cf696c09f2f4829d55d02f,0
netfilter: x_tables: fix compat match/target pad out-of-bound write,xt_compat_match/target_from_user doesn't check that zeroing the area to start of next rule won't write past end of allocated ruleset blob.  Remove this code and zero the entire blob beforehand.  ,b29c457a6511435960115c0f548c4360d5f4801d,1
inet: frags: fix use-after-free read in inet_frag_destroy_rcu,"As caught by syzbot [1], the rcu grace period that is respected before fqdir_rwork_fn() proceeds and frees fqdir is not enough to prevent inet_frag_destroy_rcu() being run after the freeing.  We need a proper rcu_barrier() synchronization to replace the one we had in inet_frags_fini()  We also have to fix a potential problem at module removal : inet_frags_fini() needs to make sure that all queued work queues (fqdir_rwork_fn) have completed, otherwise we might call kmem_cache_destroy() too soon and get another use-after-free.  [1] BUG: KASAN: use-after-free in inet_frag_destroy_rcu+0xd9/0xe0 net/ipv4/inet_fragment.c:201 Read of size 8 at addr ffff88806ed47a18 by task swapper/1/0  CPU: 1 PID: 0 Comm: swapper/1 Not tainted 5.2.0-rc1+ #2 Hardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 01/01/2011 Call Trace:  <IRQ>  __dump_stack lib/dump_stack.c:77 [inline]  dump_stack+0x172/0x1f0 lib/dump_stack.c:113  print_address_description.cold+0x7c/0x20d mm/kasan/report.c:188  __kasan_report.cold+0x1b/0x40 mm/kasan/report.c:317  kasan_report+0x12/0x20 mm/kasan/common.c:614  __asan_report_load8_noabort+0x14/0x20 mm/kasan/generic_report.c:132  inet_frag_destroy_rcu+0xd9/0xe0 net/ipv4/inet_fragment.c:201  __rcu_reclaim kernel/rcu/rcu.h:222 [inline]  rcu_do_batch kernel/rcu/tree.c:2092 [inline]  invoke_rcu_callbacks kernel/rcu/tree.c:2310 [inline]  rcu_core+0xba5/0x1500 kernel/rcu/tree.c:2291  __do_softirq+0x25c/0x94c kernel/softirq.c:293  invoke_softirq kernel/softirq.c:374 [inline]  irq_exit+0x180/0x1d0 kernel/softirq.c:414  exiting_irq arch/x86/include/asm/apic.h:536 [inline]  smp_apic_timer_interrupt+0x13b/0x550 arch/x86/kernel/apic/apic.c:1068  apic_timer_interrupt+0xf/0x20 arch/x86/entry/entry_64.S:806  </IRQ> ",dc93f46bc4e00899eaf4579962cfac8cf2f9966d,1
vsock: fix potential null pointer dereference in vsock_poll(),"syzbot reported this issue where in the vsock_poll() we find the socket state at TCP_ESTABLISHED, but 'transport' is null:   general protection fault, probably for non-canonical address 0xdffffc0000000012: 0000 [#1] PREEMPT SMP KASAN   KASAN: null-ptr-deref in range [0x0000000000000090-0x0000000000000097]   CPU: 0 PID: 8227 Comm: syz-executor.2 Not tainted 5.8.0-rc7-syzkaller #0   Hardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 01/01/2011   ",1980c05844830a44708c98c96d600833aa3fae08,1
USB: handle NULL config in usb_find_alt_setting(),"usb_find_alt_setting() takes a pointer to a struct usb_host_config as an argument; it searches for an interface with specified interface and alternate setting numbers in that config.  However, it crashes if the usb_host_config pointer argument is NULL.  Since this is a general-purpose routine, available for use in many places, we want to to be more robust.  This patch makes it return NULL whenever the config argument is NULL.  ",c9a4cb204e9eb7fa7dfbe3f7d3a674fa530aa193,1
sched/fair: Fix shift-out-of-bounds in load_balance(),"Syzbot reported a handful of occurrences where an sd->nr_balance_failed can grow to much higher values than one would expect.  A successful load_balance() resets it to 0; a failed one increments it. Once it gets to sd->cache_nice_tries + 3, this *should* trigger an active balance, which will either set it to sd->cache_nice_tries+1 or reset it to 0. However, in case the to-be-active-balanced task is not allowed to run on env->dst_cpu, then the increment is done without any further modification.  This could then be repeated ad nauseam, and would explain the absurdly high values reported by syzbot (86, 149). VincentG noted there is value in letting sd->cache_nice_tries grow, so the shift itself should be fixed. That means preventing:    """"""   If the value of the right operand is negative or is greater than or equal   to the width of the promoted left operand, the behavior is undefined.   """"""  Thus we need to cap the shift exponent to   BITS_PER_TYPE(typeof(lefthand)) - 1.  I had a look around for other similar cases via coccinelle:    @expr@   position pos;   expression E1;   expression E2;   @@   (   E1 >> E2@pos   |   E1 >> E2@pos   )    @cst depends on expr@   position pos;   expression expr.E1;   constant cst;   @@   (   E1 >> cst@pos   |   E1 << cst@pos   )    @script:python depends on !cst@   pos << expr.pos;   exp << expr.E2;   @@   # Dirty hack to ignore constexpr   if exp.upper() != exp:      coccilib.report.print_report(pos[0], ""Possible UB shift here"")  The only other match in kernel/sched is rq_clock_thermal() which employs sched_thermal_decay_shift, and that exponent is already capped to 10, so that one is fine.  ",39a2a6eb5c9b66ea7c8055026303b3aa681b49a5,1
RDMA/core: Fix missing error check on dev_set_name(),If name memory allocation fails the name will be left empty and device_add_one() will crash:    kobject: (0000000004952746): attempted to be registered with empty name!   ,f2f2b3bbf0d9f8d090b9a019679223b2bd1c66c4,1
HID: wacom: Fix memory leakage caused by kfifo_alloc,"As reported by syzbot below, kfifo_alloc'd memory would not be freed if a non-zero return value is triggered in wacom_probe. This patch creates and uses devm_kfifo_alloc to allocate and free itself.  BUG: memory leak unreferenced object 0xffff88810dc44a00 (size 512):   comm ""kworker/1:2"", pid 3674, jiffies 4294943617 (age 14.100s)   ",37309f47e2f5674f3e86cb765312ace42cfcedf5,1
tipc: fix missing initializer in tipc_sendmsg(),"The stack variable 'dnode' in __tipc_sendmsg() may theoretically end up tipc_node_get_mtu() as an unitilalized variable.  We fix this by intializing the variable at declaration. We also add a default else clause to the two conditional ones already there, so that we never end up in the named function if the given address type is illegal.  ",335b929b28aeb5bfc0698adb21deaf685b2982d1,0
nl80211: fix NLA_POLICY_NESTED() arguments,"syzbot reported an out-of-bounds read when passing certain malformed messages into nl80211. The specific place where this happened isn't interesting, the problem is that nested policy parsing was referring to the wrong maximum attribute and thus the policy wasn't long enough.  Fix this by referring to the correct attribute. Since this is really not necessary, I'll come up with a separate patch to just pass the policy instead of both, in the common case we can infer the maxattr from the size of the policy array.  ",a8b5c6d69261889e022e9d64ac7ee8741db730bf,1
vsock: split dwork to avoid reinitializations,syzbot reported that we reinitialize an active delayed work in vsock_stream_connect():  	ODEBUG: init active (active state 0) object type: timer_list hint: 	delayed_work_timer_fn+0x0/0x90 kernel/workqueue.c:1414 	,455f05ecd2b219e9a216050796d30c830d9bc393,1
xfrm: check id proto in validate_tmpl(),"syzbot reported a kernel warning in xfrm_state_fini(), which indicates that we have entries left in the list net->xfrm.state_all whose proto is zero. And xfrm_id_proto_match() doesn't consider them as a match with IPSEC_PROTO_ANY in this case.  Proto with value 0 is probably not a valid value, at least verify_newsa_info() doesn't consider it valid either.  This patch fixes it by checking the proto value in validate_tmpl() and rejecting invalid ones, like what iproute2 does in xfrm_xfrmproto_getbyname().  ",6a53b7593233ab9e4f96873ebacc0f653a55c3e1,0
net: xfrm: Add '_rcu' tag for rcu protected pointer in netns_xfrm,"For rcu protected pointers, we'd better add '__rcu' for them.  Once added '__rcu' tag for rcu protected pointer, the sparse tool reports warnings.  net/xfrm/xfrm_user.c:1198:39: sparse:    expected struct sock *sk net/xfrm/xfrm_user.c:1198:39: sparse:    got struct sock [noderef] <asn:4> *nlsk [...]  So introduce a new wrapper function of nlmsg_unicast  to handle type conversions.  This patch also fixes a direct access of a rcu protected socket.  ",f10e0010fae8174dc20bdc872bcaa85baa925cb7,0
sctp: reset owner sk for data chunks on out queues when migrating a sock,"Now when migrating sock to another one in sctp_sock_migrate(), it only resets owner sk for the data in receive queues, not the chunks on out queues.  It would cause that data chunks length on the sock is not consistent with sk sk_wmem_alloc. When closing the sock or freeing these chunks, the old sk would never be freed, and the new sock may crash due to the overflow sk_wmem_alloc.  syzbot found this issue with this series:    r0 = socket$inet_sctp()   sendto$inet(r0)   listen(r0)   accept4(r0)   close(r0)  Although listen() should have returned error when one TCP-style socket is in connecting (I may fix this one in another patch), it could also be reproduced by peeling off an assoc.  This issue is there since very beginning.  This patch is to reset owner sk for the chunks on out queues so that sk sk_wmem_alloc has correct value after accept one sock or peeloff an assoc to one sock.  Note that when resetting owner sk for chunks on outqueue, it has to sctp_clear_owner_w/skb_orphan chunks before changing assoc->base.sk first and then sctp_set_owner_w them after changing assoc->base.sk, due to that sctp_wfree and it's callees are using assoc->base.sk.  ",d04adf1b355181e737b6b1e23d801b07f0b7c4c0,1
rtlwifi: rtl8192cu: Fix WARNING when calling local_irq_restore() with interrupts enabled,Syzbot reports the following ,8b144dedb928e4e2f433a328d58f44c3c098d63e,0
seccomp: fix UAF in user-trap code,"On the failure path, we do an fput() of the listener fd if the filter fails to install (e.g. because of a TSYNC race that's lost, or if the thread is killed, etc.). fput() doesn't actually release the fd, it just ads it to a work queue. Then the thread proceeds to free the filter, even though the listener struct file has a reference to it.  To fix this, on the failure path let's set the private data to null, so we know in ->release() to ignore the filter.  ",a811dc61559e0c8003f1086c2a4dc8e4d5ae4cb8,1
"netfilter: conntrack: dccp, sctp: handle null timeout argument","The timeout pointer can be NULL which means we should modify the per-nets timeout instead.  All do this, except sctp and dccp which instead give:  general protection fault: 0000 [#1] PREEMPT SMP KASAN net/netfilter/nf_conntrack_proto_dccp.c:682  ctnl_timeout_parse_policy+0x150/0x1d0 net/netfilter/nfnetlink_cttimeout.c:67  cttimeout_default_set+0x150/0x1c0 net/netfilter/nfnetlink_cttimeout.c:368  nfnetlink_rcv_msg+0xcf2/0xfb0 net/netfilter/nfnetlink.c:229  netlink_rcv_skb+0x177/0x450 net/netlink/af_netlink.c:2477  ",1d9a7acd3d1e74c2d150d8934f7f55bed6d70858,1
Bluetooth: advmon offload MSFT add rssi support,"MSFT needs rssi parameter for monitoring advertisement packet, therefore we should supply them from mgmt. This adds a new opcode to add advertisement monitor with rssi parameters.  ",b4a221ea8a1f890b50838ef389d016c7ff280abc,0
bpf: Add rcu_read_lock in bpf_get_current_[ancestor_]cgroup_id() helpers,"Currently, if bpf_get_current_cgroup_id() or bpf_get_current_ancestor_cgroup_id() helper is called with sleepable programs e.g., sleepable fentry/fmod_ret/fexit/lsm programs, a rcu warning may appear. For example, if I added the following hack to test_progs/test_lsm sleepable fentry program test_sys_setdomainname:    ",2d3a1e3615c5449a4583010f41a6f824a4ffa03e,0
ath9k: Fix use-after-free Read in ath9k_wmi_ctrl_rx,"Free wmi later after cmd urb has been killed, as urb cb will access wmi.  the case reported by syzbot: https://lore.kernel.org/linux-usb/0000000000000002fc05a1d61a68@google.com BUG: KASAN: use-after-free in ath9k_wmi_ctrl_rx+0x416/0x500 drivers/net/wireless/ath/ath9k/wmi.c:215 Read of size 1 at addr ffff8881cef1417c by task swapper/1/0  Call Trace: <IRQ> ath9k_wmi_ctrl_rx+0x416/0x500 drivers/net/wireless/ath/ath9k/wmi.c:215 ath9k_htc_rx_msg+0x2da/0xaf0 drivers/net/wireless/ath/ath9k/htc_hst.c:459 ath9k_hif_usb_reg_in_cb+0x1ba/0x630 drivers/net/wireless/ath/ath9k/hif_usb.c:718 __usb_hcd_giveback_urb+0x29a/0x550 drivers/usb/core/hcd.c:1650 usb_hcd_giveback_urb+0x368/0x420 drivers/usb/core/hcd.c:1716 dummy_timer+0x1258/0x32ae drivers/usb/gadget/udc/dummy_hcd.c:1966 call_timer_fn+0x195/0x6f0 kernel/time/timer.c:1404 expire_timers kernel/time/timer.c:1449 [inline] __run_timers kernel/time/timer.c:1773 [inline] __run_timers kernel/time/timer.c:1740 [inline] run_timer_softirq+0x5f9/0x1500 kernel/time/timer.c:1786  ",abeaa85054ff8cfe8b99aafc5c70ea067e5d0908,1
tipc: fix a deadlock when flushing scheduled work,"In the commit fdeba99b1e58 (""tipc: fix use-after-free in tipc_bcast_get_mode""), we're trying to make sure the tipc_net_finalize_work work item finished if it enqueued. But calling flush_scheduled_work() is not just affecting above work item but either any scheduled work. This has turned out to be overkill and caused to deadlock as ",d966ddcc38217a6110a6a0ff37ad2dee7d42e23e,1
mm: madvise: fix vma user-after-free,"The syzbot reported the below use-after-free:    BUG: KASAN: use-after-free in madvise_willneed mm/madvise.c:293 [inline]   BUG: KASAN: use-after-free in madvise_vma mm/madvise.c:942 [inline]   BUG: KASAN: use-after-free in do_madvise.part.0+0x1c8b/0x1cf0 mm/madvise.c:1145   Read of size 8 at addr ffff8880a6163eb0 by task syz-executor.0/9996    CPU: 0 PID: 9996 Comm: syz-executor.0 Not tainted 5.9.0-rc1-syzkaller #0   Hardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 01/01/2011   Call Trace:     __dump_stack lib/dump_stack.c:77 [inline]     dump_stack+0x18f/0x20d lib/dump_stack.c:118     print_address_description.constprop.0.cold+0xae/0x497 mm/kasan/report.c:383     __kasan_report mm/kasan/report.c:513 [inline]     kasan_report.cold+0x1f/0x37 mm/kasan/report.c:530     madvise_willneed mm/madvise.c:293 [inline]     madvise_vma mm/madvise.c:942 [inline]     do_madvise.part.0+0x1c8b/0x1cf0 mm/madvise.c:1145     do_madvise mm/madvise.c:1169 [inline]     __do_sys_madvise mm/madvise.c:1171 [inline]     __se_sys_madvise mm/madvise.c:1169 [inline]     __x64_sys_madvise+0xd9/0x110 mm/madvise.c:1169     do_syscall_64+0x2d/0x70 arch/x86/entry/common.c:46     entry_SYSCALL_64_after_hwframe+0x44/0xa9    Allocated by task 9992:     kmem_cache_alloc+0x138/0x3a0 mm/slab.c:3482     vm_area_alloc+0x1c/0x110 kernel/fork.c:347     mmap_region+0x8e5/0x1780 mm/mmap.c:1743     do_mmap+0xcf9/0x11d0 mm/mmap.c:1545     vm_mmap_pgoff+0x195/0x200 mm/util.c:506     ksys_mmap_pgoff+0x43a/0x560 mm/mmap.c:1596     do_syscall_64+0x2d/0x70 arch/x86/entry/common.c:46     entry_SYSCALL_64_after_hwframe+0x44/0xa9    Freed by task 9992:     kmem_cache_free.part.0+0x67/0x1f0 mm/slab.c:3693     remove_vma+0x132/0x170 mm/mmap.c:184     remove_vma_list mm/mmap.c:2613 [inline]     __do_munmap+0x743/0x1170 mm/mmap.c:2869     do_munmap mm/mmap.c:2877 [inline]     mmap_region+0x257/0x1780 mm/mmap.c:1716     do_mmap+0xcf9/0x11d0 mm/mmap.c:1545     vm_mmap_pgoff+0x195/0x200 mm/util.c:506     ksys_mmap_pgoff+0x43a/0x560 mm/mmap.c:1596     do_syscall_64+0x2d/0x70 arch/x86/entry/common.c:46     entry_SYSCALL_64_after_hwframe+0x44/0xa9  It is because vma is accessed after releasing mmap_lock, but someone else acquired the mmap_lock and the vma is gone.  Releasing mmap_lock after accessing vma should fix the problem.  ",7867fd7cc44e63c6673cd0f8fea155456d34d0de,1
can: j1939: j1939_netdev_start(): fix UAF for rx_kref of j1939_priv,"It will trigger UAF for rx_kref of j1939_priv as following.          cpu0                                    cpu1 j1939_sk_bind(socket0, ndev0, ...) j1939_netdev_start                                         j1939_sk_bind(socket1, ndev0, ...)                                         j1939_netdev_start j1939_priv_set                                         j1939_priv_get_by_ndev_locked j1939_jsk_add ..... j1939_netdev_stop kref_put_lock(&priv->rx_kref, ...)                                         kref_get(&priv->rx_kref, ...)                                         REFCOUNT_WARN(""addition on 0;..."")  ",d9d52a3ebd284882f5562c88e55991add5d01586,0
reiserfs: Fix memory leak of journal device string,"When a filesystem is mounted with jdev mount option, we store the journal device name in an allocated string in superblock. However we fail to ever free that string. Fix it.  ",5474ca7da6f34fa95e82edc747d5faa19cbdfb5c,1
rxrpc: fix race condition in rxrpc_input_packet(),"After commit 5271953cad31 (""rxrpc: Use the UDP encap_rcv hook""), rxrpc_input_packet() is directly called from lockless UDP receive path, under rcu_read_lock() protection.  It must therefore use RCU rules :  - udp_sk->sk_user_data can be cleared at any point in this function.   rcu_dereference_sk_user_data() is what we need here.  - Also, since sk_user_data might have been set in rxrpc_open_socket()   we must observe a proper RCU grace period before kfree(local) in   rxrpc_lookup_local()  v4: @local can be NULL in xrpc_lookup_local() as reported by kbuild test robot <lkp@intel.com>         and Julia Lawall <julia.lawall@lip6.fr>, thanks !  v3,v2 : addressed David Howells feedback, thanks !  syzbot reported :  kasan: CONFIG_KASAN_INLINE enabled kasan: GPF could be caused by NULL-ptr deref or user memory access general protection fault: 0000 [#1] PREEMPT SMP KASAN CPU: 0 PID: 19236 Comm: syz-executor703 Not tainted 5.1.0-rc6 #79 Hardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 01/01/2011 ",032be5f19a94de51093851757089133dcc1e92aa,1
net/x25: prevent a couple of overflows,"The .x25_addr[] address comes from the user and is not necessarily NUL terminated.  This leads to a couple problems.  The first problem is that the strlen() in x25_bind() can read beyond the end of the buffer.  The second problem is more subtle and could result in memory corruption. The call tree is:   x25_connect()   --> x25_write_internal()       --> x25_addr_aton()  The .x25_addr[] buffers are copied to the ""addresses"" buffer from x25_write_internal() so it will lead to stack corruption.  Verify that the strings are NUL terminated and return -EINVAL if they are not.  ",6ee50c8e262a0f0693dad264c3c99e30e6442a56,1
x86/unwind/orc: Fix unwind_get_return_address_ptr() for inactive tasks,"Normally, show_trace_log_lvl() scans the stack, looking for text addresses to print.  In parallel, it unwinds the stack with unwind_next_frame().  If the stack address matches the pointer returned by unwind_get_return_address_ptr() for the current frame, the text address is printed normally without a question mark.  Otherwise it's considered a breadcrumb (potentially from a previous call path) and it's printed with a question mark to indicate that the address is unreliable and typically can be ignored.  Since the following commit:    f1d9a2abff66 (""x86/unwind/orc: Don't skip the first frame for inactive tasks"")  ... for inactive tasks, show_trace_log_lvl() prints *only* unreliable addresses (prepended with '?').  That happens because, for the first frame of an inactive task, unwind_get_return_address_ptr() returns the wrong return address pointer: one word *below* the task stack pointer.  show_trace_log_lvl() starts scanning at the stack pointer itself, so it never finds the first 'reliable' address, causing only guesses to being printed.  The first frame of an inactive task isn't a normal stack frame.  It's actually just an instance of 'struct inactive_task_frame' which is left behind by __switch_to_asm().  Now that this inactive frame is actually exposed to callers, fix unwind_get_return_address_ptr() to interpret it properly.  ",187b96db5ca79423618dfa29a05c438c34f9e1f0,0
isdn: fix kernel-infoleak in capi_unlocked_ioctl,"Since capi_ioctl() copies 64 bytes after calling capi20_get_manufacturer() we need to ensure to not leak information to user.  BUG: KMSAN: kernel-infoleak in _copy_to_user+0x16b/0x1f0 lib/usercopy.c:32 CPU: 0 PID: 11245 Comm: syz-executor633 Not tainted 4.20.0-rc7+ #2 Hardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 01/01/2011 Call Trace:  __dump_stack lib/dump_stack.c:77 [inline]  dump_stack+0x173/0x1d0 lib/dump_stack.c:113  kmsan_report+0x12e/0x2a0 mm/kmsan/kmsan.c:613  kmsan_internal_check_memory+0x9d4/0xb00 mm/kmsan/kmsan.c:704  kmsan_copy_to_user+0xab/0xc0 mm/kmsan/kmsan_hooks.c:601  _copy_to_user+0x16b/0x1f0 lib/usercopy.c:32  capi_ioctl include/linux/uaccess.h:177 [inline]  capi_unlocked_ioctl+0x1a0b/0x1bf0 drivers/isdn/capi/capi.c:939  do_vfs_ioctl+0xebd/0x2bf0 fs/ioctl.c:46  ksys_ioctl fs/ioctl.c:713 [inline]  __do_sys_ioctl fs/ioctl.c:720 [inline]  __se_sys_ioctl+0x1da/0x270 fs/ioctl.c:718  __x64_sys_ioctl+0x4a/0x70 fs/ioctl.c:718  do_syscall_64+0xbc/0xf0 arch/x86/entry/common.c:291  entry_SYSCALL_64_after_hwframe+0x63/0xe7 ",d63967e475ae10f286dbd35e189cb241e0b1f284,1
kernfs: deal with kernfs_fill_super() failures,"make sure that info->node is initialized early, so that kernfs_kill_sb() can list_del() it safely.  ",82382acec0c97b91830fff7130d0acce4ac4f3f3,0
ALSA: seq: oss: Fix missing error check in snd_seq_oss_synth_make_info(),"snd_seq_oss_synth_make_info() didn't check the error code from snd_seq_oss_midi_make_info(), and this leads to the call of strlcpy() with the uninitialized string as the source, which may lead to the access over the limit.  Add the proper error check for avoiding the failure.  ",217bfbb8b0bfa24619b11ab75c135fec99b99b20,1
mm/list_lru.c: fix memory leak in __memcg_init_list_lru_node,"Syzbot reported following memory leak:  ffffffffda RBX: 0000000000000003 RCX: 0000000000441f79 BUG: memory leak unreferenced object 0xffff888114f26040 (size 32):   comm ""syz-executor626"", pid 7056, jiffies 4294948701 (age 39.410s)   ",3510955b327176fd4cbab5baa75b449f077722a2,1
media: gscpa/stv06xx: fix memory leak,"For two of the supported sensors the stv06xx driver allocates memory which is stored in sd->sensor_priv. This memory is freed on a disconnect, but if the probe() fails, then it isn't freed and so this leaks memory.  Add a new probe_error() op that drivers can use to free any allocated memory in case there was a probe failure.  ",4f4e6644cd876c844cdb3bea2dd7051787d5ae25,1
loop: Don't change loop device under exclusive opener,"Loop module allows calling LOOP_SET_FD while there are other openers of the loop device. Even exclusive ones. This can lead to weird consequences such as kernel deadlocks like:  mount_bdev()				lo_ioctl()   udf_fill_super()     udf_load_vrs()       sb_set_blocksize() - sets desired block size B       udf_tread()         sb_bread()           __bread_gfp(bdev, block, B) 					  loop_set_fd() 					    set_blocksize()             - now __getblk_slow() indefinitely loops because B != bdev               block size  Fix the problem by disallowing LOOP_SET_FD ioctl when there are exclusive openers of a loop device.  [Deliberately chosen not to CC stable as a user with priviledges to trigger this race has other means of taking the system down and this has a potential of breaking some weird userspace setup]  ",33ec3e53e7b1869d7851e59e126bdb0fe0bd1982,1
bonding: fix suspicious RCU usage in bond_ipsec_add_sa(),"To dereference bond->curr_active_slave, it uses rcu_dereference(). But it and the caller doesn't acquire RCU so a warning occurs. So add rcu_read_lock().  Test commands:     ip link add dummy0 type dummy     ip link add bond0 type bond     ip link set dummy0 master bond0     ip link set dummy0 up     ip link set bond0 up     ip x s add proto esp dst 14.1.1.1 src 15.1.1.1 spi 0x07 \ 	    mode transport \ 	    reqid 0x07 replay-window 32 aead 'rfc4106(gcm(aes))' \ 	    0x44434241343332312423222114131211f4f3f2f1 128 sel \ 	    src 14.0.0.52/24 dst 14.0.0.70/24 proto tcp offload \ 	    dev bond0 dir in  Splat looks like: ",b648eba4c69e5819880b4907e7fcb2bb576069ab,1
bpf: fix precision bit propagation for BPF_ST instructions,"When backtracking instructions to propagate precision bit for registers and stack slots, one class of instructions (BPF_ST) weren't handled causing extra stack slots to be propagated into parent state. Parent state might not have that much stack allocated, though, which causes warning on invalid stack slot usage.  This patch adds handling of BPF_ST instructions:  BPF_MEM | <size> | BPF_ST:   *(size *) (dst_reg + off) = imm32  ",b3b50f05dc501cc2cd90349a7bbfd932af0ceb31,1
tcp: add an ability to dump and restore window parameters,"We found that sometimes a restored tcp socket doesn't work.  A reason of this bug is incorrect window parameters and in this case tcp_acceptable_seq() returns tcp_wnd_end(tp) instead of tp->snd_nxt. The other side drops packets with this seq, because seq is less than tp->rcv_nxt ( tcp_sequence() ).  Data from a send queue is sent only if there is enough space in a window, so when we restore unacked data, we need to expand a window to fit this data.  This was in a first version of this patch: ""tcp: extend window to fit all restored unacked data in a send queue""  Then Alexey recommended me to restore window parameters instead of adjusted them according with data in a sent queue. This sounds resonable.  rcv_wnd has to be restored, because it was reported to another side and the offered window is never shrunk. One of reasons why we need to restore snd_wnd was described above.  ",b1ed4c4fa9a5ccf325184fd90edc50978ef6e33a,0
smackfs: use __GFP_NOFAIL for smk_cipso_doi(),"syzbot is reporting kernel panic at smk_cipso_doi() due to memory allocation fault injection [1]. The reason for need to use panic() was not explained. But since no fix was proposed for 18 months, for now let's use __GFP_NOFAIL for utilizing syzbot resource on other bugs.  ",f91488ee15bd3cac467e2d6a361fc2d34d1052ae,0
netfilter: provide correct argument to nla_strlcpy(),"Recent patch forgot to remove nla_data(), upsetting syzkaller a bit.  BUG: KASAN: slab-out-of-bounds in nla_strlcpy+0x13d/0x150 lib/nlattr.c:314 Read of size 1 at addr ffff8801ad1f4fdd by task syz-executor189/4509  CPU: 1 PID: 4509 Comm: syz-executor189 Not tainted 4.17.0-rc6+ #62 Hardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 01/01/2011 Call Trace:  __dump_stack lib/dump_stack.c:77 [inline]  dump_stack+0x1b9/0x294 lib/dump_stack.c:113  print_address_description+0x6c/0x20b mm/kasan/report.c:256  kasan_report_error mm/kasan/report.c:354 [inline]  kasan_report.cold.7+0x242/0x2fe mm/kasan/report.c:412  __asan_report_load1_noabort+0x14/0x20 mm/kasan/report.c:430  nla_strlcpy+0x13d/0x150 lib/nlattr.c:314  nfnl_acct_new+0x574/0xc50 net/netfilter/nfnetlink_acct.c:118  nfnetlink_rcv_msg+0xdb5/0xff0 net/netfilter/nfnetlink.c:212  netlink_rcv_skb+0x172/0x440 net/netlink/af_netlink.c:2448  nfnetlink_rcv+0x1fe/0x1ba0 net/netfilter/nfnetlink.c:513  netlink_unicast_kernel net/netlink/af_netlink.c:1310 [inline]  netlink_unicast+0x58b/0x740 net/netlink/af_netlink.c:1336  netlink_sendmsg+0x9f0/0xfa0 net/netlink/af_netlink.c:1901  sock_sendmsg_nosec net/socket.c:629 [inline]  sock_sendmsg+0xd5/0x120 net/socket.c:639  sock_write_iter+0x35a/0x5a0 net/socket.c:908  call_write_iter include/linux/fs.h:1784 [inline]  new_sync_write fs/read_write.c:474 [inline]  __vfs_write+0x64d/0x960 fs/read_write.c:487  vfs_write+0x1f8/0x560 fs/read_write.c:549  ksys_write+0xf9/0x250 fs/read_write.c:598  __do_sys_write fs/read_write.c:610 [inline]  __se_sys_write fs/read_write.c:607 [inline]  __x64_sys_write+0x73/0xb0 fs/read_write.c:607  ",4b83a9049a983b20b1ec2757727c5e39f5847ad2,1
tomoyo: Check address length before reading address family,"KMSAN will complain if valid address length passed to bind()/connect()/ sendmsg() is shorter than sizeof(""struct sockaddr""->sa_family) bytes.  ",e6193f78bb689f3f424559bb45f4a091c8b314df,0
ipv6: explicitly initialize udp6_addr in udp_sock_create6(),"syzbot reported the use of uninitialized udp6_addr::sin6_scope_id. We can just set ::sin6_scope_id to zero, as tunnels are unlikely to use an IPv6 address that needs a scope id and there is no interface to bind in this context.  For net-next, it looks different as we have cfg->bind_ifindex there so we can probably call ipv6_iface_scope_id().  Same for ::sin6_flowinfo, tunnels don't use it.  ",fb24274546310872eeeaf3d1d53799d8414aa0f2,1
perf: Fix data race between pin_count increment/decrement,"KCSAN reports a data race between increment and decrement of pin_count:    write to 0xffff888237c2d4e0 of 4 bytes by task 15740 on cpu 1:    find_get_context		kernel/events/core.c:4617    __do_sys_perf_event_open	kernel/events/core.c:12097 [inline]    __se_sys_perf_event_open	kernel/events/core.c:11933    ...   read to 0xffff888237c2d4e0 of 4 bytes by task 15743 on cpu 0:    perf_unpin_context		kernel/events/core.c:1525 [inline]    __do_sys_perf_event_open	kernel/events/core.c:12328 [inline]    __se_sys_perf_event_open	kernel/events/core.c:11933    ...  Because neither read-modify-write here is atomic, this can lead to one of the operations being lost, resulting in an inconsistent pin_count. Fix it by adding the missing locking in the CPU-event case.  ",6c605f8371159432ec61cbb1488dcf7ad24ad19a,1
ipv6: remove null_entry before adding default route,"In the current code, when creating a new fib6 table, tb6_root.leaf gets initialized to net->ipv6.ip6_null_entry. If a default route is being added with rt->rt6i_metric = 0xffffffff, fib6_add() will add this route after net->ipv6.ip6_null_entry. As null_entry is shared, it could cause problem.  In order to fix it, set fn->leaf to NULL before calling fib6_add_rt2node() when trying to add the first default route. And reset fn->leaf to null_entry when adding fails or when deleting the last default route.  syzkaller reported the following issue which is fixed by this commit:  ",4512c43eac7e007d982e7ea45152ea6f3f4d1921,1
USB: core: Fix unterminated string returned by usb_string(),"Some drivers (such as the vub300 MMC driver) expect usb_string() to return a properly NUL-terminated string, even when an error occurs. (In fact, vub300's probe routine doesn't bother to check the return code from usb_string().)  When the driver goes on to use an unterminated string, it leads to kernel errors such as stack-out-of-bounds, as found by the syzkaller USB fuzzer.  An out-of-range string index argument is not at all unlikely, given that some devices don't provide string descriptors and therefore list 0 as the value for their string indexes.  This patch makes usb_string() return a properly terminated empty string along with the -EINVAL error code when an out-of-range index is encountered.  And since a USB string index is a single-byte value, indexes >= 256 are just as invalid as values of 0 or below.  ",c01c348ecdc66085e44912c97368809612231520,1
USB: core: Fix bug caused by duplicate interface PM usage counter,The syzkaller fuzzer reported a bug in the USB hub driver which turned out to be caused by a negative runtime-PM usage counter.  This allowed a hub to be runtime suspended at a time when the driver did not expect it.  The symptom is a ,c2b71462d294cf517a0bc6e4fd6424d7cee5596f,1
